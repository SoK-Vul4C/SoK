<S2SV_ModStart> -> info_ptr_end ; bfd_size_type num_nested_funcs ; <S2SV_ModStart> i -- ) { <S2SV_ModStart> * ) ) ; if ( nested_funcs [ i ] == NULL ) goto fail <S2SV_ModStart> return FALSE ; } <S2SV_ModStart> = 0 ; num_nested_funcs = 0 ; <S2SV_ModStart> nesting_level ) { if ( num_nested_funcs!= NULL ) { bfd_free ( nested_funcs [ nesting_level ] ) ; nested_funcs [ nesting_level ] = NULL ; }
<S2SV_ModStart> int nesting_level = 0 <S2SV_ModEnd> ; struct funcinfo <S2SV_ModStart> funcinfo * * <S2SV_ModEnd> nested_funcs = ( <S2SV_ModStart> i -- ) { <S2SV_ModStart> * ) ) ; if (! nested_funcs [ i ] ) goto fail <S2SV_ModStart> return FALSE ; } <S2SV_ModStart> = 0 ; fail :
<S2SV_ModStart> -> info_ptr_end ; bfd_size_type alloc_size = 0 ; <S2SV_ModStart> i -- ) { <S2SV_ModStart> * ) ) ; if (! nested_funcs [ i ] ) goto fail <S2SV_ModStart> return FALSE ; } <S2SV_ModStart> = 0 ; fail : if ( alloc_size!= 0 ) { bfd_set_error ( bfd_error_bad_value ) ; goto fail ; }
<S2SV_ModStart> -> info_ptr_end ; bfd_size_type alloc_size ; <S2SV_ModStart> i -- ) { <S2SV_ModStart> * ) ) ; if (! nested_funcs ) goto fail <S2SV_ModStart> return FALSE ; } <S2SV_ModStart> = 0 ; alloc_size = 0 ; <S2SV_ModStart> -> name = find_abstract_instance_name ( unit, & attr, & func -> is_linkage, & alloc_size ) ; if (! func -> name ) goto fail ; if ( alloc_size ) goto fail <S2SV_ModEnd> ; } else
<S2SV_ModStart> int nesting_level = 0 <S2SV_ModEnd> ; struct funcinfo <S2SV_ModStart> funcinfo * * <S2SV_ModEnd> nested_funcs = ( <S2SV_ModStart> = 32 ; nested_funcs = ( <S2SV_ModStart> * * ) bfd_calloc <S2SV_ModEnd> ( nested_funcs_size * <S2SV_ModStart> * sizeof ( <S2SV_ModEnd> funcinfo * ) <S2SV_ModStart> return FALSE ; <S2SV_ModEnd> while ( nesting_level <S2SV_ModStart> case DW_AT_specification : if (! <S2SV_ModStart> func -> is_linkage ) { bfd_set_error ( bfd_error_bad_value ) ; goto fail ; } nested_funcs [ nesting_level <S2SV_ModEnd> ] = func <S2SV_ModStart> break ; } <S2SV_ModEnd> } else {
<S2SV_ModStart> int nesting_level = 0 <S2SV_ModEnd> ; struct funcinfo <S2SV_ModStart> funcinfo * * <S2SV_ModEnd> nested_funcs = ( <S2SV_ModStart> = 32 ; nested_funcs = ( <S2SV_ModStart> * * ) bfd_malloc <S2SV_ModEnd> ( nested_funcs_size * <S2SV_ModStart> * sizeof ( <S2SV_ModEnd> funcinfo * ) <S2SV_ModStart> return FALSE ; <S2SV_ModEnd> while ( nesting_level <S2SV_ModStart> case DW_AT_specification : if (! <S2SV_ModStart> func -> is_linkage ) { bfd_set_error ( bfd_error_bad_value ) ; goto fail ; } nested_funcs [ nesting_level <S2SV_ModEnd> ] = func <S2SV_ModStart> break ; } <S2SV_ModEnd> } else {
<S2SV_ModStart> -> info_ptr_end ; bfd_size_type alloc_size ; <S2SV_ModStart> i -- ) { <S2SV_ModStart> * ) ) ; if (! nested_funcs [ i ] ) goto fail <S2SV_ModStart> return FALSE ; } <S2SV_ModStart> = 0 ; fail : return FALSE ;
<S2SV_ModStart> -> info_ptr_end ; bfd_size_type num_nested_funcs ; <S2SV_ModStart> i -- ) { <S2SV_ModStart> * ) ) ; if ( nested_funcs [ i ]!= NULL ) num_nested_funcs = i <S2SV_ModStart> return FALSE ; } <S2SV_ModStart> = 0 ; if ( num_nested_funcs < 1 ) { bfd_set_error ( bfd_error_bad_value ) ; goto fail ; }
<S2SV_ModStart> -> info_ptr_end ; bfd_size_type num_nested_funcs ; <S2SV_ModStart> i -- ) { <S2SV_ModStart> * ) ) ; if ( nested_funcs [ i ] == NULL ) goto fail <S2SV_ModStart> return FALSE ; } <S2SV_ModStart> = 0 ; num_nested_funcs = 0 ; <S2SV_ModStart> nesting_level ) { if ( num_nested_funcs < 1 ) { bfd_set_error ( bfd_error_bad_value ) ) ; goto fail ; }
<S2SV_ModStart> -> info_ptr_end ; bfd_size_type num_nested_funcs ; <S2SV_ModStart> i -- ) { <S2SV_ModStart> * ) ) ; if ( nested_funcs [ i ] == NULL ) goto fail <S2SV_ModStart> return FALSE ; } <S2SV_ModStart> = 0 ; num_nested_funcs = count_nested_funcs ( unit, nested_funcs ) ; if ( num_nested_funcs == 0 ) goto fail ;
<S2SV_ModStart> int nesting_level = 0 <S2SV_ModEnd> ; struct funcinfo <S2SV_ModStart> funcinfo * * <S2SV_ModEnd> nested_funcs = ( <S2SV_ModStart> i -- ) { <S2SV_ModStart> * ) ) ; if ( nested_funcs [ i ] == NULL ) goto fail <S2SV_ModStart> return FALSE ; } <S2SV_ModStart> = 0 ; fail :
<S2SV_ModStart> -> info_ptr_end ; bfd_size_type alloc_size = 0 ; <S2SV_ModStart> i -- ) { <S2SV_ModStart> * ) ) ; if ( nested_funcs [ i ] == NULL ) goto fail <S2SV_ModStart> return FALSE ; } <S2SV_ModStart> = 0 ; fail : if ( alloc_size!= 0 ) { bfd_set_error ( bfd_error_bad_value ) ; goto fail ; }
<S2SV_ModStart> int nesting_level = 0 <S2SV_ModEnd> ; struct funcinfo <S2SV_ModStart> funcinfo * * <S2SV_ModEnd> nested_funcs = ( <S2SV_ModStart> i -- ) { <S2SV_ModStart> i ] ) { <S2SV_ModStart> return FALSE ; } <S2SV_ModStart> = 0 ; nested_funcs [ nesting_level ] = func ;
<S2SV_ModStart> -> info_ptr_end ; bfd_size_type num_nested_funcs ; <S2SV_ModStart> i -- ) { <S2SV_ModStart> * ) ) ; if ( nested_funcs [ i ] == NULL ) goto fail <S2SV_ModStart> return FALSE ; } <S2SV_ModStart> = 0 ; num_nested_funcs = count_nested_funcs ( nesting_level ) ; if ( num_nested_funcs == 0 ) goto fail ;
<S2SV_ModStart> int nesting_level = 0 <S2SV_ModEnd> ; struct funcinfo <S2SV_ModStart> funcinfo * * <S2SV_ModEnd> nested_funcs = ( <S2SV_ModStart> = 32 ; nested_funcs = ( <S2SV_ModStart> * * ) bfd_calloc <S2SV_ModEnd> ( nested_funcs_size * <S2SV_ModStart> * sizeof ( <S2SV_ModEnd> funcinfo * ) <S2SV_ModStart> return FALSE ; <S2SV_ModEnd> while ( nesting_level <S2SV_ModStart> case DW_AT_specification : if (! <S2SV_ModStart> func -> is_linkage ) { bfd_set_error ( bfd_error_bad_value ) ; goto fail ; } nested_funcs [ nesting_level <S2SV_ModEnd> ] = func <S2SV_ModStart> = func ; break ;
<S2SV_ModStart> -> info_ptr_end ; bfd_size_type num_nested_funcs ; <S2SV_ModStart> i -- ) { <S2SV_ModStart> * ) ) ; if ( nested_funcs [ i ]!= NULL ) num_nested_funcs = i <S2SV_ModStart> return FALSE ; } <S2SV_ModStart> = 0 ; if ( num_nested_funcs!= NULL ) { bfd_set_error ( bfd_error_bad_value ) ; goto fail ; }
<S2SV_ModStart> -> info_ptr_end ; bfd_size_type num_nested_funcs ; <S2SV_ModStart> i -- ) { <S2SV_ModStart> * ) ) ; if ( nested_funcs [ i ] == NULL ) goto fail <S2SV_ModStart> return FALSE ; } <S2SV_ModStart> = 0 ; num_nested_funcs = 0 ; <S2SV_ModStart> -> name = find_abstract_instance_name ( unit, & attr, & func -> is_linkage ) ; if ( num_nested_funcs == 0 ) goto fail <S2SV_ModEnd> ; } else
<S2SV_ModStart> -> info_ptr_end ; bfd_size_type alloc_size = 0 ; <S2SV_ModStart> i -- ) { <S2SV_ModStart> * ) ) ; if (! nested_funcs ) goto fail <S2SV_ModStart> return FALSE ; } <S2SV_ModStart> = 0 ; fail : if ( alloc_size!= 0 ) { bfd_set_error ( bfd_error_bad_value ) ; goto fail ; }
<S2SV_ModStart> -> info_ptr_end ; bfd_size_type num_nested_funcs ; <S2SV_ModStart> i -- ) { <S2SV_ModStart> * ) ) ; if ( nested_funcs [ i ] == NULL ) goto fail <S2SV_ModStart> return FALSE ; } <S2SV_ModStart> = 0 ; num_nested_funcs = 0 ; <S2SV_ModStart> nesting_level ) { if ( num_nested_funcs < 1 ) { bfd_set_error ( bfd_error_bad_value ) ) ; goto fail ; } <S2SV_ModStart> i -- ) { if ( nested_funcs [ i ] == NULL ) { bfd_set_error ( bfd_error_bad_value ) ) ; goto fail ; }
<S2SV_ModStart> -> info_ptr_end ; bfd_size_type alloc_size ; <S2SV_ModStart> i -- ) { <S2SV_ModStart> * ) ) ; if (! nested_funcs ) goto fail <S2SV_ModStart> return FALSE ; } <S2SV_ModStart> = 0 ; alloc_size = 0 ; <S2SV_ModStart> -> name = find_abstract_instance_name ( unit, & attr, & func -> is_linkage, alloc_size ) ; if (! func -> name ) goto fail <S2SV_ModEnd> ; } else
<S2SV_ModStart> int nesting_level = 0 <S2SV_ModEnd> ; struct funcinfo <S2SV_ModStart> funcinfo * * <S2SV_ModEnd> nested_funcs = ( <S2SV_ModStart> = 32 ; nested_funcs = ( <S2SV_ModStart> * * ) bfd_calloc <S2SV_ModEnd> ( nested_funcs_size * <S2SV_ModStart> * sizeof ( <S2SV_ModEnd> funcinfo * ) <S2SV_ModStart> return FALSE ; <S2SV_ModEnd> while ( nesting_level <S2SV_ModStart> == DW_AT_specification ) { <S2SV_ModStart> i -- ) { <S2SV_ModStart> func -> is_linkage = TRUE ; } <S2SV_ModEnd> break ; } <S2SV_ModStart> break ; } }
<S2SV_ModStart> int nesting_level = 0 <S2SV_ModEnd> ; struct funcinfo <S2SV_ModStart> funcinfo * * <S2SV_ModEnd> nested_funcs = ( <S2SV_ModStart> = 32 ; nested_funcs = ( <S2SV_ModStart> * * ) bfd_malloc <S2SV_ModEnd> ( nested_funcs_size * <S2SV_ModStart> * sizeof ( <S2SV_ModEnd> funcinfo * ) <S2SV_ModStart> return FALSE ; <S2SV_ModEnd> while ( nesting_level <S2SV_ModStart> case DW_AT_specification : if (! <S2SV_ModStart> func -> is_linkage ) { bfd_set_error ( bfd_error_bad_value ) ; goto fail ; } nested_funcs [ nesting_level <S2SV_ModEnd> ] = func <S2SV_ModStart> = func ; break ;
<S2SV_ModStart> int nesting_level = 0 <S2SV_ModEnd> ; struct funcinfo <S2SV_ModStart> funcinfo * * <S2SV_ModEnd> nested_funcs = ( <S2SV_ModStart> i -- ) { <S2SV_ModStart> i ] ) { <S2SV_ModStart> return FALSE ; } <S2SV_ModStart> = 0 ; if ( nesting_level < 1 ) { bfd_set_error ( bfd_error_bad_value ) ; goto fail ; }
<S2SV_ModStart> -> info_ptr_end ; bfd_size_type num_nested_funcs ; <S2SV_ModStart> i -- ) { <S2SV_ModStart> * ) ) ; if ( nested_funcs [ i ] == NULL ) goto fail <S2SV_ModStart> return FALSE ; } <S2SV_ModStart> = 0 ; num_nested_funcs = 0 ; <S2SV_ModStart> nesting_level ) { if (! func -> is_linkage ) { bfd_set_error ( bfd_error_bad_value ) ) ; goto fail ; }
<S2SV_ModStart> int nesting_level = 0 <S2SV_ModEnd> ; struct funcinfo <S2SV_ModStart> funcinfo * * <S2SV_ModEnd> nested_funcs = ( <S2SV_ModStart> = 32 ; nested_funcs = ( <S2SV_ModStart> * * ) bfd_calloc <S2SV_ModEnd> ( nested_funcs_size * <S2SV_ModStart> * sizeof ( <S2SV_ModEnd> funcinfo * ) <S2SV_ModStart> return FALSE ; <S2SV_ModEnd> while ( nesting_level <S2SV_ModStart> == DW_AT_specification ) { <S2SV_ModStart> i -- ) { <S2SV_ModStart> func -> is_linkage = TRUE ; } <S2SV_ModEnd> break ; } <S2SV_ModStart> break ; } <S2SV_ModEnd> } else {
<S2SV_ModStart> -> info_ptr_end ; bfd_size_type num_nested_funcs ; <S2SV_ModStart> i -- ) { <S2SV_ModStart> * ) ) ; if ( nested_funcs [ i ]!= NULL ) num_nested_funcs = i <S2SV_ModStart> return FALSE ; } <S2SV_ModStart> = 0 ; if ( num_nested_funcs < 2 ) { bfd_set_error ( bfd_error_bad_value ) ; goto fail ; }
<S2SV_ModStart> int nesting_level = 0 <S2SV_ModEnd> ; struct funcinfo <S2SV_ModStart> funcinfo * * <S2SV_ModEnd> nested_funcs = ( <S2SV_ModStart> = 32 ; nested_funcs = ( <S2SV_ModStart> * * ) bfd_calloc <S2SV_ModEnd> ( nested_funcs_size * <S2SV_ModStart> * sizeof ( <S2SV_ModEnd> funcinfo * ) <S2SV_ModStart> return FALSE ; <S2SV_ModEnd> while ( nesting_level <S2SV_ModStart> case DW_AT_specification : if ( nesting_level == 0 ) { nested_funcs [ nesting_level ] = func ; break ; } <S2SV_ModStart> break ; } <S2SV_ModEnd> } else {
<S2SV_ModStart> int nesting_level = 0 <S2SV_ModEnd> ; struct funcinfo <S2SV_ModStart> funcinfo * * <S2SV_ModEnd> nested_funcs = ( <S2SV_ModStart> = 32 ; nested_funcs = ( <S2SV_ModStart> * * ) bfd_calloc <S2SV_ModEnd> ( nested_funcs_size * <S2SV_ModStart> * sizeof ( <S2SV_ModEnd> funcinfo * ) <S2SV_ModStart> return FALSE ; <S2SV_ModEnd> while ( nesting_level <S2SV_ModStart> case DW_AT_specification : if ( attr. u. val!= 0 ) goto fail ; <S2SV_ModStart> func -> is_linkage = TRUE ; break ; } nested_funcs [ nesting_level ] = func ; break ; case DW_AT_function : if (! func -> name ) goto fail ; break ; case DW_AT_decl_file : if (! func -> file ) goto fail ; break ; case DW_AT_decl_line : if (
<S2SV_ModStart> int nesting_level = 0 <S2SV_ModEnd> ; struct funcinfo <S2SV_ModStart> funcinfo * * <S2SV_ModEnd> nested_funcs = ( <S2SV_ModStart> = 32 ; nested_funcs = ( <S2SV_ModStart> * * ) bfd_malloc <S2SV_ModEnd> ( nested_funcs_size * <S2SV_ModStart> * sizeof ( <S2SV_ModEnd> funcinfo * ) <S2SV_ModStart> return FALSE ; <S2SV_ModEnd> while ( nesting_level <S2SV_ModStart> == DW_AT_specification ) { <S2SV_ModStart> i -- ) { <S2SV_ModStart> func -> is_linkage = TRUE ; } <S2SV_ModEnd> break ; } <S2SV_ModStart> break ; } }
<S2SV_ModStart> int nesting_level = 0 <S2SV_ModEnd> ; struct funcinfo <S2SV_ModStart> funcinfo * * <S2SV_ModEnd> nested_funcs = ( <S2SV_ModStart> = 32 ; nested_funcs = ( <S2SV_ModStart> * * ) bfd_calloc <S2SV_ModEnd> ( nested_funcs_size * <S2SV_ModStart> * sizeof ( <S2SV_ModEnd> funcinfo * ) <S2SV_ModStart> return FALSE ; <S2SV_ModEnd> while ( nesting_level <S2SV_ModStart> case DW_AT_specification : if (! <S2SV_ModStart> func -> is_linkage ) { bfd_set_error ( bfd_error_bad_value ) ; goto fail ; } <S2SV_ModEnd> nested_funcs [ nesting_level <S2SV_ModStart> nesting_level ] = find_abstract_instance_name <S2SV_ModEnd> ( unit, <S2SV_ModStart> attr, & <S2SV_ModEnd> func -> is_linkage <S2SV_ModStart> func -> is_linkage ) ; break ; } else { bfd_set_error ( bfd_error_bad_value
<S2SV_ModStart> -> info_ptr_end ; bfd_size_type num_nested_funcs ; <S2SV_ModStart> i -- ) { <S2SV_ModStart> * ) ) ; if ( nested_funcs [ i ] == NULL ) goto fail <S2SV_ModStart> return FALSE ; } <S2SV_ModStart> = 0 ; num_nested_funcs = count_nested_funcs ( unit, nested_funcs ) ; if ( num_nested_funcs!= 0 ) { bfd_set_error ( bfd_error_bad_value ) ) ; goto fail ; }
<S2SV_ModStart> -> info_ptr_end ; bfd_size_type num_nested_funcs ; <S2SV_ModStart> i -- ) { <S2SV_ModStart> * ) ) ; if ( nested_funcs [ i ] == NULL ) goto fail <S2SV_ModStart> return FALSE ; } <S2SV_ModStart> = 0 ; num_nested_funcs = 0 ; <S2SV_ModStart> -> name = find_abstract_instance_name ( unit, & attr, & func -> is_linkage, num_nested_funcs ) ; if ( func -> name == NULL ) goto fail <S2SV_ModEnd> ; } else
<S2SV_ModStart> int nesting_level = 0 <S2SV_ModEnd> ; struct funcinfo <S2SV_ModStart> funcinfo * * <S2SV_ModEnd> nested_funcs = ( <S2SV_ModStart> = 32 ; nested_funcs = ( <S2SV_ModStart> * * ) bfd_calloc <S2SV_ModEnd> ( nested_funcs_size * <S2SV_ModStart> * sizeof ( <S2SV_ModEnd> funcinfo * ) <S2SV_ModStart> return FALSE ; <S2SV_ModEnd> while ( nesting_level <S2SV_ModStart> == DW_AT_specification ) { <S2SV_ModStart> i -- ) { <S2SV_ModStart> var ; } <S2SV_ModEnd> break ; } <S2SV_ModStart> break ; } }
<S2SV_ModStart> int nesting_level = 0 <S2SV_ModEnd> ; struct funcinfo <S2SV_ModStart> funcinfo * * <S2SV_ModEnd> nested_funcs = ( <S2SV_ModStart> = 32 ; nested_funcs = ( <S2SV_ModStart> * * ) bfd_malloc <S2SV_ModEnd> ( nested_funcs_size * <S2SV_ModStart> * sizeof ( <S2SV_ModEnd> funcinfo * ) <S2SV_ModStart> return FALSE ; <S2SV_ModEnd> while ( nesting_level <S2SV_ModStart> == DW_AT_specification ) { <S2SV_ModStart> i -- ) { <S2SV_ModStart> func -> is_linkage = TRUE ; } <S2SV_ModEnd> break ; } <S2SV_ModStart> break ; } <S2SV_ModEnd> } else {
<S2SV_ModStart> -> info_ptr_end ; bfd_size_type num_nested_funcs ; <S2SV_ModStart> i -- ) { <S2SV_ModStart> * ) ) ; if ( nested_funcs [ i ] == NULL ) goto fail <S2SV_ModStart> return FALSE ; } <S2SV_ModStart> = 0 ; num_nested_funcs = 0 ; <S2SV_ModStart> -> name = find_abstract_class_name <S2SV_ModEnd> ( unit, <S2SV_ModStart> & attr, & func -> is_linkage, num_nested_funcs ) ; if (! func -> name ) goto fail <S2SV_ModEnd> ; } else
<S2SV_ModStart> int nesting_level = 0 <S2SV_ModEnd> ; struct funcinfo <S2SV_ModStart> funcinfo * * <S2SV_ModEnd> nested_funcs = ( <S2SV_ModStart> i -- ) { <S2SV_ModStart> * ) ) ; if (! nested_funcs [ i ] ) goto fail <S2SV_ModStart> return FALSE ; } <S2SV_ModStart> = 0 ; fail : return FALSE ;
<S2SV_ModStart> -> info_ptr_end ; bfd_size_type alloc_size ; <S2SV_ModStart> i -- ) { <S2SV_ModStart> * ) ) ; if (! nested_funcs ) goto fail <S2SV_ModStart> return FALSE ; } <S2SV_ModStart> = 0 ; alloc_size = 0 ; <S2SV_ModStart> -> name = find_abstract_instance_name ( unit, & attr, & func -> is_linkage, & alloc_size ) ; if (! func -> name ) goto fail ; if ( alloc_size ) { bfd_set_error ( bfd_error_bad_value ) ; goto fail ; }
<S2SV_ModStart> -> info_ptr_end ; bfd_size_type num_nested_funcs ; <S2SV_ModStart> i -- ) { <S2SV_ModStart> * ) ) ; if ( nested_funcs [ i ] == NULL ) goto fail <S2SV_ModStart> return FALSE ; } <S2SV_ModStart> = 0 ; num_nested_funcs = 0 ; <S2SV_ModStart> -> name = find_abstract_instance_name ( unit, & attr, & func -> is_linkage ) ; if ( num_nested_funcs == 0 ) goto fail <S2SV_ModEnd> ; break ;
<S2SV_ModStart> int nesting_level = 0 <S2SV_ModEnd> ; struct funcinfo <S2SV_ModStart> funcinfo * * <S2SV_ModEnd> nested_funcs = ( <S2SV_ModStart> = 32 ; nested_funcs = ( <S2SV_ModStart> * * ) bfd_calloc <S2SV_ModEnd> ( nested_funcs_size * <S2SV_ModStart> * sizeof ( <S2SV_ModEnd> funcinfo * ) <S2SV_ModStart> return FALSE ; <S2SV_ModEnd> while ( nesting_level <S2SV_ModStart> == DW_AT_specification ) { <S2SV_ModStart> i -- ) { <S2SV_ModStart> var ; } if (! func -> is_linkage ) { bfd_set_error ( bfd_error_bad_value ) ; goto fail ; } <S2SV_ModStart> nesting_level ] = find_abstract_instance_name ( unit, & attr, & func -> is_linkage ) ; break ; } <S2SV_ModEnd> } else {
<S2SV_ModStart> int nesting_level = 0 <S2SV_ModEnd> ; struct funcinfo <S2SV_ModStart> funcinfo * * <S2SV_ModEnd> nested_funcs = ( <S2SV_ModStart> = 32 ; nested_funcs = ( <S2SV_ModStart> * * ) bfd_calloc <S2SV_ModEnd> ( nested_funcs_size * <S2SV_ModStart> * sizeof ( <S2SV_ModEnd> funcinfo * ) <S2SV_ModStart> return FALSE ; <S2SV_ModEnd> while ( nesting_level <S2SV_ModStart> case DW_AT_specification : if (! <S2SV_ModStart> func -> is_linkage ) { bfd_set_error ( bfd_error_bad_value ) ; goto fail ; } <S2SV_ModEnd> nested_funcs [ nesting_level <S2SV_ModStart> nesting_level ] = find_abstract_instance_name <S2SV_ModEnd> ( unit, <S2SV_ModStart> attr, & <S2SV_ModEnd> func -> is_linkage <S2SV_ModStart> func -> is_linkage, & nested_funcs [ nesting_level ]
<S2SV_ModStart> int nesting_level = 0 <S2SV_ModEnd> ; struct funcinfo <S2SV_ModStart> funcinfo * * <S2SV_ModEnd> nested_funcs = ( <S2SV_ModStart> = 32 ; nested_funcs = ( <S2SV_ModStart> * * ) bfd_calloc <S2SV_ModEnd> ( nested_funcs_size * <S2SV_ModStart> * sizeof ( <S2SV_ModEnd> funcinfo * ) <S2SV_ModStart> return FALSE ; <S2SV_ModEnd> while ( nesting_level <S2SV_ModStart> == DW_AT_specification ) { <S2SV_ModStart> i -- ) { <S2SV_ModStart> func -> is_linkage = TRUE ; } else { nested_funcs [ nesting_level ] = NULL ; } <S2SV_ModEnd> break ; }
<S2SV_ModStart> -> info_ptr_end ; bfd_size_type num_nested_funcs ; <S2SV_ModStart> i -- ) { <S2SV_ModStart> * ) ) ; if ( nested_funcs [ i ] == NULL ) goto fail <S2SV_ModStart> return FALSE ; } <S2SV_ModStart> = 0 ; num_nested_funcs = 0 ; <S2SV_ModStart> -> name = find_abstract_instance_name ( unit, & attr, & func -> is_linkage ) ; if ( num_nested_funcs == 0 ) { bfd_set_error ( bfd_error_bad_value ) ; goto fail ; } <S2SV_ModEnd> break ; case
<S2SV_ModStart> int nesting_level = 0 <S2SV_ModEnd> ; struct funcinfo <S2SV_ModStart> funcinfo * * <S2SV_ModEnd> nested_funcs = ( <S2SV_ModStart> = 32 ; nested_funcs = ( <S2SV_ModStart> * * ) bfd_malloc <S2SV_ModEnd> ( nested_funcs_size * <S2SV_ModStart> * sizeof ( <S2SV_ModEnd> funcinfo * ) <S2SV_ModStart> return FALSE ; <S2SV_ModEnd> while ( nesting_level <S2SV_ModStart> case DW_AT_specification : if (! <S2SV_ModStart> func -> is_linkage ) { bfd_set_error ( bfd_error_bad_value ) ; goto fail ; } <S2SV_ModEnd> nested_funcs [ nesting_level <S2SV_ModStart> nesting_level ] = find_abstract_instance_name <S2SV_ModEnd> ( unit, <S2SV_ModStart> attr, & <S2SV_ModEnd> func -> is_linkage <S2SV_ModStart> func -> is_linkage ) ; break ; } else { bfd_set_error ( bfd_error_bad_value
<S2SV_ModStart> int nesting_level = 0 <S2SV_ModEnd> ; struct funcinfo <S2SV_ModStart> funcinfo * * <S2SV_ModEnd> nested_funcs = ( <S2SV_ModStart> = 32 ; nested_funcs = ( <S2SV_ModStart> * * ) bfd_malloc <S2SV_ModEnd> ( nested_funcs_size * <S2SV_ModStart> * sizeof ( <S2SV_ModEnd> funcinfo * ) <S2SV_ModStart> return FALSE ; <S2SV_ModEnd> while ( nesting_level <S2SV_ModStart> case DW_AT_specification : if ( attr. u. val!= 0 ) goto fail ; <S2SV_ModStart> func -> is_linkage = TRUE ; break ; } nested_funcs [ nesting_level ] = func ; break ; case DW_AT_function : if (! func -> name ) goto fail ; break ; case DW_AT_decl_file : if (! func -> file ) goto fail ; break ; case DW_AT_decl_line : if (
<S2SV_ModStart> -> info_ptr_end ; bfd_size_type num_nested_funcs ; <S2SV_ModStart> i -- ) { <S2SV_ModStart> * ) ) ; if ( nested_funcs [ i ] == NULL ) goto fail <S2SV_ModStart> return FALSE ; } <S2SV_ModStart> = 0 ; num_nested_funcs = 0 ; <S2SV_ModStart> case DW_AT_specification : if (! func -> name ) goto fail ; <S2SV_ModStart> i -- ) { <S2SV_ModStart> func -> is_linkage = TRUE ; } else { func -> is_linkage = FALSE ; } <S2SV_ModEnd> break ; }
<S2SV_ModStart> int nesting_level = 0 <S2SV_ModEnd> ; struct funcinfo <S2SV_ModStart> funcinfo * * <S2SV_ModEnd> nested_funcs = ( <S2SV_ModStart> = 32 ; nested_funcs = ( <S2SV_ModStart> * * ) bfd_calloc <S2SV_ModEnd> ( nested_funcs_size * <S2SV_ModStart> * sizeof ( <S2SV_ModEnd> funcinfo * ) <S2SV_ModStart> return FALSE ; <S2SV_ModEnd> while ( nesting_level <S2SV_ModStart> case DW_AT_specification : if ( attr. u. val!= 0 ) goto fail ; <S2SV_ModStart> func -> is_linkage = TRUE ; break ; } nested_funcs [ nesting_level ] = func ; break ; <S2SV_ModEnd> } else {
<S2SV_ModStart> int nesting_level = 0 <S2SV_ModEnd> ; struct funcinfo <S2SV_ModStart> funcinfo * * <S2SV_ModEnd> nested_funcs = ( <S2SV_ModStart> = 32 ; nested_funcs = ( <S2SV_ModStart> * * ) bfd_malloc <S2SV_ModEnd> ( nested_funcs_size * <S2SV_ModStart> * sizeof ( <S2SV_ModEnd> funcinfo * ) <S2SV_ModStart> return FALSE ; <S2SV_ModEnd> while ( nesting_level <S2SV_ModStart> == DW_AT_specification ) { <S2SV_ModStart> i -- ) { <S2SV_ModStart> var ; } <S2SV_ModEnd> break ; } <S2SV_ModStart> break ; } }
<S2SV_ModStart> -> info_ptr_end ; bfd_size_type name_size ; <S2SV_ModStart> i -- ) { <S2SV_ModStart> * ) ) ; if (! nested_funcs [ i ] ) goto fail <S2SV_ModStart> return FALSE ; } <S2SV_ModStart> = 0 ; fail : return FALSE ;
<S2SV_ModStart> int nesting_level = 0 <S2SV_ModEnd> ; struct funcinfo <S2SV_ModStart> funcinfo * * <S2SV_ModEnd> nested_funcs = ( <S2SV_ModStart> = 32 ; nested_funcs = ( <S2SV_ModStart> * * ) bfd_malloc <S2SV_ModEnd> ( nested_funcs_size * <S2SV_ModStart> * sizeof ( <S2SV_ModEnd> funcinfo * ) <S2SV_ModStart> return FALSE ; <S2SV_ModEnd> while ( nesting_level <S2SV_ModStart> == DW_AT_specification ) { <S2SV_ModStart> i -- ) { <S2SV_ModStart> func -> is_linkage = TRUE ; } else { nested_funcs [ nesting_level ] = NULL ; } <S2SV_ModEnd> break ; }
<S2SV_ModStart> -> info_ptr_end ; bfd_size_type alloc_size ; <S2SV_ModStart> i -- ) { <S2SV_ModStart> * ) ) ; if (! nested_funcs ) goto fail <S2SV_ModStart> return FALSE ; } <S2SV_ModStart> = 0 ; alloc_size = 0 ; <S2SV_ModStart> -> name = find_abstract_class_name <S2SV_ModEnd> ( unit, <S2SV_ModStart> attr, & alloc_size, & <S2SV_ModStart> func -> is_linkage, & alloc_size
