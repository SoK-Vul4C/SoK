cwe_id,source,target,project_and_commit_id,cve_id,original_address,time
CWE-119,"CWE-119 static struct dentry * proc_mount ( struct file_system_type * fs_type , int flags , const char * dev_name , void * data ) { int err ; struct super_block * sb ; struct pid_namespace * ns ; char * options ; if ( flags & MS_KERNMOUNT ) { ns = ( struct pid_namespace * ) data ; options = NULL ; } else { ns = task_active_pid_ns ( current ) ; options = data ; if ( ! ns_capable ( ns -> user_ns , CAP_SYS_ADMIN ) ) return ERR_PTR ( - EPERM ) ; } sb = sget ( fs_type , proc_test_super , proc_set_super , flags , ns ) ; if ( IS_ERR ( sb ) ) return ERR_CAST ( sb ) ; <S2SV_StartBug> if ( ! proc_parse_options ( options , ns ) ) { <S2SV_EndBug> deactivate_locked_super ( sb ) ; return ERR_PTR ( - EINVAL ) ; } if ( ! sb -> s_root ) { err = proc_fill_super ( sb ) ; if ( err ) { deactivate_locked_super ( sb ) ; return ERR_PTR ( err ) ; } sb -> s_flags |= MS_ACTIVE ; sb -> s_iflags |= SB_I_NOEXEC ; } return dget ( sb -> s_root ) ; }",<S2SV_ModStart> sb ) ; sb -> s_stack_depth = FILESYSTEM_MAX_STACK_DEPTH ;,torvalds@linux/f5364c150aa645b3d7daa21b5c0b9feaa1c9cd6d,CVE-2016-1583,https://github.com/torvalds/linux/commit/f5364c150aa645b3d7daa21b5c0b9feaa1c9cd6d,2016-06-27T10:59Z
CWE-119,"CWE-119 static ssize_t k90_show_current_profile ( struct device * dev , struct device_attribute * attr , char * buf ) { int ret ; struct usb_interface * usbif = to_usb_interface ( dev -> parent ) ; struct usb_device * usbdev = interface_to_usbdev ( usbif ) ; int current_profile ; <S2SV_StartBug> char data [ 8 ] ; <S2SV_EndBug> ret = usb_control_msg ( usbdev , usb_rcvctrlpipe ( usbdev , 0 ) , K90_REQUEST_STATUS , USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE , 0 , 0 , data , 8 , USB_CTRL_SET_TIMEOUT ) ; if ( ret < 0 ) { dev_warn ( dev , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>K90<S2SV_blank>initial<S2SV_blank>state<S2SV_blank>(error<S2SV_blank>%d).\\n"" , ret ) ; <S2SV_StartBug> return - EIO ; <S2SV_EndBug> } current_profile = data [ 7 ] ; if ( current_profile < 1 || current_profile > 3 ) { dev_warn ( dev , ""Read<S2SV_blank>invalid<S2SV_blank>current<S2SV_blank>profile:<S2SV_blank>%02hhx.\\n"" , data [ 7 ] ) ; <S2SV_StartBug> return - EIO ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> return snprintf ( buf , PAGE_SIZE , ""%d\\n"" , current_profile ) ; }","<S2SV_ModStart> current_profile ; char * data ; data = kmalloc ( 8 , GFP_KERNEL ) ; if ( ! data ) return - ENOMEM <S2SV_ModEnd> ; ret = <S2SV_ModStart> ret ) ; ret = - EIO ; goto out <S2SV_ModEnd> ; } current_profile <S2SV_ModStart> ] ) ; ret = <S2SV_ModEnd> - EIO ; <S2SV_ModStart> - EIO ; goto out ; } ret = snprintf ( buf , PAGE_SIZE , ""%d\\n"" , current_profile ) ; out : kfree ( data ) ; return ret <S2SV_ModEnd> ; } <S2SV_null>",torvalds@linux/6d104af38b570d37aa32a5803b04c354f8ed513d,CVE-2017-5547,https://github.com/torvalds/linux/commit/6d104af38b570d37aa32a5803b04c354f8ed513d,2017-02-06T06:59Z
CWE-362,"CWE-362 static void bt_tags_for_each ( struct blk_mq_tags * tags , struct blk_mq_bitmap_tags * bt , unsigned int off , busy_tag_iter_fn * fn , void * data , bool reserved ) { struct request * rq ; int bit , i ; if ( ! tags -> rqs ) return ; for ( i = 0 ; i < bt -> map_nr ; i ++ ) { struct blk_align_bitmap * bm = & bt -> map [ i ] ; for ( bit = find_first_bit ( & bm -> word , bm -> depth ) ; bit < bm -> depth ; bit = find_next_bit ( & bm -> word , bm -> depth , bit + 1 ) ) { <S2SV_StartBug> rq = blk_mq_tag_to_rq ( tags , off + bit ) ; <S2SV_EndBug> fn ( rq , data , reserved ) ; } off += ( 1 << bt -> bits_per_word ) ; } }",<S2SV_ModStart> { rq = tags -> rqs [ <S2SV_ModEnd> off + bit <S2SV_ModStart> off + bit ] <S2SV_ModEnd> ; fn (,torvalds@linux/0048b4837affd153897ed1222283492070027aa9,CVE-2015-9016,https://github.com/torvalds/linux/commit/0048b4837affd153897ed1222283492070027aa9,2018-04-05T18:29Z
CWE-284,"CWE-284 UINT32 UIPC_Read ( tUIPC_CH_ID ch_id , UINT16 * p_msg_evt , UINT8 * p_buf , UINT32 len ) { int n ; int n_read = 0 ; int fd = uipc_main . ch [ ch_id ] . fd ; struct pollfd pfd ; UNUSED ( p_msg_evt ) ; if ( ch_id >= UIPC_CH_NUM ) { BTIF_TRACE_ERROR ( ""UIPC_Read<S2SV_blank>:<S2SV_blank>invalid<S2SV_blank>ch<S2SV_blank>id<S2SV_blank>%d"" , ch_id ) ; return 0 ; } if ( fd == UIPC_DISCONNECTED ) { BTIF_TRACE_ERROR ( ""UIPC_Read<S2SV_blank>:<S2SV_blank>channel<S2SV_blank>%d<S2SV_blank>closed"" , ch_id ) ; return 0 ; } while ( n_read < ( int ) len ) { pfd . fd = fd ; pfd . events = POLLIN | POLLHUP ; <S2SV_StartBug> if ( poll ( & pfd , 1 , uipc_main . ch [ ch_id ] . read_poll_tmo_ms ) == 0 ) <S2SV_EndBug> { BTIF_TRACE_EVENT ( ""poll<S2SV_blank>timeout<S2SV_blank>(%d<S2SV_blank>ms)"" , uipc_main . ch [ ch_id ] . read_poll_tmo_ms ) ; break ; } if ( pfd . revents & ( POLLHUP | POLLNVAL ) ) { BTIF_TRACE_EVENT ( ""poll<S2SV_blank>:<S2SV_blank>channel<S2SV_blank>detached<S2SV_blank>remotely"" ) ; UIPC_LOCK ( ) ; uipc_close_locked ( ch_id ) ; UIPC_UNLOCK ( ) ; return 0 ; } <S2SV_StartBug> n = recv ( fd , p_buf + n_read , len - n_read , 0 ) ; <S2SV_EndBug> if ( n == 0 ) { BTIF_TRACE_EVENT ( ""UIPC_Read<S2SV_blank>:<S2SV_blank>channel<S2SV_blank>detached<S2SV_blank>remotely"" ) ; UIPC_LOCK ( ) ; uipc_close_locked ( ch_id ) ; UIPC_UNLOCK ( ) ; return 0 ; } if ( n < 0 ) { BTIF_TRACE_EVENT ( ""UIPC_Read<S2SV_blank>:<S2SV_blank>read<S2SV_blank>failed<S2SV_blank>(%s)"" , strerror ( errno ) ) ; return 0 ; } n_read += n ; } return n_read ; }","<S2SV_ModStart> ; if ( TEMP_FAILURE_RETRY ( <S2SV_ModStart> ] . read_poll_tmo_ms ) <S2SV_ModStart> } n = TEMP_FAILURE_RETRY ( <S2SV_ModStart> , 0 ) )",system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z
CWE-119,"CWE-119 static void optimize_mb ( MACROBLOCK * x ) { int b ; int type ; int has_2nd_order ; ENTROPY_CONTEXT_PLANES t_above , t_left ; ENTROPY_CONTEXT * ta ; ENTROPY_CONTEXT * tl ; <S2SV_StartBug> vpx_memcpy ( & t_above , x -> e_mbd . above_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & t_left , x -> e_mbd . left_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> ta = ( ENTROPY_CONTEXT * ) & t_above ; tl = ( ENTROPY_CONTEXT * ) & t_left ; has_2nd_order = ( x -> e_mbd . mode_info_context -> mbmi . mode != B_PRED && x -> e_mbd . mode_info_context -> mbmi . mode != SPLITMV ) ; type = has_2nd_order ? PLANE_TYPE_Y_NO_DC : PLANE_TYPE_Y_WITH_DC ; for ( b = 0 ; b < 16 ; b ++ ) { optimize_b ( x , b , type , ta + vp8_block2above [ b ] , tl + vp8_block2left [ b ] ) ; } for ( b = 16 ; b < 24 ; b ++ ) { optimize_b ( x , b , PLANE_TYPE_UV , ta + vp8_block2above [ b ] , tl + vp8_block2left [ b ] ) ; } if ( has_2nd_order ) { b = 24 ; optimize_b ( x , b , PLANE_TYPE_Y2 , ta + vp8_block2above [ b ] , tl + vp8_block2left [ b ] ) ; check_reset_2nd_coeffs ( & x -> e_mbd , PLANE_TYPE_Y2 , ta + vp8_block2above [ b ] , tl + vp8_block2left [ b ] ) ; } }",<S2SV_ModStart> * tl ; memcpy <S2SV_ModEnd> ( & t_above <S2SV_ModStart> ) ) ; memcpy <S2SV_ModEnd> ( & t_left,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-119,"CWE-119 int mp_pack ( lua_State * L ) { int nargs = lua_gettop ( L ) ; int i ; mp_buf * buf ; if ( nargs == 0 ) return luaL_argerror ( L , 0 , ""MessagePack<S2SV_blank>pack<S2SV_blank>needs<S2SV_blank>input."" ) ; if ( ! lua_checkstack ( L , nargs ) ) return luaL_argerror ( L , 0 , ""Too<S2SV_blank>many<S2SV_blank>arguments<S2SV_blank>for<S2SV_blank>MessagePack<S2SV_blank>pack."" ) ; buf = mp_buf_new ( L ) ; for ( i = 1 ; i <= nargs ; i ++ ) { <S2SV_StartBug> lua_pushvalue ( L , i ) ; <S2SV_EndBug> mp_encode_lua_type ( L , buf , 0 ) ; lua_pushlstring ( L , ( char * ) buf -> b , buf -> len ) ; buf -> free += buf -> len ; buf -> len = 0 ; } mp_buf_free ( L , buf ) ; lua_concat ( L , nargs ) ; return 1 ; }","<S2SV_ModStart> ++ ) { luaL_checkstack ( L , 1 , ""in<S2SV_blank>function<S2SV_blank>mp_check"" ) ;",antirez@redis/5ccb6f7a791bf3490357b00a898885759d98bab0,CVE-2018-11218,https://github.com/antirez/redis/commit/5ccb6f7a791bf3490357b00a898885759d98bab0,2018-06-17T17:29Z
CWE-120,"CWE-000 void gtkui_icmp_redir ( void ) { GtkWidget * dialog , * table , * hbox , * image , * label , * entry1 , * entry2 , * frame ; gint response = 0 ; DEBUG_MSG ( ""gtk_icmp_redir"" ) ; dialog = gtk_dialog_new_with_buttons ( ""MITM<S2SV_blank>Attack:<S2SV_blank>ICMP<S2SV_blank>Redirect"" , GTK_WINDOW ( window ) , GTK_DIALOG_MODAL , GTK_STOCK_OK , GTK_RESPONSE_OK , GTK_STOCK_CANCEL , GTK_RESPONSE_CANCEL , NULL ) ; gtk_container_set_border_width ( GTK_CONTAINER ( dialog ) , 5 ) ; gtk_dialog_set_has_separator ( GTK_DIALOG ( dialog ) , FALSE ) ; hbox = gtk_hbox_new ( FALSE , 5 ) ; gtk_box_pack_start ( GTK_BOX ( GTK_DIALOG ( dialog ) -> vbox ) , hbox , FALSE , FALSE , 0 ) ; gtk_widget_show ( hbox ) ; image = gtk_image_new_from_stock ( GTK_STOCK_DIALOG_QUESTION , GTK_ICON_SIZE_DIALOG ) ; gtk_misc_set_alignment ( GTK_MISC ( image ) , 0.5 , 0.1 ) ; gtk_box_pack_start ( GTK_BOX ( hbox ) , image , FALSE , FALSE , 5 ) ; gtk_widget_show ( image ) ; frame = gtk_frame_new ( ""Gateway<S2SV_blank>Information"" ) ; gtk_container_set_border_width ( GTK_CONTAINER ( frame ) , 5 ) ; gtk_box_pack_start ( GTK_BOX ( hbox ) , frame , TRUE , TRUE , 0 ) ; gtk_widget_show ( frame ) ; table = gtk_table_new ( 2 , 2 , FALSE ) ; gtk_table_set_row_spacings ( GTK_TABLE ( table ) , 5 ) ; gtk_table_set_col_spacings ( GTK_TABLE ( table ) , 5 ) ; gtk_container_set_border_width ( GTK_CONTAINER ( table ) , 8 ) ; gtk_container_add ( GTK_CONTAINER ( frame ) , table ) ; gtk_widget_show ( table ) ; label = gtk_label_new ( ""MAC<S2SV_blank>Address"" ) ; gtk_misc_set_alignment ( GTK_MISC ( label ) , 0 , 0.5 ) ; gtk_table_attach ( GTK_TABLE ( table ) , label , 0 , 1 , 0 , 1 , GTK_FILL , GTK_FILL , 0 , 0 ) ; gtk_widget_show ( label ) ; entry1 = gtk_entry_new ( ) ; gtk_entry_set_max_length ( GTK_ENTRY ( entry1 ) , ETH_ASCII_ADDR_LEN ) ; gtk_table_attach_defaults ( GTK_TABLE ( table ) , entry1 , 1 , 2 , 0 , 1 ) ; gtk_widget_show ( entry1 ) ; label = gtk_label_new ( ""IP<S2SV_blank>Address"" ) ; gtk_misc_set_alignment ( GTK_MISC ( label ) , 0 , 0.5 ) ; gtk_table_attach ( GTK_TABLE ( table ) , label , 0 , 1 , 1 , 2 , GTK_FILL , GTK_FILL , 0 , 0 ) ; gtk_widget_show ( label ) ; entry2 = gtk_entry_new ( ) ; gtk_entry_set_max_length ( GTK_ENTRY ( entry2 ) , IP6_ASCII_ADDR_LEN ) ; gtk_table_attach_defaults ( GTK_TABLE ( table ) , entry2 , 1 , 2 , 1 , 2 ) ; gtk_widget_show ( entry2 ) ; response = gtk_dialog_run ( GTK_DIALOG ( dialog ) ) ; if ( response == GTK_RESPONSE_OK ) { gtk_widget_hide ( dialog ) ; snprintf ( params , 6 , ""icmp:"" ) ; <S2SV_StartBug> strncat ( params , gtk_entry_get_text ( GTK_ENTRY ( entry1 ) ) , PARAMS_LEN ) ; <S2SV_EndBug> <S2SV_StartBug> strncat ( params , ""/"" , PARAMS_LEN ) ; <S2SV_EndBug> <S2SV_StartBug> strncat ( params , gtk_entry_get_text ( GTK_ENTRY ( entry2 ) ) , PARAMS_LEN ) ; <S2SV_EndBug> gtkui_start_mitm ( ) ; } gtk_widget_destroy ( dialog ) ; }","<S2SV_ModStart> ) ) , ETH_ASCII_ADDR_LEN <S2SV_ModEnd> ) ; strncat <S2SV_ModStart> , ""/"" , 1 <S2SV_ModEnd> ) ; strncat <S2SV_ModStart> ) ) , IP6_ASCII_ADDR_LEN <S2SV_ModEnd> ) ; gtkui_start_mitm",Ettercap@ettercap/4ef3ede30181eca9add74305ad26dbcb0c3686a0,CVE-2010-3844,https://github.com/Ettercap/ettercap/commit/4ef3ede30181eca9add74305ad26dbcb0c3686a0,2019-11-12T22:15Z
CWE-119,"CWE-119 cJSON * cJSON_DetachItemFromArray ( cJSON * array , int which ) { cJSON * c = array -> child ; <S2SV_StartBug> while ( c && which > 0 ) { <S2SV_EndBug> <S2SV_StartBug> c = c -> next ; <S2SV_EndBug> -- which ; } if ( ! c ) return 0 ; if ( c -> prev ) c -> prev -> next = c -> next ; if ( c -> next ) c -> next -> prev = c -> prev ; if ( c == array -> child ) array -> child = c -> next ; c -> prev = c -> next = 0 ; return c ; }","<S2SV_ModStart> > 0 ) <S2SV_ModEnd> c = c <S2SV_ModStart> c -> next , which -- ; <S2SV_ModEnd> if ( !",esnet@iperf/91f2fa59e8ed80dfbf400add0164ee0e508e412a,CVE-2016-4303,https://github.com/esnet/iperf/commit/91f2fa59e8ed80dfbf400add0164ee0e508e412a,2016-09-26T14:59Z
CWE-835,"CWE-000 static int read_part_of_packet ( AVFormatContext * s , int64_t * pts , int * len , int * strid , int read_packet ) { AVIOContext * pb = s -> pb ; PVAContext * pvactx = s -> priv_data ; int syncword , streamid , reserved , flags , length , pts_flag ; int64_t pva_pts = AV_NOPTS_VALUE , startpos ; int ret ; recover : startpos = avio_tell ( pb ) ; syncword = avio_rb16 ( pb ) ; streamid = avio_r8 ( pb ) ; avio_r8 ( pb ) ; reserved = avio_r8 ( pb ) ; flags = avio_r8 ( pb ) ; length = avio_rb16 ( pb ) ; pts_flag = flags & 0x10 ; if ( syncword != PVA_MAGIC ) { pva_log ( s , AV_LOG_ERROR , ""invalid<S2SV_blank>syncword\\n"" ) ; return AVERROR ( EIO ) ; } if ( streamid != PVA_VIDEO_PAYLOAD && streamid != PVA_AUDIO_PAYLOAD ) { pva_log ( s , AV_LOG_ERROR , ""invalid<S2SV_blank>streamid\\n"" ) ; return AVERROR ( EIO ) ; } if ( reserved != 0x55 ) { pva_log ( s , AV_LOG_WARNING , ""expected<S2SV_blank>reserved<S2SV_blank>byte<S2SV_blank>to<S2SV_blank>be<S2SV_blank>0x55\\n"" ) ; } if ( length > PVA_MAX_PAYLOAD_LENGTH ) { pva_log ( s , AV_LOG_ERROR , ""invalid<S2SV_blank>payload<S2SV_blank>length<S2SV_blank>%u\\n"" , length ) ; return AVERROR ( EIO ) ; } if ( streamid == PVA_VIDEO_PAYLOAD && pts_flag ) { pva_pts = avio_rb32 ( pb ) ; length -= 4 ; } else if ( streamid == PVA_AUDIO_PAYLOAD ) { if ( ! pvactx -> continue_pes ) { int pes_signal , pes_header_data_length , pes_packet_length , pes_flags ; unsigned char pes_header_data [ 256 ] ; pes_signal = avio_rb24 ( pb ) ; avio_r8 ( pb ) ; pes_packet_length = avio_rb16 ( pb ) ; pes_flags = avio_rb16 ( pb ) ; pes_header_data_length = avio_r8 ( pb ) ; <S2SV_StartBug> if ( pes_signal != 1 || pes_header_data_length == 0 ) { <S2SV_EndBug> pva_log ( s , AV_LOG_WARNING , ""expected<S2SV_blank>non<S2SV_blank>empty<S2SV_blank>signaled<S2SV_blank>PES<S2SV_blank>packet,<S2SV_blank>"" ""trying<S2SV_blank>to<S2SV_blank>recover\\n"" ) ; avio_skip ( pb , length - 9 ) ; if ( ! read_packet ) return AVERROR ( EIO ) ; goto recover ; } ret = avio_read ( pb , pes_header_data , pes_header_data_length ) ; if ( ret != pes_header_data_length ) return ret < 0 ? ret : AVERROR_INVALIDDATA ; length -= 9 + pes_header_data_length ; pes_packet_length -= 3 + pes_header_data_length ; pvactx -> continue_pes = pes_packet_length ; if ( pes_flags & 0x80 && ( pes_header_data [ 0 ] & 0xf0 ) == 0x20 ) { if ( pes_header_data_length < 5 ) { pva_log ( s , AV_LOG_ERROR , ""header<S2SV_blank>too<S2SV_blank>short\\n"" ) ; avio_skip ( pb , length ) ; return AVERROR_INVALIDDATA ; } pva_pts = ff_parse_pes_pts ( pes_header_data ) ; } } pvactx -> continue_pes -= length ; if ( pvactx -> continue_pes < 0 ) { pva_log ( s , AV_LOG_WARNING , ""audio<S2SV_blank>data<S2SV_blank>corruption\\n"" ) ; pvactx -> continue_pes = 0 ; } } if ( pva_pts != AV_NOPTS_VALUE ) av_add_index_entry ( s -> streams [ streamid - 1 ] , startpos , pva_pts , 0 , 0 , AVINDEX_KEYFRAME ) ; * pts = pva_pts ; * len = length ; * strid = streamid ; return 0 ; }",<S2SV_ModStart> ; if ( avio_feof ( pb ) ) { return AVERROR_EOF ; } if (,FFmpeg@FFmpeg/9807d3976be0e92e4ece3b4b1701be894cd7c2e1,CVE-2018-1999012,https://github.com/FFmpeg/FFmpeg/commit/9807d3976be0e92e4ece3b4b1701be894cd7c2e1,2018-07-23T15:29Z
CWE-119,"CWE-119 static int atusb_get_and_show_revision ( struct atusb * atusb ) { struct usb_device * usb_dev = atusb -> usb_dev ; <S2SV_StartBug> unsigned char buffer [ 3 ] ; <S2SV_EndBug> int ret ; ret = atusb_control_msg ( atusb , usb_rcvctrlpipe ( usb_dev , 0 ) , ATUSB_ID , ATUSB_REQ_FROM_DEV , 0 , 0 , buffer , 3 , 1000 ) ; if ( ret >= 0 ) { atusb -> fw_ver_maj = buffer [ 0 ] ; atusb -> fw_ver_min = buffer [ 1 ] ; atusb -> fw_hw_type = buffer [ 2 ] ; dev_info ( & usb_dev -> dev , ""Firmware:<S2SV_blank>major:<S2SV_blank>%u,<S2SV_blank>minor:<S2SV_blank>%u,<S2SV_blank>hardware<S2SV_blank>type:<S2SV_blank>%u\\n"" , atusb -> fw_ver_maj , atusb -> fw_ver_min , atusb -> fw_hw_type ) ; } if ( atusb -> fw_ver_maj == 0 && atusb -> fw_ver_min < 2 ) { dev_info ( & usb_dev -> dev , ""Firmware<S2SV_blank>version<S2SV_blank>(%u.%u)<S2SV_blank>predates<S2SV_blank>our<S2SV_blank>first<S2SV_blank>public<S2SV_blank>release."" , atusb -> fw_ver_maj , atusb -> fw_ver_min ) ; dev_info ( & usb_dev -> dev , ""Please<S2SV_blank>update<S2SV_blank>to<S2SV_blank>version<S2SV_blank>0.2<S2SV_blank>or<S2SV_blank>newer"" ) ; } <S2SV_StartBug> return ret ; <S2SV_EndBug> }","<S2SV_ModStart> ; unsigned char * buffer ; int ret ; buffer = kmalloc ( 3 , GFP_KERNEL ) ; if ( ! buffer ) return - ENOMEM <S2SV_ModEnd> ; ret = <S2SV_ModStart> ) ; } kfree ( buffer ) ;",torvalds@linux/05a974efa4bdf6e2a150e3f27dc6fcf0a9ad5655,CVE-2017-5548,https://github.com/torvalds/linux/commit/05a974efa4bdf6e2a150e3f27dc6fcf0a9ad5655,2017-02-06T06:59Z
CWE-119,"CWE-119 static int evaluate_inter_mode ( unsigned int * sse , int rate2 , int * distortion2 , VP8_COMP * cpi , MACROBLOCK * x , int rd_adj ) { MB_PREDICTION_MODE this_mode = x -> e_mbd . mode_info_context -> mbmi . mode ; int_mv mv = x -> e_mbd . mode_info_context -> mbmi . mv ; <S2SV_StartBug> int this_rd ; <S2SV_EndBug> if ( cpi -> active_map_enabled && x -> active_ptr [ 0 ] == 0 ) { * sse = 0 ; * distortion2 = 0 ; x -> skip = 1 ; return INT_MAX ; } if ( ( this_mode != NEWMV ) || ! ( cpi -> sf . half_pixel_search ) || cpi -> common . full_pixel == 1 ) * distortion2 = vp8_get_inter_mbpred_error ( x , & cpi -> fn_ptr [ BLOCK_16X16 ] , sse , mv ) ; this_rd = RDCOST ( x -> rdmult , x -> rddiv , rate2 , * distortion2 ) ; <S2SV_StartBug> if ( this_mode == ZEROMV ) <S2SV_EndBug> { <S2SV_StartBug> if ( ( cpi -> ref_frame_flags & VP8_LAST_FRAME & <S2SV_EndBug> cpi -> common . refresh_last_frame ) && x -> e_mbd . mode_info_context -> mbmi . ref_frame != LAST_FRAME ) rd_adj = 100 ; this_rd = ( ( int64_t ) this_rd ) * rd_adj / 100 ; } check_for_encode_breakout ( * sse , x ) ; return this_rd ; }",<S2SV_ModStart> ; int this_rd ; int denoise_aggressive = 0 <S2SV_ModStart> distortion2 ) ; # if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity > 0 ) { denoise_aggressive = ( cpi -> denoiser . denoiser_mode == kDenoiserOnYUVAggressive ) ? 1 : 0 ; } # endif if ( ! cpi -> oxcf . screen_content_mode && <S2SV_ModEnd> this_mode == ZEROMV <S2SV_ModStart> this_mode == ZEROMV && x -> e_mbd . mode_info_context -> mbmi . ref_frame == LAST_FRAME && ( denoise_aggressive || ( cpi -> closest_reference_frame == LAST_FRAME ) ) <S2SV_ModStart> { if ( x -> is_skin <S2SV_ModEnd> ) rd_adj =,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-264,"CWE-264 static void * arm_coherent_dma_alloc ( struct device * dev , size_t size , dma_addr_t * handle , gfp_t gfp , struct dma_attrs * attrs ) { <S2SV_StartBug> pgprot_t prot = __get_dma_pgprot ( attrs , pgprot_kernel ) ; <S2SV_EndBug> void * memory ; if ( dma_alloc_from_coherent ( dev , size , handle , & memory ) ) return memory ; return __dma_alloc ( dev , size , handle , gfp , prot , true , __builtin_return_address ( 0 ) ) ; }","<S2SV_ModStart> ( attrs , PAGE_KERNEL <S2SV_ModEnd> ) ; void",torvalds@linux/0ea1ec713f04bdfac343c9702b21cd3a7c711826,CVE-2014-9888,https://github.com/torvalds/linux/commit/0ea1ec713f04bdfac343c9702b21cd3a7c711826,2016-08-06T10:59Z
CWE-119,"CWE-119 CURLcode Curl_smtp_escape_eob ( struct connectdata * conn , const ssize_t nread ) { ssize_t i ; ssize_t si ; struct Curl_easy * data = conn -> data ; struct SMTP * smtp = data -> req . protop ; char * scratch = data -> state . scratch ; char * newscratch = NULL ; char * oldscratch = NULL ; size_t eob_sent ; if ( ! scratch || data -> set . crlf ) { oldscratch = scratch ; <S2SV_StartBug> scratch = newscratch = malloc ( 2 * data -> set . buffer_size ) ; <S2SV_EndBug> if ( ! newscratch ) { failf ( data , ""Failed<S2SV_blank>to<S2SV_blank>alloc<S2SV_blank>scratch<S2SV_blank>buffer!"" ) ; return CURLE_OUT_OF_MEMORY ; } <S2SV_StartBug> } <S2SV_EndBug> eob_sent = smtp -> eob ; for ( i = 0 , si = 0 ; i < nread ; i ++ ) { if ( SMTP_EOB [ smtp -> eob ] == data -> req . upload_fromhere [ i ] ) { smtp -> eob ++ ; if ( 2 == smtp -> eob || SMTP_EOB_LEN == smtp -> eob ) smtp -> trailing_crlf = TRUE ; else smtp -> trailing_crlf = FALSE ; } else if ( smtp -> eob ) { memcpy ( & scratch [ si ] , & SMTP_EOB [ eob_sent ] , smtp -> eob - eob_sent ) ; si += smtp -> eob - eob_sent ; if ( SMTP_EOB [ 0 ] == data -> req . upload_fromhere [ i ] ) smtp -> eob = 1 ; else smtp -> eob = 0 ; eob_sent = 0 ; smtp -> trailing_crlf = FALSE ; } if ( SMTP_EOB_FIND_LEN == smtp -> eob ) { memcpy ( & scratch [ si ] , & SMTP_EOB_REPL [ eob_sent ] , SMTP_EOB_REPL_LEN - eob_sent ) ; si += SMTP_EOB_REPL_LEN - eob_sent ; smtp -> eob = 0 ; eob_sent = 0 ; } else if ( ! smtp -> eob ) scratch [ si ++ ] = data -> req . upload_fromhere [ i ] ; } if ( smtp -> eob - eob_sent ) { memcpy ( & scratch [ si ] , & SMTP_EOB [ eob_sent ] , smtp -> eob - eob_sent ) ; si += smtp -> eob - eob_sent ; } if ( si != nread ) { data -> req . upload_fromhere = scratch ; data -> state . scratch = scratch ; free ( oldscratch ) ; data -> req . upload_present = si ; } else free ( newscratch ) ; return CURLE_OK ; }",<S2SV_ModStart> ( 2 * UPLOAD_BUFSIZE <S2SV_ModEnd> ) ; if <S2SV_ModStart> ; } } DEBUGASSERT ( UPLOAD_BUFSIZE >= nread ) ;,curl@curl/ba1dbd78e5f1ed67c1b8d37ac89d90e5e330b628,CVE-2018-0500,https://github.com/curl/curl/commit/ba1dbd78e5f1ed67c1b8d37ac89d90e5e330b628,2018-07-11T13:29Z
CWE-119,"CWE-119 static int muscle_list_files ( sc_card_t * card , u8 * buf , size_t bufLen ) { muscle_private_t * priv = MUSCLE_DATA ( card ) ; mscfs_t * fs = priv -> fs ; int x ; int count = 0 ; mscfs_check_cache ( priv -> fs ) ; for ( x = 0 ; x < fs -> cache . size ; x ++ ) { u8 * oid = fs -> cache . array [ x ] . objectId . id ; <S2SV_StartBug> sc_debug ( card -> ctx , SC_LOG_DEBUG_NORMAL , <S2SV_EndBug> ""FILE:<S2SV_blank>%02X%02X%02X%02X\\n"" , oid [ 0 ] , oid [ 1 ] , oid [ 2 ] , oid [ 3 ] ) ; if ( 0 == memcmp ( fs -> currentPath , oid , 2 ) ) { buf [ 0 ] = oid [ 2 ] ; buf [ 1 ] = oid [ 3 ] ; if ( buf [ 0 ] == 0x00 && buf [ 1 ] == 0x00 ) continue ; buf += 2 ; count += 2 ; <S2SV_StartBug> } <S2SV_EndBug> } return count ; }",<S2SV_ModStart> . id ; if ( bufLen < 2 ) break ; <S2SV_ModStart> += 2 ; bufLen -= 2 ;,OpenSC@OpenSC/360e95d45ac4123255a4c796db96337f332160ad,CVE-2018-16391,https://github.com/OpenSC/OpenSC/commit/360e95d45ac4123255a4c796db96337f332160ad#diff-477b7a40136bb418b10ce271c8664536,2018-09-03T14:29Z
CWE-284,"CWE-284 static my_bool get_one_option ( int optid , const struct my_option * opt , char * argument ) { my_bool add_option = TRUE ; switch ( optid ) { case '?' : printf ( ""%s<S2SV_blank><S2SV_blank>Ver<S2SV_blank>%s<S2SV_blank>Distrib<S2SV_blank>%s,<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>(%s)\\n"" , my_progname , VER , MYSQL_SERVER_VERSION , SYSTEM_TYPE , MACHINE_TYPE ) ; puts ( ORACLE_WELCOME_COPYRIGHT_NOTICE ( ""2000"" ) ) ; puts ( ""MySQL<S2SV_blank>utility<S2SV_blank>for<S2SV_blank>upgrading<S2SV_blank>databases<S2SV_blank>to<S2SV_blank>new<S2SV_blank>MySQL<S2SV_blank>versions.\\n"" ) ; my_print_help ( my_long_options ) ; exit ( 0 ) ; break ; case '#' : DBUG_PUSH ( argument ? argument : default_dbug_option ) ; add_option = FALSE ; debug_check_flag = 1 ; break ; case 'p' : if ( argument == disabled_my_option ) argument = ( char * ) """" ; tty_password = 1 ; add_option = FALSE ; if ( argument ) { add_one_option ( & ds_args , opt , argument ) ; while ( * argument ) * argument ++ = 'x' ; tty_password = 0 ; } break ; case 't' : my_stpnmov ( opt_tmpdir , argument , sizeof ( opt_tmpdir ) ) ; add_option = FALSE ; break ; case 'k' : case 'v' : case 'f' : case 's' : case OPT_WRITE_BINLOG : add_option = FALSE ; break ; <S2SV_StartBug> case 'h' : <S2SV_EndBug> case 'W' : case 'P' : case 'S' : case OPT_MYSQL_PROTOCOL : case OPT_SHARED_MEMORY_BASE_NAME : case OPT_PLUGIN_DIR : case OPT_DEFAULT_AUTH : add_one_option ( & conn_args , opt , argument ) ; break ; } if ( add_option ) { add_one_option ( & ds_args , opt , argument ) ; } return 0 ; }",<S2SV_ModStart> ; break ; # include < sslopt - case . h >,mysql@mysql-server/3bd5589e1a5a93f9c224badf983cd65c45215390,CVE-2015-3152,https://github.com/mysql/mysql-server/commit/3bd5589e1a5a93f9c224badf983cd65c45215390,2016-05-16T10:59Z
,"CWE-000 int snd_ctl_replace ( struct snd_card * card , struct snd_kcontrol * kcontrol , bool add_on_replace ) { <S2SV_StartBug> struct snd_ctl_elem_id id ; <S2SV_EndBug> unsigned int idx ; struct snd_kcontrol * old ; int ret ; if ( ! kcontrol ) return - EINVAL ; if ( snd_BUG_ON ( ! card || ! kcontrol -> info ) ) { ret = - EINVAL ; goto error ; } id = kcontrol -> id ; down_write ( & card -> controls_rwsem ) ; old = snd_ctl_find_id ( card , & id ) ; if ( ! old ) { if ( add_on_replace ) goto add ; up_write ( & card -> controls_rwsem ) ; ret = - EINVAL ; goto error ; } ret = snd_ctl_remove ( card , old ) ; if ( ret < 0 ) { up_write ( & card -> controls_rwsem ) ; goto error ; } add : if ( snd_ctl_find_hole ( card , kcontrol -> count ) < 0 ) { up_write ( & card -> controls_rwsem ) ; ret = - ENOMEM ; goto error ; } list_add_tail ( & kcontrol -> list , & card -> controls ) ; card -> controls_count += kcontrol -> count ; kcontrol -> id . numid = card -> last_numid + 1 ; card -> last_numid += kcontrol -> count ; <S2SV_StartBug> up_write ( & card -> controls_rwsem ) ; <S2SV_EndBug> <S2SV_StartBug> for ( idx = 0 ; idx < kcontrol -> count ; idx ++ , id . index ++ , id . numid ++ ) <S2SV_EndBug> snd_ctl_notify ( card , SNDRV_CTL_EVENT_MASK_ADD , & id ) ; return 0 ; error : snd_ctl_free_one ( kcontrol ) ; return ret ; }",<S2SV_ModStart> struct snd_ctl_elem_id id ; unsigned int count <S2SV_ModStart> -> count ; count = kcontrol -> count ; <S2SV_ModStart> ; idx < <S2SV_ModEnd> count ; idx,torvalds@linux/fd9f26e4eca5d08a27d12c0933fceef76ed9663d,CVE-2014-4653,https://github.com/torvalds/linux/commit/fd9f26e4eca5d08a27d12c0933fceef76ed9663d,2014-07-03T04:22Z
CWE-119,"CWE-119 static TX_SIZE read_selected_tx_size ( VP9_COMMON * cm , MACROBLOCKD * xd , <S2SV_StartBug> TX_SIZE max_tx_size , vp9_reader * r ) { <S2SV_EndBug> <S2SV_StartBug> const int ctx = vp9_get_tx_size_context ( xd ) ; <S2SV_EndBug> <S2SV_StartBug> const vp9_prob * tx_probs = get_tx_probs ( max_tx_size , ctx , & cm -> fc . tx_probs ) ; <S2SV_EndBug> <S2SV_StartBug> int tx_size = vp9_read ( r , tx_probs [ 0 ] ) ; <S2SV_EndBug> if ( tx_size != TX_4X4 && max_tx_size >= TX_16X16 ) { <S2SV_StartBug> tx_size += vp9_read ( r , tx_probs [ 1 ] ) ; <S2SV_EndBug> if ( tx_size != TX_8X8 && max_tx_size >= TX_32X32 ) <S2SV_StartBug> tx_size += vp9_read ( r , tx_probs [ 2 ] ) ; <S2SV_EndBug> } <S2SV_StartBug> if ( ! cm -> frame_parallel_decoding_mode ) <S2SV_EndBug> <S2SV_StartBug> ++ get_tx_counts ( max_tx_size , ctx , & cm -> counts . tx ) [ tx_size ] ; <S2SV_EndBug> return ( TX_SIZE ) tx_size ; }","<S2SV_ModStart> TX_SIZE max_tx_size , vpx_reader <S2SV_ModEnd> * r ) <S2SV_ModStart> r ) { FRAME_COUNTS * counts = xd -> counts ; <S2SV_ModStart> int ctx = get_tx_size_context <S2SV_ModEnd> ( xd ) <S2SV_ModStart> ) ; const vpx_prob <S2SV_ModEnd> * tx_probs = <S2SV_ModStart> cm -> fc -> <S2SV_ModEnd> tx_probs ) ; <S2SV_ModStart> int tx_size = vpx_read <S2SV_ModEnd> ( r , <S2SV_ModStart> { tx_size += vpx_read <S2SV_ModEnd> ( r , <S2SV_ModStart> ) tx_size += vpx_read <S2SV_ModEnd> ( r , <S2SV_ModStart> } if ( counts <S2SV_ModEnd> ) ++ get_tx_counts <S2SV_ModStart> ctx , & counts -> <S2SV_ModEnd> tx ) [",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-119,"CWE-119 static INLINE void load_pred_mv ( MACROBLOCK * x , PICK_MODE_CONTEXT * ctx ) { <S2SV_StartBug> vpx_memcpy ( x -> pred_mv , ctx -> pred_mv , sizeof ( x -> pred_mv ) ) ; <S2SV_EndBug> }",<S2SV_ModStart> ctx ) { memcpy <S2SV_ModEnd> ( x ->,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-200,"CWE-200 bool __net_get_random_once ( void * buf , int nbytes , bool * done , <S2SV_StartBug> struct static_key * done_key ) <S2SV_EndBug> { static DEFINE_SPINLOCK ( lock ) ; unsigned long flags ; spin_lock_irqsave ( & lock , flags ) ; if ( * done ) { spin_unlock_irqrestore ( & lock , flags ) ; return false ; } get_random_bytes ( buf , nbytes ) ; * done = true ; spin_unlock_irqrestore ( & lock , flags ) ; <S2SV_StartBug> __net_random_once_disable_jump ( done_key ) ; <S2SV_EndBug> return true ; }",<S2SV_ModStart> struct static_key * once_key <S2SV_ModEnd> ) { static <S2SV_ModStart> ; __net_random_once_disable_jump ( once_key <S2SV_ModEnd> ) ; return,torvalds@linux/3d4405226d27b3a215e4d03cfa51f536244e5de7,CVE-2014-7284,https://github.com/torvalds/linux/commit/3d4405226d27b3a215e4d03cfa51f536244e5de7,2014-10-13T10:55Z
CWE-787,"CWE-787 static grub_disk_addr_t grub_ext2_read_block ( grub_fshelp_node_t node , grub_disk_addr_t fileblock ) { struct grub_ext2_data * data = node -> data ; struct grub_ext2_inode * inode = & node -> inode ; int blknr = - 1 ; unsigned int blksz = EXT2_BLOCK_SIZE ( data ) ; int log2_blksz = LOG2_EXT2_BLOCK_SIZE ( data ) ; if ( grub_le_to_cpu32 ( inode -> flags ) & EXT4_EXTENTS_FLAG ) { # ifndef _MSC_VER char buf [ EXT2_BLOCK_SIZE ( data ) ] ; # else char * buf = grub_malloc ( EXT2_BLOCK_SIZE ( data ) ) ; # endif struct grub_ext4_extent_header * leaf ; struct grub_ext4_extent * ext ; int i ; leaf = grub_ext4_find_leaf ( data , buf , ( struct grub_ext4_extent_header * ) inode -> blocks . dir_blocks , fileblock ) ; if ( ! leaf ) { grub_error ( GRUB_ERR_BAD_FS , ""invalid<S2SV_blank>extent"" ) ; return - 1 ; } ext = ( struct grub_ext4_extent * ) ( leaf + 1 ) ; for ( i = 0 ; i < grub_le_to_cpu16 ( leaf -> entries ) ; i ++ ) { if ( fileblock < grub_le_to_cpu32 ( ext [ i ] . block ) ) break ; } if ( -- i >= 0 ) { fileblock -= grub_le_to_cpu32 ( ext [ i ] . block ) ; if ( fileblock >= grub_le_to_cpu16 ( ext [ i ] . len ) ) return 0 ; else { grub_disk_addr_t start ; start = grub_le_to_cpu16 ( ext [ i ] . start_hi ) ; start = ( start << 32 ) + grub_le_to_cpu32 ( ext [ i ] . start ) ; return fileblock + start ; } } else { grub_error ( GRUB_ERR_BAD_FS , ""something<S2SV_blank>wrong<S2SV_blank>with<S2SV_blank>extent"" ) ; return - 1 ; } } <S2SV_StartBug> if ( fileblock < INDIRECT_BLOCKS ) <S2SV_EndBug> blknr = grub_le_to_cpu32 ( inode -> blocks . dir_blocks [ fileblock ] ) ; <S2SV_StartBug> else if ( fileblock < INDIRECT_BLOCKS + blksz / 4 ) <S2SV_EndBug> { grub_uint32_t * indir ; indir = grub_malloc ( blksz ) ; if ( ! indir ) return grub_errno ; if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( inode -> blocks . indir_block ) ) << log2_blksz , 0 , blksz , indir ) ) return grub_errno ; blknr = grub_le_to_cpu32 ( indir [ fileblock - INDIRECT_BLOCKS ] ) ; grub_free ( indir ) ; } else if ( fileblock < ( grub_disk_addr_t ) ( INDIRECT_BLOCKS + blksz / 4 ) * ( grub_disk_addr_t ) ( blksz / 4 + 1 ) ) { unsigned int perblock = blksz / 4 ; unsigned int rblock = fileblock - ( INDIRECT_BLOCKS + blksz / 4 ) ; grub_uint32_t * indir ; indir = grub_malloc ( blksz ) ; if ( ! indir ) return grub_errno ; if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( inode -> blocks . double_indir_block ) ) << log2_blksz , 0 , blksz , indir ) ) return grub_errno ; if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( indir [ rblock / perblock ] ) ) << log2_blksz , 0 , blksz , indir ) ) return grub_errno ; blknr = grub_le_to_cpu32 ( indir [ rblock % perblock ] ) ; grub_free ( indir ) ; } else { grub_error ( GRUB_ERR_NOT_IMPLEMENTED_YET , ""ext2fs<S2SV_blank>doesn\'t<S2SV_blank>support<S2SV_blank>triple<S2SV_blank>indirect<S2SV_blank>blocks"" ) ; } return blknr ; }",<S2SV_ModStart> < INDIRECT_BLOCKS ) { <S2SV_ModStart> ] ) ; },radare@radare2/796dd28aaa6b9fa76d99c42c4d5ff8b257cc2191,CVE-2017-9949,https://github.com/radare/radare2/commit/796dd28aaa6b9fa76d99c42c4d5ff8b257cc2191,2017-06-26T20:29Z
CWE-476,"CWE-476 static void * skcipher_bind ( const char * name , u32 type , u32 mask ) { <S2SV_StartBug> return crypto_alloc_skcipher ( name , type , mask ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>","<S2SV_ModStart> mask ) { struct skcipher_tfm * tfm ; struct crypto_skcipher * skcipher ; tfm = kzalloc ( sizeof ( * tfm ) , GFP_KERNEL ) ; if ( ! tfm ) return ERR_PTR ( - ENOMEM ) ; skcipher = <S2SV_ModEnd> crypto_alloc_skcipher ( name <S2SV_ModStart> mask ) ; if ( IS_ERR ( skcipher ) ) { kfree ( tfm ) ; return ERR_CAST ( skcipher ) ; } tfm -> skcipher = skcipher ; return tfm ;",torvalds@linux/dd504589577d8e8e70f51f997ad487a4cb6c026f,CVE-2015-8970,https://github.com/torvalds/linux/commit/dd504589577d8e8e70f51f997ad487a4cb6c026f,2016-11-28T03:59Z
CWE-476,"CWE-476 static int whereIndexExprTransColumn ( Walker * p , Expr * pExpr ) { if ( pExpr -> op == TK_COLUMN ) { IdxExprTrans * pX = p -> u . pIdxTrans ; if ( pExpr -> iTable == pX -> iTabCur && pExpr -> iColumn == pX -> iTabCol ) { <S2SV_StartBug> pExpr -> iTable = pX -> iIdxCur ; <S2SV_EndBug> pExpr -> iColumn = pX -> iIdxCol ; pExpr -> y . pTab = 0 ; } } return WRC_Continue ; }","<S2SV_ModStart> iTabCol ) { assert ( pExpr -> y . pTab != 0 ) ; pExpr -> affExpr = sqlite3TableColumnAffinity ( pExpr -> y . pTab , pExpr -> iColumn ) ;",sqlite@sqlite/57f7ece78410a8aae86aa4625fb7556897db384c,CVE-2019-19242,https://github.com/sqlite/sqlite/commit/57f7ece78410a8aae86aa4625fb7556897db384c,2019-11-27T17:15Z
CWE-190,"CWE-190 static inline unsigned short ReadPropertyUnsignedShort ( const EndianType endian , const unsigned char * buffer ) { unsigned short value ; if ( endian == LSBEndian ) { <S2SV_StartBug> value = ( unsigned short ) ( ( buffer [ 1 ] << 8 ) | buffer [ 0 ] ) ; <S2SV_EndBug> <S2SV_StartBug> return ( ( unsigned short ) ( value & 0xffff ) ) ; <S2SV_EndBug> } <S2SV_StartBug> value = ( unsigned short ) ( ( ( ( unsigned char * ) buffer ) [ 0 ] << 8 ) | <S2SV_EndBug> ( ( unsigned char * ) buffer ) [ 1 ] ) ; <S2SV_StartBug> return ( ( unsigned short ) ( value & 0xffff ) ) ; <S2SV_EndBug> }",<S2SV_ModStart> unsigned short ) <S2SV_ModEnd> buffer [ 1 <S2SV_ModStart> ] << 8 ; value |= ( unsigned short ) <S2SV_ModEnd> buffer [ 0 <S2SV_ModStart> [ 0 ] <S2SV_ModEnd> ; return ( <S2SV_ModStart> ; return ( <S2SV_ModEnd> value & 0xffff <S2SV_ModStart> value & 0xffff <S2SV_ModEnd> ) ; } <S2SV_ModStart> unsigned short ) buffer <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> ] << 8 ; value |= <S2SV_ModEnd> ( unsigned short <S2SV_ModStart> unsigned short ) buffer [ 1 ] ; return <S2SV_ModStart> & 0xffff ) <S2SV_ModEnd> ; } <S2SV_null>,ImageMagick@ImageMagick/d8ab7f046587f2e9f734b687ba7e6e10147c294b,CVE-2016-5841,https://github.com/ImageMagick/ImageMagick/commit/d8ab7f046587f2e9f734b687ba7e6e10147c294b,2016-12-13T15:59Z
CWE-119,"CWE-119 static int smacker_decode_tree ( BitstreamContext * bc , HuffContext * hc , uint32_t prefix , int length ) { <S2SV_StartBug> if ( ! bitstream_read_bit ( bc ) ) { <S2SV_EndBug> if ( hc -> current >= 256 ) { av_log ( NULL , AV_LOG_ERROR , ""Tree<S2SV_blank>size<S2SV_blank>exceeded!\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( length ) { hc -> bits [ hc -> current ] = prefix ; hc -> lengths [ hc -> current ] = length ; } else { hc -> bits [ hc -> current ] = 0 ; hc -> lengths [ hc -> current ] = 0 ; } hc -> values [ hc -> current ] = bitstream_read ( bc , 8 ) ; hc -> current ++ ; if ( hc -> maxlength < length ) hc -> maxlength = length ; return 0 ; } else { int r ; length ++ ; r = smacker_decode_tree ( bc , hc , prefix , length ) ; if ( r ) return r ; return smacker_decode_tree ( bc , hc , prefix | ( 1 << ( length - 1 ) ) , length ) ; } }","<S2SV_ModStart> { if ( length > SMKTREE_DECODE_MAX_RECURSION ) { av_log ( NULL , AV_LOG_ERROR , ""Maximum<S2SV_blank>tree<S2SV_blank>recursion<S2SV_blank>level<S2SV_blank>exceeded.\\n"" ) ; return AVERROR_INVALIDDATA ; } if (",libav@libav/cd4663dc80323ba64989d0c103d51ad3ee0e9c2f,CVE-2017-16803,https://github.com/libav/libav/commit/cd4663dc80323ba64989d0c103d51ad3ee0e9c2f,2017-11-13T17:29Z
CWE-125,"CWE-125 BOOL nego_read_request ( rdpNego * nego , wStream * s ) { BYTE li ; BYTE type ; UINT16 length ; if ( ! tpkt_read_header ( s , & length ) ) return FALSE ; if ( ! tpdu_read_connection_request ( s , & li , length ) ) return FALSE ; if ( li != Stream_GetRemainingLength ( s ) + 6 ) { WLog_ERR ( TAG , ""Incorrect<S2SV_blank>TPDU<S2SV_blank>length<S2SV_blank>indicator."" ) ; return FALSE ; } if ( ! nego_read_request_token_or_cookie ( nego , s ) ) { WLog_ERR ( TAG , ""Failed<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>routing<S2SV_blank>token<S2SV_blank>or<S2SV_blank>cookie."" ) ; return FALSE ; } if ( Stream_GetRemainingLength ( s ) >= 8 ) { Stream_Read_UINT8 ( s , type ) ; if ( type != TYPE_RDP_NEG_REQ ) { WLog_ERR ( TAG , ""Incorrect<S2SV_blank>negotiation<S2SV_blank>request<S2SV_blank>type<S2SV_blank>%"" PRIu8 """" , type ) ; return FALSE ; } <S2SV_StartBug> nego_process_negotiation_request ( nego , s ) ; <S2SV_EndBug> } return tpkt_ensure_stream_consumed ( s , length ) ; }","<S2SV_ModStart> FALSE ; } if ( ! <S2SV_ModStart> , s ) ) return FALSE",FreeRDP@FreeRDP/6b485b146a1b9d6ce72dfd7b5f36456c166e7a16,CVE-2020-11089,https://github.com/FreeRDP/FreeRDP/commit/6b485b146a1b9d6ce72dfd7b5f36456c166e7a16,2020-05-29T20:15Z
CWE-704,"CWE-000 void xgroupCommand ( client * c ) { const char * help [ ] = { ""CREATE<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><key><S2SV_blank><groupname><S2SV_blank><id<S2SV_blank>or<S2SV_blank>$><S2SV_blank><S2SV_blank>--<S2SV_blank>Create<S2SV_blank>a<S2SV_blank>new<S2SV_blank>consumer<S2SV_blank>group."" , ""SETID<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><key><S2SV_blank><groupname><S2SV_blank><id<S2SV_blank>or<S2SV_blank>$><S2SV_blank><S2SV_blank>--<S2SV_blank>Set<S2SV_blank>the<S2SV_blank>current<S2SV_blank>group<S2SV_blank>ID."" , ""DELGROUP<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><key><S2SV_blank><groupname><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>--<S2SV_blank>Remove<S2SV_blank>the<S2SV_blank>specified<S2SV_blank>group."" , ""DELCONSUMER<S2SV_blank><key><S2SV_blank><groupname><S2SV_blank><consumer><S2SV_blank>--<S2SV_blank>Remove<S2SV_blank>the<S2SV_blank>specified<S2SV_blank>conusmer."" , ""HELP<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>--<S2SV_blank>Prints<S2SV_blank>this<S2SV_blank>help."" , NULL } ; stream * s = NULL ; sds grpname = NULL ; streamCG * cg = NULL ; char * opt = c -> argv [ 1 ] -> ptr ; if ( c -> argc >= 4 ) { robj * o = lookupKeyWriteOrReply ( c , c -> argv [ 2 ] , shared . nokeyerr ) ; <S2SV_StartBug> if ( o == NULL ) return ; <S2SV_EndBug> s = o -> ptr ; grpname = c -> argv [ 3 ] -> ptr ; if ( ( cg = streamLookupCG ( s , grpname ) ) == NULL && ( ! strcasecmp ( opt , ""SETID"" ) || ! strcasecmp ( opt , ""DELCONSUMER"" ) ) ) { addReplyErrorFormat ( c , ""-NOGROUP<S2SV_blank>No<S2SV_blank>such<S2SV_blank>consumer<S2SV_blank>group<S2SV_blank>\'%s\'<S2SV_blank>"" ""for<S2SV_blank>key<S2SV_blank>name<S2SV_blank>\'%s\'"" , ( char * ) grpname , ( char * ) c -> argv [ 2 ] -> ptr ) ; return ; } } if ( ! strcasecmp ( opt , ""CREATE"" ) && c -> argc == 5 ) { streamID id ; if ( ! strcmp ( c -> argv [ 4 ] -> ptr , ""$"" ) ) { id = s -> last_id ; } else if ( streamParseIDOrReply ( c , c -> argv [ 4 ] , & id , 0 ) != C_OK ) { return ; } streamCG * cg = streamCreateCG ( s , grpname , sdslen ( grpname ) , & id ) ; if ( cg ) { addReply ( c , shared . ok ) ; server . dirty ++ ; } else { addReplySds ( c , sdsnew ( ""-BUSYGROUP<S2SV_blank>Consumer<S2SV_blank>Group<S2SV_blank>name<S2SV_blank>already<S2SV_blank>exists\\r\\n"" ) ) ; } } else if ( ! strcasecmp ( opt , ""SETID"" ) && c -> argc == 5 ) { streamID id ; if ( ! strcmp ( c -> argv [ 4 ] -> ptr , ""$"" ) ) { id = s -> last_id ; } else if ( streamParseIDOrReply ( c , c -> argv [ 4 ] , & id , 0 ) != C_OK ) { return ; } cg -> last_id = id ; addReply ( c , shared . ok ) ; } else if ( ! strcasecmp ( opt , ""DESTROY"" ) && c -> argc == 4 ) { if ( cg ) { raxRemove ( s -> cgroups , ( unsigned char * ) grpname , sdslen ( grpname ) , NULL ) ; streamFreeCG ( cg ) ; addReply ( c , shared . cone ) ; } else { addReply ( c , shared . czero ) ; } } else if ( ! strcasecmp ( opt , ""DELCONSUMER"" ) && c -> argc == 5 ) { long long pending = streamDelConsumer ( cg , c -> argv [ 4 ] -> ptr ) ; addReplyLongLong ( c , pending ) ; server . dirty ++ ; } else if ( ! strcasecmp ( opt , ""HELP"" ) ) { addReplyHelp ( c , help ) ; } else { addReply ( c , shared . syntaxerr ) ; } }","<S2SV_ModStart> o == NULL || checkType ( c , o , OBJ_STREAM )",antirez@redis/c04082cf138f1f51cedf05ee9ad36fb6763cafc6,CVE-2018-12453,https://github.com/antirez/redis/commit/c04082cf138f1f51cedf05ee9ad36fb6763cafc6,2018-06-16T17:29Z
CWE-119,"CWE-119 static void fill_variance_tree ( void * data , BLOCK_SIZE bsize ) { <S2SV_StartBug> variance_node node ; <S2SV_EndBug> tree_to_node ( data , bsize , & node ) ; sum_2_variances ( node . split [ 0 ] , node . split [ 1 ] , & node . part_variances -> horz [ 0 ] ) ; sum_2_variances ( node . split [ 2 ] , node . split [ 3 ] , & node . part_variances -> horz [ 1 ] ) ; sum_2_variances ( node . split [ 0 ] , node . split [ 2 ] , & node . part_variances -> vert [ 0 ] ) ; sum_2_variances ( node . split [ 1 ] , node . split [ 3 ] , & node . part_variances -> vert [ 1 ] ) ; sum_2_variances ( & node . part_variances -> vert [ 0 ] , & node . part_variances -> vert [ 1 ] , & node . part_variances -> none ) ; }","<S2SV_ModStart> { variance_node node ; memset ( & node , 0 , sizeof ( node ) )",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-119,"CWE-119 <S2SV_StartBug> static INLINE void read_mv ( vp9_reader * r , MV * mv , const MV * ref , <S2SV_EndBug> const nmv_context * ctx , nmv_context_counts * counts , int allow_hp ) { const MV_JOINT_TYPE joint_type = <S2SV_StartBug> ( MV_JOINT_TYPE ) vp9_read_tree ( r , vp9_mv_joint_tree , ctx -> joints ) ; <S2SV_EndBug> const int use_hp = allow_hp && vp9_use_mv_hp ( ref ) ; MV diff = { 0 , 0 } ; if ( mv_joint_vertical ( joint_type ) ) diff . row = read_mv_component ( r , & ctx -> comps [ 0 ] , use_hp ) ; if ( mv_joint_horizontal ( joint_type ) ) diff . col = read_mv_component ( r , & ctx -> comps [ 1 ] , use_hp ) ; vp9_inc_mv ( & diff , counts ) ; mv -> row = ref -> row + diff . row ; mv -> col = ref -> col + diff . col ; }","<S2SV_ModStart> void read_mv ( vpx_reader <S2SV_ModEnd> * r , <S2SV_ModStart> ( MV_JOINT_TYPE ) vpx_read_tree <S2SV_ModEnd> ( r ,",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-354,CWE-000 bool recovery_cipher_abort ( void ) <S2SV_StartBug> { <S2SV_EndBug> if ( awaiting_character ) { awaiting_character = false ; return true ; } return false ; },<S2SV_ModStart> void ) { recovery_started = false ;,keepkey@keepkey-firmware/769714fcb569e7a4faff9530a2d9ac1f9d6e5680,CVE-2019-18672,https://github.com/keepkey/keepkey-firmware/commit/769714fcb569e7a4faff9530a2d9ac1f9d6e5680,2019-12-06T18:15Z
CWE-125,"CWE-125 static int lldp_private_8023_print ( netdissect_options * ndo , const u_char * tptr , u_int tlv_len ) { int subtype , hexdump = FALSE ; if ( tlv_len < 4 ) { return hexdump ; } subtype = * ( tptr + 3 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Subtype<S2SV_blank>(%u)"" , tok2str ( lldp_8023_subtype_values , ""unknown"" , subtype ) , subtype ) ) ; switch ( subtype ) { case LLDP_PRIVATE_8023_SUBTYPE_MACPHY : if ( tlv_len < 9 ) { return hexdump ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>autonegotiation<S2SV_blank>[%s]<S2SV_blank>(0x%02x)"" , bittok2str ( lldp_8023_autonegotiation_values , ""none"" , * ( tptr + 4 ) ) , * ( tptr + 4 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>PMD<S2SV_blank>autoneg<S2SV_blank>capability<S2SV_blank>[%s]<S2SV_blank>(0x%04x)"" , bittok2str ( lldp_pmd_capability_values , ""unknown"" , EXTRACT_16BITS ( tptr + 5 ) ) , EXTRACT_16BITS ( tptr + 5 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>MAU<S2SV_blank>type<S2SV_blank>%s<S2SV_blank>(0x%04x)"" , tok2str ( lldp_mau_types_values , ""unknown"" , EXTRACT_16BITS ( tptr + 7 ) ) , EXTRACT_16BITS ( tptr + 7 ) ) ) ; break ; case LLDP_PRIVATE_8023_SUBTYPE_MDIPOWER : if ( tlv_len < 7 ) { return hexdump ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>MDI<S2SV_blank>power<S2SV_blank>support<S2SV_blank>[%s],<S2SV_blank>power<S2SV_blank>pair<S2SV_blank>%s,<S2SV_blank>power<S2SV_blank>class<S2SV_blank>%s"" , bittok2str ( lldp_mdi_values , ""none"" , * ( tptr + 4 ) ) , tok2str ( lldp_mdi_power_pairs_values , ""unknown"" , * ( tptr + 5 ) ) , tok2str ( lldp_mdi_power_class_values , ""unknown"" , * ( tptr + 6 ) ) ) ) ; break ; case LLDP_PRIVATE_8023_SUBTYPE_LINKAGGR : if ( tlv_len < 9 ) { return hexdump ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>aggregation<S2SV_blank>status<S2SV_blank>[%s],<S2SV_blank>aggregation<S2SV_blank>port<S2SV_blank>ID<S2SV_blank>%u"" , bittok2str ( lldp_aggregation_values , ""none"" , * ( tptr + 4 ) ) , EXTRACT_32BITS ( tptr + 5 ) ) ) ; break ; case LLDP_PRIVATE_8023_SUBTYPE_MTU : <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>MTU<S2SV_blank>size<S2SV_blank>%u"" , EXTRACT_16BITS ( tptr + 4 ) ) ) ; <S2SV_EndBug> break ; default : hexdump = TRUE ; break ; } return hexdump ; }",<S2SV_ModStart> case LLDP_PRIVATE_8023_SUBTYPE_MTU : if ( tlv_len < 6 ) { return hexdump ; },the-tcpdump-group@tcpdump/e6511cc1a950fe1566b2236329d6b4bd0826cc7a,CVE-2017-13054,https://github.com/the-tcpdump-group/tcpdump/commit/e6511cc1a950fe1566b2236329d6b4bd0826cc7a,2017-09-14T06:29Z
CWE-200,"CWE-200 static int vmci_transport_dgram_dequeue ( struct kiocb * kiocb , struct vsock_sock * vsk , struct msghdr * msg , size_t len , int flags ) { int err ; int noblock ; struct vmci_datagram * dg ; size_t payload_len ; struct sk_buff * skb ; noblock = flags & MSG_DONTWAIT ; if ( flags & MSG_OOB || flags & MSG_ERRQUEUE ) return - EOPNOTSUPP ; <S2SV_StartBug> err = 0 ; <S2SV_EndBug> skb = skb_recv_datagram ( & vsk -> sk , flags , noblock , & err ) ; if ( err ) return err ; if ( ! skb ) return - EAGAIN ; dg = ( struct vmci_datagram * ) skb -> data ; if ( ! dg ) goto out ; payload_len = dg -> payload_size ; if ( payload_len != skb -> len - sizeof ( * dg ) ) { err = - EINVAL ; goto out ; } if ( payload_len > len ) { payload_len = len ; msg -> msg_flags |= MSG_TRUNC ; } err = skb_copy_datagram_iovec ( skb , sizeof ( * dg ) , msg -> msg_iov , payload_len ) ; if ( err ) goto out ; <S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> if ( msg -> msg_name ) { struct sockaddr_vm * vm_addr ; vm_addr = ( struct sockaddr_vm * ) msg -> msg_name ; vsock_addr_init ( vm_addr , dg -> src . context , dg -> src . resource ) ; msg -> msg_namelen = sizeof ( * vm_addr ) ; } err = payload_len ; out : skb_free_datagram ( & vsk -> sk , skb ) ; return err ; }",<S2SV_ModStart> - EOPNOTSUPP ; msg -> msg_namelen = 0 ; <S2SV_ModStart> goto out ; <S2SV_ModEnd> if ( msg,torvalds@linux/680d04e0ba7e926233e3b9cee59125ce181f66ba,CVE-2013-3236,https://github.com/torvalds/linux/commit/680d04e0ba7e926233e3b9cee59125ce181f66ba,2013-04-22T11:41Z
CWE-200,"CWE-200 static inline int verify_replay ( struct xfrm_usersa_info * p , struct nlattr * * attrs ) { struct nlattr * rt = attrs [ XFRMA_REPLAY_ESN_VAL ] ; <S2SV_StartBug> if ( ( p -> flags & XFRM_STATE_ESN ) && ! rt ) <S2SV_EndBug> <S2SV_StartBug> return - EINVAL ; <S2SV_EndBug> if ( ! rt ) return 0 ; if ( p -> id . proto != IPPROTO_ESP ) return - EINVAL ; if ( p -> replay_window != 0 ) return - EINVAL ; return 0 ; }",<S2SV_ModStart> XFRMA_REPLAY_ESN_VAL ] ; struct xfrm_replay_state_esn * rs ; if <S2SV_ModEnd> ( p -> <S2SV_ModStart> & XFRM_STATE_ESN ) { if ( <S2SV_ModEnd> ! rt ) <S2SV_ModStart> - EINVAL ; rs = nla_data ( rt ) ; if ( rs -> bmp_len > XFRMA_REPLAY_ESN_MAX / sizeof ( rs -> bmp [ 0 ] ) / 8 ) return - EINVAL ; if ( nla_len ( rt ) < xfrm_replay_state_esn_len ( rs ) && nla_len ( rt ) != sizeof ( * rs ) ) return - EINVAL ; },torvalds@linux/ecd7918745234e423dd87fcc0c077da557909720,CVE-2012-6536,https://github.com/torvalds/linux/commit/ecd7918745234e423dd87fcc0c077da557909720,2013-03-15T20:55Z
CWE-362,"CWE-362 static bool blk_kick_flush ( struct request_queue * q , struct blk_flush_queue * fq ) { struct list_head * pending = & fq -> flush_queue [ fq -> flush_pending_idx ] ; struct request * first_rq = list_first_entry ( pending , struct request , flush . list ) ; struct request * flush_rq = fq -> flush_rq ; if ( fq -> flush_pending_idx != fq -> flush_running_idx || list_empty ( pending ) ) return false ; if ( ! list_empty ( & fq -> flush_data_in_flight ) && time_before ( jiffies , fq -> flush_pending_since + FLUSH_PENDING_TIMEOUT ) ) return false ; fq -> flush_pending_idx ^= 1 ; blk_rq_init ( q , flush_rq ) ; if ( q -> mq_ops ) { <S2SV_StartBug> flush_rq -> mq_ctx = first_rq -> mq_ctx ; <S2SV_EndBug> <S2SV_StartBug> flush_rq -> tag = first_rq -> tag ; <S2SV_EndBug> } flush_rq -> cmd_type = REQ_TYPE_FS ; flush_rq -> cmd_flags = WRITE_FLUSH | REQ_FLUSH_SEQ ; flush_rq -> rq_disk = first_rq -> rq_disk ; flush_rq -> end_io = flush_end_io ; return blk_flush_queue_rq ( flush_rq , false ) ; }","<S2SV_ModStart> mq_ops ) { struct blk_mq_hw_ctx * hctx ; <S2SV_ModStart> first_rq -> tag ; fq -> orig_rq = first_rq ; hctx = q -> mq_ops -> map_queue ( q , first_rq -> mq_ctx -> cpu ) ; blk_mq_tag_set_rq ( hctx , first_rq -> tag , flush_rq )",torvalds@linux/0048b4837affd153897ed1222283492070027aa9,CVE-2015-9016,https://github.com/torvalds/linux/commit/0048b4837affd153897ed1222283492070027aa9,2018-04-05T18:29Z
CWE-119,CWE-119 static vpx_codec_err_t encoder_destroy ( vpx_codec_alg_priv_t * ctx ) { free ( ctx -> cx_data ) ; vp9_remove_compressor ( ctx -> cpi ) ; <S2SV_StartBug> free ( ctx ) ; <S2SV_EndBug> return VPX_CODEC_OK ; },<S2SV_ModStart> cpi ) ; # if CONFIG_MULTITHREAD pthread_mutex_destroy ( & ctx -> buffer_pool -> pool_mutex ) ; # endif vpx_free ( ctx -> buffer_pool ) ; vpx_free <S2SV_ModEnd> ( ctx ),external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-399,"CWE-399 static int fst_get_iface ( struct fst_card_info * card , struct fst_port_info * port , struct ifreq * ifr ) { sync_serial_settings sync ; int i ; switch ( port -> hwif ) { case E1 : ifr -> ifr_settings . type = IF_IFACE_E1 ; break ; case T1 : ifr -> ifr_settings . type = IF_IFACE_T1 ; break ; case V35 : ifr -> ifr_settings . type = IF_IFACE_V35 ; break ; case V24 : ifr -> ifr_settings . type = IF_IFACE_V24 ; break ; case X21D : ifr -> ifr_settings . type = IF_IFACE_X21D ; break ; case X21 : default : ifr -> ifr_settings . type = IF_IFACE_X21 ; break ; } if ( ifr -> ifr_settings . size == 0 ) { return 0 ; } if ( ifr -> ifr_settings . size < sizeof ( sync ) ) { return - ENOMEM ; } i = port -> index ; <S2SV_StartBug> sync . clock_rate = FST_RDL ( card , portConfig [ i ] . lineSpeed ) ; <S2SV_EndBug> sync . clock_type = FST_RDB ( card , portConfig [ i ] . internalClock ) == INTCLK ? CLOCK_INT : CLOCK_EXT ; sync . loopback = 0 ; if ( copy_to_user ( ifr -> ifr_settings . ifs_ifsu . sync , & sync , sizeof ( sync ) ) ) { return - EFAULT ; } ifr -> ifr_settings . size = sizeof ( sync ) ; return 0 ; }","<S2SV_ModStart> -> index ; memset ( & sync , 0 , sizeof ( sync ) ) ;",torvalds@linux/96b340406724d87e4621284ebac5e059d67b2194,CVE-2014-1444,https://github.com/torvalds/linux/commit/96b340406724d87e4621284ebac5e059d67b2194,2014-01-18T22:55Z
CWE-284,"CWE-284 static inline int btif_hl_select_close_connected ( void ) { char sig_on = btif_hl_signal_select_close_connected ; BTIF_TRACE_DEBUG ( ""btif_hl_select_close_connected"" ) ; <S2SV_StartBug> return send ( signal_fds [ 1 ] , & sig_on , sizeof ( sig_on ) , 0 ) ; <S2SV_EndBug> }","<S2SV_ModStart> ) ; return TEMP_FAILURE_RETRY ( <S2SV_ModStart> , 0 ) )",system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z
CWE-399,"CWE-399 gboolean cib_notify_client ( gpointer key , gpointer value , gpointer user_data ) { const char * type = NULL ; gboolean do_send = FALSE ; cib_client_t * client = value ; xmlNode * update_msg = user_data ; CRM_CHECK ( client != NULL , return TRUE ) ; CRM_CHECK ( update_msg != NULL , return TRUE ) ; <S2SV_StartBug> if ( client -> ipc == NULL ) { <S2SV_EndBug> crm_warn ( ""Skipping<S2SV_blank>client<S2SV_blank>with<S2SV_blank>NULL<S2SV_blank>channel"" ) ; return FALSE ; } type = crm_element_value ( update_msg , F_SUBTYPE ) ; CRM_LOG_ASSERT ( type != NULL ) ; if ( client -> diffs && safe_str_eq ( type , T_CIB_DIFF_NOTIFY ) ) { do_send = TRUE ; } else if ( client -> replace && safe_str_eq ( type , T_CIB_REPLACE_NOTIFY ) ) { do_send = TRUE ; } else if ( client -> confirmations && safe_str_eq ( type , T_CIB_UPDATE_CONFIRM ) ) { do_send = TRUE ; } else if ( client -> pre_notify && safe_str_eq ( type , T_CIB_PRE_NOTIFY ) ) { do_send = TRUE ; } else if ( client -> post_notify && safe_str_eq ( type , T_CIB_POST_NOTIFY ) ) { do_send = TRUE ; } if ( do_send ) { if ( client -> ipc ) { if ( crm_ipcs_send ( client -> ipc , 0 , update_msg , TRUE ) == FALSE ) { crm_warn ( ""Notification<S2SV_blank>of<S2SV_blank>client<S2SV_blank>%s/%s<S2SV_blank>failed"" , client -> name , client -> id ) ; } # ifdef HAVE_GNUTLS_GNUTLS_H } else if ( client -> session ) { crm_debug ( ""Sent<S2SV_blank>%s<S2SV_blank>notification<S2SV_blank>to<S2SV_blank>client<S2SV_blank>%s/%s"" , type , client -> name , client -> id ) ; crm_send_remote_msg ( client -> session , update_msg , client -> encrypted ) ; # endif } else { crm_err ( ""Unknown<S2SV_blank>transport<S2SV_blank>for<S2SV_blank>%s"" , client -> name ) ; } } return FALSE ; }",<S2SV_ModStart> ipc == NULL && client -> session == NULL,ClusterLabs@pacemaker/564f7cc2a51dcd2f28ab12a13394f31be5aa3c93,CVE-2013-0281,https://github.com/ClusterLabs/pacemaker/commit/564f7cc2a51dcd2f28ab12a13394f31be5aa3c93,2013-11-23T11:55Z
CWE-119,"CWE-119 static int pop_fetch_headers ( struct Context * ctx ) { struct PopData * pop_data = ( struct PopData * ) ctx -> data ; struct Progress progress ; # ifdef USE_HCACHE header_cache_t * hc = pop_hcache_open ( pop_data , ctx -> path ) ; # endif time ( & pop_data -> check_time ) ; pop_data -> clear_cache = false ; for ( int i = 0 ; i < ctx -> msgcount ; i ++ ) ctx -> hdrs [ i ] -> refno = - 1 ; const int old_count = ctx -> msgcount ; int ret = pop_fetch_data ( pop_data , ""UIDL\\r\\n"" , NULL , fetch_uidl , ctx ) ; const int new_count = ctx -> msgcount ; ctx -> msgcount = old_count ; if ( pop_data -> cmd_uidl == 2 ) { if ( ret == 0 ) { pop_data -> cmd_uidl = 1 ; mutt_debug ( 1 , ""set<S2SV_blank>UIDL<S2SV_blank>capability\\n"" ) ; } if ( ret == - 2 && pop_data -> cmd_uidl == 2 ) { pop_data -> cmd_uidl = 0 ; mutt_debug ( 1 , ""unset<S2SV_blank>UIDL<S2SV_blank>capability\\n"" ) ; snprintf ( pop_data -> err_msg , sizeof ( pop_data -> err_msg ) , ""%s"" , _ ( ""Command<S2SV_blank>UIDL<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>server."" ) ) ; } } if ( ! ctx -> quiet ) { mutt_progress_init ( & progress , _ ( ""Fetching<S2SV_blank>message<S2SV_blank>headers..."" ) , MUTT_PROGRESS_MSG , ReadInc , new_count - old_count ) ; } if ( ret == 0 ) { int i , deleted ; for ( i = 0 , deleted = 0 ; i < old_count ; i ++ ) { if ( ctx -> hdrs [ i ] -> refno == - 1 ) { ctx -> hdrs [ i ] -> deleted = true ; deleted ++ ; } } if ( deleted > 0 ) { mutt_error ( ngettext ( ""%d<S2SV_blank>message<S2SV_blank>has<S2SV_blank>been<S2SV_blank>lost.<S2SV_blank>Try<S2SV_blank>reopening<S2SV_blank>the<S2SV_blank>mailbox."" , ""%d<S2SV_blank>messages<S2SV_blank>have<S2SV_blank>been<S2SV_blank>lost.<S2SV_blank>Try<S2SV_blank>reopening<S2SV_blank>the<S2SV_blank>mailbox."" , deleted ) , deleted ) ; } bool hcached = false ; for ( i = old_count ; i < new_count ; i ++ ) { if ( ! ctx -> quiet ) mutt_progress_update ( & progress , i + 1 - old_count , - 1 ) ; # ifdef USE_HCACHE void * data = mutt_hcache_fetch ( hc , ctx -> hdrs [ i ] -> data , strlen ( ctx -> hdrs [ i ] -> data ) ) ; if ( data ) { char * uidl = mutt_str_strdup ( ctx -> hdrs [ i ] -> data ) ; int refno = ctx -> hdrs [ i ] -> refno ; int index = ctx -> hdrs [ i ] -> index ; struct Header * h = mutt_hcache_restore ( ( unsigned char * ) data ) ; mutt_hcache_free ( hc , & data ) ; mutt_header_free ( & ctx -> hdrs [ i ] ) ; ctx -> hdrs [ i ] = h ; ctx -> hdrs [ i ] -> refno = refno ; ctx -> hdrs [ i ] -> index = index ; ctx -> hdrs [ i ] -> data = uidl ; ret = 0 ; hcached = true ; } else # endif if ( ( ret = pop_read_header ( pop_data , ctx -> hdrs [ i ] ) ) < 0 ) break ; # ifdef USE_HCACHE else { mutt_hcache_store ( hc , ctx -> hdrs [ i ] -> data , strlen ( ctx -> hdrs [ i ] -> data ) , ctx -> hdrs [ i ] , 0 ) ; } # endif const bool bcached = <S2SV_StartBug> ( mutt_bcache_exists ( pop_data -> bcache , ctx -> hdrs [ i ] -> data ) == 0 ) ; <S2SV_EndBug> ctx -> hdrs [ i ] -> old = false ; ctx -> hdrs [ i ] -> read = false ; if ( hcached ) { if ( bcached ) ctx -> hdrs [ i ] -> read = true ; else if ( MarkOld ) ctx -> hdrs [ i ] -> old = true ; } else { if ( bcached ) ctx -> hdrs [ i ] -> read = true ; } ctx -> msgcount ++ ; } if ( i > old_count ) mx_update_context ( ctx , i - old_count ) ; } # ifdef USE_HCACHE mutt_hcache_close ( hc ) ; # endif if ( ret < 0 ) { for ( int i = ctx -> msgcount ; i < new_count ; i ++ ) mutt_header_free ( & ctx -> hdrs [ i ] ) ; return ret ; } if ( MessageCacheClean ) mutt_bcache_list ( pop_data -> bcache , msg_cache_check , ( void * ) ctx ) ; mutt_clear_error ( ) ; return ( new_count - old_count ) ; }","<S2SV_ModStart> -> bcache , cache_id ( ctx -> hdrs [ i ] -> data ) <S2SV_ModEnd> ) == 0",neomutt@neomutt/9bfab35522301794483f8f9ed60820bdec9be59e,CVE-2018-14362,https://github.com/neomutt/neomutt/commit/9bfab35522301794483f8f9ed60820bdec9be59e,2018-07-17T17:29Z
CWE-119,"CWE-119 static int dtls1_buffer_record ( SSL * s , record_pqueue * queue , unsigned char * priority ) { DTLS1_RECORD_DATA * rdata ; pitem * item ; if ( pqueue_size ( queue -> q ) >= 100 ) return 0 ; rdata = OPENSSL_malloc ( sizeof ( DTLS1_RECORD_DATA ) ) ; item = pitem_new ( priority , rdata ) ; if ( rdata == NULL || item == NULL ) { if ( rdata != NULL ) OPENSSL_free ( rdata ) ; if ( item != NULL ) pitem_free ( item ) ; SSLerr ( SSL_F_DTLS1_BUFFER_RECORD , ERR_R_INTERNAL_ERROR ) ; return ( 0 ) ; } rdata -> packet = s -> packet ; rdata -> packet_length = s -> packet_length ; memcpy ( & ( rdata -> rbuf ) , & ( s -> s3 -> rbuf ) , sizeof ( SSL3_BUFFER ) ) ; memcpy ( & ( rdata -> rrec ) , & ( s -> s3 -> rrec ) , sizeof ( SSL3_RECORD ) ) ; item -> data = rdata ; # ifndef OPENSSL_NO_SCTP if ( BIO_dgram_is_sctp ( SSL_get_rbio ( s ) ) && ( s -> state == SSL3_ST_SR_FINISHED_A || s -> state == SSL3_ST_CR_FINISHED_A ) ) { BIO_ctrl ( SSL_get_rbio ( s ) , BIO_CTRL_DGRAM_SCTP_GET_RCVINFO , sizeof ( rdata -> recordinfo ) , & rdata -> recordinfo ) ; } # endif s -> packet = NULL ; s -> packet_length = 0 ; memset ( & ( s -> s3 -> rbuf ) , 0 , sizeof ( SSL3_BUFFER ) ) ; memset ( & ( s -> s3 -> rrec ) , 0 , sizeof ( SSL3_RECORD ) ) ; if ( ! ssl3_setup_buffers ( s ) ) { SSLerr ( SSL_F_DTLS1_BUFFER_RECORD , ERR_R_INTERNAL_ERROR ) ; <S2SV_StartBug> OPENSSL_free ( rdata ) ; <S2SV_EndBug> pitem_free ( item ) ; <S2SV_StartBug> return ( 0 ) ; <S2SV_EndBug> } if ( pqueue_insert ( queue -> q , item ) == NULL ) { SSLerr ( SSL_F_DTLS1_BUFFER_RECORD , ERR_R_INTERNAL_ERROR ) ; <S2SV_StartBug> OPENSSL_free ( rdata ) ; <S2SV_EndBug> pitem_free ( item ) ; <S2SV_StartBug> return ( 0 ) ; <S2SV_EndBug> } return ( 1 ) ; }",<S2SV_ModStart> ERR_R_INTERNAL_ERROR ) ; if ( rdata -> rbuf . buf != NULL ) <S2SV_ModStart> OPENSSL_free ( rdata -> rbuf . buf ) ; OPENSSL_free ( rdata <S2SV_ModStart> ; return ( - 1 <S2SV_ModEnd> ) ; } <S2SV_ModStart> ERR_R_INTERNAL_ERROR ) ; if ( rdata -> rbuf . buf != NULL ) <S2SV_ModStart> OPENSSL_free ( rdata -> rbuf . buf ) ; OPENSSL_free ( rdata <S2SV_ModStart> ; return ( - 1 <S2SV_ModEnd> ) ; },openssl@openssl/103b171d8fc282ef435f8de9afbf7782e312961f,CVE-2015-0206,https://github.com/openssl/openssl/commit/103b171d8fc282ef435f8de9afbf7782e312961f,2015-01-09T02:59Z
CWE-399,"CWE-399 static int dcbnl_getperm_hwaddr ( struct net_device * netdev , struct nlmsghdr * nlh , u32 seq , struct nlattr * * tb , struct sk_buff * skb ) { u8 perm_addr [ MAX_ADDR_LEN ] ; if ( ! netdev -> dcbnl_ops -> getpermhwaddr ) return - EOPNOTSUPP ; <S2SV_StartBug> netdev -> dcbnl_ops -> getpermhwaddr ( netdev , perm_addr ) ; <S2SV_EndBug> return nla_put ( skb , DCB_ATTR_PERM_HWADDR , sizeof ( perm_addr ) , perm_addr ) ; }","<S2SV_ModStart> - EOPNOTSUPP ; memset ( perm_addr , 0 , sizeof ( perm_addr ) ) ;",torvalds@linux/29cd8ae0e1a39e239a3a7b67da1986add1199fc0,CVE-2013-2634,https://github.com/torvalds/linux/commit/29cd8ae0e1a39e239a3a7b67da1986add1199fc0,2013-03-22T11:59Z
CWE-119,"CWE-119 static void yv12_extend_frame_left_right_c ( YV12_BUFFER_CONFIG * ybf , unsigned char * y_src , unsigned char * u_src , unsigned char * v_src ) { int i ; unsigned char * src_ptr1 , * src_ptr2 ; unsigned char * dest_ptr1 , * dest_ptr2 ; unsigned int Border ; int plane_stride ; int plane_height ; int plane_width ; Border = ybf -> border ; plane_stride = ybf -> y_stride ; plane_height = 16 ; plane_width = ybf -> y_width ; src_ptr1 = y_src ; src_ptr2 = src_ptr1 + plane_width - 1 ; dest_ptr1 = src_ptr1 - Border ; dest_ptr2 = src_ptr2 + 1 ; for ( i = 0 ; i < plane_height ; i ++ ) { <S2SV_StartBug> vpx_memset ( dest_ptr1 , src_ptr1 [ 0 ] , Border ) ; <S2SV_EndBug> vpx_memset ( dest_ptr2 , src_ptr2 [ 0 ] , Border ) ; src_ptr1 += plane_stride ; src_ptr2 += plane_stride ; dest_ptr1 += plane_stride ; dest_ptr2 += plane_stride ; } plane_stride = ybf -> uv_stride ; plane_height = 8 ; plane_width = ybf -> uv_width ; Border /= 2 ; src_ptr1 = u_src ; src_ptr2 = src_ptr1 + plane_width - 1 ; dest_ptr1 = src_ptr1 - Border ; dest_ptr2 = src_ptr2 + 1 ; for ( i = 0 ; i < plane_height ; i ++ ) { <S2SV_StartBug> vpx_memset ( dest_ptr1 , src_ptr1 [ 0 ] , Border ) ; <S2SV_EndBug> vpx_memset ( dest_ptr2 , src_ptr2 [ 0 ] , Border ) ; src_ptr1 += plane_stride ; src_ptr2 += plane_stride ; dest_ptr1 += plane_stride ; dest_ptr2 += plane_stride ; } src_ptr1 = v_src ; src_ptr2 = src_ptr1 + plane_width - 1 ; dest_ptr1 = src_ptr1 - Border ; dest_ptr2 = src_ptr2 + 1 ; for ( i = 0 ; i < plane_height ; i ++ ) { <S2SV_StartBug> vpx_memset ( dest_ptr1 , src_ptr1 [ 0 ] , Border ) ; <S2SV_EndBug> vpx_memset ( dest_ptr2 , src_ptr2 [ 0 ] , Border ) ; src_ptr1 += plane_stride ; src_ptr2 += plane_stride ; dest_ptr1 += plane_stride ; dest_ptr2 += plane_stride ; } }","<S2SV_ModStart> ++ ) { memset ( dest_ptr1 , src_ptr1 [ 0 ] , Border ) ; memset <S2SV_ModEnd> ( dest_ptr2 , <S2SV_ModStart> ++ ) { memset ( dest_ptr1 , src_ptr1 [ 0 ] , Border ) ; memset <S2SV_ModEnd> ( dest_ptr2 , <S2SV_ModStart> ++ ) { memset ( dest_ptr1 , src_ptr1 [ 0 ] , Border ) ; memset <S2SV_ModEnd> ( dest_ptr2 ,",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-399,"CWE-399 static int xfrm6_tunnel_rcv ( struct sk_buff * skb ) { struct ipv6hdr * iph = ipv6_hdr ( skb ) ; __be32 spi ; spi = xfrm6_tunnel_spi_lookup ( ( xfrm_address_t * ) & iph -> saddr ) ; <S2SV_StartBug> return xfrm6_rcv_spi ( skb , spi ) ; <S2SV_EndBug> }","<S2SV_ModStart> , spi ) > 0 ? : 0",torvalds@linux/d0772b70faaf8e9f2013b6c4273d94d5eac8047a,CVE-2012-1583,https://github.com/torvalds/linux/commit/d0772b70faaf8e9f2013b6c4273d94d5eac8047a,2012-06-16T21:55Z
CWE-20,"CWE-20 static zval * * spl_array_get_dimension_ptr_ptr ( int check_inherited , zval * object , zval * offset , int type TSRMLS_DC ) { spl_array_object * intern = ( spl_array_object * ) zend_object_store_get_object ( object TSRMLS_CC ) ; zval * * retval ; char * key ; uint len ; long index ; HashTable * ht = spl_array_get_hash_table ( intern , 0 TSRMLS_CC ) ; <S2SV_StartBug> if ( ! offset ) { <S2SV_EndBug> return & EG ( uninitialized_zval_ptr ) ; } if ( ( type == BP_VAR_W || type == BP_VAR_RW ) && ( ht -> nApplyCount > 0 ) ) { zend_error ( E_WARNING , ""Modification<S2SV_blank>of<S2SV_blank>ArrayObject<S2SV_blank>during<S2SV_blank>sorting<S2SV_blank>is<S2SV_blank>prohibited"" ) ; return & EG ( error_zval_ptr ) ; ; } switch ( Z_TYPE_P ( offset ) ) { case IS_STRING : key = Z_STRVAL_P ( offset ) ; len = Z_STRLEN_P ( offset ) + 1 ; string_offest : if ( zend_symtable_find ( ht , key , len , ( void * * ) & retval ) == FAILURE ) { switch ( type ) { case BP_VAR_R : zend_error ( E_NOTICE , ""Undefined<S2SV_blank>index:<S2SV_blank>%s"" , key ) ; case BP_VAR_UNSET : case BP_VAR_IS : retval = & EG ( uninitialized_zval_ptr ) ; break ; case BP_VAR_RW : zend_error ( E_NOTICE , ""Undefined<S2SV_blank>index:<S2SV_blank>%s"" , key ) ; case BP_VAR_W : { zval * value ; ALLOC_INIT_ZVAL ( value ) ; zend_symtable_update ( ht , key , len , ( void * * ) & value , sizeof ( void * ) , ( void * * ) & retval ) ; } } } return retval ; case IS_NULL : key = """" ; len = 1 ; goto string_offest ; case IS_RESOURCE : zend_error ( E_STRICT , ""Resource<S2SV_blank>ID#%ld<S2SV_blank>used<S2SV_blank>as<S2SV_blank>offset,<S2SV_blank>casting<S2SV_blank>to<S2SV_blank>integer<S2SV_blank>(%ld)"" , Z_LVAL_P ( offset ) , Z_LVAL_P ( offset ) ) ; case IS_DOUBLE : case IS_BOOL : case IS_LONG : if ( offset -> type == IS_DOUBLE ) { index = ( long ) Z_DVAL_P ( offset ) ; } else { index = Z_LVAL_P ( offset ) ; } if ( zend_hash_index_find ( ht , index , ( void * * ) & retval ) == FAILURE ) { switch ( type ) { case BP_VAR_R : zend_error ( E_NOTICE , ""Undefined<S2SV_blank>offset:<S2SV_blank>%ld"" , index ) ; case BP_VAR_UNSET : case BP_VAR_IS : retval = & EG ( uninitialized_zval_ptr ) ; break ; case BP_VAR_RW : zend_error ( E_NOTICE , ""Undefined<S2SV_blank>offset:<S2SV_blank>%ld"" , index ) ; case BP_VAR_W : { zval * value ; ALLOC_INIT_ZVAL ( value ) ; zend_hash_index_update ( ht , index , ( void * * ) & value , sizeof ( void * ) , ( void * * ) & retval ) ; } } } return retval ; default : zend_error ( E_WARNING , ""Illegal<S2SV_blank>offset<S2SV_blank>type"" ) ; return ( type == BP_VAR_W || type == BP_VAR_RW ) ? & EG ( error_zval_ptr ) : & EG ( uninitialized_zval_ptr ) ; } }",<S2SV_ModStart> ( ! offset || ! ht,php@php-src/ecb7f58a069be0dec4a6131b6351a761f808f22e,CVE-2016-7417,https://github.com/php/php-src/commit/ecb7f58a069be0dec4a6131b6351a761f808f22e?w=1,2016-09-17T21:59Z
CWE-264,"CWE-264 static int sd_ioctl ( struct block_device * bdev , fmode_t mode , unsigned int cmd , unsigned long arg ) { struct gendisk * disk = bdev -> bd_disk ; struct scsi_disk * sdkp = scsi_disk ( disk ) ; struct scsi_device * sdp = sdkp -> device ; void __user * p = ( void __user * ) arg ; int error ; SCSI_LOG_IOCTL ( 1 , sd_printk ( KERN_INFO , sdkp , ""sd_ioctl:<S2SV_blank>disk=%s,<S2SV_blank>"" ""cmd=0x%x\\n"" , disk -> disk_name , cmd ) ) ; <S2SV_StartBug> error = scsi_nonblockable_ioctl ( sdp , cmd , p , <S2SV_EndBug> ( mode & FMODE_NDELAY ) != 0 ) ; if ( ! scsi_block_when_processing_errors ( sdp ) || ! error ) goto out ; switch ( cmd ) { case SCSI_IOCTL_GET_IDLUN : case SCSI_IOCTL_GET_BUS_NUMBER : error = scsi_ioctl ( sdp , cmd , p ) ; break ; default : error = scsi_cmd_blk_ioctl ( bdev , mode , cmd , p ) ; if ( error != - ENOTTY ) break ; error = scsi_ioctl ( sdp , cmd , p ) ; break ; } out : return error ; }","<S2SV_ModStart> ; error = scsi_verify_blk_ioctl ( bdev , cmd ) ; if ( error < 0 ) return error ; error =",torvalds@linux/0bfc96cb77224736dfa35c3c555d37b3646ef35e,CVE-2011-4127,https://github.com/torvalds/linux/commit/0bfc96cb77224736dfa35c3c555d37b3646ef35e,2012-07-03T16:40Z
CWE-78,"CWE-000 static char * __filterShell ( const char * arg ) { r_return_val_if_fail ( arg , NULL ) ; char * a = malloc ( strlen ( arg ) + 1 ) ; if ( ! a ) { return NULL ; } char * b = a ; while ( * arg ) { <S2SV_StartBug> switch ( * arg ) { <S2SV_EndBug> case '@' : case '`' : case '|' : case ';' : <S2SV_StartBug> case '\\n' : <S2SV_EndBug> break ; default : <S2SV_StartBug> * b ++ = * arg ; <S2SV_EndBug> break ; } arg ++ ; } * b = 0 ; return a ; }",<S2SV_ModStart> arg ) { char ch = * arg ; switch ( ch <S2SV_ModEnd> ) { case <S2SV_ModStart> ';' : case '=' : case <S2SV_ModStart> b ++ = ch <S2SV_ModEnd> ; break ;,radareorg@radare2/5411543a310a470b1257fb93273cdd6e8dfcb3af,CVE-2019-16718,https://github.com/radareorg/radare2/commit/5411543a310a470b1257fb93273cdd6e8dfcb3af,2019-09-23T14:15Z
CWE-119,"CWE-119 static void tg3_read_vpd ( struct tg3 * tp ) { u8 * vpd_data ; unsigned int block_end , rosize , len ; u32 vpdlen ; int j , i = 0 ; vpd_data = ( u8 * ) tg3_vpd_readblock ( tp , & vpdlen ) ; if ( ! vpd_data ) goto out_no_vpd ; i = pci_vpd_find_tag ( vpd_data , 0 , vpdlen , PCI_VPD_LRDT_RO_DATA ) ; if ( i < 0 ) goto out_not_found ; rosize = pci_vpd_lrdt_size ( & vpd_data [ i ] ) ; block_end = i + PCI_VPD_LRDT_TAG_SIZE + rosize ; i += PCI_VPD_LRDT_TAG_SIZE ; if ( block_end > vpdlen ) goto out_not_found ; j = pci_vpd_find_info_keyword ( vpd_data , i , rosize , PCI_VPD_RO_KEYWORD_MFR_ID ) ; if ( j > 0 ) { len = pci_vpd_info_field_size ( & vpd_data [ j ] ) ; j += PCI_VPD_INFO_FLD_HDR_SIZE ; if ( j + len > block_end || len != 4 || memcmp ( & vpd_data [ j ] , ""1028"" , 4 ) ) goto partno ; j = pci_vpd_find_info_keyword ( vpd_data , i , rosize , PCI_VPD_RO_KEYWORD_VENDOR0 ) ; if ( j < 0 ) goto partno ; len = pci_vpd_info_field_size ( & vpd_data [ j ] ) ; j += PCI_VPD_INFO_FLD_HDR_SIZE ; if ( j + len > block_end ) goto partno ; <S2SV_StartBug> memcpy ( tp -> fw_ver , & vpd_data [ j ] , len ) ; <S2SV_EndBug> <S2SV_StartBug> strncat ( tp -> fw_ver , ""<S2SV_blank>bc<S2SV_blank>"" , vpdlen - len - 1 ) ; <S2SV_EndBug> } partno : i = pci_vpd_find_info_keyword ( vpd_data , i , rosize , PCI_VPD_RO_KEYWORD_PARTNO ) ; if ( i < 0 ) goto out_not_found ; len = pci_vpd_info_field_size ( & vpd_data [ i ] ) ; i += PCI_VPD_INFO_FLD_HDR_SIZE ; if ( len > TG3_BPN_SIZE || ( len + i ) > vpdlen ) goto out_not_found ; memcpy ( tp -> board_part_number , & vpd_data [ i ] , len ) ; out_not_found : kfree ( vpd_data ) ; if ( tp -> board_part_number [ 0 ] ) return ; out_no_vpd : if ( tg3_asic_rev ( tp ) == ASIC_REV_5717 ) { if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_5717 || tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_5717_C ) strcpy ( tp -> board_part_number , ""BCM5717"" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_5718 ) strcpy ( tp -> board_part_number , ""BCM5718"" ) ; else goto nomatch ; } else if ( tg3_asic_rev ( tp ) == ASIC_REV_57780 ) { if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57780 ) strcpy ( tp -> board_part_number , ""BCM57780"" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57760 ) strcpy ( tp -> board_part_number , ""BCM57760"" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57790 ) strcpy ( tp -> board_part_number , ""BCM57790"" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57788 ) strcpy ( tp -> board_part_number , ""BCM57788"" ) ; else goto nomatch ; } else if ( tg3_asic_rev ( tp ) == ASIC_REV_57765 ) { if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57761 ) strcpy ( tp -> board_part_number , ""BCM57761"" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57765 ) strcpy ( tp -> board_part_number , ""BCM57765"" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57781 ) strcpy ( tp -> board_part_number , ""BCM57781"" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57785 ) strcpy ( tp -> board_part_number , ""BCM57785"" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57791 ) strcpy ( tp -> board_part_number , ""BCM57791"" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57795 ) strcpy ( tp -> board_part_number , ""BCM57795"" ) ; else goto nomatch ; } else if ( tg3_asic_rev ( tp ) == ASIC_REV_57766 ) { if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57762 ) strcpy ( tp -> board_part_number , ""BCM57762"" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57766 ) strcpy ( tp -> board_part_number , ""BCM57766"" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57782 ) strcpy ( tp -> board_part_number , ""BCM57782"" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57786 ) strcpy ( tp -> board_part_number , ""BCM57786"" ) ; else goto nomatch ; } else if ( tg3_asic_rev ( tp ) == ASIC_REV_5906 ) { strcpy ( tp -> board_part_number , ""BCM95906"" ) ; } else { nomatch : strcpy ( tp -> board_part_number , ""none"" ) ; } }","<S2SV_ModStart> goto partno ; if ( len >= sizeof <S2SV_ModEnd> ( tp -> <S2SV_ModStart> tp -> fw_ver ) ) len = sizeof <S2SV_ModEnd> ( tp -> <S2SV_ModStart> tp -> fw_ver ) - 1 ; memset ( tp -> fw_ver , 0 , sizeof ( tp -> fw_ver ) ) ; snprintf ( tp -> fw_ver , sizeof ( tp -> fw_ver ) , ""%.*s<S2SV_blank>bc<S2SV_blank>"" , len , & vpd_data [ j ] <S2SV_ModEnd> ) ; }",torvalds@linux/715230a44310a8cf66fbfb5a46f9a62a9b2de424,CVE-2013-1929,https://github.com/torvalds/linux/commit/715230a44310a8cf66fbfb5a46f9a62a9b2de424,2013-06-07T14:03Z
CWE-190,"CWE-190 static inline signed short ReadPropertyMSBShort ( const unsigned char * * p , size_t * length ) { union { unsigned short unsigned_value ; signed short signed_value ; } quantum ; int c ; register ssize_t i ; unsigned char buffer [ 2 ] ; unsigned short value ; if ( * length < 2 ) return ( ( unsigned short ) ~ 0 ) ; for ( i = 0 ; i < 2 ; i ++ ) { c = ( int ) ( * ( * p ) ++ ) ; ( * length ) -- ; buffer [ i ] = ( unsigned char ) c ; } <S2SV_StartBug> value = ( unsigned short ) ( buffer [ 0 ] << 8 ) ; <S2SV_EndBug> <S2SV_StartBug> value |= buffer [ 1 ] ; <S2SV_EndBug> <S2SV_StartBug> quantum . unsigned_value = ( value & 0xffff ) ; <S2SV_EndBug> return ( quantum . signed_value ) ; }",<S2SV_ModStart> unsigned short ) <S2SV_ModEnd> buffer [ 0 <S2SV_ModStart> ] << 8 <S2SV_ModEnd> ; value |= <S2SV_ModStart> ; value |= ( unsigned short ) <S2SV_ModStart> . unsigned_value = <S2SV_ModEnd> value & 0xffff <S2SV_ModStart> value & 0xffff <S2SV_ModEnd> ; return (,ImageMagick@ImageMagick/d8ab7f046587f2e9f734b687ba7e6e10147c294b,CVE-2016-5841,https://github.com/ImageMagick/ImageMagick/commit/d8ab7f046587f2e9f734b687ba7e6e10147c294b,2016-12-13T15:59Z
CWE-119,"CWE-119 static void update_golden_frame_stats ( VP8_COMP * cpi ) { VP8_COMMON * cm = & cpi -> common ; if ( cm -> refresh_golden_frame ) { if ( ! cpi -> auto_gold ) cpi -> frames_till_gf_update_due = DEFAULT_GF_INTERVAL ; if ( ( cpi -> pass != 2 ) && ( cpi -> frames_till_gf_update_due > 0 ) ) { cpi -> current_gf_interval = cpi -> frames_till_gf_update_due ; if ( ( cm -> frame_type != KEY_FRAME ) && ! cpi -> source_alt_ref_active ) { cpi -> gf_overspend_bits += ( cpi -> projected_frame_size - cpi -> inter_frame_target ) ; } cpi -> non_gf_bitrate_adjustment = cpi -> gf_overspend_bits / cpi -> frames_till_gf_update_due ; } <S2SV_StartBug> vpx_memset ( cpi -> gf_active_flags , 1 , ( cm -> mb_rows * cm -> mb_cols ) ) ; <S2SV_EndBug> cpi -> gf_active_count = cm -> mb_rows * cm -> mb_cols ; cm -> refresh_golden_frame = 0 ; cpi -> frames_since_golden = 0 ; cpi -> recent_ref_frame_usage [ INTRA_FRAME ] = 1 ; cpi -> recent_ref_frame_usage [ LAST_FRAME ] = 1 ; cpi -> recent_ref_frame_usage [ GOLDEN_FRAME ] = 1 ; cpi -> recent_ref_frame_usage [ ALTREF_FRAME ] = 1 ; if ( cpi -> oxcf . fixed_q >= 0 && cpi -> oxcf . play_alternate && ! cpi -> common . refresh_alt_ref_frame ) { cpi -> source_alt_ref_pending = 1 ; cpi -> frames_till_gf_update_due = cpi -> baseline_gf_interval ; } if ( ! cpi -> source_alt_ref_pending ) cpi -> source_alt_ref_active = 0 ; if ( cpi -> frames_till_gf_update_due > 0 ) cpi -> frames_till_gf_update_due -- ; } else if ( ! cpi -> common . refresh_alt_ref_frame ) { if ( cpi -> frames_till_gf_update_due > 0 ) cpi -> frames_till_gf_update_due -- ; if ( cpi -> frames_till_alt_ref_frame ) cpi -> frames_till_alt_ref_frame -- ; cpi -> frames_since_golden ++ ; if ( cpi -> frames_since_golden > 1 ) { cpi -> recent_ref_frame_usage [ INTRA_FRAME ] += cpi -> mb . count_mb_ref_frame_usage [ INTRA_FRAME ] ; cpi -> recent_ref_frame_usage [ LAST_FRAME ] += cpi -> mb . count_mb_ref_frame_usage [ LAST_FRAME ] ; cpi -> recent_ref_frame_usage [ GOLDEN_FRAME ] += cpi -> mb . count_mb_ref_frame_usage [ GOLDEN_FRAME ] ; cpi -> recent_ref_frame_usage [ ALTREF_FRAME ] += cpi -> mb . count_mb_ref_frame_usage [ ALTREF_FRAME ] ; } } }",<S2SV_ModStart> frames_till_gf_update_due ; } memset <S2SV_ModEnd> ( cpi ->,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-119,"CWE-119 vpx_codec_err_t vpx_codec_destroy ( vpx_codec_ctx_t * ctx ) { vpx_codec_err_t res ; if ( ! ctx ) res = VPX_CODEC_INVALID_PARAM ; else if ( ! ctx -> iface || ! ctx -> priv ) res = VPX_CODEC_ERROR ; else { <S2SV_StartBug> if ( ctx -> priv -> alg_priv ) <S2SV_EndBug> <S2SV_StartBug> ctx -> iface -> destroy ( ctx -> priv -> alg_priv ) ; <S2SV_EndBug> ctx -> iface = NULL ; ctx -> name = NULL ; ctx -> priv = NULL ; res = VPX_CODEC_OK ; } return SAVE_STATUS ( ctx , res ) ; }",<S2SV_ModStart> ; else { <S2SV_ModEnd> ctx -> iface <S2SV_ModStart> -> destroy ( ( vpx_codec_alg_priv_t * ) <S2SV_ModStart> ctx -> priv <S2SV_ModEnd> ) ; ctx,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-399,"CWE-399 <S2SV_StartBug> static void ip6_append_data_mtu ( int * mtu , <S2SV_EndBug> int * maxfraglen , unsigned int fragheaderlen , struct sk_buff * skb , <S2SV_StartBug> struct rt6_info * rt ) <S2SV_EndBug> { if ( ! ( rt -> dst . flags & DST_XFRM_TUNNEL ) ) { if ( skb == NULL ) { * mtu = * mtu - rt -> dst . header_len ; } else { <S2SV_StartBug> * mtu = dst_mtu ( rt -> dst . path ) ; <S2SV_EndBug> } * maxfraglen = ( ( * mtu - fragheaderlen ) & ~ 7 ) + fragheaderlen - sizeof ( struct frag_hdr ) ; } }","<S2SV_ModStart> void ip6_append_data_mtu ( unsigned <S2SV_ModStart> rt6_info * rt , bool pmtuprobe <S2SV_ModStart> * mtu = min ( * mtu , pmtuprobe ? rt -> dst . dev -> mtu : <S2SV_ModStart> dst . path )",torvalds@linux/75a493e60ac4bbe2e977e7129d6d8cbb0dd236be,CVE-2013-4163,https://github.com/torvalds/linux/commit/75a493e60ac4bbe2e977e7129d6d8cbb0dd236be,2013-07-29T13:59Z
CWE-119,"CWE-119 <S2SV_StartBug> static void write_mv_update ( const vp9_tree_index * tree , <S2SV_EndBug> <S2SV_StartBug> vp9_prob probs [ ] , <S2SV_EndBug> const unsigned int counts [ ] , <S2SV_StartBug> int n , vp9_writer * w ) { <S2SV_EndBug> int i ; unsigned int branch_ct [ 32 ] [ 2 ] ; assert ( n <= 32 ) ; vp9_tree_probs_from_distribution ( tree , branch_ct , counts ) ; for ( i = 0 ; i < n - 1 ; ++ i ) update_mv ( w , branch_ct [ i ] , & probs [ i ] , MV_UPDATE_PROB ) ; }","<S2SV_ModStart> write_mv_update ( const vpx_tree_index <S2SV_ModEnd> * tree , <S2SV_ModStart> * tree , vpx_prob <S2SV_ModEnd> probs [ ] <S2SV_ModStart> int n , vpx_writer <S2SV_ModEnd> * w )",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-119,"CWE-119 static void record_recent_object ( struct object * obj , <S2SV_StartBug> struct strbuf * path , <S2SV_EndBug> <S2SV_StartBug> const char * last , <S2SV_EndBug> void * data ) { sha1_array_append ( & recent_objects , obj -> oid . hash ) ; }","<S2SV_ModStart> * obj , <S2SV_ModEnd> const char * <S2SV_ModStart> const char * name <S2SV_ModEnd> , void *",git@git/de1e67d0703894cb6ea782e36abb63976ab07e60,CVE-2016-2315,https://github.com/git/git/commit/de1e67d0703894cb6ea782e36abb63976ab07e60,2016-04-08T14:59Z
CWE-125,"CWE-125 static x86newTokenType getToken ( const char * str , size_t * begin , size_t * end ) { <S2SV_StartBug> while ( begin && isspace ( ( ut8 ) str [ * begin ] ) ) { <S2SV_EndBug> ++ ( * begin ) ; } if ( ! str [ * begin ] ) { * end = * begin ; return TT_EOF ; <S2SV_StartBug> } else if ( isalpha ( ( ut8 ) str [ * begin ] ) ) { <S2SV_EndBug> * end = * begin ; <S2SV_StartBug> while ( end && isalnum ( ( ut8 ) str [ * end ] ) ) { <S2SV_EndBug> ++ ( * end ) ; } return TT_WORD ; <S2SV_StartBug> } else if ( isdigit ( ( ut8 ) str [ * begin ] ) ) { <S2SV_EndBug> * end = * begin ; while ( end && isalnum ( ( ut8 ) str [ * end ] ) ) { ++ ( * end ) ; } return TT_NUMBER ; } else { * end = * begin + 1 ; return TT_SPECIAL ; } }",<S2SV_ModStart> end ) { if ( * begin > strlen ( str ) ) { return TT_EOF ; } <S2SV_ModStart> ( begin && str [ * begin ] && <S2SV_ModStart> TT_EOF ; } <S2SV_ModEnd> if ( isalpha <S2SV_ModStart> ( end && str [ * end ] && <S2SV_ModStart> TT_WORD ; } <S2SV_ModEnd> if ( isdigit,radare@radare2/66191f780863ea8c66ace4040d0d04a8842e8432,CVE-2018-19842,https://github.com/radare/radare2/commit/66191f780863ea8c66ace4040d0d04a8842e8432,2018-12-04T09:29Z
CWE-125,"CWE-125 node * PyParser_ParseStringObject ( const char * s , PyObject * filename , grammar * g , int start , perrdetail * err_ret , int * flags ) { struct tok_state * tok ; int exec_input = start == file_input ; if ( initerr ( err_ret , filename ) < 0 ) return NULL ; if ( * flags & PyPARSE_IGNORE_COOKIE ) tok = PyTokenizer_FromUTF8 ( s , exec_input ) ; else tok = PyTokenizer_FromString ( s , exec_input ) ; if ( tok == NULL ) { err_ret -> error = PyErr_Occurred ( ) ? E_DECODE : E_NOMEM ; return NULL ; } <S2SV_StartBug> # ifndef PGEN <S2SV_EndBug> Py_INCREF ( err_ret -> filename ) ; tok -> filename = err_ret -> filename ; # endif return parsetok ( tok , g , start , err_ret , flags ) ; }",<S2SV_ModStart> NULL ; } if ( * flags & PyPARSE_TYPE_COMMENTS ) { tok -> type_comments = 1 ; },python@typed_ast/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,CVE-2019-19275,https://github.com/python/typed_ast/commit/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,2019-11-26T15:15Z
CWE-617,"CWE-000 int pci_emul_alloc_pbar ( struct pci_vdev * pdi , int idx , uint64_t hostbase , enum pcibar_type type , uint64_t size ) { int error ; uint64_t * baseptr , limit , addr , mask , lobits , bar ; <S2SV_StartBug> assert ( idx >= 0 && idx <= PCI_BARMAX ) ; <S2SV_EndBug> if ( ( size & ( size - 1 ) ) != 0 ) size = 1UL << flsl ( size ) ; if ( type == PCIBAR_IO ) { if ( size < 4 ) size = 4 ; } else { if ( size < 16 ) size = 16 ; } switch ( type ) { case PCIBAR_NONE : baseptr = NULL ; addr = mask = lobits = 0 ; break ; case PCIBAR_IO : baseptr = & pci_emul_iobase ; limit = PCI_EMUL_IOLIMIT ; mask = PCIM_BAR_IO_BASE ; lobits = PCIM_BAR_IO_SPACE ; break ; <S2SV_StartBug> case PCIBAR_MEM64 : <S2SV_EndBug> if ( ! skip_pci_mem64bar_workaround && ( size <= 32 * 1024 * 1024 ) ) { baseptr = & pci_emul_membase32 ; limit = PCI_EMUL_MEMLIMIT32 ; mask = PCIM_BAR_MEM_BASE ; lobits = PCIM_BAR_MEM_SPACE | PCIM_BAR_MEM_64 ; break ; } if ( size == 0x100000000UL ) baseptr = & hostbase ; else baseptr = & pci_emul_membase64 ; limit = PCI_EMUL_MEMLIMIT64 ; mask = PCIM_BAR_MEM_BASE ; lobits = PCIM_BAR_MEM_SPACE | PCIM_BAR_MEM_64 | PCIM_BAR_MEM_PREFETCH ; break ; case PCIBAR_MEM32 : baseptr = & pci_emul_membase32 ; limit = PCI_EMUL_MEMLIMIT32 ; mask = PCIM_BAR_MEM_BASE ; lobits = PCIM_BAR_MEM_SPACE | PCIM_BAR_MEM_32 ; break ; default : <S2SV_StartBug> printf ( ""%s:<S2SV_blank>invalid<S2SV_blank>bar<S2SV_blank>type<S2SV_blank>%d\\n"" , __func__ , type ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( 0 ) ; <S2SV_EndBug> } if ( baseptr != NULL ) { error = pci_emul_alloc_resource ( baseptr , limit , size , & addr ) ; if ( error != 0 ) return error ; } pdi -> bar [ idx ] . type = type ; pdi -> bar [ idx ] . addr = addr ; pdi -> bar [ idx ] . size = size ; bar = ( addr & mask ) | lobits ; pci_set_cfgdata32 ( pdi , PCIR_BAR ( idx ) , bar ) ; if ( type == PCIBAR_MEM64 ) { <S2SV_StartBug> assert ( idx + 1 <= PCI_BARMAX ) ; <S2SV_EndBug> pdi -> bar [ idx + 1 ] . type = PCIBAR_MEMHI64 ; pci_set_cfgdata32 ( pdi , PCIR_BAR ( idx + 1 ) , bar >> 32 ) ; } register_bar ( pdi , idx ) ; return 0 ; }","<S2SV_ModStart> , bar ; <S2SV_ModEnd> if ( ( <S2SV_ModStart> case PCIBAR_MEM64 : if ( idx + 1 > PCI_BARMAX ) { pr_err ( ""%s:<S2SV_blank>invalid<S2SV_blank>bar<S2SV_blank>number<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>MEM64<S2SV_blank>type\\n"" , __func__ , idx ) ; return - 1 ; } <S2SV_ModStart> ; default : pr_err <S2SV_ModEnd> ( ""%s:<S2SV_blank>invalid<S2SV_blank>bar<S2SV_blank>type<S2SV_blank>%d\\n"" , <S2SV_ModStart> type ) ; return - 1 <S2SV_ModEnd> ; } if <S2SV_ModStart> PCIBAR_MEM64 ) { <S2SV_ModEnd> pdi -> bar",projectacrn@acrn-hypervisor/2b3dedfb9ba13f15887f22b935d373f36c9a59fa,CVE-2019-18844,https://github.com/projectacrn/acrn-hypervisor/commit/2b3dedfb9ba13f15887f22b935d373f36c9a59fa,2019-11-13T20:15Z
CWE-77,"CWE-000 static int save_dev ( blkid_dev dev , FILE * file ) { struct list_head * p ; if ( ! dev || dev -> bid_name [ 0 ] != '/' ) return 0 ; DBG ( SAVE , ul_debug ( ""device<S2SV_blank>%s,<S2SV_blank>type<S2SV_blank>%s"" , dev -> bid_name , dev -> bid_type ? dev -> bid_type : ""(null)"" ) ) ; fprintf ( file , ""<device<S2SV_blank>DEVNO=\\""0x%04lx\\""<S2SV_blank>TIME=\\""%ld.%ld\\"""" , ( unsigned long ) dev -> bid_devno , ( long ) dev -> bid_time , ( long ) dev -> bid_utime ) ; if ( dev -> bid_pri ) fprintf ( file , ""<S2SV_blank>PRI=\\""%d\\"""" , dev -> bid_pri ) ; list_for_each ( p , & dev -> bid_tags ) { blkid_tag tag = list_entry ( p , struct blkid_struct_tag , bit_tags ) ; <S2SV_StartBug> fprintf ( file , ""<S2SV_blank>%s=\\""%s\\"""" , tag -> bit_name , tag -> bit_val ) ; <S2SV_EndBug> } fprintf ( file , "">%s</device>\\n"" , dev -> bid_name ) ; return 0 ; }","<S2SV_ModStart> bit_tags ) ; fputc ( '<S2SV_blank>' , file ) ; fputs ( <S2SV_ModEnd> tag -> bit_name <S2SV_ModStart> -> bit_name , file ) ; fputc ( '=' , file ) ; save_quoted ( <S2SV_ModStart> tag -> bit_val , file",karelzak@util-linux/89e90ae7b2826110ea28c1c0eb8e7c56c3907bdc,CVE-2014-9114,https://github.com/karelzak/util-linux/commit/89e90ae7b2826110ea28c1c0eb8e7c56c3907bdc,2017-03-31T16:59Z
CWE-362,"CWE-362 void sctp_generate_t3_rtx_event ( unsigned long peer ) { int error ; struct sctp_transport * transport = ( struct sctp_transport * ) peer ; struct sctp_association * asoc = transport -> asoc ; <S2SV_StartBug> struct net * net = sock_net ( asoc -> base . sk ) ; <S2SV_EndBug> <S2SV_StartBug> bh_lock_sock ( asoc -> base . sk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( sock_owned_by_user ( asoc -> base . sk ) ) { <S2SV_EndBug> pr_debug ( ""%s:<S2SV_blank>sock<S2SV_blank>is<S2SV_blank>busy\\n"" , __func__ ) ; if ( ! mod_timer ( & transport -> T3_rtx_timer , jiffies + ( HZ / 20 ) ) ) sctp_transport_hold ( transport ) ; goto out_unlock ; } if ( transport -> dead ) goto out_unlock ; error = sctp_do_sm ( net , SCTP_EVENT_T_TIMEOUT , SCTP_ST_TIMEOUT ( SCTP_EVENT_TIMEOUT_T3_RTX ) , asoc -> state , asoc -> ep , asoc , transport , GFP_ATOMIC ) ; if ( error ) <S2SV_StartBug> asoc -> base . sk -> sk_err = - error ; <S2SV_EndBug> out_unlock : <S2SV_StartBug> bh_unlock_sock ( asoc -> base . sk ) ; <S2SV_EndBug> sctp_transport_put ( transport ) ; }",<S2SV_ModStart> asoc ; struct sock * sk = asoc -> base . sk ; struct <S2SV_ModStart> = sock_net ( <S2SV_ModEnd> sk ) ; <S2SV_ModStart> ; bh_lock_sock ( <S2SV_ModEnd> sk ) ; <S2SV_ModStart> ( sock_owned_by_user ( <S2SV_ModEnd> sk ) ) <S2SV_ModStart> ( error ) <S2SV_ModEnd> sk -> sk_err <S2SV_ModStart> : bh_unlock_sock ( <S2SV_ModEnd> sk ) ;,torvalds@linux/635682a14427d241bab7bbdeebb48a7d7b91638e,CVE-2015-8767,https://github.com/torvalds/linux/commit/635682a14427d241bab7bbdeebb48a7d7b91638e,2016-02-08T03:59Z
CWE-476,"CWE-476 static int dissect_usb_video_control_interface_descriptor ( proto_tree * parent_tree , tvbuff_t * tvb , guint8 descriptor_len , packet_info * pinfo , usb_conv_info_t * usb_conv_info ) { video_conv_info_t * video_conv_info = NULL ; video_entity_t * entity = NULL ; proto_item * item = NULL ; proto_item * subtype_item = NULL ; proto_tree * tree = NULL ; guint8 entity_id = 0 ; guint16 terminal_type = 0 ; int offset = 0 ; guint8 subtype ; subtype = tvb_get_guint8 ( tvb , offset + 2 ) ; if ( parent_tree ) { const gchar * subtype_str ; subtype_str = val_to_str_ext ( subtype , & vc_if_descriptor_subtypes_ext , ""Unknown<S2SV_blank>(0x%x)"" ) ; tree = proto_tree_add_subtree_format ( parent_tree , tvb , offset , descriptor_len , ett_descriptor_video_control , & item , ""VIDEO<S2SV_blank>CONTROL<S2SV_blank>INTERFACE<S2SV_blank>DESCRIPTOR<S2SV_blank>[%s]"" , subtype_str ) ; } dissect_usb_descriptor_header ( tree , tvb , offset , & vid_descriptor_type_vals_ext ) ; subtype_item = proto_tree_add_item ( tree , hf_usb_vid_control_ifdesc_subtype , tvb , offset + 2 , 1 , ENC_LITTLE_ENDIAN ) ; offset += 3 ; if ( subtype == VC_HEADER ) { guint8 num_vs_interfaces ; proto_tree_add_item ( tree , hf_usb_vid_control_ifdesc_bcdUVC , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ; proto_tree_add_item ( tree , hf_usb_vid_ifdesc_wTotalLength , tvb , offset + 2 , 2 , ENC_LITTLE_ENDIAN ) ; proto_tree_add_item ( tree , hf_usb_vid_control_ifdesc_dwClockFrequency , tvb , offset + 4 , 4 , ENC_LITTLE_ENDIAN ) ; num_vs_interfaces = tvb_get_guint8 ( tvb , offset + 8 ) ; proto_tree_add_item ( tree , hf_usb_vid_control_ifdesc_bInCollection , tvb , offset + 8 , 1 , ENC_LITTLE_ENDIAN ) ; if ( num_vs_interfaces > 0 ) { proto_tree_add_item ( tree , hf_usb_vid_control_ifdesc_baInterfaceNr , tvb , offset + 9 , num_vs_interfaces , ENC_NA ) ; } offset += 9 + num_vs_interfaces ; } else if ( ( subtype == VC_INPUT_TERMINAL ) || ( subtype == VC_OUTPUT_TERMINAL ) ) { entity_id = tvb_get_guint8 ( tvb , offset ) ; terminal_type = tvb_get_letohs ( tvb , offset + 1 ) ; proto_tree_add_item ( tree , hf_usb_vid_control_ifdesc_terminal_id , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ; proto_tree_add_item ( tree , hf_usb_vid_control_ifdesc_terminal_type , tvb , offset + 1 , 2 , ENC_LITTLE_ENDIAN ) ; proto_tree_add_item ( tree , hf_usb_vid_control_ifdesc_assoc_terminal , tvb , offset + 3 , 1 , ENC_LITTLE_ENDIAN ) ; offset += 4 ; if ( subtype == VC_OUTPUT_TERMINAL ) { proto_tree_add_item ( tree , hf_usb_vid_control_ifdesc_src_id , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ; ++ offset ; } proto_tree_add_item ( tree , hf_usb_vid_control_ifdesc_iTerminal , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ; ++ offset ; if ( subtype == VC_INPUT_TERMINAL ) { if ( terminal_type == ITT_CAMERA ) { offset = dissect_usb_video_camera_terminal ( tree , tvb , offset ) ; } else if ( terminal_type == ITT_MEDIA_TRANSPORT_INPUT ) { } } if ( subtype == VC_OUTPUT_TERMINAL ) { if ( terminal_type == OTT_MEDIA_TRANSPORT_OUTPUT ) { } } } else { entity_id = tvb_get_guint8 ( tvb , offset ) ; proto_tree_add_item ( tree , hf_usb_vid_control_ifdesc_unit_id , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ; ++ offset ; if ( subtype == VC_PROCESSING_UNIT ) { offset = dissect_usb_video_processing_unit ( tree , tvb , offset ) ; } else if ( subtype == VC_SELECTOR_UNIT ) { offset = dissect_usb_video_selector_unit ( tree , tvb , offset ) ; } else if ( subtype == VC_EXTENSION_UNIT ) { offset = dissect_usb_video_extension_unit ( tree , tvb , offset ) ; } else if ( subtype == VC_ENCODING_UNIT ) { } else { expert_add_info_format ( pinfo , subtype_item , & ei_usb_vid_subtype_unknown , ""Unknown<S2SV_blank>VC<S2SV_blank>subtype<S2SV_blank>%u"" , subtype ) ; } } if ( offset < descriptor_len ) { proto_tree_add_item ( tree , hf_usb_vid_descriptor_data , tvb , offset , descriptor_len - offset , ENC_NA ) ; } if ( entity_id != 0 ) proto_item_append_text ( item , ""<S2SV_blank>(Entity<S2SV_blank>%d)"" , entity_id ) ; if ( subtype != VC_HEADER && usb_conv_info ) { usb_conv_info = get_usb_iface_conv_info ( pinfo , usb_conv_info -> interfaceNum ) ; video_conv_info = ( video_conv_info_t * ) usb_conv_info -> class_data ; if ( ! video_conv_info ) { video_conv_info = wmem_new ( wmem_file_scope ( ) , video_conv_info_t ) ; video_conv_info -> entities = wmem_tree_new ( wmem_file_scope ( ) ) ; usb_conv_info -> class_data = video_conv_info ; <S2SV_StartBug> } <S2SV_EndBug> entity = ( video_entity_t * ) wmem_tree_lookup32 ( video_conv_info -> entities , entity_id ) ; if ( ! entity ) { entity = wmem_new ( wmem_file_scope ( ) , video_entity_t ) ; entity -> entityID = entity_id ; entity -> subtype = subtype ; entity -> terminalType = terminal_type ; wmem_tree_insert32 ( video_conv_info -> entities , entity_id , entity ) ; } } return descriptor_len ; }",<S2SV_ModStart> = video_conv_info ; usb_conv_info -> class_data_type = USB_CONV_VIDEO ; } else if ( usb_conv_info -> class_data_type != USB_CONV_VIDEO ) { return descriptor_len ;,wireshark@wireshark/2cb5985bf47bdc8bea78d28483ed224abdd33dc6,CVE-2016-5354,https://github.com/wireshark/wireshark/commit/2cb5985bf47bdc8bea78d28483ed224abdd33dc6,2016-08-07T16:59Z
,"CWE-000 static ssize_t aio_setup_single_vector ( struct kiocb * kiocb , int rw , char __user * buf , unsigned long * nr_segs , size_t len , <S2SV_StartBug> struct iovec * iovec ) <S2SV_EndBug> { if ( unlikely ( ! access_ok ( ! rw , buf , len ) ) ) return - EFAULT ; iovec -> iov_base = buf ; iovec -> iov_len = len ; * nr_segs = 1 ; <S2SV_StartBug> return 0 ; <S2SV_EndBug> }","<S2SV_ModStart> iovec * iovec , struct iov_iter * iter ) { if ( len > MAX_RW_COUNT ) len = MAX_RW_COUNT ; <S2SV_ModEnd> if ( unlikely <S2SV_ModStart> = 1 ; iov_iter_init ( iter , rw , iovec , * nr_segs , len ) ;",torvalds@linux/4c185ce06dca14f5cea192f5a2c981ef50663f2b,CVE-2015-8830,https://github.com/torvalds/linux/commit/4c185ce06dca14f5cea192f5a2c981ef50663f2b,2016-05-02T10:59Z
CWE-200,"CWE-200 static int vsock_stream_recvmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sock * sk ; struct vsock_sock * vsk ; int err ; size_t target ; ssize_t copied ; long timeout ; struct vsock_transport_recv_notify_data recv_data ; DEFINE_WAIT ( wait ) ; sk = sock -> sk ; vsk = vsock_sk ( sk ) ; err = 0 ; <S2SV_StartBug> lock_sock ( sk ) ; <S2SV_EndBug> if ( sk -> sk_state != SS_CONNECTED ) { if ( sock_flag ( sk , SOCK_DONE ) ) err = 0 ; else err = - ENOTCONN ; goto out ; } if ( flags & MSG_OOB ) { err = - EOPNOTSUPP ; goto out ; } if ( sk -> sk_shutdown & RCV_SHUTDOWN ) { err = 0 ; goto out ; } if ( ! len ) { err = 0 ; goto out ; } target = sock_rcvlowat ( sk , flags & MSG_WAITALL , len ) ; if ( target >= transport -> stream_rcvhiwat ( vsk ) ) { err = - ENOMEM ; goto out ; } timeout = sock_rcvtimeo ( sk , flags & MSG_DONTWAIT ) ; copied = 0 ; err = transport -> notify_recv_init ( vsk , target , & recv_data ) ; if ( err < 0 ) goto out ; prepare_to_wait ( sk_sleep ( sk ) , & wait , TASK_INTERRUPTIBLE ) ; while ( 1 ) { s64 ready = vsock_stream_has_data ( vsk ) ; if ( ready < 0 ) { err = - ENOMEM ; goto out_wait ; } else if ( ready > 0 ) { ssize_t read ; err = transport -> notify_recv_pre_dequeue ( vsk , target , & recv_data ) ; if ( err < 0 ) break ; read = transport -> stream_dequeue ( vsk , msg -> msg_iov , len - copied , flags ) ; if ( read < 0 ) { err = - ENOMEM ; break ; } copied += read ; err = transport -> notify_recv_post_dequeue ( vsk , target , read , ! ( flags & MSG_PEEK ) , & recv_data ) ; if ( err < 0 ) goto out_wait ; if ( read >= target || flags & MSG_PEEK ) break ; target -= read ; } else { if ( sk -> sk_err != 0 || ( sk -> sk_shutdown & RCV_SHUTDOWN ) || ( vsk -> peer_shutdown & SEND_SHUTDOWN ) ) { break ; } if ( timeout == 0 ) { err = - EAGAIN ; break ; } err = transport -> notify_recv_pre_block ( vsk , target , & recv_data ) ; if ( err < 0 ) break ; release_sock ( sk ) ; timeout = schedule_timeout ( timeout ) ; lock_sock ( sk ) ; if ( signal_pending ( current ) ) { err = sock_intr_errno ( timeout ) ; break ; } else if ( timeout == 0 ) { err = - EAGAIN ; break ; } prepare_to_wait ( sk_sleep ( sk ) , & wait , TASK_INTERRUPTIBLE ) ; } } if ( sk -> sk_err ) err = - sk -> sk_err ; else if ( sk -> sk_shutdown & RCV_SHUTDOWN ) err = 0 ; if ( copied > 0 ) { if ( ! ( flags & MSG_PEEK ) ) { if ( vsk -> peer_shutdown & SEND_SHUTDOWN ) { if ( vsock_stream_has_data ( vsk ) <= 0 ) { sk -> sk_state = SS_UNCONNECTED ; sock_set_flag ( sk , SOCK_DONE ) ; sk -> sk_state_change ( sk ) ; } } } err = copied ; } out_wait : finish_wait ( sk_sleep ( sk ) , & wait ) ; out : release_sock ( sk ) ; return err ; }",<S2SV_ModStart> = 0 ; msg -> msg_namelen = 0 ;,torvalds@linux/d5e0d0f607a7a029c6563a0470d88255c89a8d11,CVE-2013-3237,https://github.com/torvalds/linux/commit/d5e0d0f607a7a029c6563a0470d88255c89a8d11,2013-04-22T11:41Z
CWE-200,"CWE-200 int dse_bind ( Slapi_PBlock * pb ) { ber_tag_t method ; struct berval * cred ; Slapi_Value * * bvals ; struct dse * pdse ; Slapi_Attr * attr ; Slapi_DN * sdn = NULL ; Slapi_Entry * ec = NULL ; if ( slapi_pblock_get ( pb , SLAPI_PLUGIN_PRIVATE , & pdse ) < 0 || slapi_pblock_get ( pb , SLAPI_BIND_TARGET_SDN , & sdn ) < 0 || slapi_pblock_get ( pb , SLAPI_BIND_METHOD , & method ) < 0 || slapi_pblock_get ( pb , SLAPI_BIND_CREDENTIALS , & cred ) < 0 ) { slapi_send_ldap_result ( pb , LDAP_OPERATIONS_ERROR , NULL , NULL , 0 , NULL ) ; return SLAPI_BIND_FAIL ; } if ( method == LDAP_AUTH_SIMPLE && cred -> bv_len == 0 ) { slapi_send_ldap_result ( pb , LDAP_SUCCESS , NULL , NULL , 0 , NULL ) ; return ( SLAPI_BIND_FAIL ) ; } ec = dse_get_entry_copy ( pdse , sdn , DSE_USE_LOCK ) ; if ( ec == NULL ) { <S2SV_StartBug> slapi_send_ldap_result ( pb , LDAP_NO_SUCH_OBJECT , NULL , NULL , 0 , NULL ) ; <S2SV_EndBug> return ( SLAPI_BIND_FAIL ) ; } switch ( method ) { case LDAP_AUTH_SIMPLE : { Slapi_Value cv ; if ( slapi_entry_attr_find ( ec , ""userpassword"" , & attr ) != 0 ) { <S2SV_StartBug> slapi_send_ldap_result ( pb , LDAP_INAPPROPRIATE_AUTH , NULL , NULL , 0 , NULL ) ; <S2SV_EndBug> slapi_entry_free ( ec ) ; return SLAPI_BIND_FAIL ; } bvals = attr_get_present_values ( attr ) ; slapi_value_init_berval ( & cv , cred ) ; if ( slapi_pw_find_sv ( bvals , & cv ) != 0 ) { <S2SV_StartBug> slapi_send_ldap_result ( pb , LDAP_INVALID_CREDENTIALS , NULL , NULL , 0 , NULL ) ; <S2SV_EndBug> slapi_entry_free ( ec ) ; value_done ( & cv ) ; return SLAPI_BIND_FAIL ; } value_done ( & cv ) ; } break ; default : slapi_send_ldap_result ( pb , LDAP_STRONG_AUTH_NOT_SUPPORTED , NULL , ""auth<S2SV_blank>method<S2SV_blank>not<S2SV_blank>supported"" , 0 , NULL ) ; slapi_entry_free ( ec ) ; return SLAPI_BIND_FAIL ; } slapi_entry_free ( ec ) ; return SLAPI_BIND_SUCCESS ; }","<S2SV_ModStart> NULL ) { slapi_pblock_set ( pb , SLAPI_PB_RESULT_TEXT , ""Entry<S2SV_blank>does<S2SV_blank>not<S2SV_blank>exist"" ) ; slapi_send_ldap_result ( pb , LDAP_INVALID_CREDENTIALS <S2SV_ModEnd> , NULL , <S2SV_ModStart> 0 ) { slapi_pblock_set ( pb , SLAPI_PB_RESULT_TEXT , ""Entry<S2SV_blank>does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>userpassword<S2SV_blank>set"" ) ; slapi_send_ldap_result ( pb , LDAP_INVALID_CREDENTIALS <S2SV_ModEnd> , NULL , <S2SV_ModStart> 0 ) { slapi_pblock_set ( pb , SLAPI_PB_RESULT_TEXT , ""Invalid<S2SV_blank>credentials"" ) ;",389ds@389-ds-base/b6aae4d8e7c8a6ddd21646f94fef1bf7f22c3f32,CVE-2020-35518,https://github.com/389ds/389-ds-base/commit/b6aae4d8e7c8a6ddd21646f94fef1bf7f22c3f32,2021-03-26T17:15Z
CWE-416,"CWE-416 static struct page * follow_page_pte ( struct vm_area_struct * vma , unsigned long address , pmd_t * pmd , unsigned int flags , struct dev_pagemap * * pgmap ) { struct mm_struct * mm = vma -> vm_mm ; struct page * page ; spinlock_t * ptl ; pte_t * ptep , pte ; retry : if ( unlikely ( pmd_bad ( * pmd ) ) ) return no_page_table ( vma , flags ) ; ptep = pte_offset_map_lock ( mm , pmd , address , & ptl ) ; pte = * ptep ; if ( ! pte_present ( pte ) ) { swp_entry_t entry ; if ( likely ( ! ( flags & FOLL_MIGRATION ) ) ) goto no_page ; if ( pte_none ( pte ) ) goto no_page ; entry = pte_to_swp_entry ( pte ) ; if ( ! is_migration_entry ( entry ) ) goto no_page ; pte_unmap_unlock ( ptep , ptl ) ; migration_entry_wait ( mm , pmd , address ) ; goto retry ; } if ( ( flags & FOLL_NUMA ) && pte_protnone ( pte ) ) goto no_page ; if ( ( flags & FOLL_WRITE ) && ! can_follow_write_pte ( pte , flags ) ) { pte_unmap_unlock ( ptep , ptl ) ; return NULL ; } page = vm_normal_page ( vma , address , pte ) ; if ( ! page && pte_devmap ( pte ) && ( flags & FOLL_GET ) ) { * pgmap = get_dev_pagemap ( pte_pfn ( pte ) , * pgmap ) ; if ( * pgmap ) page = pte_page ( pte ) ; else goto no_page ; } else if ( unlikely ( ! page ) ) { if ( flags & FOLL_DUMP ) { page = ERR_PTR ( - EFAULT ) ; goto out ; } if ( is_zero_pfn ( pte_pfn ( pte ) ) ) { page = pte_page ( pte ) ; } else { int ret ; ret = follow_pfn_pte ( vma , address , ptep , flags ) ; page = ERR_PTR ( ret ) ; goto out ; } } if ( flags & FOLL_SPLIT && PageTransCompound ( page ) ) { int ret ; get_page ( page ) ; pte_unmap_unlock ( ptep , ptl ) ; lock_page ( page ) ; ret = split_huge_page ( page ) ; unlock_page ( page ) ; put_page ( page ) ; if ( ret ) return ERR_PTR ( ret ) ; goto retry ; } if ( flags & FOLL_GET ) <S2SV_StartBug> get_page ( page ) ; <S2SV_EndBug> if ( flags & FOLL_TOUCH ) { if ( ( flags & FOLL_WRITE ) && ! pte_dirty ( pte ) && ! PageDirty ( page ) ) set_page_dirty ( page ) ; mark_page_accessed ( page ) ; } if ( ( flags & FOLL_MLOCK ) && ( vma -> vm_flags & VM_LOCKED ) ) { if ( PageTransCompound ( page ) ) goto out ; if ( page -> mapping && trylock_page ( page ) ) { lru_add_drain ( ) ; mlock_vma_page ( page ) ; unlock_page ( page ) ; } } out : pte_unmap_unlock ( ptep , ptl ) ; return page ; no_page : pte_unmap_unlock ( ptep , ptl ) ; if ( ! pte_none ( pte ) ) return NULL ; return no_page_table ( vma , flags ) ; }",<S2SV_ModStart> & FOLL_GET ) { if ( unlikely ( ! try_get_page ( page ) ) ) { page = ERR_PTR ( - ENOMEM ) ; goto out ; } } <S2SV_ModEnd> if ( flags,torvalds@linux/6b3a707736301c2128ca85ce85fb13f60b5e350a,CVE-2019-11487,https://github.com/torvalds/linux/commit/6b3a707736301c2128ca85ce85fb13f60b5e350a,2019-04-23T22:29Z
CWE-119,"CWE-119 static void unqueue_me_pi ( struct futex_q * q ) { WARN_ON ( plist_node_empty ( & q -> list ) ) ; plist_del ( & q -> list , & q -> list . plist ) ; BUG_ON ( ! q -> pi_state ) ; free_pi_state ( q -> pi_state ) ; q -> pi_state = NULL ; spin_unlock ( q -> lock_ptr ) ; <S2SV_StartBug> drop_futex_key_refs ( & q -> key ) ; <S2SV_EndBug> }",<S2SV_ModStart> lock_ptr ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>,torvalds@linux/7ada876a8703f23befbb20a7465a702ee39b1704,CVE-2014-0205,https://github.com/torvalds/linux/commit/7ada876a8703f23befbb20a7465a702ee39b1704,2014-09-28T19:55Z
CWE-476,"CWE-476 void pdo_stmt_init ( TSRMLS_D ) { zend_class_entry ce ; INIT_CLASS_ENTRY ( ce , ""PDOStatement"" , pdo_dbstmt_functions ) ; pdo_dbstmt_ce = zend_register_internal_class ( & ce TSRMLS_CC ) ; pdo_dbstmt_ce -> get_iterator = pdo_stmt_iter_get ; pdo_dbstmt_ce -> create_object = pdo_dbstmt_new ; zend_class_implements ( pdo_dbstmt_ce TSRMLS_CC , 1 , zend_ce_traversable ) ; zend_declare_property_null ( pdo_dbstmt_ce , ""queryString"" , sizeof ( ""queryString"" ) - 1 , ZEND_ACC_PUBLIC TSRMLS_CC ) ; memcpy ( & pdo_dbstmt_object_handlers , & std_object_handlers , sizeof ( zend_object_handlers ) ) ; pdo_dbstmt_object_handlers . write_property = dbstmt_prop_write ; pdo_dbstmt_object_handlers . unset_property = dbstmt_prop_delete ; pdo_dbstmt_object_handlers . get_method = dbstmt_method_get ; pdo_dbstmt_object_handlers . compare_objects = dbstmt_compare ; pdo_dbstmt_object_handlers . clone_obj = dbstmt_clone_obj ; INIT_CLASS_ENTRY ( ce , ""PDORow"" , pdo_row_functions ) ; pdo_row_ce = zend_register_internal_class ( & ce TSRMLS_CC ) ; pdo_row_ce -> ce_flags |= ZEND_ACC_FINAL_CLASS ; pdo_row_ce -> create_object = pdo_row_new ; pdo_row_ce -> serialize = pdo_row_serialize ; <S2SV_StartBug> } <S2SV_EndBug>",<S2SV_ModStart> = pdo_row_serialize ; pdo_row_ce -> unserialize = zend_class_unserialize_deny ;,php@php-src/6045de69c7dedcba3eadf7c4bba424b19c81d00d,CVE-2016-9934,https://github.com/php/php-src/commit/6045de69c7dedcba3eadf7c4bba424b19c81d00d,2017-01-04T20:59Z
CWE-189,"CWE-189 static ssize_t f_hidg_write ( struct file * file , const char __user * buffer , size_t count , loff_t * offp ) { struct f_hidg * hidg = file -> private_data ; struct usb_request * req ; unsigned long flags ; ssize_t status = - ENOMEM ; if ( ! access_ok ( buffer , count ) ) return - EFAULT ; spin_lock_irqsave ( & hidg -> write_spinlock , flags ) ; # define WRITE_COND ( ! hidg -> write_pending ) try_again : while ( ! WRITE_COND ) { spin_unlock_irqrestore ( & hidg -> write_spinlock , flags ) ; if ( file -> f_flags & O_NONBLOCK ) return - EAGAIN ; if ( wait_event_interruptible_exclusive ( hidg -> write_queue , WRITE_COND ) ) return - ERESTARTSYS ; spin_lock_irqsave ( & hidg -> write_spinlock , flags ) ; } hidg -> write_pending = 1 ; req = hidg -> req ; count = min_t ( unsigned , count , hidg -> report_length ) ; spin_unlock_irqrestore ( & hidg -> write_spinlock , flags ) ; status = copy_from_user ( req -> buf , buffer , count ) ; if ( status != 0 ) { ERROR ( hidg -> func . config -> cdev , ""copy_from_user<S2SV_blank>error\\n"" ) ; status = - EINVAL ; goto release_write_pending ; } spin_lock_irqsave ( & hidg -> write_spinlock , flags ) ; if ( ! hidg -> req ) { free_ep_req ( hidg -> in_ep , req ) ; goto try_again ; } req -> status = 0 ; req -> zero = 0 ; req -> length = count ; req -> complete = f_hidg_req_complete ; req -> context = hidg ; <S2SV_StartBug> status = usb_ep_queue ( hidg -> in_ep , req , GFP_ATOMIC ) ; <S2SV_EndBug> if ( status < 0 ) { ERROR ( hidg -> func . config -> cdev , ""usb_ep_queue<S2SV_blank>error<S2SV_blank>on<S2SV_blank>int<S2SV_blank>endpoint<S2SV_blank>%zd\\n"" , status ) ; <S2SV_StartBug> goto release_write_pending_unlocked ; <S2SV_EndBug> } else { status = count ; } <S2SV_StartBug> spin_unlock_irqrestore ( & hidg -> write_spinlock , flags ) ; <S2SV_EndBug> return status ; release_write_pending : spin_lock_irqsave ( & hidg -> write_spinlock , flags ) ; <S2SV_StartBug> release_write_pending_unlocked : <S2SV_EndBug> hidg -> write_pending = 0 ; spin_unlock_irqrestore ( & hidg -> write_spinlock , flags ) ; wake_up ( & hidg -> write_queue ) ; return status ; }","<S2SV_ModStart> = hidg ; spin_unlock_irqrestore ( & hidg -> write_spinlock , flags ) ; <S2SV_ModStart> ) ; goto release_write_pending <S2SV_ModEnd> ; } else <S2SV_ModStart> count ; } <S2SV_ModEnd> return status ; <S2SV_ModStart> flags ) ; <S2SV_ModEnd> hidg -> write_pending",torvalds@linux/072684e8c58d17e853f8e8b9f6d9ce2e58d2b036,CVE-2019-14763,https://github.com/torvalds/linux/commit/072684e8c58d17e853f8e8b9f6d9ce2e58d2b036,2019-08-07T22:15Z
CWE-119,"CWE-119 static void close_output_file ( struct stream_state * stream , unsigned int fourcc ) { const struct vpx_codec_enc_cfg * const cfg = & stream -> config . cfg ; if ( cfg -> g_pass == VPX_RC_FIRST_PASS ) return ; # if CONFIG_WEBM_IO if ( stream -> config . write_webm ) { <S2SV_StartBug> write_webm_file_footer ( & stream -> ebml , stream -> hash ) ; <S2SV_EndBug> free ( stream -> ebml . cue_list ) ; stream -> ebml . cue_list = NULL ; } # endif if ( ! stream -> config . write_webm ) { if ( ! fseek ( stream -> file , 0 , SEEK_SET ) ) ivf_write_file_header ( stream -> file , & stream -> config . cfg , fourcc , stream -> frames_out ) ; } fclose ( stream -> file ) ; }",<S2SV_ModStart> stream -> ebml ) <S2SV_ModEnd> ; } #,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-125,"CWE-125 static void voutf ( struct GlobalConfig * config , const char * prefix , const char * fmt , va_list ap ) { size_t width = ( 79 - strlen ( prefix ) ) ; if ( ! config -> mute ) { size_t len ; char * ptr ; char * print_buffer ; print_buffer = curlx_mvaprintf ( fmt , ap ) ; if ( ! print_buffer ) return ; len = strlen ( print_buffer ) ; ptr = print_buffer ; while ( len > 0 ) { fputs ( prefix , config -> errors ) ; if ( len > width ) { size_t cut = width - 1 ; while ( ! ISSPACE ( ptr [ cut ] ) && cut ) { cut -- ; } if ( 0 == cut ) cut = width - 1 ; ( void ) fwrite ( ptr , cut + 1 , 1 , config -> errors ) ; fputs ( ""\\n"" , config -> errors ) ; ptr += cut + 1 ; <S2SV_StartBug> len -= cut ; <S2SV_EndBug> } else { fputs ( ptr , config -> errors ) ; len = 0 ; } } curl_free ( print_buffer ) ; } }",<S2SV_ModStart> len -= cut + 1,curl@curl/d530e92f59ae9bb2d47066c3c460b25d2ffeb211,CVE-2018-16842,https://github.com/curl/curl/commit/d530e92f59ae9bb2d47066c3c460b25d2ffeb211,2018-10-31T19:29Z
CWE-200,"CWE-200 int parse_config ( char * filename , bridge_t * * bridges ) { dictionary * ubridge_config = NULL ; const char * value ; const char * bridge_name ; int i , nsec ; <S2SV_StartBug> if ( ( ubridge_config = iniparser_load ( filename ) ) == NULL ) { <S2SV_EndBug> return FALSE ; } nsec = iniparser_getnsec ( ubridge_config ) ; for ( i = 0 ; i < nsec ; i ++ ) { bridge_t * bridge ; nio_t * source_nio = NULL ; nio_t * destination_nio = NULL ; bridge_name = iniparser_getsecname ( ubridge_config , i ) ; printf ( ""Parsing<S2SV_blank>%s\\n"" , bridge_name ) ; if ( getstr ( ubridge_config , bridge_name , ""source_udp"" , & value ) ) source_nio = create_udp_tunnel ( value ) ; else if ( getstr ( ubridge_config , bridge_name , ""source_unix"" , & value ) ) source_nio = create_unix_socket ( value ) ; else if ( getstr ( ubridge_config , bridge_name , ""source_ethernet"" , & value ) ) source_nio = open_ethernet_device ( value ) ; else if ( getstr ( ubridge_config , bridge_name , ""source_tap"" , & value ) ) source_nio = open_tap_device ( value ) ; # ifdef LINUX_RAW else if ( getstr ( ubridge_config , bridge_name , ""source_linux_raw"" , & value ) ) source_nio = open_linux_raw ( value ) ; # endif # ifdef __APPLE__ else if ( getstr ( ubridge_config , bridge_name , ""source_fusion_vmnet"" , & value ) ) source_nio = open_fusion_vmnet ( value ) ; # endif else fprintf ( stderr , ""source<S2SV_blank>NIO<S2SV_blank>not<S2SV_blank>found\\n"" ) ; if ( getstr ( ubridge_config , bridge_name , ""destination_udp"" , & value ) ) destination_nio = create_udp_tunnel ( value ) ; else if ( getstr ( ubridge_config , bridge_name , ""destination_unix"" , & value ) ) destination_nio = create_unix_socket ( value ) ; else if ( getstr ( ubridge_config , bridge_name , ""destination_ethernet"" , & value ) ) destination_nio = open_ethernet_device ( value ) ; else if ( getstr ( ubridge_config , bridge_name , ""destination_tap"" , & value ) ) destination_nio = open_tap_device ( value ) ; # ifdef LINUX_RAW else if ( getstr ( ubridge_config , bridge_name , ""destination_linux_raw"" , & value ) ) source_nio = open_linux_raw ( value ) ; # endif # ifdef __APPLE__ else if ( getstr ( ubridge_config , bridge_name , ""destination_fusion_vmnet"" , & value ) ) destination_nio = open_fusion_vmnet ( value ) ; # endif else fprintf ( stderr , ""destination<S2SV_blank>NIO<S2SV_blank>not<S2SV_blank>found\\n"" ) ; if ( source_nio && destination_nio ) { bridge = add_bridge ( bridges ) ; bridge -> source_nio = source_nio ; bridge -> destination_nio = destination_nio ; if ( ! ( bridge -> name = strdup ( bridge_name ) ) ) { fprintf ( stderr , ""bridge<S2SV_blank>creation:<S2SV_blank>insufficient<S2SV_blank>memory\\n"" ) ; return FALSE ; } parse_capture ( ubridge_config , bridge_name , bridge ) ; parse_filter ( ubridge_config , bridge_name , bridge ) ; } else if ( source_nio != NULL ) free_nio ( source_nio ) ; else if ( destination_nio != NULL ) free_nio ( destination_nio ) ; } iniparser_freedict ( ubridge_config ) ; return TRUE ; }","<S2SV_ModStart> iniparser_load ( filename , HIDE_ERRORED_LINE_CONTENT",GNS3@ubridge/2eb0d1dab6a6de76cf3556130a2d52af101077db,CVE-2020-14976,https://github.com/GNS3/ubridge/commit/2eb0d1dab6a6de76cf3556130a2d52af101077db,2020-06-23T20:15Z
CWE-264,"CWE-264 int do_set_thread_area ( struct task_struct * p , int idx , struct user_desc __user * u_info , int can_allocate ) { struct user_desc info ; if ( copy_from_user ( & info , u_info , sizeof ( info ) ) ) <S2SV_StartBug> return - EFAULT ; <S2SV_EndBug> if ( idx == - 1 ) idx = info . entry_number ; if ( idx == - 1 && can_allocate ) { idx = get_free_idx ( ) ; if ( idx < 0 ) return idx ; if ( put_user ( idx , & u_info -> entry_number ) ) return - EFAULT ; } if ( idx < GDT_ENTRY_TLS_MIN || idx > GDT_ENTRY_TLS_MAX ) return - EINVAL ; set_tls_desc ( p , idx , & info , 1 ) ; return 0 ; }",<S2SV_ModStart> return - EFAULT ; if ( ! tls_desc_okay ( & info ) ) return - EINVAL,torvalds@linux/41bdc78544b8a93a9c6814b8bbbfef966272abbe,CVE-2014-8133,https://github.com/torvalds/linux/commit/41bdc78544b8a93a9c6814b8bbbfef966272abbe,2014-12-17T11:59Z
CWE-125,"CWE-125 PyObject * ast2obj_excepthandler ( void * _o ) { excepthandler_ty o = ( excepthandler_ty ) _o ; PyObject * result = NULL , * value = NULL ; if ( ! o ) { <S2SV_StartBug> Py_INCREF ( Py_None ) ; <S2SV_EndBug> return Py_None ; } switch ( o -> kind ) { case ExceptHandler_kind : result = PyType_GenericNew ( ExceptHandler_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . ExceptHandler . type ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_identifier ( o -> v . ExceptHandler . name ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_name , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . ExceptHandler . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; } value = ast2obj_int ( o -> lineno ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_lineno , value ) < 0 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> col_offset ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_col_offset , value ) < 0 ) goto failed ; Py_DECREF ( value ) ; return result ; failed : Py_XDECREF ( value ) ; Py_XDECREF ( result ) ; return NULL ; }",<S2SV_ModStart> o ) { Py_RETURN_NONE <S2SV_ModEnd> ; } switch,python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z
,"CWE-000 int vp8_remove_decoder_instances ( struct frame_buffers * fb ) { if ( ! fb -> use_frame_threads ) { VP8D_COMP * pbi = fb -> pbi [ 0 ] ; if ( ! pbi ) return VPX_CODEC_ERROR ; # if CONFIG_MULTITHREAD <S2SV_StartBug> if ( pbi -> b_multithreaded_rd ) <S2SV_EndBug> vp8mt_de_alloc_temp_buffers ( pbi , pbi -> common . mb_rows ) ; vp8_decoder_remove_threads ( pbi ) ; # endif remove_decompressor ( pbi ) ; } else { } return VPX_CODEC_OK ; }",<S2SV_ModStart> # if CONFIG_MULTITHREAD <S2SV_ModEnd> vp8_decoder_remove_threads ( pbi,external@libvpx/6886e8e0a9db2dbad723dc37a548233e004b33bc,CVE-2017-0393,https://android.googlesource.com/platform/external/libvpx/+/6886e8e0a9db2dbad723dc37a548233e004b33bc,2017-01-12T20:59Z
CWE-416,"CWE-416 static int do_last ( struct nameidata * nd , struct file * file , const struct open_flags * op ) { <S2SV_StartBug> struct dentry * dir = nd -> path . dentry ; <S2SV_EndBug> int open_flag = op -> open_flag ; bool will_truncate = ( open_flag & O_TRUNC ) != 0 ; bool got_write = false ; int acc_mode = op -> acc_mode ; unsigned seq ; struct inode * inode ; struct path path ; int error ; nd -> flags &= ~ LOOKUP_PARENT ; nd -> flags |= op -> intent ; if ( nd -> last_type != LAST_NORM ) { error = handle_dots ( nd , nd -> last_type ) ; if ( unlikely ( error ) ) return error ; goto finish_open ; } if ( ! ( open_flag & O_CREAT ) ) { if ( nd -> last . name [ nd -> last . len ] ) nd -> flags |= LOOKUP_FOLLOW | LOOKUP_DIRECTORY ; error = lookup_fast ( nd , & path , & inode , & seq ) ; if ( likely ( error > 0 ) ) goto finish_lookup ; if ( error < 0 ) return error ; BUG_ON ( nd -> inode != dir -> d_inode ) ; BUG_ON ( nd -> flags & LOOKUP_RCU ) ; } else { error = complete_walk ( nd ) ; if ( error ) return error ; audit_inode ( nd -> name , dir , AUDIT_INODE_PARENT ) ; if ( unlikely ( nd -> last . name [ nd -> last . len ] ) ) return - EISDIR ; } if ( open_flag & ( O_CREAT | O_TRUNC | O_WRONLY | O_RDWR ) ) { error = mnt_want_write ( nd -> path . mnt ) ; if ( ! error ) got_write = true ; } if ( open_flag & O_CREAT ) inode_lock ( dir -> d_inode ) ; else inode_lock_shared ( dir -> d_inode ) ; error = lookup_open ( nd , & path , file , op , got_write ) ; if ( open_flag & O_CREAT ) inode_unlock ( dir -> d_inode ) ; else inode_unlock_shared ( dir -> d_inode ) ; if ( error ) goto out ; if ( file -> f_mode & FMODE_OPENED ) { if ( ( file -> f_mode & FMODE_CREATED ) || ! S_ISREG ( file_inode ( file ) -> i_mode ) ) will_truncate = false ; audit_inode ( nd -> name , file -> f_path . dentry , 0 ) ; goto opened ; } if ( file -> f_mode & FMODE_CREATED ) { open_flag &= ~ O_TRUNC ; will_truncate = false ; acc_mode = 0 ; path_to_nameidata ( & path , nd ) ; goto finish_open_created ; } if ( got_write ) { mnt_drop_write ( nd -> path . mnt ) ; got_write = false ; } error = follow_managed ( & path , nd ) ; if ( unlikely ( error < 0 ) ) return error ; audit_inode ( nd -> name , path . dentry , 0 ) ; if ( unlikely ( ( open_flag & ( O_EXCL | O_CREAT ) ) == ( O_EXCL | O_CREAT ) ) ) { path_to_nameidata ( & path , nd ) ; return - EEXIST ; } seq = 0 ; inode = d_backing_inode ( path . dentry ) ; finish_lookup : error = step_into ( nd , & path , 0 , inode , seq ) ; if ( unlikely ( error ) ) return error ; finish_open : error = complete_walk ( nd ) ; if ( error ) return error ; audit_inode ( nd -> name , nd -> path . dentry , 0 ) ; if ( open_flag & O_CREAT ) { error = - EISDIR ; if ( d_is_dir ( nd -> path . dentry ) ) goto out ; <S2SV_StartBug> error = may_create_in_sticky ( dir , <S2SV_EndBug> d_backing_inode ( nd -> path . dentry ) ) ; if ( unlikely ( error ) ) goto out ; } error = - ENOTDIR ; if ( ( nd -> flags & LOOKUP_DIRECTORY ) && ! d_can_lookup ( nd -> path . dentry ) ) goto out ; if ( ! d_is_reg ( nd -> path . dentry ) ) will_truncate = false ; if ( will_truncate ) { error = mnt_want_write ( nd -> path . mnt ) ; if ( error ) goto out ; got_write = true ; } finish_open_created : error = may_open ( & nd -> path , acc_mode , open_flag ) ; if ( error ) goto out ; BUG_ON ( file -> f_mode & FMODE_OPENED ) ; error = vfs_open ( & nd -> path , file ) ; if ( error ) goto out ; opened : error = ima_file_check ( file , op -> acc_mode ) ; if ( ! error && will_truncate ) error = handle_truncate ( file ) ; out : if ( unlikely ( error > 0 ) ) { WARN_ON ( 1 ) ; error = - EINVAL ; } if ( got_write ) mnt_drop_write ( nd -> path . mnt ) ; return error ; }","<S2SV_ModStart> path . dentry ; kuid_t dir_uid = dir -> d_inode -> i_uid ; umode_t dir_mode = dir -> d_inode -> i_mode <S2SV_ModStart> = may_create_in_sticky ( dir_mode , dir_uid <S2SV_ModEnd> , d_backing_inode (",torvalds@linux/d0cb50185ae942b03c4327be322055d622dc79f6,CVE-2020-8428,https://github.com/torvalds/linux/commit/d0cb50185ae942b03c4327be322055d622dc79f6,2020-01-29T00:15Z
,"CWE-000 static int crypto_report_kpp ( struct sk_buff * skb , struct crypto_alg * alg ) { struct crypto_report_kpp rkpp ; <S2SV_StartBug> strlcpy ( rkpp . type , ""kpp"" , sizeof ( rkpp . type ) ) ; <S2SV_EndBug> if ( nla_put ( skb , CRYPTOCFGA_REPORT_KPP , sizeof ( struct crypto_report_kpp ) , & rkpp ) ) goto nla_put_failure ; return 0 ; nla_put_failure : return - EMSGSIZE ; }",<S2SV_ModStart> crypto_report_kpp rkpp ; strncpy <S2SV_ModEnd> ( rkpp .,torvalds@linux/f43f39958beb206b53292801e216d9b8a660f087,CVE-2018-19854,https://github.com/torvalds/linux/commit/f43f39958beb206b53292801e216d9b8a660f087,2018-12-04T16:29Z
CWE-59,"CWE-000 int pidfile_write ( const char * pid_file , int pid ) { FILE * pidfile = NULL ; <S2SV_StartBug> int pidfd = creat ( pid_file , S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH ) ; <S2SV_EndBug> if ( pidfd != - 1 ) pidfile = fdopen ( pidfd , ""w"" ) ; if ( ! pidfile ) { log_message ( LOG_INFO , ""pidfile_write<S2SV_blank>:<S2SV_blank>Cannot<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>pidfile"" , pid_file ) ; return 0 ; } fprintf ( pidfile , ""%d\\n"" , pid ) ; fclose ( pidfile ) ; return 1 ; }","<S2SV_ModStart> int pidfd = open ( pid_file , O_NOFOLLOW | O_CREAT | O_WRONLY | O_TRUNC <S2SV_ModEnd> , S_IRUSR |",acassen@keepalived/04f2d32871bb3b11d7dc024039952f2fe2750306,CVE-2018-19044,https://github.com/acassen/keepalived/commit/04f2d32871bb3b11d7dc024039952f2fe2750306,2018-11-08T20:29Z
CWE-119,CWE-119 void vp9_save_layer_context ( VP9_COMP * const cpi ) { <S2SV_StartBug> const VP9_CONFIG * const oxcf = & cpi -> oxcf ; <S2SV_EndBug> <S2SV_StartBug> LAYER_CONTEXT * const lc = get_layer_context ( & cpi -> svc ) ; <S2SV_EndBug> lc -> rc = cpi -> rc ; lc -> twopass = cpi -> twopass ; lc -> target_bandwidth = ( int ) oxcf -> target_bandwidth ; <S2SV_StartBug> lc -> starting_buffer_level = oxcf -> starting_buffer_level ; <S2SV_EndBug> lc -> optimal_buffer_level = oxcf -> optimal_buffer_level ; lc -> maximum_buffer_size = oxcf -> maximum_buffer_size ; <S2SV_StartBug> lc -> framerate = cpi -> output_framerate ; <S2SV_EndBug> },<S2SV_ModStart> ) { const VP9EncoderConfig <S2SV_ModEnd> * const oxcf <S2SV_ModStart> = get_layer_context ( cpi <S2SV_ModEnd> ) ; lc <S2SV_ModStart> ; lc -> alt_ref_source <S2SV_ModEnd> = cpi -> <S2SV_ModStart> = cpi -> alt_ref_source <S2SV_ModEnd> ; } <S2SV_null>,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-59,"CWE-000 static int setup_dev_console ( const struct lxc_rootfs * rootfs , const struct lxc_console * console ) { char path [ MAXPATHLEN ] ; struct stat s ; int ret ; ret = snprintf ( path , sizeof ( path ) , ""%s/dev/console"" , rootfs -> mount ) ; if ( ret >= sizeof ( path ) ) { ERROR ( ""console<S2SV_blank>path<S2SV_blank>too<S2SV_blank>long"" ) ; return - 1 ; } if ( access ( path , F_OK ) ) { WARN ( ""rootfs<S2SV_blank>specified<S2SV_blank>but<S2SV_blank>no<S2SV_blank>console<S2SV_blank>found<S2SV_blank>at<S2SV_blank>\'%s\'"" , path ) ; return 0 ; } if ( console -> master < 0 ) { INFO ( ""no<S2SV_blank>console"" ) ; return 0 ; } if ( stat ( path , & s ) ) { SYSERROR ( ""failed<S2SV_blank>to<S2SV_blank>stat<S2SV_blank>\'%s\'"" , path ) ; return - 1 ; } if ( chmod ( console -> name , s . st_mode ) ) { SYSERROR ( ""failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>mode<S2SV_blank>\'0%o\'<S2SV_blank>to<S2SV_blank>\'%s\'"" , s . st_mode , console -> name ) ; return - 1 ; } <S2SV_StartBug> if ( mount ( console -> name , path , ""none"" , MS_BIND , 0 ) ) { <S2SV_EndBug> ERROR ( ""failed<S2SV_blank>to<S2SV_blank>mount<S2SV_blank>\'%s\'<S2SV_blank>on<S2SV_blank>\'%s\'"" , console -> name , path ) ; return - 1 ; } INFO ( ""console<S2SV_blank>has<S2SV_blank>been<S2SV_blank>setup"" ) ; return 0 ; }","<S2SV_ModStart> } if ( safe_mount ( console -> name , path , ""none"" , MS_BIND , 0 , rootfs -> mount <S2SV_ModEnd> ) ) {",lxc@lxc/592fd47a6245508b79fe6ac819fe6d3b2c1289be,CVE-2015-1335,https://github.com/lxc/lxc/commit/592fd47a6245508b79fe6ac819fe6d3b2c1289be,2015-10-01T20:59Z
CWE-416,"CWE-416 static int archive_read_format_rar_read_data ( struct archive_read * a , const void * * buff , size_t * size , int64_t * offset ) { struct rar * rar = ( struct rar * ) ( a -> format -> data ) ; int ret ; if ( rar -> has_encrypted_entries == ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW ) { rar -> has_encrypted_entries = 0 ; } if ( rar -> bytes_unconsumed > 0 ) { __archive_read_consume ( a , rar -> bytes_unconsumed ) ; rar -> bytes_unconsumed = 0 ; } * buff = NULL ; if ( rar -> entry_eof || rar -> offset_seek >= rar -> unp_size ) { * size = 0 ; * offset = rar -> offset ; if ( * offset < rar -> unp_size ) * offset = rar -> unp_size ; return ( ARCHIVE_EOF ) ; } switch ( rar -> compression_method ) { case COMPRESS_METHOD_STORE : ret = read_data_stored ( a , buff , size , offset ) ; break ; case COMPRESS_METHOD_FASTEST : case COMPRESS_METHOD_FAST : case COMPRESS_METHOD_NORMAL : case COMPRESS_METHOD_GOOD : case COMPRESS_METHOD_BEST : ret = read_data_compressed ( a , buff , size , offset ) ; <S2SV_StartBug> if ( ret != ARCHIVE_OK && ret != ARCHIVE_WARN ) <S2SV_EndBug> __archive_ppmd7_functions . Ppmd7_Free ( & rar -> ppmd7_context ) ; <S2SV_StartBug> break ; <S2SV_EndBug> default : archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Unsupported<S2SV_blank>compression<S2SV_blank>method<S2SV_blank>for<S2SV_blank>RAR<S2SV_blank>file."" ) ; ret = ARCHIVE_FATAL ; break ; } return ( ret ) ; }",<S2SV_ModStart> != ARCHIVE_WARN ) { <S2SV_ModStart> ppmd7_context ) ; rar -> start_new_table = 1 ; },libarchive@libarchive/b8592ecba2f9e451e1f5cb7ab6dcee8b8e7b3f60,CVE-2019-18408,https://github.com/libarchive/libarchive/commit/b8592ecba2f9e451e1f5cb7ab6dcee8b8e7b3f60,2019-10-24T14:15Z
CWE-190,"CWE-190 static int vdbePmaReadBlob ( PmaReader * p , int nByte , u8 * * ppOut ) { int iBuf ; int nAvail ; if ( p -> aMap ) { * ppOut = & p -> aMap [ p -> iReadOff ] ; p -> iReadOff += nByte ; return SQLITE_OK ; } assert ( p -> aBuffer ) ; iBuf = p -> iReadOff % p -> nBuffer ; if ( iBuf == 0 ) { int nRead ; int rc ; if ( ( p -> iEof - p -> iReadOff ) > ( i64 ) p -> nBuffer ) { nRead = p -> nBuffer ; } else { nRead = ( int ) ( p -> iEof - p -> iReadOff ) ; } assert ( nRead > 0 ) ; rc = sqlite3OsRead ( p -> pFd , p -> aBuffer , nRead , p -> iReadOff ) ; assert ( rc != SQLITE_IOERR_SHORT_READ ) ; if ( rc != SQLITE_OK ) return rc ; } nAvail = p -> nBuffer - iBuf ; if ( nByte <= nAvail ) { * ppOut = & p -> aBuffer [ iBuf ] ; p -> iReadOff += nByte ; } else { int nRem ; if ( p -> nAlloc < nByte ) { u8 * aNew ; <S2SV_StartBug> int nNew = MAX ( 128 , p -> nAlloc * 2 ) ; <S2SV_EndBug> while ( nByte > nNew ) nNew = nNew * 2 ; aNew = sqlite3Realloc ( p -> aAlloc , nNew ) ; if ( ! aNew ) return SQLITE_NOMEM_BKPT ; p -> nAlloc = nNew ; p -> aAlloc = aNew ; } memcpy ( p -> aAlloc , & p -> aBuffer [ iBuf ] , nAvail ) ; p -> iReadOff += nAvail ; nRem = nByte - nAvail ; while ( nRem > 0 ) { int rc ; int nCopy ; u8 * aNext ; nCopy = nRem ; if ( nRem > p -> nBuffer ) nCopy = p -> nBuffer ; rc = vdbePmaReadBlob ( p , nCopy , & aNext ) ; if ( rc != SQLITE_OK ) return rc ; assert ( aNext != p -> aAlloc ) ; memcpy ( & p -> aAlloc [ nByte - nRem ] , aNext , nCopy ) ; nRem -= nCopy ; } * ppOut = p -> aAlloc ; } return SQLITE_OK ; }","<S2SV_ModStart> * aNew ; sqlite3_int64 <S2SV_ModEnd> nNew = MAX <S2SV_ModStart> ( 128 , 2 * ( sqlite3_int64 ) <S2SV_ModStart> p -> nAlloc <S2SV_ModEnd> ) ; while",chromium@chromium/517ac71c9ee27f856f9becde8abea7d1604af9d4,CVE-2019-5827,https://github.com/chromium/chromium/commit/517ac71c9ee27f856f9becde8abea7d1604af9d4,2019-06-27T17:15Z
CWE-200,"CWE-200 __be32 ipv6_proxy_select_ident ( struct net * net , struct sk_buff * skb ) { <S2SV_StartBug> static u32 ip6_proxy_idents_hashrnd __read_mostly ; <S2SV_EndBug> struct in6_addr buf [ 2 ] ; struct in6_addr * addrs ; u32 id ; addrs = skb_header_pointer ( skb , skb_network_offset ( skb ) + offsetof ( struct ipv6hdr , saddr ) , sizeof ( buf ) , buf ) ; if ( ! addrs ) return 0 ; <S2SV_StartBug> net_get_random_once ( & ip6_proxy_idents_hashrnd , <S2SV_EndBug> sizeof ( ip6_proxy_idents_hashrnd ) ) ; <S2SV_StartBug> id = __ipv6_select_ident ( net , ip6_proxy_idents_hashrnd , <S2SV_EndBug> & addrs [ 1 ] , & addrs [ 0 ] ) ; return htonl ( id ) ; }","<S2SV_ModStart> skb ) { <S2SV_ModEnd> struct in6_addr buf <S2SV_ModStart> return 0 ; <S2SV_ModEnd> id = __ipv6_select_ident <S2SV_ModStart> ( net , <S2SV_ModEnd> & addrs [",torvalds@linux/df453700e8d81b1bdafdf684365ee2b9431fb702,CVE-2019-10638,https://github.com/torvalds/linux/commit/df453700e8d81b1bdafdf684365ee2b9431fb702,2019-07-05T23:15Z
CWE-125,"CWE-125 static const char * parse_string ( cJSON * item , const char * str , const char * * ep ) { const char * ptr = str + 1 , * end_ptr = str + 1 ; char * ptr2 ; char * out ; int len = 0 ; unsigned uc , uc2 ; if ( * str != \'\\""\' ) { * ep = str ; return 0 ; } <S2SV_StartBug> while ( * end_ptr != \'\\""\' && * end_ptr && ++ len ) if ( * end_ptr ++ == '\\\\' ) end_ptr ++ ; <S2SV_EndBug> out = ( char * ) cJSON_malloc ( len + 1 ) ; if ( ! out ) return 0 ; item -> valuestring = out ; item -> type = cJSON_String ; ptr = str + 1 ; ptr2 = out ; while ( ptr < end_ptr ) { if ( * ptr != '\\\\' ) * ptr2 ++ = * ptr ++ ; else { ptr ++ ; switch ( * ptr ) { case 'b' : * ptr2 ++ = '\\b' ; break ; case 'f' : * ptr2 ++ = '\\f' ; break ; case 'n' : * ptr2 ++ = '\\n' ; break ; case 'r' : * ptr2 ++ = '\\r' ; break ; case 't' : * ptr2 ++ = '\\t' ; break ; case 'u' : uc = parse_hex4 ( ptr + 1 ) ; ptr += 4 ; if ( ptr >= end_ptr ) { * ep = str ; return 0 ; } if ( ( uc >= 0xDC00 && uc <= 0xDFFF ) || uc == 0 ) { * ep = str ; return 0 ; } if ( uc >= 0xD800 && uc <= 0xDBFF ) { if ( ptr + 6 > end_ptr ) { * ep = str ; return 0 ; } if ( ptr [ 1 ] != '\\\\' || ptr [ 2 ] != 'u' ) { * ep = str ; return 0 ; } uc2 = parse_hex4 ( ptr + 3 ) ; ptr += 6 ; if ( uc2 < 0xDC00 || uc2 > 0xDFFF ) { * ep = str ; return 0 ; } uc = 0x10000 + ( ( ( uc & 0x3FF ) << 10 ) | ( uc2 & 0x3FF ) ) ; } len = 4 ; if ( uc < 0x80 ) len = 1 ; else if ( uc < 0x800 ) len = 2 ; else if ( uc < 0x10000 ) len = 3 ; ptr2 += len ; switch ( len ) { case 4 : * -- ptr2 = ( ( uc | 0x80 ) & 0xBF ) ; uc >>= 6 ; case 3 : * -- ptr2 = ( ( uc | 0x80 ) & 0xBF ) ; uc >>= 6 ; case 2 : * -- ptr2 = ( ( uc | 0x80 ) & 0xBF ) ; uc >>= 6 ; case 1 : * -- ptr2 = ( uc | firstByteMark [ len ] ) ; } ptr2 += len ; break ; default : * ptr2 ++ = * ptr ; break ; } ptr ++ ; } } * ptr2 = 0 ; if ( * ptr == \'\\""\' ) ptr ++ ; return ptr ; }",<S2SV_ModStart> ++ len ) { <S2SV_ModStart> == '\\\\' ) { if ( * end_ptr == '\\0' ) { return 0 ; } end_ptr ++ ; } } <S2SV_ModEnd> out = (,DaveGamble@cJSON/94df772485c92866ca417d92137747b2e3b0a917,CVE-2016-10749,https://github.com/DaveGamble/cJSON/commit/94df772485c92866ca417d92137747b2e3b0a917,2019-04-29T14:29Z
CWE-601,"CWE-000 int am_check_url ( request_rec * r , const char * url ) { const char * i ; for ( i = url ; * i ; i ++ ) { if ( * i >= 0 && * i < '<S2SV_blank>' ) { AM_LOG_RERROR ( APLOG_MARK , APLOG_ERR , HTTP_BAD_REQUEST , r , ""Control<S2SV_blank>character<S2SV_blank>detected<S2SV_blank>in<S2SV_blank>URL."" ) ; return HTTP_BAD_REQUEST ; } <S2SV_StartBug> } <S2SV_EndBug> return OK ; }","<S2SV_ModStart> HTTP_BAD_REQUEST ; } if ( * i == '\\\\' ) { AM_LOG_RERROR ( APLOG_MARK , APLOG_ERR , HTTP_BAD_REQUEST , r , ""Backslash<S2SV_blank>character<S2SV_blank>detected<S2SV_blank>in<S2SV_blank>URL."" ) ; return HTTP_BAD_REQUEST ; }",Uninett@mod_auth_mellon/62041428a32de402e0be6ba45fe12df6a83bedb8,CVE-2019-3877,https://github.com/Uninett/mod_auth_mellon/commit/62041428a32de402e0be6ba45fe12df6a83bedb8,2019-03-27T13:29Z
CWE-119,CWE-119 void unix_notinflight ( struct file * fp ) { struct sock * s = unix_get_socket ( fp ) ; <S2SV_StartBug> if ( s ) { <S2SV_EndBug> <S2SV_StartBug> struct unix_sock * u = unix_sk ( s ) ; <S2SV_EndBug> spin_lock ( & unix_gc_lock ) ; BUG_ON ( list_empty ( & u -> link ) ) ; if ( atomic_long_dec_and_test ( & u -> inflight ) ) list_del_init ( & u -> link ) ; unix_tot_inflight -- ; <S2SV_StartBug> spin_unlock ( & unix_gc_lock ) ; <S2SV_EndBug> } <S2SV_StartBug> } <S2SV_EndBug>,<S2SV_ModStart> fp ) ; spin_lock ( & unix_gc_lock ) ; <S2SV_ModStart> unix_sk ( s <S2SV_ModEnd> ) ; BUG_ON <S2SV_ModStart> unix_tot_inflight -- ; } fp -> f_cred -> user -> unix_inflight -- ; <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>,torvalds@linux/712f4aad406bb1ed67f3f98d04c044191f0ff593,CVE-2013-4312,https://github.com/torvalds/linux/commit/712f4aad406bb1ed67f3f98d04c044191f0ff593,2016-02-08T03:59Z
CWE-119,"CWE-119 static inline void header_put_le_3byte ( SF_PRIVATE * psf , int x ) <S2SV_StartBug> { if ( psf -> headindex < SIGNED_SIZEOF ( psf -> header ) - 3 ) <S2SV_EndBug> <S2SV_StartBug> { psf -> header [ psf -> headindex ++ ] = x ; <S2SV_EndBug> <S2SV_StartBug> psf -> header [ psf -> headindex ++ ] = ( x >> 8 ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> header [ psf -> headindex ++ ] = ( x >> 16 ) ; <S2SV_EndBug> <S2SV_StartBug> } ; <S2SV_EndBug> }",<S2SV_ModStart> x ) { <S2SV_ModEnd> psf -> header <S2SV_ModStart> psf -> header . ptr [ <S2SV_ModEnd> psf -> header <S2SV_ModStart> psf -> header . indx <S2SV_ModEnd> ++ ] = <S2SV_ModStart> psf -> header . ptr <S2SV_ModStart> [ psf -> header . indx <S2SV_ModEnd> ++ ] = <S2SV_ModStart> psf -> header . ptr <S2SV_ModStart> [ psf -> header . indx <S2SV_ModEnd> ++ ] = <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>,erikd@libsndfile/708e996c87c5fae77b104ccfeb8f6db784c32074,CVE-2017-7586,https://github.com/erikd/libsndfile/commit/708e996c87c5fae77b104ccfeb8f6db784c32074,2017-04-07T20:59Z
CWE-772,"CWE-772 int button_open ( Button * b ) { char * p , name [ 256 ] ; int r ; assert ( b ) ; b -> fd = safe_close ( b -> fd ) ; p = strjoina ( ""/dev/input/"" , b -> name ) ; b -> fd = open ( p , O_RDWR | O_CLOEXEC | O_NOCTTY | O_NONBLOCK ) ; if ( b -> fd < 0 ) return log_warning_errno ( errno , ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s:<S2SV_blank>%m"" , p ) ; r = button_suitable ( b ) ; if ( r < 0 ) return log_warning_errno ( r , ""Failed<S2SV_blank>to<S2SV_blank>determine<S2SV_blank>whether<S2SV_blank>input<S2SV_blank>device<S2SV_blank>is<S2SV_blank>relevant<S2SV_blank>to<S2SV_blank>us:<S2SV_blank>%m"" ) ; if ( r == 0 ) return log_debug_errno ( SYNTHETIC_ERRNO ( EADDRNOTAVAIL ) , ""Device<S2SV_blank>%s<S2SV_blank>does<S2SV_blank>not<S2SV_blank>expose<S2SV_blank>keys<S2SV_blank>or<S2SV_blank>switches<S2SV_blank>relevant<S2SV_blank>to<S2SV_blank>us,<S2SV_blank>ignoring."" , p ) ; if ( ioctl ( b -> fd , EVIOCGNAME ( sizeof ( name ) ) , name ) < 0 ) { r = log_error_errno ( errno , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>input<S2SV_blank>name:<S2SV_blank>%m"" ) ; goto fail ; } ( void ) button_set_mask ( b ) ; <S2SV_StartBug> r = sd_event_add_io ( b -> manager -> event , & b -> io_event_source , b -> fd , EPOLLIN , button_dispatch , b ) ; <S2SV_EndBug> if ( r < 0 ) { log_error_errno ( r , ""Failed<S2SV_blank>to<S2SV_blank>add<S2SV_blank>button<S2SV_blank>event:<S2SV_blank>%m"" ) ; goto fail ; } log_info ( ""Watching<S2SV_blank>system<S2SV_blank>buttons<S2SV_blank>on<S2SV_blank>/dev/input/%s<S2SV_blank>(%s)"" , b -> name , name ) ; return 0 ; fail : b -> fd = safe_close ( b -> fd ) ; return r ; }",<S2SV_ModStart> b ) ; b -> io_event_source = sd_event_source_unref ( b -> io_event_source ) ;,systemd@systemd/b2774a3ae692113e1f47a336a6c09bac9cfb49ad,CVE-2019-20386,https://github.com/systemd/systemd/commit/b2774a3ae692113e1f47a336a6c09bac9cfb49ad,2020-01-21T06:15Z
CWE-119,"CWE-119 vpx_codec_err_t vpx_codec_enc_config_default ( vpx_codec_iface_t * iface , vpx_codec_enc_cfg_t * cfg , unsigned int usage ) { vpx_codec_err_t res ; <S2SV_StartBug> vpx_codec_enc_cfg_map_t * map ; <S2SV_EndBug> if ( ! iface || ! cfg || usage > INT_MAX ) res = VPX_CODEC_INVALID_PARAM ; else if ( ! ( iface -> caps & VPX_CODEC_CAP_ENCODER ) ) res = VPX_CODEC_INCAPABLE ; else { res = VPX_CODEC_INVALID_PARAM ; <S2SV_StartBug> for ( map = iface -> enc . cfg_maps ; map -> usage >= 0 ; map ++ ) { <S2SV_EndBug> if ( map -> usage == ( int ) usage ) { * cfg = map -> cfg ; cfg -> g_usage = usage ; res = VPX_CODEC_OK ; break ; } } } return res ; }",<S2SV_ModStart> vpx_codec_enc_cfg_map_t * map ; int i <S2SV_ModStart> ; for ( i = 0 ; i < iface -> enc . cfg_map_count ; ++ i ) { <S2SV_ModStart> enc . cfg_maps + i ; <S2SV_ModEnd> if ( map,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-284,"CWE-284 static int dbConnect ( char * host , char * user , char * passwd ) { DBUG_ENTER ( ""dbConnect"" ) ; if ( verbose ) { fprintf ( stderr , ""#<S2SV_blank>Connecting<S2SV_blank>to<S2SV_blank>%s...\\n"" , host ? host : ""localhost"" ) ; } mysql_init ( & mysql_connection ) ; if ( opt_compress ) mysql_options ( & mysql_connection , MYSQL_OPT_COMPRESS , NullS ) ; <S2SV_StartBug> # ifdef HAVE_OPENSSL <S2SV_EndBug> if ( opt_use_ssl ) { mysql_ssl_set ( & mysql_connection , opt_ssl_key , opt_ssl_cert , opt_ssl_ca , opt_ssl_capath , opt_ssl_cipher ) ; mysql_options ( & mysql_connection , MYSQL_OPT_SSL_CRL , opt_ssl_crl ) ; mysql_options ( & mysql_connection , MYSQL_OPT_SSL_CRLPATH , opt_ssl_crlpath ) ; } # endif if ( opt_protocol ) mysql_options ( & mysql_connection , MYSQL_OPT_PROTOCOL , ( char * ) & opt_protocol ) ; if ( opt_bind_addr ) mysql_options ( & mysql_connection , MYSQL_OPT_BIND , opt_bind_addr ) ; # if defined ( _WIN32 ) && ! defined ( EMBEDDED_LIBRARY ) if ( shared_memory_base_name ) mysql_options ( & mysql_connection , MYSQL_SHARED_MEMORY_BASE_NAME , shared_memory_base_name ) ; # endif if ( opt_plugin_dir && * opt_plugin_dir ) mysql_options ( & mysql_connection , MYSQL_PLUGIN_DIR , opt_plugin_dir ) ; if ( opt_default_auth && * opt_default_auth ) mysql_options ( & mysql_connection , MYSQL_DEFAULT_AUTH , opt_default_auth ) ; mysql_options ( & mysql_connection , MYSQL_SET_CHARSET_NAME , default_charset ) ; mysql_options ( & mysql_connection , MYSQL_OPT_CONNECT_ATTR_RESET , 0 ) ; mysql_options4 ( & mysql_connection , MYSQL_OPT_CONNECT_ATTR_ADD , ""program_name"" , ""mysqlcheck"" ) ; if ( ! ( sock = mysql_real_connect ( & mysql_connection , host , user , passwd , NULL , opt_mysql_port , opt_mysql_unix_port , 0 ) ) ) { DBerror ( & mysql_connection , ""when<S2SV_blank>trying<S2SV_blank>to<S2SV_blank>connect"" ) ; DBUG_RETURN ( 1 ) ; } mysql_connection . reconnect = 1 ; DBUG_RETURN ( 0 ) ; }",<S2SV_ModStart> NullS ) ; SSL_SET_OPTIONS ( & mysql_connection ) ; <S2SV_ModEnd> if ( opt_protocol,mysql@mysql-server/3bd5589e1a5a93f9c224badf983cd65c45215390,CVE-2015-3152,https://github.com/mysql/mysql-server/commit/3bd5589e1a5a93f9c224badf983cd65c45215390,2016-05-16T10:59Z
CWE-362,"CWE-362 int ext4_insert_range ( struct inode * inode , loff_t offset , loff_t len ) { struct super_block * sb = inode -> i_sb ; handle_t * handle ; struct ext4_ext_path * path ; struct ext4_extent * extent ; ext4_lblk_t offset_lblk , len_lblk , ee_start_lblk = 0 ; unsigned int credits , ee_len ; int ret = 0 , depth , split_flag = 0 ; loff_t ioffset ; if ( ! ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) return - EOPNOTSUPP ; if ( offset & ( EXT4_CLUSTER_SIZE ( sb ) - 1 ) || len & ( EXT4_CLUSTER_SIZE ( sb ) - 1 ) ) return - EINVAL ; if ( ! S_ISREG ( inode -> i_mode ) ) return - EOPNOTSUPP ; trace_ext4_insert_range ( inode , offset , len ) ; offset_lblk = offset >> EXT4_BLOCK_SIZE_BITS ( sb ) ; len_lblk = len >> EXT4_BLOCK_SIZE_BITS ( sb ) ; if ( ext4_should_journal_data ( inode ) ) { ret = ext4_force_commit ( inode -> i_sb ) ; if ( ret ) return ret ; } ioffset = round_down ( offset , PAGE_SIZE ) ; ret = filemap_write_and_wait_range ( inode -> i_mapping , ioffset , LLONG_MAX ) ; if ( ret ) return ret ; mutex_lock ( & inode -> i_mutex ) ; if ( ! ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) { ret = - EOPNOTSUPP ; goto out_mutex ; } if ( inode -> i_size + len > inode -> i_sb -> s_maxbytes ) { ret = - EFBIG ; goto out_mutex ; } if ( offset >= i_size_read ( inode ) ) { ret = - EINVAL ; goto out_mutex ; } <S2SV_StartBug> truncate_pagecache ( inode , ioffset ) ; <S2SV_EndBug> <S2SV_StartBug> ext4_inode_block_unlocked_dio ( inode ) ; <S2SV_EndBug> inode_dio_wait ( inode ) ; credits = ext4_writepage_trans_blocks ( inode ) ; handle = ext4_journal_start ( inode , EXT4_HT_TRUNCATE , credits ) ; if ( IS_ERR ( handle ) ) { ret = PTR_ERR ( handle ) ; <S2SV_StartBug> goto out_dio ; <S2SV_EndBug> } inode -> i_size += len ; EXT4_I ( inode ) -> i_disksize += len ; inode -> i_mtime = inode -> i_ctime = ext4_current_time ( inode ) ; ret = ext4_mark_inode_dirty ( handle , inode ) ; if ( ret ) goto out_stop ; down_write ( & EXT4_I ( inode ) -> i_data_sem ) ; ext4_discard_preallocations ( inode ) ; path = ext4_find_extent ( inode , offset_lblk , NULL , 0 ) ; if ( IS_ERR ( path ) ) { up_write ( & EXT4_I ( inode ) -> i_data_sem ) ; goto out_stop ; } depth = ext_depth ( inode ) ; extent = path [ depth ] . p_ext ; if ( extent ) { ee_start_lblk = le32_to_cpu ( extent -> ee_block ) ; ee_len = ext4_ext_get_actual_len ( extent ) ; if ( ( offset_lblk > ee_start_lblk ) && ( offset_lblk < ( ee_start_lblk + ee_len ) ) ) { if ( ext4_ext_is_unwritten ( extent ) ) split_flag = EXT4_EXT_MARK_UNWRIT1 | EXT4_EXT_MARK_UNWRIT2 ; ret = ext4_split_extent_at ( handle , inode , & path , offset_lblk , split_flag , EXT4_EX_NOCACHE | EXT4_GET_BLOCKS_PRE_IO | EXT4_GET_BLOCKS_METADATA_NOFAIL ) ; } ext4_ext_drop_refs ( path ) ; kfree ( path ) ; if ( ret < 0 ) { up_write ( & EXT4_I ( inode ) -> i_data_sem ) ; goto out_stop ; } } ret = ext4_es_remove_extent ( inode , offset_lblk , EXT_MAX_BLOCKS - offset_lblk ) ; if ( ret ) { up_write ( & EXT4_I ( inode ) -> i_data_sem ) ; goto out_stop ; } ret = ext4_ext_shift_extents ( inode , handle , ee_start_lblk > offset_lblk ? ee_start_lblk : offset_lblk , len_lblk , SHIFT_RIGHT ) ; up_write ( & EXT4_I ( inode ) -> i_data_sem ) ; if ( IS_SYNC ( inode ) ) ext4_handle_sync ( handle ) ; out_stop : ext4_journal_stop ( handle ) ; <S2SV_StartBug> out_dio : <S2SV_EndBug> ext4_inode_resume_unlocked_dio ( inode ) ; out_mutex : mutex_unlock ( & inode -> i_mutex ) ; return ret ; }",<S2SV_ModStart> out_mutex ; } ext4_inode_block_unlocked_dio ( inode ) ; inode_dio_wait ( inode ) ; down_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ; <S2SV_ModStart> ioffset ) ; <S2SV_ModEnd> credits = ext4_writepage_trans_blocks <S2SV_ModStart> ) ; goto out_mmap <S2SV_ModEnd> ; } inode <S2SV_ModStart> handle ) ; out_mmap : up_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ; <S2SV_ModEnd> ext4_inode_resume_unlocked_dio ( inode,torvalds@linux/ea3d7209ca01da209cda6f0dea8be9cc4b7a933b,CVE-2015-8839,https://github.com/torvalds/linux/commit/ea3d7209ca01da209cda6f0dea8be9cc4b7a933b,2016-05-02T10:59Z
CWE-20,"CWE-20 static int cbor2json ( OSCTXT * pCborCtxt , OSCTXT * pJsonCtxt ) { int ret = 0 ; OSOCTET tag , ub ; ret = rtxReadBytes ( pCborCtxt , & ub , 1 ) ; if ( 0 != ret ) return LOG_RTERR ( pCborCtxt , ret ) ; tag = ub >> 5 ; switch ( tag ) { case OSRTCBOR_UINT : { OSUINTTYPE value ; ret = rtCborDecUInt ( pCborCtxt , ub , & value ) ; if ( 0 != ret ) return LOG_RTERR ( pCborCtxt , ret ) ; # ifndef _NO_INT64_SUPPORT ret = rtJsonEncUInt64Value ( pJsonCtxt , value ) ; # else ret = rtJsonEncUIntValue ( pJsonCtxt , value ) ; # endif if ( 0 != ret ) return LOG_RTERR ( pJsonCtxt , ret ) ; break ; } case OSRTCBOR_NEGINT : { OSINTTYPE value ; ret = rtCborDecInt ( pCborCtxt , ub , & value ) ; if ( 0 != ret ) return LOG_RTERR ( pCborCtxt , ret ) ; # ifndef _NO_INT64_SUPPORT ret = rtJsonEncInt64Value ( pJsonCtxt , value ) ; # else ret = rtJsonEncIntValue ( pJsonCtxt , value ) ; # endif if ( 0 != ret ) return LOG_RTERR ( pJsonCtxt , ret ) ; break ; } case OSRTCBOR_BYTESTR : { OSDynOctStr64 byteStr ; ret = rtCborDecDynByteStr ( pCborCtxt , ub , & byteStr ) ; if ( 0 != ret ) return LOG_RTERR ( pCborCtxt , ret ) ; ret = rtJsonEncHexStr ( pJsonCtxt , byteStr . numocts , byteStr . data ) ; rtxMemFreePtr ( pCborCtxt , byteStr . data ) ; if ( 0 != ret ) return LOG_RTERR ( pJsonCtxt , ret ) ; break ; } case OSRTCBOR_UTF8STR : { OSUTF8CHAR * utf8str ; <S2SV_StartBug> ret = rtCborDecDynUTF8Str ( pCborCtxt , ub , ( char * * ) & utf8str ) ; <S2SV_EndBug> ret = rtJsonEncStringValue ( pJsonCtxt , utf8str ) ; rtxMemFreePtr ( pCborCtxt , utf8str ) ; if ( 0 != ret ) return LOG_RTERR ( pJsonCtxt , ret ) ; break ; } case OSRTCBOR_ARRAY : case OSRTCBOR_MAP : { OSOCTET len = ub & 0x1F ; char startChar = ( tag == OSRTCBOR_ARRAY ) ? '[' : '{' ; char endChar = ( tag == OSRTCBOR_ARRAY ) ? ']' : '}' ; OSRTSAFEPUTCHAR ( pJsonCtxt , startChar ) ; if ( len == OSRTCBOR_INDEF ) { OSBOOL first = TRUE ; for ( ; ; ) { if ( OSRTCBOR_MATCHEOC ( pCborCtxt ) ) { pCborCtxt -> buffer . byteIndex ++ ; break ; } if ( ! first ) OSRTSAFEPUTCHAR ( pJsonCtxt , ',' ) ; else first = FALSE ; if ( tag == OSRTCBOR_MAP ) { ret = cborElemNameToJson ( pCborCtxt , pJsonCtxt ) ; } if ( 0 == ret ) ret = cbor2json ( pCborCtxt , pJsonCtxt ) ; if ( 0 != ret ) { OSCTXT * pctxt = ( rtxErrGetErrorCnt ( pJsonCtxt ) > 0 ) ? pJsonCtxt : pCborCtxt ; return LOG_RTERR ( pctxt , ret ) ; } } } else { OSSIZE nitems ; ret = rtCborDecSize ( pCborCtxt , len , & nitems ) ; if ( 0 == ret ) { OSSIZE i ; for ( i = 0 ; i < nitems ; i ++ ) { if ( 0 != i ) OSRTSAFEPUTCHAR ( pJsonCtxt , ',' ) ; if ( tag == OSRTCBOR_MAP ) { ret = cborElemNameToJson ( pCborCtxt , pJsonCtxt ) ; } if ( 0 == ret ) ret = cbor2json ( pCborCtxt , pJsonCtxt ) ; if ( 0 != ret ) { OSCTXT * pctxt = ( rtxErrGetErrorCnt ( pJsonCtxt ) > 0 ) ? pJsonCtxt : pCborCtxt ; return LOG_RTERR ( pctxt , ret ) ; } } } } OSRTSAFEPUTCHAR ( pJsonCtxt , endChar ) ; break ; } case OSRTCBOR_FLOAT : if ( tag == OSRTCBOR_FALSEENC || tag == OSRTCBOR_TRUEENC ) { OSBOOL boolval = ( ub == OSRTCBOR_TRUEENC ) ? TRUE : FALSE ; ret = rtJsonEncBoolValue ( pJsonCtxt , boolval ) ; if ( 0 != ret ) return LOG_RTERR ( pJsonCtxt , ret ) ; } else if ( tag == OSRTCBOR_FLT16ENC || tag == OSRTCBOR_FLT32ENC || tag == OSRTCBOR_FLT64ENC ) { OSDOUBLE fltval ; ret = rtCborDecFloat ( pCborCtxt , ub , & fltval ) ; if ( 0 != ret ) return LOG_RTERR ( pCborCtxt , ret ) ; ret = rtJsonEncDoubleValue ( pJsonCtxt , fltval , 0 ) ; if ( 0 != ret ) return LOG_RTERR ( pJsonCtxt , ret ) ; } else { ret = cborTagNotSupp ( pCborCtxt , tag ) ; } break ; default : ret = cborTagNotSupp ( pCborCtxt , tag ) ; } return ret ; }","<S2SV_ModStart> ) & utf8str ) ; if ( 0 != ret ) return LOG_RTERR ( pCborCtxt , ret",objsys@oocborrt/539851c66778f68a244633985f6f8d0df94ea3b3,CVE-2020-24753,https://github.com/objsys/oocborrt/commit/539851c66778f68a244633985f6f8d0df94ea3b3,2020-09-17T18:15Z
,"CWE-000 static int treo_attach ( struct usb_serial * serial ) { struct usb_serial_port * swap_port ; if ( ! ( ( le16_to_cpu ( serial -> dev -> descriptor . idVendor ) == HANDSPRING_VENDOR_ID ) || ( le16_to_cpu ( serial -> dev -> descriptor . idVendor ) == KYOCERA_VENDOR_ID ) ) || ( serial -> num_interrupt_in == 0 ) ) return 0 ; <S2SV_StartBug> # define COPY_PORT ( dest , src ) do { int i ; for ( i = 0 ; i < ARRAY_SIZE ( src -> read_urbs ) ; ++ i ) { dest -> read_urbs [ i ] = src -> read_urbs [ i ] ; dest -> read_urbs [ i ] -> context = dest ; dest -> bulk_in_buffers [ i ] = src -> bulk_in_buffers [ i ] ; } dest -> read_urb = src -> read_urb ; dest -> bulk_in_endpointAddress = src -> bulk_in_endpointAddress ; dest -> bulk_in_buffer = src -> bulk_in_buffer ; dest -> bulk_in_size = src -> bulk_in_size ; dest -> interrupt_in_urb = src -> interrupt_in_urb ; dest -> interrupt_in_urb -> context = dest ; dest -> interrupt_in_endpointAddress = src -> interrupt_in_endpointAddress ; dest -> interrupt_in_buffer = src -> interrupt_in_buffer ; } while ( 0 ) ; <S2SV_EndBug> swap_port = kmalloc ( sizeof ( * swap_port ) , GFP_KERNEL ) ; if ( ! swap_port ) return - ENOMEM ; COPY_PORT ( swap_port , serial -> port [ 0 ] ) ; COPY_PORT ( serial -> port [ 0 ] , serial -> port [ 1 ] ) ; COPY_PORT ( serial -> port [ 1 ] , swap_port ) ; kfree ( swap_port ) ; return 0 ; }","<S2SV_ModStart> return 0 ; if ( serial -> num_bulk_in < 2 || serial -> num_interrupt_in < 2 ) { dev_err ( & serial -> interface -> dev , ""missing<S2SV_blank>endpoints\\n"" ) ; return - ENODEV ; }",torvalds@linux/cac9b50b0d75a1d50d6c056ff65c005f3224c8e0,CVE-2016-2782,https://github.com/torvalds/linux/commit/cac9b50b0d75a1d50d6c056ff65c005f3224c8e0,2016-04-27T17:59Z
CWE-190,"CWE-190 void * <S2SV_StartBug> checked_xmalloc ( size_t size ) <S2SV_EndBug> { <S2SV_StartBug> alloc_limit_assert ( ""checked_xmalloc"" , size ) ; <S2SV_EndBug> <S2SV_StartBug> return xmalloc ( size ) ; <S2SV_EndBug> }","<S2SV_ModStart> checked_xmalloc ( size_t num , size_t <S2SV_ModStart> size ) { size_t res ; if ( check_mul_overflow ( num , size , & res ) ) abort ( ) ; <S2SV_ModStart> ( ""checked_xmalloc"" , res <S2SV_ModEnd> ) ; return <S2SV_ModStart> return xmalloc ( num ,",verdammelt@tnef/c5044689e50039635e7700fe2472fd632ac77176,CVE-2017-6308,https://github.com/verdammelt/tnef/commit/c5044689e50039635e7700fe2472fd632ac77176,2017-02-24T04:59Z
CWE-125,"CWE-125 static void nfnetlink_rcv_batch ( struct sk_buff * skb , struct nlmsghdr * nlh , u_int16_t subsys_id ) { struct sk_buff * oskb = skb ; struct net * net = sock_net ( skb -> sk ) ; const struct nfnetlink_subsystem * ss ; const struct nfnl_callback * nc ; static LIST_HEAD ( err_list ) ; u32 status ; int err ; if ( subsys_id >= NFNL_SUBSYS_COUNT ) return netlink_ack ( skb , nlh , - EINVAL ) ; replay : status = 0 ; skb = netlink_skb_clone ( oskb , GFP_KERNEL ) ; if ( ! skb ) return netlink_ack ( oskb , nlh , - ENOMEM ) ; nfnl_lock ( subsys_id ) ; ss = nfnl_dereference_protected ( subsys_id ) ; if ( ! ss ) { # ifdef CONFIG_MODULES nfnl_unlock ( subsys_id ) ; request_module ( ""nfnetlink-subsys-%d"" , subsys_id ) ; nfnl_lock ( subsys_id ) ; ss = nfnl_dereference_protected ( subsys_id ) ; if ( ! ss ) # endif { nfnl_unlock ( subsys_id ) ; netlink_ack ( oskb , nlh , - EOPNOTSUPP ) ; return kfree_skb ( skb ) ; } } if ( ! ss -> commit || ! ss -> abort ) { nfnl_unlock ( subsys_id ) ; netlink_ack ( oskb , nlh , - EOPNOTSUPP ) ; return kfree_skb ( skb ) ; } while ( skb -> len >= nlmsg_total_size ( 0 ) ) { int msglen , type ; nlh = nlmsg_hdr ( skb ) ; err = 0 ; <S2SV_StartBug> if ( nlmsg_len ( nlh ) < sizeof ( struct nfgenmsg ) || <S2SV_EndBug> skb -> len < nlh -> nlmsg_len ) { err = - EINVAL ; goto ack ; } if ( ! ( nlh -> nlmsg_flags & NLM_F_REQUEST ) ) { err = - EINVAL ; goto ack ; } type = nlh -> nlmsg_type ; if ( type == NFNL_MSG_BATCH_BEGIN ) { nfnl_err_reset ( & err_list ) ; status |= NFNL_BATCH_FAILURE ; goto done ; } else if ( type == NFNL_MSG_BATCH_END ) { status |= NFNL_BATCH_DONE ; goto done ; } else if ( type < NLMSG_MIN_TYPE ) { err = - EINVAL ; goto ack ; } if ( NFNL_SUBSYS_ID ( type ) != subsys_id ) { err = - EINVAL ; goto ack ; } nc = nfnetlink_find_client ( type , ss ) ; if ( ! nc ) { err = - EINVAL ; goto ack ; } { int min_len = nlmsg_total_size ( sizeof ( struct nfgenmsg ) ) ; u_int8_t cb_id = NFNL_MSG_TYPE ( nlh -> nlmsg_type ) ; struct nlattr * cda [ ss -> cb [ cb_id ] . attr_count + 1 ] ; struct nlattr * attr = ( void * ) nlh + min_len ; int attrlen = nlh -> nlmsg_len - min_len ; err = nla_parse ( cda , ss -> cb [ cb_id ] . attr_count , attr , attrlen , ss -> cb [ cb_id ] . policy ) ; if ( err < 0 ) goto ack ; if ( nc -> call_batch ) { err = nc -> call_batch ( net , net -> nfnl , skb , nlh , ( const struct nlattr * * ) cda ) ; } if ( err == - EAGAIN ) { status |= NFNL_BATCH_REPLAY ; goto next ; } } ack : if ( nlh -> nlmsg_flags & NLM_F_ACK || err ) { if ( nfnl_err_add ( & err_list , nlh , err ) < 0 ) { nfnl_err_reset ( & err_list ) ; netlink_ack ( oskb , nlmsg_hdr ( oskb ) , - ENOMEM ) ; status |= NFNL_BATCH_FAILURE ; goto done ; } if ( err ) status |= NFNL_BATCH_FAILURE ; } next : msglen = NLMSG_ALIGN ( nlh -> nlmsg_len ) ; if ( msglen > skb -> len ) msglen = skb -> len ; skb_pull ( skb , msglen ) ; } done : if ( status & NFNL_BATCH_REPLAY ) { ss -> abort ( net , oskb ) ; nfnl_err_reset ( & err_list ) ; nfnl_unlock ( subsys_id ) ; kfree_skb ( skb ) ; goto replay ; } else if ( status == NFNL_BATCH_DONE ) { ss -> commit ( net , oskb ) ; } else { ss -> abort ( net , oskb ) ; } nfnl_err_deliver ( & err_list , oskb ) ; nfnl_unlock ( subsys_id ) ; kfree_skb ( skb ) ; }",<S2SV_ModStart> ; if ( nlh -> nlmsg_len < NLMSG_HDRLEN || skb -> len < nlh -> nlmsg_len || <S2SV_ModStart> struct nfgenmsg ) ) { nfnl_err_reset ( & err_list ) ; status |= NFNL_BATCH_FAILURE ; goto done <S2SV_ModEnd> ; } if,torvalds@linux/c58d6c93680f28ac58984af61d0a7ebf4319c241,CVE-2016-7917,https://github.com/torvalds/linux/commit/c58d6c93680f28ac58984af61d0a7ebf4319c241,2016-11-16T05:59Z
CWE-255,"CWE-000 static int verify_source_vc ( char * * ret_path , const char * src_vc ) { _cleanup_close_ int fd = - 1 ; char * path ; int r ; fd = open_terminal ( src_vc , O_RDWR | O_CLOEXEC | O_NOCTTY ) ; if ( fd < 0 ) return log_error_errno ( fd , ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s:<S2SV_blank>%m"" , src_vc ) ; r = verify_vc_device ( fd ) ; if ( r < 0 ) return log_error_errno ( r , ""Device<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>virtual<S2SV_blank>console:<S2SV_blank>%m"" , src_vc ) ; r = verify_vc_allocation_byfd ( fd ) ; if ( r < 0 ) return log_error_errno ( r , ""Virtual<S2SV_blank>console<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>allocated:<S2SV_blank>%m"" , src_vc ) ; <S2SV_StartBug> r = verify_vc_kbmode ( fd ) ; <S2SV_EndBug> if ( r < 0 ) return log_error_errno ( r , ""Virtual<S2SV_blank>console<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>in<S2SV_blank>K_XLATE<S2SV_blank>or<S2SV_blank>K_UNICODE:<S2SV_blank>%m"" , src_vc ) ; path = strdup ( src_vc ) ; if ( ! path ) return log_oom ( ) ; * ret_path = path ; return TAKE_FD ( fd ) ; }",<S2SV_ModStart> ; r = vt_verify_kbmode <S2SV_ModEnd> ( fd ),systemd@systemd/9725f1a10f80f5e0ae7d9b60547458622aeb322f,CVE-2018-20839,https://github.com/systemd/systemd/commit/9725f1a10f80f5e0ae7d9b60547458622aeb322f,2019-05-17T04:29Z
CWE-125,"CWE-125 static int ape_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) { AVFrame * frame = data ; const uint8_t * buf = avpkt -> data ; APEContext * s = avctx -> priv_data ; uint8_t * sample8 ; int16_t * sample16 ; int32_t * sample24 ; int i , ch , ret ; <S2SV_StartBug> int blockstodecode ; <S2SV_EndBug> av_assert0 ( s -> samples >= 0 ) ; if ( ! s -> samples ) { uint32_t nblocks , offset ; int buf_size ; if ( ! avpkt -> size ) { * got_frame_ptr = 0 ; return 0 ; } if ( avpkt -> size < 8 ) { av_log ( avctx , AV_LOG_ERROR , ""Packet<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small\\n"" ) ; return AVERROR_INVALIDDATA ; } buf_size = avpkt -> size & ~ 3 ; if ( buf_size != avpkt -> size ) { av_log ( avctx , AV_LOG_WARNING , ""packet<S2SV_blank>size<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>4.<S2SV_blank>"" ""extra<S2SV_blank>bytes<S2SV_blank>at<S2SV_blank>the<S2SV_blank>end<S2SV_blank>will<S2SV_blank>be<S2SV_blank>skipped.\\n"" ) ; } if ( s -> fileversion < 3950 ) buf_size += 2 ; av_fast_padded_malloc ( & s -> data , & s -> data_size , buf_size ) ; if ( ! s -> data ) return AVERROR ( ENOMEM ) ; s -> bdsp . bswap_buf ( ( uint32_t * ) s -> data , ( const uint32_t * ) buf , buf_size >> 2 ) ; memset ( s -> data + ( buf_size & ~ 3 ) , 0 , buf_size & 3 ) ; s -> ptr = s -> data ; s -> data_end = s -> data + buf_size ; nblocks = bytestream_get_be32 ( & s -> ptr ) ; offset = bytestream_get_be32 ( & s -> ptr ) ; if ( s -> fileversion >= 3900 ) { if ( offset > 3 ) { av_log ( avctx , AV_LOG_ERROR , ""Incorrect<S2SV_blank>offset<S2SV_blank>passed\\n"" ) ; s -> data = NULL ; return AVERROR_INVALIDDATA ; } if ( s -> data_end - s -> ptr < offset ) { av_log ( avctx , AV_LOG_ERROR , ""Packet<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small\\n"" ) ; return AVERROR_INVALIDDATA ; } s -> ptr += offset ; } else { if ( ( ret = init_get_bits8 ( & s -> gb , s -> ptr , s -> data_end - s -> ptr ) ) < 0 ) return ret ; if ( s -> fileversion > 3800 ) skip_bits_long ( & s -> gb , offset * 8 ) ; else skip_bits_long ( & s -> gb , offset ) ; } <S2SV_StartBug> if ( ! nblocks || nblocks > INT_MAX ) { <S2SV_EndBug> av_log ( avctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>sample<S2SV_blank>count:<S2SV_blank>%"" PRIu32 "".\\n"" , nblocks ) ; return AVERROR_INVALIDDATA ; } if ( init_frame_decoder ( s ) < 0 ) { av_log ( avctx , AV_LOG_ERROR , ""Error<S2SV_blank>reading<S2SV_blank>frame<S2SV_blank>header\\n"" ) ; return AVERROR_INVALIDDATA ; } s -> samples = nblocks ; } if ( ! s -> data ) { * got_frame_ptr = 0 ; return avpkt -> size ; } blockstodecode = FFMIN ( s -> blocks_per_loop , s -> samples ) ; if ( s -> fileversion < 3930 ) blockstodecode = s -> samples ; <S2SV_StartBug> av_fast_malloc ( & s -> decoded_buffer , & s -> decoded_size , <S2SV_EndBug> <S2SV_StartBug> 2 * FFALIGN ( blockstodecode , 8 ) * sizeof ( * s -> decoded_buffer ) ) ; <S2SV_EndBug> if ( ! s -> decoded_buffer ) return AVERROR ( ENOMEM ) ; memset ( s -> decoded_buffer , 0 , s -> decoded_size ) ; s -> decoded [ 0 ] = s -> decoded_buffer ; s -> decoded [ 1 ] = s -> decoded_buffer + FFALIGN ( blockstodecode , 8 ) ; frame -> nb_samples = blockstodecode ; if ( ( ret = ff_get_buffer ( avctx , frame , 0 ) ) < 0 ) return ret ; s -> error = 0 ; if ( ( s -> channels == 1 ) || ( s -> frameflags & APE_FRAMECODE_PSEUDO_STEREO ) ) ape_unpack_mono ( s , blockstodecode ) ; else ape_unpack_stereo ( s , blockstodecode ) ; emms_c ( ) ; if ( s -> error ) { s -> samples = 0 ; av_log ( avctx , AV_LOG_ERROR , ""Error<S2SV_blank>decoding<S2SV_blank>frame\\n"" ) ; return AVERROR_INVALIDDATA ; } switch ( s -> bps ) { case 8 : for ( ch = 0 ; ch < s -> channels ; ch ++ ) { sample8 = ( uint8_t * ) frame -> data [ ch ] ; for ( i = 0 ; i < blockstodecode ; i ++ ) * sample8 ++ = ( s -> decoded [ ch ] [ i ] + 0x80 ) & 0xff ; } break ; case 16 : for ( ch = 0 ; ch < s -> channels ; ch ++ ) { sample16 = ( int16_t * ) frame -> data [ ch ] ; for ( i = 0 ; i < blockstodecode ; i ++ ) * sample16 ++ = s -> decoded [ ch ] [ i ] ; } break ; case 24 : for ( ch = 0 ; ch < s -> channels ; ch ++ ) { sample24 = ( int32_t * ) frame -> data [ ch ] ; for ( i = 0 ; i < blockstodecode ; i ++ ) * sample24 ++ = s -> decoded [ ch ] [ i ] << 8 ; } break ; } s -> samples -= blockstodecode ; * got_frame_ptr = 1 ; return ! s -> samples ? avpkt -> size : 0 ; }","<S2SV_ModStart> ; int blockstodecode ; uint64_t decoded_buffer_size <S2SV_ModStart> nblocks > INT_MAX / 2 / sizeof ( * s -> decoded_buffer ) - 8 <S2SV_ModStart> -> samples ; decoded_buffer_size = 2LL * FFALIGN ( blockstodecode , 8 ) * sizeof ( * s -> decoded_buffer ) ; av_assert0 ( decoded_buffer_size <= INT_MAX ) ; <S2SV_ModStart> -> decoded_size , decoded_buffer_size <S2SV_ModEnd> ) ; if",FFmpeg@FFmpeg/ba4beaf6149f7241c8bd85fe853318c2f6837ad0,CVE-2017-11399,https://github.com/FFmpeg/FFmpeg/commit/ba4beaf6149f7241c8bd85fe853318c2f6837ad0,2017-07-17T19:29Z
CWE-125,"CWE-125 static void ip_optprint ( netdissect_options * ndo , register const u_char * cp , u_int length ) { register u_int option_len ; const char * sep = """" ; for ( ; length > 0 ; cp += option_len , length -= option_len ) { u_int option_code ; ND_PRINT ( ( ndo , ""%s"" , sep ) ) ; sep = "","" ; ND_TCHECK ( * cp ) ; option_code = * cp ; ND_PRINT ( ( ndo , ""%s"" , tok2str ( ip_option_values , ""unknown<S2SV_blank>%u"" , option_code ) ) ) ; if ( option_code == IPOPT_NOP || option_code == IPOPT_EOL ) option_len = 1 ; else { ND_TCHECK ( cp [ 1 ] ) ; option_len = cp [ 1 ] ; if ( option_len < 2 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>[bad<S2SV_blank>length<S2SV_blank>%u]"" , option_len ) ) ; return ; } } if ( option_len > length ) { ND_PRINT ( ( ndo , ""<S2SV_blank>[bad<S2SV_blank>length<S2SV_blank>%u]"" , option_len ) ) ; return ; } ND_TCHECK2 ( * cp , option_len ) ; switch ( option_code ) { case IPOPT_EOL : return ; case IPOPT_TS : <S2SV_StartBug> ip_printts ( ndo , cp , option_len ) ; <S2SV_EndBug> break ; case IPOPT_RR : case IPOPT_SSRR : case IPOPT_LSRR : if ( ip_printroute ( ndo , cp , option_len ) == - 1 ) goto trunc ; break ; <S2SV_StartBug> case IPOPT_RA : <S2SV_EndBug> if ( option_len < 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>[bad<S2SV_blank>length<S2SV_blank>%u]"" , option_len ) ) ; break ; } ND_TCHECK ( cp [ 3 ] ) ; if ( EXTRACT_16BITS ( & cp [ 2 ] ) != 0 ) ND_PRINT ( ( ndo , ""<S2SV_blank>value<S2SV_blank>%u"" , EXTRACT_16BITS ( & cp [ 2 ] ) ) ) ; break ; case IPOPT_NOP : case IPOPT_SECURITY : default : break ; } } return ; trunc : ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; }","<S2SV_ModStart> case IPOPT_TS : if ( ip_printts <S2SV_ModEnd> ( ndo , <S2SV_ModStart> break ; case IPOPT_RR : case IPOPT_SSRR : case IPOPT_LSRR : if ( ip_printroute ( ndo , cp , option_len ) == - 1 ) goto trunc ; break ; case",the-tcpdump-group@tcpdump/2c2cfbd2b771ac888bc5c4a6d922f749d3822538,CVE-2017-13037,https://github.com/the-tcpdump-group/tcpdump/commit/2c2cfbd2b771ac888bc5c4a6d922f749d3822538,2017-09-14T06:29Z
NVD-CWE-noinfo,"CWE-000 static int list_tables ( MYSQL * mysql , const char * db , const char * table ) { const char * header ; uint head_length , counter = 0 ; <S2SV_StartBug> char query [ 255 ] , rows [ NAME_LEN ] , fields [ 16 ] ; <S2SV_EndBug> MYSQL_FIELD * field ; MYSQL_RES * result ; MYSQL_ROW row , rrow ; if ( mysql_select_db ( mysql , db ) ) { fprintf ( stderr , ""%s:<S2SV_blank>Cannot<S2SV_blank>connect<S2SV_blank>to<S2SV_blank>db<S2SV_blank>%s:<S2SV_blank>%s\\n"" , my_progname , db , mysql_error ( mysql ) ) ; return 1 ; } if ( table ) { mysql_real_escape_string ( mysql , rows , table , ( unsigned long ) strlen ( table ) ) ; my_snprintf ( query , sizeof ( query ) , ""show%s<S2SV_blank>tables<S2SV_blank>like<S2SV_blank>\'%s\'"" , opt_table_type ? ""<S2SV_blank>full"" : """" , rows ) ; } else my_snprintf ( query , sizeof ( query ) , ""show%s<S2SV_blank>tables"" , opt_table_type ? ""<S2SV_blank>full"" : """" ) ; if ( mysql_query ( mysql , query ) || ! ( result = mysql_store_result ( mysql ) ) ) { fprintf ( stderr , ""%s:<S2SV_blank>Cannot<S2SV_blank>list<S2SV_blank>tables<S2SV_blank>in<S2SV_blank>%s:<S2SV_blank>%s\\n"" , my_progname , db , mysql_error ( mysql ) ) ; exit ( 1 ) ; } printf ( ""Database:<S2SV_blank>%s"" , db ) ; if ( table ) printf ( ""<S2SV_blank><S2SV_blank>Wildcard:<S2SV_blank>%s"" , table ) ; putchar ( '\\n' ) ; header = ""Tables"" ; head_length = ( uint ) strlen ( header ) ; field = mysql_fetch_field ( result ) ; if ( head_length < field -> max_length ) head_length = field -> max_length ; if ( opt_table_type ) { if ( ! opt_verbose ) print_header ( header , head_length , ""table_type"" , 10 , NullS ) ; else if ( opt_verbose == 1 ) print_header ( header , head_length , ""table_type"" , 10 , ""Columns"" , 8 , NullS ) ; else { print_header ( header , head_length , ""table_type"" , 10 , ""Columns"" , 8 , ""Total<S2SV_blank>Rows"" , 10 , NullS ) ; } } else { if ( ! opt_verbose ) print_header ( header , head_length , NullS ) ; else if ( opt_verbose == 1 ) print_header ( header , head_length , ""Columns"" , 8 , NullS ) ; else print_header ( header , head_length , ""Columns"" , 8 , ""Total<S2SV_blank>Rows"" , 10 , NullS ) ; } while ( ( row = mysql_fetch_row ( result ) ) ) { counter ++ ; if ( opt_verbose > 0 ) { if ( ! ( mysql_select_db ( mysql , db ) ) ) { MYSQL_RES * rresult = mysql_list_fields ( mysql , row [ 0 ] , NULL ) ; ulong rowcount = 0L ; if ( ! rresult ) { strmov ( fields , ""N/A"" ) ; strmov ( rows , ""N/A"" ) ; } else { sprintf ( fields , ""%8u"" , ( uint ) mysql_num_fields ( rresult ) ) ; mysql_free_result ( rresult ) ; if ( opt_verbose > 1 ) { <S2SV_StartBug> sprintf ( query , ""SELECT<S2SV_blank>COUNT(*)<S2SV_blank>FROM<S2SV_blank>`%s`"" , row [ 0 ] ) ; <S2SV_EndBug> if ( ! ( mysql_query ( mysql , query ) ) ) { if ( ( rresult = mysql_store_result ( mysql ) ) ) { rrow = mysql_fetch_row ( rresult ) ; rowcount += ( unsigned long ) strtoull ( rrow [ 0 ] , ( char * * ) 0 , 10 ) ; mysql_free_result ( rresult ) ; } sprintf ( rows , ""%10lu"" , rowcount ) ; } else sprintf ( rows , ""%10d"" , 0 ) ; } } } else { strmov ( fields , ""N/A"" ) ; strmov ( rows , ""N/A"" ) ; } } if ( opt_table_type ) { if ( ! opt_verbose ) print_row ( row [ 0 ] , head_length , row [ 1 ] , 10 , NullS ) ; else if ( opt_verbose == 1 ) print_row ( row [ 0 ] , head_length , row [ 1 ] , 10 , fields , 8 , NullS ) ; else print_row ( row [ 0 ] , head_length , row [ 1 ] , 10 , fields , 8 , rows , 10 , NullS ) ; } else { if ( ! opt_verbose ) print_row ( row [ 0 ] , head_length , NullS ) ; else if ( opt_verbose == 1 ) print_row ( row [ 0 ] , head_length , fields , 8 , NullS ) ; else print_row ( row [ 0 ] , head_length , fields , 8 , rows , 10 , NullS ) ; } } print_trailer ( head_length , ( opt_table_type ? 10 : opt_verbose > 0 ? 8 : 0 ) , ( opt_table_type ? ( opt_verbose > 0 ? 8 : 0 ) : ( opt_verbose > 1 ? 10 : 0 ) ) , ! opt_table_type ? 0 : opt_verbose > 1 ? 10 : 0 , 0 ) ; if ( counter && opt_verbose ) printf ( ""%u<S2SV_blank>row%s<S2SV_blank>in<S2SV_blank>set.\\n\\n"" , counter , ( counter > 1 ) ? ""s"" : """" ) ; mysql_free_result ( result ) ; return 0 ; }","<S2SV_ModStart> char query [ NAME_LEN + 100 <S2SV_ModEnd> ] , rows <S2SV_ModStart> 1 ) { my_snprintf <S2SV_ModEnd> ( query , <S2SV_ModStart> ( query , sizeof ( query ) ,",mysql@mysql-server/0dbd5a8797ed4bd18e8b883988fb62177eb0f73f,CVE-2016-0546,https://github.com/mysql/mysql-server/commit/0dbd5a8797ed4bd18e8b883988fb62177eb0f73f,2016-01-21T03:01Z
CWE-119,"CWE-119 static guint32 parse_wbxml_attribute_list ( proto_tree * tree , tvbuff_t * tvb , guint32 offset , guint32 str_tbl , guint8 level , guint8 * codepage_attr ) { guint32 tvb_len = tvb_reported_length ( tvb ) ; <S2SV_StartBug> guint32 off = offset ; <S2SV_EndBug> guint32 len ; guint str_len ; guint32 ent ; guint32 idx ; guint8 peek ; <S2SV_StartBug> DebugLog ( ( ""parse_wbxml_attr<S2SV_blank>(level<S2SV_blank>=<S2SV_blank>%u,<S2SV_blank>offset<S2SV_blank>=<S2SV_blank>%u)\\n"" , level , offset ) ) ; <S2SV_EndBug> while ( off < tvb_len ) { peek = tvb_get_guint8 ( tvb , off ) ; DebugLog ( ( ""ATTR:<S2SV_blank>(top<S2SV_blank>of<S2SV_blank>while)<S2SV_blank>level<S2SV_blank>=<S2SV_blank>%3u,<S2SV_blank>peek<S2SV_blank>=<S2SV_blank>0x%02X,<S2SV_blank>"" ""off<S2SV_blank>=<S2SV_blank>%u,<S2SV_blank>tvb_len<S2SV_blank>=<S2SV_blank>%u\\n"" , level , peek , off , tvb_len ) ) ; if ( ( peek & 0x3F ) < 5 ) switch ( peek ) { case 0x00 : * codepage_attr = tvb_get_guint8 ( tvb , off + 1 ) ; proto_tree_add_text ( tree , tvb , off , 2 , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>|<S2SV_blank><S2SV_blank>Attr<S2SV_blank>|<S2SV_blank>A<S2SV_blank>-->%3d<S2SV_blank>"" ""|<S2SV_blank>SWITCH_PAGE<S2SV_blank>(Attr<S2SV_blank>code<S2SV_blank>page)<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>|"" , * codepage_attr ) ; off += 2 ; break ; case 0x01 : off ++ ; DebugLog ( ( ""ATTR:<S2SV_blank>level<S2SV_blank>=<S2SV_blank>%u,<S2SV_blank>Return:<S2SV_blank>len<S2SV_blank>=<S2SV_blank>%u\\n"" , level , off - offset ) ) ; return ( off - offset ) ; case 0x02 : ent = tvb_get_guintvar ( tvb , off + 1 , & len ) ; proto_tree_add_text ( tree , tvb , off , 1 + len , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank><S2SV_blank>Attr<S2SV_blank>|<S2SV_blank>A<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>ENTITY<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s\'&#%u;\'"" , level , * codepage_attr , Indent ( level ) , ent ) ; off += 1 + len ; break ; case 0x03 : len = tvb_strsize ( tvb , off + 1 ) ; proto_tree_add_text ( tree , tvb , off , 1 + len , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank><S2SV_blank>Attr<S2SV_blank>|<S2SV_blank>A<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>STR_I<S2SV_blank>(Inline<S2SV_blank>string)<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s\\\'%s\\\'"" , level , * codepage_attr , Indent ( level ) , tvb_format_text ( tvb , off + 1 , len - 1 ) ) ; off += 1 + len ; break ; case 0x04 : idx = tvb_get_guintvar ( tvb , off + 1 , & len ) ; str_len = tvb_strsize ( tvb , str_tbl + idx ) ; proto_tree_add_text ( tree , tvb , off , 1 + len , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank><S2SV_blank>Attr<S2SV_blank>|<S2SV_blank>A<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>LITERAL<S2SV_blank>(Literal<S2SV_blank>Attribute)<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank><S2SV_blank><S2SV_blank>%s<%s<S2SV_blank>/>"" , level , * codepage_attr , Indent ( level ) , tvb_format_text ( tvb , str_tbl + idx , str_len - 1 ) ) ; off += 1 + len ; break ; case 0x40 : case 0x41 : case 0x42 : len = tvb_strsize ( tvb , off + 1 ) ; proto_tree_add_text ( tree , tvb , off , 1 + len , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank><S2SV_blank>Attr<S2SV_blank>|<S2SV_blank>A<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>EXT_I_%1x<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(Extension<S2SV_blank>Token)<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s(Inline<S2SV_blank>string<S2SV_blank>extension:<S2SV_blank>\\\'%s\\\')"" , level , * codepage_attr , peek & 0x0f , Indent ( level ) , tvb_format_text ( tvb , off + 1 , len - 1 ) ) ; off += 1 + len ; break ; case 0x80 : case 0x81 : case 0x82 : idx = tvb_get_guintvar ( tvb , off + 1 , & len ) ; proto_tree_add_text ( tree , tvb , off , 1 + len , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank><S2SV_blank>Attr<S2SV_blank>|<S2SV_blank>A<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>EXT_T_%1x<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(Extension<S2SV_blank>Token)<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s(Extension<S2SV_blank>Token,<S2SV_blank>integer<S2SV_blank>value:<S2SV_blank>%u)"" , level , * codepage_attr , peek & 0x0f , Indent ( level ) , idx ) ; off += 1 + len ; break ; case 0x83 : idx = tvb_get_guintvar ( tvb , off + 1 , & len ) ; str_len = tvb_strsize ( tvb , str_tbl + idx ) ; proto_tree_add_text ( tree , tvb , off , 1 + len , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank><S2SV_blank>Attr<S2SV_blank>|<S2SV_blank>A<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>STR_T<S2SV_blank>(Tableref<S2SV_blank>string)<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s\\\'%s\\\'"" , level , * codepage_attr , Indent ( level ) , tvb_format_text ( tvb , str_tbl + idx , str_len - 1 ) ) ; off += 1 + len ; break ; case 0xC0 : case 0xC1 : case 0xC2 : proto_tree_add_text ( tree , tvb , off , 1 , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank><S2SV_blank>Attr<S2SV_blank>|<S2SV_blank>A<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>EXT_%1x<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(Extension<S2SV_blank>Token)<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s(Single-byte<S2SV_blank>extension)"" , level , * codepage_attr , peek & 0x0f , Indent ( level ) ) ; off ++ ; break ; case 0xC3 : if ( tvb_get_guint8 ( tvb , 0 ) ) { idx = tvb_get_guintvar ( tvb , off + 1 , & len ) ; proto_tree_add_text ( tree , tvb , off , 1 + len + idx , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank><S2SV_blank>Attr<S2SV_blank>|<S2SV_blank>A<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>OPAQUE<S2SV_blank>(Opaque<S2SV_blank>data)<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s(%d<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>opaque<S2SV_blank>data)"" , level , * codepage_attr , Indent ( level ) , idx ) ; off += 1 + len + idx ; } else { proto_tree_add_text ( tree , tvb , off , 1 , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank><S2SV_blank>Attr<S2SV_blank>|<S2SV_blank>A<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>RESERVED_2<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(Invalid<S2SV_blank>Token!)<S2SV_blank>"" ""|<S2SV_blank>WBXML<S2SV_blank>1.0<S2SV_blank>parsing<S2SV_blank>stops<S2SV_blank>here."" , level , * codepage_attr ) ; off = tvb_len ; DebugLog ( ( ""ATTR:<S2SV_blank>level<S2SV_blank>=<S2SV_blank>%u,<S2SV_blank>Return:<S2SV_blank>len<S2SV_blank>=<S2SV_blank>%u\\n"" , level , off - offset ) ) ; return ( off - offset ) ; } break ; default : proto_tree_add_text ( tree , tvb , off , 1 , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank><S2SV_blank>Attr<S2SV_blank>|<S2SV_blank>A<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>%-10s<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(Invalid<S2SV_blank>Token!)<S2SV_blank>"" ""|<S2SV_blank>WBXML<S2SV_blank>parsing<S2SV_blank>stops<S2SV_blank>here."" , level , * codepage_attr , val_to_str_ext ( peek , & vals_wbxml1x_global_tokens_ext , ""(unknown<S2SV_blank>0x%x)"" ) ) ; off = tvb_len ; break ; } else { if ( peek & 0x80 ) { proto_tree_add_text ( tree , tvb , off , 1 , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank><S2SV_blank>Attr<S2SV_blank>|<S2SV_blank>A<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank><S2SV_blank><S2SV_blank>Known<S2SV_blank>attrValue<S2SV_blank>0x%02X<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%sattrValue_0x%02X"" , level , * codepage_attr , peek & 0x7f , Indent ( level ) , peek ) ; off ++ ; } else { proto_tree_add_text ( tree , tvb , off , 1 , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank><S2SV_blank>Attr<S2SV_blank>|<S2SV_blank>A<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank><S2SV_blank><S2SV_blank>Known<S2SV_blank>attrStart<S2SV_blank>0x%02X<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank><S2SV_blank><S2SV_blank>%sattrStart_0x%02X"" , level , * codepage_attr , peek & 0x7f , Indent ( level ) , peek ) ; off ++ ; } } <S2SV_StartBug> } <S2SV_EndBug> DebugLog ( ( ""ATTR:<S2SV_blank>level<S2SV_blank>=<S2SV_blank>%u,<S2SV_blank>Return:<S2SV_blank>len<S2SV_blank>=<S2SV_blank>%u<S2SV_blank>(end<S2SV_blank>of<S2SV_blank>function<S2SV_blank>body)\\n"" , level , off - offset ) ) ; return ( off - offset ) ; }","<S2SV_ModStart> off = offset , last_off <S2SV_ModStart> offset ) ) ; last_off = off <S2SV_ModStart> ; } } if ( off < last_off ) { THROW ( ReportedBoundsError ) ; } last_off = off ;",wireshark@wireshark/b8e0d416898bb975a02c1b55883342edc5b4c9c0,CVE-2016-5359,https://github.com/wireshark/wireshark/commit/b8e0d416898bb975a02c1b55883342edc5b4c9c0,2016-08-07T16:59Z
CWE-119,"CWE-119 <S2SV_StartBug> static void encode_frame ( vpx_codec_ctx_t * ctx , <S2SV_EndBug> const vpx_image_t * img , vpx_codec_pts_t pts , unsigned int duration , vpx_enc_frame_flags_t flags , unsigned int deadline , <S2SV_StartBug> VpxVideoWriter * writer ) { <S2SV_EndBug> vpx_codec_iter_t iter = NULL ; const vpx_codec_cx_pkt_t * pkt = NULL ; const vpx_codec_err_t res = vpx_codec_encode ( ctx , img , pts , duration , flags , deadline ) ; if ( res != VPX_CODEC_OK ) die_codec ( ctx , ""Failed<S2SV_blank>to<S2SV_blank>encode<S2SV_blank>frame."" ) ; <S2SV_StartBug> while ( ( pkt = vpx_codec_get_cx_data ( ctx , & iter ) ) != NULL ) { <S2SV_EndBug> if ( pkt -> kind == VPX_CODEC_CX_FRAME_PKT ) { const int keyframe = ( pkt -> data . frame . flags & VPX_FRAME_IS_KEY ) != 0 ; if ( ! vpx_video_writer_write_frame ( writer , pkt -> data . frame . buf , pkt -> data . frame . sz , pkt -> data . frame . pts ) ) die_codec ( ctx , ""Failed<S2SV_blank>to<S2SV_blank>write<S2SV_blank>compressed<S2SV_blank>frame."" ) ; printf ( keyframe ? ""K"" : ""."" ) ; fflush ( stdout ) ; } } <S2SV_StartBug> } <S2SV_EndBug>",<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> encode_frame ( vpx_codec_ctx_t <S2SV_ModStart> writer ) { int got_pkts = 0 ; <S2SV_ModStart> NULL ) { got_pkts = 1 ; <S2SV_ModStart> ; } } return got_pkts ;,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-264,"CWE-264 static int timer_start ( Unit * u ) { Timer * t = TIMER ( u ) ; TimerValue * v ; assert ( t ) ; assert ( t -> state == TIMER_DEAD || t -> state == TIMER_FAILED ) ; if ( UNIT_TRIGGER ( u ) -> load_state != UNIT_LOADED ) return - ENOENT ; t -> last_trigger = DUAL_TIMESTAMP_NULL ; LIST_FOREACH ( value , v , t -> values ) if ( v -> base == TIMER_ACTIVE ) v -> disabled = false ; if ( t -> stamp_path ) { struct stat st ; if ( stat ( t -> stamp_path , & st ) >= 0 ) t -> last_trigger . realtime = timespec_load ( & st . st_atim ) ; else if ( errno == ENOENT ) <S2SV_StartBug> touch_file ( t -> stamp_path , true , USEC_INFINITY , UID_INVALID , GID_INVALID , 0 ) ; <S2SV_EndBug> } t -> result = TIMER_SUCCESS ; timer_enter_waiting ( t , true ) ; return 1 ; }","<S2SV_ModStart> , GID_INVALID , MODE_INVALID <S2SV_ModEnd> ) ; }",systemd@systemd/ee735086f8670be1591fa9593e80dd60163a7a2f,CVE-2016-10156,https://github.com/systemd/systemd/commit/ee735086f8670be1591fa9593e80dd60163a7a2f,2017-01-23T07:59Z
CWE-787,"CWE-787 <S2SV_StartBug> static void nsc_rle_decompress_data ( NSC_CONTEXT * context ) <S2SV_EndBug> { UINT16 i ; BYTE * rle ; UINT32 planeSize ; UINT32 originalSize ; <S2SV_StartBug> rle = context -> Planes ; <S2SV_EndBug> for ( i = 0 ; i < 4 ; i ++ ) { originalSize = context -> OrgByteCount [ i ] ; planeSize = context -> PlaneByteCount [ i ] ; if ( planeSize == 0 ) <S2SV_StartBug> FillMemory ( context -> priv -> PlaneBuffers [ i ] , originalSize , 0xFF ) ; <S2SV_EndBug> <S2SV_StartBug> else if ( planeSize < originalSize ) <S2SV_EndBug> <S2SV_StartBug> nsc_rle_decode ( rle , context -> priv -> PlaneBuffers [ i ] , originalSize ) ; <S2SV_EndBug> else CopyMemory ( context -> priv -> PlaneBuffers [ i ] , rle , originalSize ) ; <S2SV_StartBug> rle += planeSize ; <S2SV_EndBug> } <S2SV_StartBug> } <S2SV_EndBug>","<S2SV_ModStart> <S2SV_null> <S2SV_null> static BOOL <S2SV_ModEnd> nsc_rle_decompress_data ( NSC_CONTEXT <S2SV_ModStart> UINT32 originalSize ; if ( ! context ) return FALSE ; <S2SV_ModStart> == 0 ) { if ( context -> priv -> PlaneBuffersLength < originalSize ) return FALSE ; <S2SV_ModStart> 0xFF ) ; } <S2SV_ModStart> < originalSize ) { if ( ! <S2SV_ModStart> i ] , context -> priv -> PlaneBuffersLength , originalSize ) ) return FALSE ; } else { if ( context -> priv -> PlaneBuffersLength < originalSize ) return FALSE ; <S2SV_ModEnd> CopyMemory ( context <S2SV_ModStart> originalSize ) ; } <S2SV_ModStart> planeSize ; } return TRUE ;",FreeRDP@FreeRDP/d1112c279bd1a327e8e4d0b5f371458bf2579659,CVE-2018-8788,https://github.com/FreeRDP/FreeRDP/commit/d1112c279bd1a327e8e4d0b5f371458bf2579659,2018-11-29T18:29Z
CWE-416,CWE-416 static void nodeDestruct ( struct SaveNode * node ) { <S2SV_StartBug> if ( node -> v == & node -> sorted ) <S2SV_EndBug> { <S2SV_StartBug> tr_free ( node -> sorted . val . l . vals ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> },<S2SV_ModStart> node ) { TR_ASSERT ( node != NULL ) ; <S2SV_ModStart> ( node -> sorted != NULL <S2SV_ModEnd> ) { tr_free <S2SV_ModStart> node -> sorted -> <S2SV_ModEnd> val . l <S2SV_ModStart> vals ) ; tr_free ( node -> sorted ) ;,transmission@transmission/2123adf8e5e1c2b48791f9d22fc8c747e974180e,CVE-2018-10756,https://github.com/transmission/transmission/commit/2123adf8e5e1c2b48791f9d22fc8c747e974180e,2020-05-15T16:15Z
CWE-125,"CWE-125 <S2SV_StartBug> void rdp_read_flow_control_pdu ( wStream * s , UINT16 * type ) <S2SV_EndBug> { <S2SV_StartBug> UINT8 pduType ; <S2SV_EndBug> Stream_Read_UINT8 ( s , pduType ) ; * type = pduType ; Stream_Seek_UINT8 ( s ) ; Stream_Seek_UINT8 ( s ) ; Stream_Seek_UINT8 ( s ) ; Stream_Seek_UINT16 ( s ) ; <S2SV_StartBug> } <S2SV_EndBug>",<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> BOOL <S2SV_ModEnd> rdp_read_flow_control_pdu ( wStream <S2SV_ModStart> { UINT8 pduType ; if ( ! type ) return FALSE ; if ( Stream_GetRemainingLength ( s ) < 6 ) return FALSE <S2SV_ModStart> s ) ; return TRUE ;,FreeRDP@FreeRDP/9301bfe730c66180263248b74353daa99f5a969b,CVE-2020-11048,https://github.com/FreeRDP/FreeRDP/commit/9301bfe730c66180263248b74353daa99f5a969b,2020-05-07T20:15Z
CWE-416,"CWE-416 static void lo_release ( struct gendisk * disk , fmode_t mode ) { <S2SV_StartBug> struct loop_device * lo = disk -> private_data ; <S2SV_EndBug> int err ; if ( atomic_dec_return ( & lo -> lo_refcnt ) ) return ; mutex_lock ( & lo -> lo_ctl_mutex ) ; if ( lo -> lo_flags & LO_FLAGS_AUTOCLEAR ) { err = loop_clr_fd ( lo ) ; if ( ! err ) return ; } else if ( lo -> lo_state == Lo_bound ) { blk_mq_freeze_queue ( lo -> lo_queue ) ; blk_mq_unfreeze_queue ( lo -> lo_queue ) ; } <S2SV_StartBug> mutex_unlock ( & lo -> lo_ctl_mutex ) ; <S2SV_EndBug> }",<S2SV_ModStart> mode ) { mutex_lock ( & loop_index_mutex ) ; __lo_release ( <S2SV_ModEnd> disk -> private_data <S2SV_ModStart> disk -> private_data ) ; <S2SV_ModEnd> mutex_unlock ( & <S2SV_ModStart> mutex_unlock ( & loop_index_mutex <S2SV_ModEnd> ) ; },torvalds@linux/ae6650163c66a7eff1acd6eb8b0f752dcfa8eba5,CVE-2018-5344,https://github.com/torvalds/linux/commit/ae6650163c66a7eff1acd6eb8b0f752dcfa8eba5,2018-01-12T09:29Z
CWE-125,"CWE-125 static int lldp_mgmt_addr_tlv_print ( netdissect_options * ndo , const u_char * pptr , u_int len ) { uint8_t mgmt_addr_len , intf_num_subtype , oid_len ; const u_char * tptr ; u_int tlen ; char * mgmt_addr ; tlen = len ; tptr = pptr ; if ( tlen < 1 ) { return 0 ; } mgmt_addr_len = * tptr ++ ; tlen -- ; if ( tlen < mgmt_addr_len ) { return 0 ; } mgmt_addr = lldp_network_addr_print ( ndo , tptr , mgmt_addr_len ) ; if ( mgmt_addr == NULL ) { return 0 ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Management<S2SV_blank>Address<S2SV_blank>length<S2SV_blank>%u,<S2SV_blank>%s"" , mgmt_addr_len , mgmt_addr ) ) ; tptr += mgmt_addr_len ; tlen -= mgmt_addr_len ; if ( tlen < LLDP_INTF_NUM_LEN ) { return 0 ; } intf_num_subtype = * tptr ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Interface<S2SV_blank>Numbering<S2SV_blank>(%u):<S2SV_blank>%u"" , tok2str ( lldp_intf_numb_subtype_values , ""Unknown"" , intf_num_subtype ) , intf_num_subtype , EXTRACT_32BITS ( tptr + 1 ) ) ) ; tptr += LLDP_INTF_NUM_LEN ; tlen -= LLDP_INTF_NUM_LEN ; if ( tlen ) { oid_len = * tptr ; <S2SV_StartBug> if ( tlen < oid_len ) { <S2SV_EndBug> return 0 ; } if ( oid_len ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>OID<S2SV_blank>length<S2SV_blank>%u"" , oid_len ) ) ; safeputs ( ndo , tptr + 1 , oid_len ) ; } } return 1 ; }",<S2SV_ModStart> ( tlen < 1U +,the-tcpdump-group@tcpdump/a77ff09c46560bc895dea11dc9fe643486b056ac,CVE-2017-13027,https://github.com/the-tcpdump-group/tcpdump/commit/a77ff09c46560bc895dea11dc9fe643486b056ac,2017-09-14T06:29Z
CWE-119,"CWE-119 static void set_segment_data ( VP8_COMP * cpi , signed char * feature_data , unsigned char abs_delta ) { cpi -> mb . e_mbd . mb_segement_abs_delta = abs_delta ; <S2SV_StartBug> vpx_memcpy ( cpi -> segment_feature_data , feature_data , sizeof ( cpi -> segment_feature_data ) ) ; <S2SV_EndBug> }",<S2SV_ModStart> = abs_delta ; memcpy <S2SV_ModEnd> ( cpi ->,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-399,"CWE-399 int __kvm_set_memory_region ( struct kvm * kvm , struct kvm_userspace_memory_region * mem , int user_alloc ) { int r ; gfn_t base_gfn ; unsigned long npages ; unsigned long i ; struct kvm_memory_slot * memslot ; struct kvm_memory_slot old , new ; struct kvm_memslots * slots , * old_memslots ; r = check_memory_region_flags ( mem ) ; if ( r ) goto out ; r = - EINVAL ; if ( mem -> memory_size & ( PAGE_SIZE - 1 ) ) goto out ; if ( mem -> guest_phys_addr & ( PAGE_SIZE - 1 ) ) goto out ; if ( user_alloc && ( ( mem -> userspace_addr & ( PAGE_SIZE - 1 ) ) || ! access_ok ( VERIFY_WRITE , ( void __user * ) ( unsigned long ) mem -> userspace_addr , mem -> memory_size ) ) ) goto out ; if ( mem -> slot >= KVM_MEM_SLOTS_NUM ) goto out ; if ( mem -> guest_phys_addr + mem -> memory_size < mem -> guest_phys_addr ) goto out ; memslot = id_to_memslot ( kvm -> memslots , mem -> slot ) ; base_gfn = mem -> guest_phys_addr >> PAGE_SHIFT ; npages = mem -> memory_size >> PAGE_SHIFT ; r = - EINVAL ; if ( npages > KVM_MEM_MAX_NR_PAGES ) goto out ; if ( ! npages ) mem -> flags &= ~ KVM_MEM_LOG_DIRTY_PAGES ; new = old = * memslot ; new . id = mem -> slot ; new . base_gfn = base_gfn ; new . npages = npages ; new . flags = mem -> flags ; r = - EINVAL ; if ( npages && old . npages && npages != old . npages ) goto out_free ; r = - EEXIST ; for ( i = 0 ; i < KVM_MEMORY_SLOTS ; ++ i ) { struct kvm_memory_slot * s = & kvm -> memslots -> memslots [ i ] ; if ( s == memslot || ! s -> npages ) continue ; if ( ! ( ( base_gfn + npages <= s -> base_gfn ) || ( base_gfn >= s -> base_gfn + s -> npages ) ) ) goto out_free ; } if ( ! ( new . flags & KVM_MEM_LOG_DIRTY_PAGES ) ) new . dirty_bitmap = NULL ; r = - ENOMEM ; if ( npages && ! old . npages ) { new . user_alloc = user_alloc ; new . userspace_addr = mem -> userspace_addr ; if ( kvm_arch_create_memslot ( & new , npages ) ) goto out_free ; } if ( ( new . flags & KVM_MEM_LOG_DIRTY_PAGES ) && ! new . dirty_bitmap ) { if ( kvm_create_dirty_bitmap ( & new ) < 0 ) goto out_free ; } <S2SV_StartBug> if ( ! npages ) { <S2SV_EndBug> struct kvm_memory_slot * slot ; r = - ENOMEM ; slots = kmemdup ( kvm -> memslots , sizeof ( struct kvm_memslots ) , GFP_KERNEL ) ; if ( ! slots ) goto out_free ; slot = id_to_memslot ( slots , mem -> slot ) ; slot -> flags |= KVM_MEMSLOT_INVALID ; update_memslots ( slots , NULL ) ; old_memslots = kvm -> memslots ; rcu_assign_pointer ( kvm -> memslots , slots ) ; synchronize_srcu_expedited ( & kvm -> srcu ) ; kvm_arch_flush_shadow_memslot ( kvm , slot ) ; kfree ( old_memslots ) ; } r = kvm_arch_prepare_memory_region ( kvm , & new , old , mem , user_alloc ) ; if ( r ) goto out_free ; if ( npages ) { r = kvm_iommu_map_pages ( kvm , & new ) ; if ( r ) goto out_free ; } else kvm_iommu_unmap_pages ( kvm , & old ) ; r = - ENOMEM ; slots = kmemdup ( kvm -> memslots , sizeof ( struct kvm_memslots ) , GFP_KERNEL ) ; if ( ! slots ) goto out_free ; if ( ! npages ) { new . dirty_bitmap = NULL ; memset ( & new . arch , 0 , sizeof ( new . arch ) ) ; } update_memslots ( slots , & new ) ; old_memslots = kvm -> memslots ; rcu_assign_pointer ( kvm -> memslots , slots ) ; synchronize_srcu_expedited ( & kvm -> srcu ) ; kvm_arch_commit_memory_region ( kvm , mem , old , user_alloc ) ; if ( npages && old . base_gfn != mem -> guest_phys_addr >> PAGE_SHIFT ) kvm_arch_flush_shadow_all ( kvm ) ; kvm_free_physmem_slot ( & old , & new ) ; kfree ( old_memslots ) ; return 0 ; out_free : kvm_free_physmem_slot ( & new , & old ) ; out : return r ; }",<S2SV_ModStart> ( ! npages || base_gfn != old . base_gfn,torvalds@linux/12d6e7538e2d418c08f082b1b44ffa5fb7270ed8,CVE-2013-4592,https://github.com/torvalds/linux/commit/12d6e7538e2d418c08f082b1b44ffa5fb7270ed8,2013-11-20T13:19Z
CWE-399,"CWE-399 xmlAttrPtr xsltAttrListTemplateProcess ( xsltTransformContextPtr ctxt , xmlNodePtr target , xmlAttrPtr attrs ) { xmlAttrPtr attr , copy , last ; xmlNodePtr oldInsert , text ; xmlNsPtr origNs = NULL , copyNs = NULL ; const xmlChar * value ; xmlChar * valueAVT ; if ( ( ctxt == NULL ) || ( target == NULL ) || ( attrs == NULL ) ) return ( NULL ) ; oldInsert = ctxt -> insert ; ctxt -> insert = target ; if ( target -> properties ) { last = target -> properties ; while ( last -> next != NULL ) last = last -> next ; } else { last = NULL ; } attr = attrs ; do { # ifdef XSLT_REFACTORED if ( attr -> psvi == xsltXSLTAttrMarker ) { goto next_attribute ; } # else if ( ( attr -> ns != NULL ) && xmlStrEqual ( attr -> ns -> href , XSLT_NAMESPACE ) ) { goto next_attribute ; } # endif if ( attr -> children != NULL ) { if ( ( attr -> children -> type != XML_TEXT_NODE ) || ( attr -> children -> next != NULL ) ) { xsltTransformError ( ctxt , NULL , attr -> parent , ""Internal<S2SV_blank>error:<S2SV_blank>The<S2SV_blank>children<S2SV_blank>of<S2SV_blank>an<S2SV_blank>attribute<S2SV_blank>node<S2SV_blank>of<S2SV_blank>a<S2SV_blank>"" ""literal<S2SV_blank>result<S2SV_blank>element<S2SV_blank>are<S2SV_blank>not<S2SV_blank>in<S2SV_blank>the<S2SV_blank>expected<S2SV_blank>form.\\n"" ) ; goto error ; } value = attr -> children -> content ; if ( value == NULL ) value = xmlDictLookup ( ctxt -> dict , BAD_CAST """" , 0 ) ; } else value = xmlDictLookup ( ctxt -> dict , BAD_CAST """" , 0 ) ; copy = xmlNewDocProp ( target -> doc , attr -> name , NULL ) ; if ( copy == NULL ) { if ( attr -> ns ) { xsltTransformError ( ctxt , NULL , attr -> parent , ""Internal<S2SV_blank>error:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>attribute<S2SV_blank>\'{%s}%s\'.\\n"" , attr -> ns -> href , attr -> name ) ; } else { xsltTransformError ( ctxt , NULL , attr -> parent , ""Internal<S2SV_blank>error:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>attribute<S2SV_blank>\'%s\'.\\n"" , attr -> name ) ; } goto error ; } copy -> parent = target ; if ( last == NULL ) { target -> properties = copy ; last = copy ; } else { last -> next = copy ; copy -> prev = last ; last = copy ; } if ( attr -> ns != origNs ) { origNs = attr -> ns ; if ( attr -> ns != NULL ) { # ifdef XSLT_REFACTORED copyNs = xsltGetSpecialNamespace ( ctxt , attr -> parent , attr -> ns -> href , attr -> ns -> prefix , target ) ; # else copyNs = xsltGetNamespace ( ctxt , attr -> parent , attr -> ns , target ) ; # endif if ( copyNs == NULL ) goto error ; } else copyNs = NULL ; } copy -> ns = copyNs ; text = xmlNewText ( NULL ) ; if ( text != NULL ) { copy -> last = copy -> children = text ; text -> parent = ( xmlNodePtr ) copy ; text -> doc = copy -> doc ; if ( attr -> psvi != NULL ) { valueAVT = xsltEvalAVT ( ctxt , attr -> psvi , attr -> parent ) ; if ( valueAVT == NULL ) { if ( attr -> ns ) { xsltTransformError ( ctxt , NULL , attr -> parent , ""Internal<S2SV_blank>error:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>evaluate<S2SV_blank>the<S2SV_blank>AVT<S2SV_blank>"" ""of<S2SV_blank>attribute<S2SV_blank>\'{%s}%s\'.\\n"" , attr -> ns -> href , attr -> name ) ; } else { xsltTransformError ( ctxt , NULL , attr -> parent , ""Internal<S2SV_blank>error:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>evaluate<S2SV_blank>the<S2SV_blank>AVT<S2SV_blank>"" ""of<S2SV_blank>attribute<S2SV_blank>\'%s\'.\\n"" , attr -> name ) ; } text -> content = xmlStrdup ( BAD_CAST """" ) ; goto error ; } else { text -> content = valueAVT ; } } else if ( ( ctxt -> internalized ) && ( target -> doc != NULL ) && <S2SV_StartBug> ( target -> doc -> dict == ctxt -> dict ) ) <S2SV_EndBug> { text -> content = ( xmlChar * ) value ; } else { text -> content = xmlStrdup ( value ) ; } if ( ( copy != NULL ) && ( text != NULL ) && ( xmlIsID ( copy -> doc , copy -> parent , copy ) ) ) xmlAddID ( NULL , copy -> doc , text -> content , copy ) ; } next_attribute : attr = attr -> next ; } while ( attr != NULL ) ; attr = attrs ; do { # ifdef XSLT_REFACTORED if ( ( attr -> psvi == xsltXSLTAttrMarker ) && xmlStrEqual ( attr -> name , ( const xmlChar * ) ""use-attribute-sets"" ) ) { xsltApplyAttributeSet ( ctxt , ctxt -> node , ( xmlNodePtr ) attr , NULL ) ; } # else if ( ( attr -> ns != NULL ) && xmlStrEqual ( attr -> name , ( const xmlChar * ) ""use-attribute-sets"" ) && xmlStrEqual ( attr -> ns -> href , XSLT_NAMESPACE ) ) { xsltApplyAttributeSet ( ctxt , ctxt -> node , ( xmlNodePtr ) attr , NULL ) ; } # endif attr = attr -> next ; } while ( attr != NULL ) ; ctxt -> insert = oldInsert ; return ( target -> properties ) ; error : ctxt -> insert = oldInsert ; return ( NULL ) ; }","<S2SV_ModStart> -> dict ) && xmlDictOwns ( ctxt -> dict , value )",chromium@chromium/2de493f4a1d48952e09230a0c32ccbd45db973b2,CVE-2012-2893,https://github.com/chromium/chromium/commit/2de493f4a1d48952e09230a0c32ccbd45db973b2,2012-09-26T10:56Z
CWE-400,CWE-000 static int xen_evtchn_cpu_prepare ( unsigned int cpu ) { <S2SV_StartBug> int ret = 0 ; <S2SV_EndBug> if ( evtchn_ops -> percpu_init ) ret = evtchn_ops -> percpu_init ( cpu ) ; return ret ; },<S2SV_ModStart> ret = 0 ; xen_cpu_init_eoi ( cpu ),torvalds@linux/e99502f76271d6bc4e374fe368c50c67a1fd3070,CVE-2020-27673,https://github.com/torvalds/linux/commit/e99502f76271d6bc4e374fe368c50c67a1fd3070,2020-10-22T21:15Z
CWE-476,"CWE-476 file_transfer_t * imcb_file_send_start ( struct im_connection * ic , char * handle , char * file_name , size_t file_size ) { bee_t * bee = ic -> bee ; bee_user_t * bu = bee_user_by_handle ( bee , ic , handle ) ; <S2SV_StartBug> if ( bee -> ui -> ft_in_start ) { <S2SV_EndBug> return bee -> ui -> ft_in_start ( bee , bu , file_name , file_size ) ; } else { return NULL ; } }",<S2SV_ModStart> ui -> ft_in_start && bu,bitlbee@bitlbee/701ab8129ba9ea64f569daedca9a8603abad740f,CVE-2016-10189,https://github.com/bitlbee/bitlbee/commit/701ab8129ba9ea64f569daedca9a8603abad740f,2017-03-14T14:59Z
,"CWE-000 static int ghash_update ( struct shash_desc * desc , const u8 * src , unsigned int srclen ) { struct ghash_desc_ctx * dctx = shash_desc_ctx ( desc ) ; struct ghash_ctx * ctx = crypto_shash_ctx ( desc -> tfm ) ; u8 * dst = dctx -> buffer ; <S2SV_StartBug> if ( dctx -> bytes ) { <S2SV_EndBug> int n = min ( srclen , dctx -> bytes ) ; u8 * pos = dst + ( GHASH_BLOCK_SIZE - dctx -> bytes ) ; dctx -> bytes -= n ; srclen -= n ; while ( n -- ) * pos ++ ^= * src ++ ; if ( ! dctx -> bytes ) gf128mul_4k_lle ( ( be128 * ) dst , ctx -> gf128 ) ; } while ( srclen >= GHASH_BLOCK_SIZE ) { crypto_xor ( dst , src , GHASH_BLOCK_SIZE ) ; gf128mul_4k_lle ( ( be128 * ) dst , ctx -> gf128 ) ; src += GHASH_BLOCK_SIZE ; srclen -= GHASH_BLOCK_SIZE ; } if ( srclen ) { dctx -> bytes = GHASH_BLOCK_SIZE - srclen ; while ( srclen -- ) * dst ++ ^= * src ++ ; } return 0 ; }",<S2SV_ModStart> ; if ( ! ctx -> gf128 ) return - ENOKEY ; if (,torvalds@linux/7ed47b7d142ec99ad6880bbbec51e9f12b3af74c,CVE-2011-4081,https://github.com/torvalds/linux/commit/7ed47b7d142ec99ad6880bbbec51e9f12b3af74c,2012-05-24T23:55Z
CWE-119,"CWE-119 <S2SV_StartBug> void vp9_entropy_mv_init ( ) { <S2SV_EndBug> vp9_tokens_from_tree ( mv_joint_encodings , vp9_mv_joint_tree ) ; vp9_tokens_from_tree ( mv_class_encodings , vp9_mv_class_tree ) ; vp9_tokens_from_tree ( mv_class0_encodings , vp9_mv_class0_tree ) ; vp9_tokens_from_tree ( mv_fp_encodings , vp9_mv_fp_tree ) ; }",<S2SV_ModStart> void vp9_entropy_mv_init ( void,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-20,"CWE-20 static void dissect_rpcap_packet ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * top_tree , proto_tree * parent_tree , gint offset , proto_item * top_item ) { proto_tree * tree ; proto_item * ti ; nstime_t ts ; tvbuff_t * new_tvb ; guint caplen , len , frame_no ; <S2SV_StartBug> gint reported_length_remaining ; <S2SV_EndBug> ti = proto_tree_add_item ( parent_tree , hf_packet , tvb , offset , 20 , ENC_NA ) ; tree = proto_item_add_subtree ( ti , ett_packet ) ; ts . secs = tvb_get_ntohl ( tvb , offset ) ; ts . nsecs = tvb_get_ntohl ( tvb , offset + 4 ) * 1000 ; proto_tree_add_time ( tree , hf_timestamp , tvb , offset , 8 , & ts ) ; offset += 8 ; caplen = tvb_get_ntohl ( tvb , offset ) ; ti = proto_tree_add_item ( tree , hf_caplen , tvb , offset , 4 , ENC_BIG_ENDIAN ) ; offset += 4 ; len = tvb_get_ntohl ( tvb , offset ) ; proto_tree_add_item ( tree , hf_len , tvb , offset , 4 , ENC_BIG_ENDIAN ) ; offset += 4 ; frame_no = tvb_get_ntohl ( tvb , offset ) ; proto_tree_add_item ( tree , hf_npkt , tvb , offset , 4 , ENC_BIG_ENDIAN ) ; offset += 4 ; proto_item_append_text ( ti , "",<S2SV_blank>Frame<S2SV_blank>%u"" , frame_no ) ; proto_item_append_text ( top_item , ""<S2SV_blank>Frame<S2SV_blank>%u"" , frame_no ) ; reported_length_remaining = tvb_reported_length_remaining ( tvb , offset ) ; if ( caplen > ( guint ) reported_length_remaining ) { expert_add_info ( pinfo , ti , & ei_caplen_too_big ) ; return ; } new_tvb = tvb_new_subset ( tvb , offset , caplen , len ) ; if ( decode_content && linktype != WTAP_ENCAP_UNKNOWN ) { <S2SV_StartBug> dissector_try_uint ( wtap_encap_dissector_table , linktype , new_tvb , pinfo , top_tree ) ; <S2SV_EndBug> if ( ! info_added ) { col_prepend_fence_fstr ( pinfo -> cinfo , COL_PROTOCOL , ""R|"" ) ; col_prepend_fence_fstr ( pinfo -> cinfo , COL_INFO , ""Remote<S2SV_blank>|<S2SV_blank>"" ) ; info_added = TRUE ; register_frame_end_routine ( pinfo , rpcap_frame_end ) ; } } else { if ( linktype == WTAP_ENCAP_UNKNOWN ) { proto_item_append_text ( ti , "",<S2SV_blank>Unknown<S2SV_blank>link-layer<S2SV_blank>type"" ) ; } call_dissector ( data_handle , new_tvb , pinfo , top_tree ) ; } }","<S2SV_ModStart> ; gint reported_length_remaining ; struct eth_phdr eth ; void * phdr <S2SV_ModStart> WTAP_ENCAP_UNKNOWN ) { switch ( linktype ) { case WTAP_ENCAP_ETHERNET : eth . fcs_len = - 1 ; phdr = & eth ; break ; default : phdr = NULL ; break ; } dissector_try_uint_new <S2SV_ModEnd> ( wtap_encap_dissector_table , <S2SV_ModStart> pinfo , top_tree , TRUE , phdr",wireshark@wireshark/2c13e97d656c1c0ac4d76eb9d307664aae0e0cf7,CVE-2016-5358,https://github.com/wireshark/wireshark/commit/2c13e97d656c1c0ac4d76eb9d307664aae0e0cf7,2016-08-07T16:59Z
CWE-362,"CWE-362 static int smb_send_kvec ( struct TCP_Server_Info * server , struct kvec * iov , size_t n_vec , size_t * sent ) { int rc = 0 ; int i = 0 ; struct msghdr smb_msg ; unsigned int remaining ; size_t first_vec = 0 ; struct socket * ssocket = server -> ssocket ; <S2SV_StartBug> * sent = 0 ; <S2SV_EndBug> if ( ssocket == NULL ) return - ENOTSOCK ; smb_msg . msg_name = ( struct sockaddr * ) & server -> dstaddr ; smb_msg . msg_namelen = sizeof ( struct sockaddr ) ; smb_msg . msg_control = NULL ; smb_msg . msg_controllen = 0 ; if ( server -> noblocksnd ) smb_msg . msg_flags = MSG_DONTWAIT + MSG_NOSIGNAL ; else smb_msg . msg_flags = MSG_NOSIGNAL ; remaining = 0 ; for ( i = 0 ; i < n_vec ; i ++ ) remaining += iov [ i ] . iov_len ; i = 0 ; while ( remaining ) { rc = kernel_sendmsg ( ssocket , & smb_msg , & iov [ first_vec ] , n_vec - first_vec , remaining ) ; if ( rc == - ENOSPC || rc == - EAGAIN ) { WARN_ON_ONCE ( rc == - ENOSPC ) ; i ++ ; if ( i >= 14 || ( ! server -> noblocksnd && ( i > 2 ) ) ) { cERROR ( 1 , ""sends<S2SV_blank>on<S2SV_blank>sock<S2SV_blank>%p<S2SV_blank>stuck<S2SV_blank>for<S2SV_blank>15<S2SV_blank>"" ""seconds"" , ssocket ) ; rc = - EAGAIN ; break ; } msleep ( 1 << i ) ; continue ; } if ( rc < 0 ) break ; * sent += rc ; if ( rc == remaining ) { remaining = 0 ; break ; } if ( rc > remaining ) { cERROR ( 1 , ""sent<S2SV_blank>%d<S2SV_blank>requested<S2SV_blank>%d"" , rc , remaining ) ; break ; } if ( rc == 0 ) { cERROR ( 1 , ""tcp<S2SV_blank>sent<S2SV_blank>no<S2SV_blank>data"" ) ; msleep ( 500 ) ; continue ; } remaining -= rc ; for ( i = first_vec ; i < n_vec ; i ++ ) { if ( iov [ i ] . iov_len ) { if ( rc > iov [ i ] . iov_len ) { rc -= iov [ i ] . iov_len ; iov [ i ] . iov_len = 0 ; } else { iov [ i ] . iov_base += rc ; iov [ i ] . iov_len -= rc ; first_vec = i ; break ; } } } i = 0 ; rc = 0 ; } return rc ; }",<S2SV_ModStart> sent = 0 <S2SV_ModEnd> ; smb_msg .,torvalds@linux/ea702b80e0bbb2448e201472127288beb82ca2fe,CVE-2013-3302,https://github.com/torvalds/linux/commit/ea702b80e0bbb2448e201472127288beb82ca2fe,2013-04-29T14:55Z
CWE-189,"CWE-189 Pairs * hstoreArrayToPairs ( ArrayType * a , int * npairs ) { Datum * key_datums ; bool * key_nulls ; int key_count ; Pairs * key_pairs ; int bufsiz ; int i , j ; deconstruct_array ( a , TEXTOID , - 1 , false , 'i' , & key_datums , & key_nulls , & key_count ) ; if ( key_count == 0 ) { * npairs = 0 ; return NULL ; } <S2SV_StartBug> key_pairs = palloc ( sizeof ( Pairs ) * key_count ) ; <S2SV_EndBug> for ( i = 0 , j = 0 ; i < key_count ; i ++ ) { if ( ! key_nulls [ i ] ) { key_pairs [ j ] . key = VARDATA ( key_datums [ i ] ) ; key_pairs [ j ] . keylen = VARSIZE ( key_datums [ i ] ) - VARHDRSZ ; key_pairs [ j ] . val = NULL ; key_pairs [ j ] . vallen = 0 ; key_pairs [ j ] . needfree = 0 ; key_pairs [ j ] . isnull = 1 ; j ++ ; } } * npairs = hstoreUniquePairs ( key_pairs , j , & bufsiz ) ; return key_pairs ; }","<S2SV_ModStart> NULL ; } if ( key_count > MaxAllocSize / sizeof ( Pairs ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""number<S2SV_blank>of<S2SV_blank>pairs<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , key_count , ( int ) ( MaxAllocSize / sizeof ( Pairs ) ) ) ) ) ;",postgres@postgres/31400a673325147e1205326008e32135a78b4d8a,CVE-2014-0064,https://github.com/postgres/postgres/commit/31400a673325147e1205326008e32135a78b4d8a,2014-03-31T14:58Z
CWE-189,"CWE-189 struct xt_table_info * xt_alloc_table_info ( unsigned int size ) { struct xt_table_info * info = NULL ; <S2SV_StartBug> size_t sz = sizeof ( * info ) + size ; <S2SV_EndBug> if ( ( SMP_ALIGN ( size ) >> PAGE_SHIFT ) + 2 > totalram_pages ) return NULL ; if ( sz <= ( PAGE_SIZE << PAGE_ALLOC_COSTLY_ORDER ) ) info = kmalloc ( sz , GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY ) ; if ( ! info ) { info = vmalloc ( sz ) ; if ( ! info ) return NULL ; } memset ( info , 0 , sizeof ( * info ) ) ; info -> size = size ; return info ; }",<S2SV_ModStart> ) + size ; if ( sz < sizeof ( * info ) ) return NULL,torvalds@linux/d157bd761585605b7882935ffb86286919f62ea1,CVE-2016-3135,https://github.com/torvalds/linux/commit/d157bd761585605b7882935ffb86286919f62ea1,2016-04-27T17:59Z
CWE-310,"CWE-000 static unsigned int do_encrypt ( const RIJNDAEL_context * ctx , unsigned char * bx , const unsigned char * ax ) { # ifdef USE_AMD64_ASM return _gcry_aes_amd64_encrypt_block ( ctx -> keyschenc , bx , ax , ctx -> rounds , <S2SV_StartBug> encT ) ; <S2SV_EndBug> # elif defined ( USE_ARM_ASM ) <S2SV_StartBug> return _gcry_aes_arm_encrypt_block ( ctx -> keyschenc , bx , ax , ctx -> rounds , encT ) ; <S2SV_EndBug> # else return do_encrypt_fn ( ctx , bx , ax ) ; # endif }","<S2SV_ModStart> -> rounds , enc_tables . T <S2SV_ModEnd> ) ; # <S2SV_ModStart> -> rounds , enc_tables . T <S2SV_ModEnd> ) ; #",gpg@libgcrypt/daedbbb5541cd8ecda1459d3b843ea4d92788762,CVE-2019-12904,https://github.com/gpg/libgcrypt/commit/daedbbb5541cd8ecda1459d3b843ea4d92788762,2019-06-20T00:15Z
CWE-254,"CWE-000 void impeg2d_next_code ( dec_state_t * ps_dec , UWORD32 u4_start_code_val ) { stream_t * ps_stream ; ps_stream = & ps_dec -> s_bit_stream ; impeg2d_bit_stream_flush_to_byte_boundary ( ps_stream ) ; <S2SV_StartBug> while ( ( impeg2d_bit_stream_nxt ( ps_stream , START_CODE_LEN ) != u4_start_code_val ) <S2SV_EndBug> <S2SV_StartBug> && ( ps_dec -> s_bit_stream . u4_offset <= ps_dec -> s_bit_stream . u4_max_offset ) ) <S2SV_EndBug> { if ( impeg2d_bit_stream_get ( ps_stream , 8 ) != 0 ) { } } return ; }",<S2SV_ModStart> != u4_start_code_val ) && <S2SV_ModEnd> ( ps_dec -> <S2SV_ModStart> s_bit_stream . u4_offset < <S2SV_ModEnd> ps_dec -> s_bit_stream,external@libmpeg2/ffab15eb80630dc799eb410855c93525b75233c3,CVE-2016-0824,https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3,2016-03-12T21:59Z
CWE-772,"CWE-772 generic_ret * purgekeys_2_svc ( purgekeys_arg * arg , struct svc_req * rqstp ) { static generic_ret ret ; char * prime_arg , * funcname ; <S2SV_StartBug> gss_buffer_desc client_name , service_name ; <S2SV_EndBug> OM_uint32 minor_stat ; kadm5_server_handle_t handle ; const char * errmsg = NULL ; xdr_free ( xdr_generic_ret , & ret ) ; if ( ( ret . code = new_server_handle ( arg -> api_version , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; ret . api_version = handle -> api_version ; funcname = ""kadm5_purgekeys"" ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = KADM5_FAILURE ; goto exit_func ; } if ( krb5_unparse_name ( handle -> context , arg -> princ , & prime_arg ) ) { ret . code = KADM5_BAD_PRINCIPAL ; goto exit_func ; } if ( ! cmp_gss_krb5_name ( handle , rqst2name ( rqstp ) , arg -> princ ) && ( CHANGEPW_SERVICE ( rqstp ) || ! kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , ACL_MODIFY , arg -> princ , NULL ) ) ) { ret . code = KADM5_AUTH_MODIFY ; log_unauth ( funcname , prime_arg , & client_name , & service_name , rqstp ) ; } else { ret . code = kadm5_purgekeys ( ( void * ) handle , arg -> princ , arg -> keepkvno ) ; if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ; log_done ( funcname , prime_arg , errmsg , & client_name , & service_name , rqstp ) ; if ( errmsg != NULL ) krb5_free_error_message ( handle -> context , errmsg ) ; } free ( prime_arg ) ; <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_StartBug> exit_func : <S2SV_EndBug> free_server_handle ( handle ) ; return & ret ; }",<S2SV_ModStart> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; OM_uint32 minor_stat <S2SV_ModStart> prime_arg ) ; exit_func : <S2SV_ModStart> service_name ) ; <S2SV_ModEnd> free_server_handle ( handle,krb5@krb5/83ed75feba32e46f736fcce0d96a0445f29b96c2,CVE-2015-8631,https://github.com/krb5/krb5/commit/83ed75feba32e46f736fcce0d96a0445f29b96c2,2016-02-13T02:59Z
CWE-200,"CWE-200 static void set_orig_addr ( struct msghdr * m , struct tipc_msg * msg ) { struct sockaddr_tipc * addr = ( struct sockaddr_tipc * ) m -> msg_name ; if ( addr ) { addr -> family = AF_TIPC ; <S2SV_StartBug> addr -> addrtype = TIPC_ADDR_ID ; <S2SV_EndBug> addr -> addr . id . ref = msg_origport ( msg ) ; addr -> addr . id . node = msg_orignode ( msg ) ; addr -> addr . name . domain = 0 ; addr -> scope = 0 ; m -> msg_namelen = sizeof ( struct sockaddr_tipc ) ; } }","<S2SV_ModStart> addrtype = TIPC_ADDR_ID ; memset ( & addr -> addr , 0 , sizeof ( addr -> addr ) )",torvalds@linux/60085c3d009b0df252547adb336d1ccca5ce52ec,CVE-2013-3235,https://github.com/torvalds/linux/commit/60085c3d009b0df252547adb336d1ccca5ce52ec,2013-04-22T11:41Z
CWE-125,"CWE-125 static int validate_node ( node * tree ) { int type = TYPE ( tree ) ; int nch = NCH ( tree ) ; dfa * nt_dfa ; state * dfa_state ; int pos , arc ; assert ( ISNONTERMINAL ( type ) ) ; type -= NT_OFFSET ; if ( type >= _PyParser_Grammar . g_ndfas ) { PyErr_Format ( parser_error , ""Unrecognized<S2SV_blank>node<S2SV_blank>type<S2SV_blank>%d."" , TYPE ( tree ) ) ; return 0 ; } nt_dfa = & _PyParser_Grammar . g_dfa [ type ] ; REQ ( tree , nt_dfa -> d_type ) ; dfa_state = & nt_dfa -> d_state [ nt_dfa -> d_initial ] ; for ( pos = 0 ; pos < nch ; ++ pos ) { node * ch = CHILD ( tree , pos ) ; int ch_type = TYPE ( ch ) ; <S2SV_StartBug> for ( arc = 0 ; arc < dfa_state -> s_narcs ; ++ arc ) { <S2SV_EndBug> short a_label = dfa_state -> s_arc [ arc ] . a_lbl ; assert ( a_label < _PyParser_Grammar . g_ll . ll_nlabels ) ; if ( _PyParser_Grammar . g_ll . ll_label [ a_label ] . lb_type == ch_type ) { if ( ISNONTERMINAL ( ch_type ) && ! validate_node ( ch ) ) return 0 ; dfa_state = & nt_dfa -> d_state [ dfa_state -> s_arc [ arc ] . a_arrow ] ; goto arc_found ; } } { short a_label = dfa_state -> s_arc -> a_lbl ; int next_type ; if ( ! a_label ) goto illegal_num_children ; next_type = _PyParser_Grammar . g_ll . ll_label [ a_label ] . lb_type ; if ( ISNONTERMINAL ( next_type ) ) PyErr_Format ( parser_error , ""Expected<S2SV_blank>node<S2SV_blank>type<S2SV_blank>%d,<S2SV_blank>got<S2SV_blank>%d."" , next_type , ch_type ) ; else PyErr_Format ( parser_error , ""Illegal<S2SV_blank>terminal:<S2SV_blank>expected<S2SV_blank>%s."" , _PyParser_TokenNames [ next_type ] ) ; return 0 ; } arc_found : continue ; } for ( arc = 0 ; arc < dfa_state -> s_narcs ; ++ arc ) { if ( ! dfa_state -> s_arc [ arc ] . a_lbl ) { return 1 ; } } illegal_num_children : PyErr_Format ( parser_error , ""Illegal<S2SV_blank>number<S2SV_blank>of<S2SV_blank>children<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>node."" , nt_dfa -> d_name ) ; return 0 ; }",<S2SV_ModStart> ch ) ; if ( ch_type == suite && TYPE ( tree ) == funcdef ) { ch_type = func_body_suite ; },python@typed_ast/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,CVE-2019-19275,https://github.com/python/typed_ast/commit/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,2019-11-26T15:15Z
CWE-20,"CWE-20 int main ( int argc , char * * argv ) { const char * test_name = NULL ; bool skip_sanity_suite = false ; for ( int i = 1 ; i < argc ; ++ i ) { if ( ! strcmp ( ""--help"" , argv [ i ] ) ) { print_usage ( argv [ 0 ] ) ; return 0 ; } if ( ! strcmp ( ""--insanity"" , argv [ i ] ) ) { skip_sanity_suite = true ; continue ; } if ( ! is_valid ( argv [ i ] ) ) { printf ( ""Error:<S2SV_blank>invalid<S2SV_blank>test<S2SV_blank>name.\\n"" ) ; print_usage ( argv [ 0 ] ) ; return - 1 ; } if ( test_name != NULL ) { printf ( ""Error:<S2SV_blank>invalid<S2SV_blank>arguments.\\n"" ) ; print_usage ( argv [ 0 ] ) ; return - 1 ; } test_name = argv [ i ] ; } if ( is_shell_running ( ) ) { printf ( ""Run<S2SV_blank>\'adb<S2SV_blank>shell<S2SV_blank>stop\'<S2SV_blank>before<S2SV_blank>running<S2SV_blank>%s.\\n"" , argv [ 0 ] ) ; return - 1 ; } config_t * config = config_new ( CONFIG_FILE_PATH ) ; if ( ! config ) { printf ( ""Error:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>stack<S2SV_blank>config<S2SV_blank>file.\\n"" ) ; print_usage ( argv [ 0 ] ) ; return - 1 ; } for ( const config_section_node_t * node = config_section_begin ( config ) ; node != config_section_end ( config ) ; node = config_section_next ( node ) ) { const char * name = config_section_name ( node ) ; if ( config_has_key ( config , name , ""LinkKey"" ) && string_to_bdaddr ( name , & bt_remote_bdaddr ) ) { break ; } } config_free ( config ) ; if ( bdaddr_is_empty ( & bt_remote_bdaddr ) ) { printf ( ""Error:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>find<S2SV_blank>paired<S2SV_blank>device<S2SV_blank>in<S2SV_blank>config<S2SV_blank>file.\\n"" ) ; print_usage ( argv [ 0 ] ) ; return - 1 ; } if ( ! hal_open ( callbacks_get_adapter_struct ( ) ) ) { printf ( ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>Bluetooth<S2SV_blank>HAL.\\n"" ) ; return 1 ; } if ( ! btsocket_init ( ) ) { printf ( ""Unable<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>Bluetooth<S2SV_blank>sockets.\\n"" ) ; return 2 ; } if ( ! pan_init ( ) ) { printf ( ""Unable<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>PAN.\\n"" ) ; return 3 ; } if ( ! gatt_init ( ) ) { printf ( ""Unable<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>GATT.\\n"" ) ; return 4 ; } watchdog_running = true ; pthread_create ( & watchdog_thread , NULL , watchdog_fn , NULL ) ; static const char * DEFAULT = ""\\x1b[0m"" ; static const char * GREEN = ""\\x1b[0;32m"" ; static const char * RED = ""\\x1b[0;31m"" ; if ( ! isatty ( fileno ( stdout ) ) ) { DEFAULT = GREEN = RED = """" ; } int pass = 0 ; int fail = 0 ; int case_num = 0 ; if ( ! skip_sanity_suite ) { for ( size_t i = 0 ; i < sanity_suite_size ; ++ i ) { if ( ! test_name || ! strcmp ( test_name , sanity_suite [ i ] . function_name ) ) { callbacks_init ( ) ; if ( sanity_suite [ i ] . function ( ) ) { printf ( ""[%4d]<S2SV_blank>%-64s<S2SV_blank>[%sPASS%s]\\n"" , ++ case_num , sanity_suite [ i ] . function_name , GREEN , DEFAULT ) ; ++ pass ; } else { printf ( ""[%4d]<S2SV_blank>%-64s<S2SV_blank>[%sFAIL%s]\\n"" , ++ case_num , sanity_suite [ i ] . function_name , RED , DEFAULT ) ; ++ fail ; } callbacks_cleanup ( ) ; ++ watchdog_id ; } } } if ( fail ) { printf ( ""\\n%sSanity<S2SV_blank>suite<S2SV_blank>failed<S2SV_blank>with<S2SV_blank>%d<S2SV_blank>errors.%s\\n"" , RED , fail , DEFAULT ) ; hal_close ( ) ; return 4 ; } for ( size_t i = 0 ; i < test_suite_size ; ++ i ) { if ( ! test_name || ! strcmp ( test_name , test_suite [ i ] . function_name ) ) { callbacks_init ( ) ; <S2SV_StartBug> CALL_AND_WAIT ( bt_interface -> enable ( ) , adapter_state_changed ) ; <S2SV_EndBug> if ( test_suite [ i ] . function ( ) ) { printf ( ""[%4d]<S2SV_blank>%-64s<S2SV_blank>[%sPASS%s]\\n"" , ++ case_num , test_suite [ i ] . function_name , GREEN , DEFAULT ) ; ++ pass ; } else { printf ( ""[%4d]<S2SV_blank>%-64s<S2SV_blank>[%sFAIL%s]\\n"" , ++ case_num , test_suite [ i ] . function_name , RED , DEFAULT ) ; ++ fail ; } CALL_AND_WAIT ( bt_interface -> disable ( ) , adapter_state_changed ) ; callbacks_cleanup ( ) ; ++ watchdog_id ; } } printf ( ""\\n"" ) ; if ( fail ) { printf ( ""%d/%d<S2SV_blank>tests<S2SV_blank>failed.<S2SV_blank>See<S2SV_blank>above<S2SV_blank>for<S2SV_blank>failed<S2SV_blank>test<S2SV_blank>cases.\\n"" , fail , sanity_suite_size + test_suite_size ) ; } else { printf ( ""All<S2SV_blank>tests<S2SV_blank>passed!\\n"" ) ; } watchdog_running = false ; pthread_join ( watchdog_thread , NULL ) ; hal_close ( ) ; return 0 ; }",<S2SV_ModStart> -> enable ( false,system@bt/37c88107679d36c419572732b4af6e18bb2f7dce,CVE-2016-3760,https://android.googlesource.com/platform/system/bt/+/37c88107679d36c419572732b4af6e18bb2f7dce,2016-07-11T02:00Z
CWE-119,"CWE-119 static void scsi_write_complete ( void * opaque , int ret ) { SCSIDiskReq * r = ( SCSIDiskReq * ) opaque ; SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , r -> req . dev ) ; <S2SV_StartBug> uint32_t len ; <S2SV_EndBug> uint32_t n ; if ( r -> req . aiocb != NULL ) { r -> req . aiocb = NULL ; bdrv_acct_done ( s -> bs , & r -> acct ) ; } if ( ret ) { if ( scsi_handle_rw_error ( r , - ret , SCSI_REQ_STATUS_RETRY_WRITE ) ) { return ; } } <S2SV_StartBug> n = r -> iov . iov_len / 512 ; <S2SV_EndBug> r -> sector += n ; r -> sector_count -= n ; if ( r -> sector_count == 0 ) { scsi_req_complete ( & r -> req , GOOD ) ; } else { <S2SV_StartBug> len = r -> sector_count * 512 ; <S2SV_EndBug> if ( len > SCSI_DMA_BUF_SIZE ) { len = SCSI_DMA_BUF_SIZE ; } r -> iov . iov_len = len ; <S2SV_StartBug> DPRINTF ( ""Write<S2SV_blank>complete<S2SV_blank>tag=0x%x<S2SV_blank>more=%d\\n"" , r -> req . tag , len ) ; <S2SV_EndBug> <S2SV_StartBug> scsi_req_data ( & r -> req , len ) ; <S2SV_EndBug> } }","<S2SV_ModStart> ) ; uint32_t <S2SV_ModEnd> n ; if <S2SV_ModStart> = r -> qiov . size <S2SV_ModEnd> / 512 ; <S2SV_ModStart> } else { scsi_init_iovec ( r ) <S2SV_ModEnd> ; DPRINTF ( <S2SV_ModStart> . tag , r -> qiov . size <S2SV_ModEnd> ) ; scsi_req_data <S2SV_ModStart> -> req , r -> qiov . size <S2SV_ModEnd> ) ; }",bonzini@qemu/103b40f51e4012b3b0ad20f615562a1806d7f49a,CVE-2011-3346,https://github.com/bonzini/qemu/commit/103b40f51e4012b3b0ad20f615562a1806d7f49a,2014-04-01T06:35Z
CWE-20,"CWE-20 static Image * ReadCALSImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char filename [ MagickPathExtent ] , header [ MagickPathExtent ] , message [ MagickPathExtent ] ; FILE * file ; Image * image ; ImageInfo * read_info ; int c , unique_file ; MagickBooleanType status ; register ssize_t i ; unsigned long density , direction , height , orientation , pel_path , type , width ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) memset ( header , 0 , sizeof ( header ) ) ; density = 0 ; direction = 0 ; orientation = 1 ; pel_path = 0 ; type = 1 ; width = 0 ; height = 0 ; for ( i = 0 ; i < 16 ; i ++ ) { if ( ReadBlob ( image , 128 , ( unsigned char * ) header ) != 128 ) break ; switch ( * header ) { case 'R' : case 'r' : { if ( LocaleNCompare ( header , ""rdensty:"" , 8 ) == 0 ) { ( void ) sscanf ( header + 8 , ""%lu"" , & density ) ; break ; } if ( LocaleNCompare ( header , ""rpelcnt:"" , 8 ) == 0 ) { ( void ) sscanf ( header + 8 , ""%lu,%lu"" , & width , & height ) ; break ; } if ( LocaleNCompare ( header , ""rorient:"" , 8 ) == 0 ) { ( void ) sscanf ( header + 8 , ""%lu,%lu"" , & pel_path , & direction ) ; if ( pel_path == 90 ) orientation = 5 ; else if ( pel_path == 180 ) orientation = 3 ; else if ( pel_path == 270 ) orientation = 7 ; if ( direction == 90 ) orientation ++ ; break ; } if ( LocaleNCompare ( header , ""rtype:"" , 6 ) == 0 ) { ( void ) sscanf ( header + 6 , ""%lu"" , & type ) ; break ; } break ; } } } file = ( FILE * ) NULL ; unique_file = AcquireUniqueFileResource ( filename ) ; if ( unique_file != - 1 ) file = fdopen ( unique_file , ""wb"" ) ; if ( ( unique_file == - 1 ) || ( file == ( FILE * ) NULL ) ) ThrowImageException ( FileOpenError , ""UnableToCreateTemporaryFile"" ) ; while ( ( c = ReadBlobByte ( image ) ) != EOF ) <S2SV_StartBug> ( void ) fputc ( c , file ) ; <S2SV_EndBug> ( void ) fclose ( file ) ; ( void ) CloseBlob ( image ) ; image = DestroyImage ( image ) ; read_info = CloneImageInfo ( image_info ) ; SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; ( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , ""group4:%s"" , filename ) ; ( void ) FormatLocaleString ( message , MagickPathExtent , ""%lux%lu"" , width , height ) ; ( void ) CloneString ( & read_info -> size , message ) ; ( void ) FormatLocaleString ( message , MagickPathExtent , ""%lu"" , density ) ; ( void ) CloneString ( & read_info -> density , message ) ; read_info -> orientation = ( OrientationType ) orientation ; image = ReadImage ( read_info , exception ) ; if ( image != ( Image * ) NULL ) { ( void ) CopyMagickString ( image -> filename , image_info -> filename , MagickPathExtent ) ; ( void ) CopyMagickString ( image -> magick_filename , image_info -> filename , MagickPathExtent ) ; ( void ) CopyMagickString ( image -> magick , ""CALS"" , MagickPathExtent ) ; } read_info = DestroyImageInfo ( read_info ) ; ( void ) RelinquishUniqueFileResource ( filename ) ; return ( image ) ; }","<S2SV_ModStart> != EOF ) if ( <S2SV_ModEnd> fputc ( c <S2SV_ModStart> , file ) != c ) break",ImageMagick@ImageMagick/6b6bff054d569a77973f2140c0e86366e6168a6c,CVE-2018-16643,https://github.com/ImageMagick/ImageMagick/commit/6b6bff054d569a77973f2140c0e86366e6168a6c,2018-09-06T22:29Z
CWE-125,"CWE-125 static void sycc444_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; <S2SV_StartBug> unsigned int maxw , maxh , max , i ; <S2SV_EndBug> int offset , upb ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; <S2SV_StartBug> maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; <S2SV_EndBug> max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; <S2SV_StartBug> d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; <S2SV_EndBug> <S2SV_StartBug> d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; <S2SV_EndBug> <S2SV_StartBug> d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; <S2SV_EndBug> if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < max ; ++ i ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ cb ; ++ cr ; ++ r ; ++ g ; ++ b ; } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; <S2SV_StartBug> return ; <S2SV_EndBug> fails : <S2SV_StartBug> if ( r ) free ( r ) ; <S2SV_EndBug> if ( g ) free ( g ) ; if ( b ) free ( b ) ; }","<S2SV_ModStart> * cr ; size_t <S2SV_ModEnd> maxw , maxh <S2SV_ModStart> maxw = ( size_t <S2SV_ModEnd> ) img -> <S2SV_ModStart> maxh = ( size_t <S2SV_ModEnd> ) img -> <S2SV_ModStart> int ) * <S2SV_ModEnd> max ) ; <S2SV_ModStart> int ) * <S2SV_ModEnd> max ) ; <S2SV_ModStart> int ) * <S2SV_ModEnd> max ) ; <S2SV_ModStart> = d2 ; img -> color_space = OPJ_CLRSPC_SRGB ; <S2SV_ModStart> ; fails : free ( r ) ; free ( g ) ; <S2SV_ModEnd> free ( b",uclouvain@openjpeg/15f081c89650dccee4aa4ae66f614c3fdb268767,CVE-2016-3183,https://github.com/uclouvain/openjpeg/commit/15f081c89650dccee4aa4ae66f614c3fdb268767,2017-02-03T16:59Z
CWE-125,"CWE-125 static struct phy * serdes_simple_xlate ( struct device * dev , struct of_phandle_args * args ) { struct serdes_ctrl * ctrl = dev_get_drvdata ( dev ) ; unsigned int port , idx , i ; if ( args -> args_count != 2 ) return ERR_PTR ( - EINVAL ) ; port = args -> args [ 0 ] ; idx = args -> args [ 1 ] ; <S2SV_StartBug> for ( i = 0 ; i <= SERDES_MAX ; i ++ ) { <S2SV_EndBug> struct serdes_macro * macro = phy_get_drvdata ( ctrl -> phys [ i ] ) ; if ( idx != macro -> idx ) continue ; if ( idx != SERDES6G ( 0 ) && macro -> port >= 0 ) return ERR_PTR ( - EBUSY ) ; macro -> port = port ; return ctrl -> phys [ i ] ; } return ERR_PTR ( - ENODEV ) ; }",<S2SV_ModStart> 0 ; i < <S2SV_ModEnd> SERDES_MAX ; i,torvalds@linux/6acb47d1a318e5b3b7115354ebc4ea060c59d3a1,CVE-2018-20854,https://github.com/torvalds/linux/commit/6acb47d1a318e5b3b7115354ebc4ea060c59d3a1,2019-07-26T05:15Z
CWE-264,"CWE-264 void perf_event_disable ( struct perf_event * event ) { <S2SV_StartBug> struct perf_event_context * ctx = event -> ctx ; <S2SV_EndBug> struct task_struct * task = ctx -> task ; if ( ! task ) { cpu_function_call ( event -> cpu , __perf_event_disable , event ) ; return ; } retry : if ( ! task_function_call ( task , __perf_event_disable , event ) ) return ; raw_spin_lock_irq ( & ctx -> lock ) ; if ( event -> state == PERF_EVENT_STATE_ACTIVE ) { raw_spin_unlock_irq ( & ctx -> lock ) ; task = ctx -> task ; goto retry ; } if ( event -> state == PERF_EVENT_STATE_INACTIVE ) { update_group_times ( event ) ; <S2SV_StartBug> event -> state = PERF_EVENT_STATE_OFF ; <S2SV_EndBug> } raw_spin_unlock_irq ( & ctx -> lock ) ; }","<S2SV_ModStart> perf_event_context * ctx ; ctx = perf_event_ctx_lock <S2SV_ModEnd> ( event ) <S2SV_ModStart> event ) ; _perf_event_disable ( event ) ; perf_event_ctx_unlock ( event , ctx <S2SV_ModEnd> ) ; }",torvalds@linux/f63a8daa5812afef4f06c962351687e1ff9ccb2b,CVE-2016-6787,https://github.com/torvalds/linux/commit/f63a8daa5812afef4f06c962351687e1ff9ccb2b,2016-12-28T07:59Z
CWE-20,"CWE-20 void kvm_lapic_sync_from_vapic ( struct kvm_vcpu * vcpu ) { <S2SV_StartBug> u32 data ; <S2SV_EndBug> void * vapic ; if ( test_bit ( KVM_APIC_PV_EOI_PENDING , & vcpu -> arch . apic_attention ) ) apic_sync_pv_eoi_from_guest ( vcpu , vcpu -> arch . apic ) ; if ( ! test_bit ( KVM_APIC_CHECK_VAPIC , & vcpu -> arch . apic_attention ) ) return ; <S2SV_StartBug> vapic = kmap_atomic ( vcpu -> arch . apic -> vapic_page ) ; <S2SV_EndBug> data = * ( u32 * ) ( vapic + offset_in_page ( vcpu -> arch . apic -> vapic_addr ) ) ; kunmap_atomic ( vapic ) ; apic_set_tpr ( vcpu -> arch . apic , data & 0xff ) ; }","<S2SV_ModStart> { u32 data <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) return ; kvm_read_guest_cached ( vcpu -> kvm , & <S2SV_ModEnd> vcpu -> arch <S2SV_ModStart> . apic -> vapic_cache , & data , sizeof ( u32 ) <S2SV_ModEnd> ) ; apic_set_tpr",torvalds@linux/fda4e2e85589191b123d31cdc21fd33ee70f50fd,CVE-2013-6368,https://github.com/torvalds/linux/commit/fda4e2e85589191b123d31cdc21fd33ee70f50fd,2013-12-14T18:08Z
CWE-787,"CWE-787 void pdf_load_pages_kids ( FILE * fp , pdf_t * pdf ) { int i , id , dummy ; char * buf , * c ; long start , sz ; start = ftell ( fp ) ; for ( i = 0 ; i < pdf -> n_xrefs ; i ++ ) { if ( pdf -> xrefs [ i ] . version && ( pdf -> xrefs [ i ] . end != 0 ) ) { fseek ( fp , pdf -> xrefs [ i ] . start , SEEK_SET ) ; while ( SAFE_F ( fp , ( fgetc ( fp ) != 't' ) ) ) ; sz = pdf -> xrefs [ i ] . end - ftell ( fp ) ; <S2SV_StartBug> buf = malloc ( sz + 1 ) ; <S2SV_EndBug> SAFE_E ( fread ( buf , 1 , sz , fp ) , sz , ""Failed<S2SV_blank>to<S2SV_blank>load<S2SV_blank>/Root.\\n"" ) ; buf [ sz ] = '\\0' ; if ( ! ( c = strstr ( buf , ""/Root"" ) ) ) { free ( buf ) ; continue ; } id = atoi ( c + strlen ( ""/Root"" ) + 1 ) ; free ( buf ) ; buf = get_object ( fp , id , & pdf -> xrefs [ i ] , NULL , & dummy ) ; if ( ! buf || ! ( c = strstr ( buf , ""/Pages"" ) ) ) { free ( buf ) ; continue ; } id = atoi ( c + strlen ( ""/Pages"" ) + 1 ) ; load_kids ( fp , id , & pdf -> xrefs [ i ] ) ; free ( buf ) ; } } fseek ( fp , start , SEEK_SET ) ; }",<S2SV_ModStart> ; buf = safe_calloc <S2SV_ModEnd> ( sz +,enferex@pdfresurrect/0c4120fffa3dffe97b95c486a120eded82afe8a6,CVE-2019-14934,https://github.com/enferex/pdfresurrect/commit/0c4120fffa3dffe97b95c486a120eded82afe8a6,2019-08-11T22:15Z
CWE-59,"CWE-000 static int mount_entry_on_absolute_rootfs ( struct mntent * mntent , const struct lxc_rootfs * rootfs , const char * lxc_name ) { char * aux ; char path [ MAXPATHLEN ] ; int r , ret = 0 , offset ; const char * lxcpath ; lxcpath = lxc_global_config_value ( ""lxc.lxcpath"" ) ; if ( ! lxcpath ) { ERROR ( ""Out<S2SV_blank>of<S2SV_blank>memory"" ) ; return - 1 ; } r = snprintf ( path , MAXPATHLEN , ""%s/%s/rootfs"" , lxcpath , lxc_name ) ; if ( r < 0 || r >= MAXPATHLEN ) goto skipvarlib ; aux = strstr ( mntent -> mnt_dir , path ) ; if ( aux ) { offset = strlen ( path ) ; goto skipabs ; } skipvarlib : aux = strstr ( mntent -> mnt_dir , rootfs -> path ) ; if ( ! aux ) { WARN ( ""ignoring<S2SV_blank>mount<S2SV_blank>point<S2SV_blank>\'%s\'"" , mntent -> mnt_dir ) ; return ret ; } offset = strlen ( rootfs -> path ) ; skipabs : r = snprintf ( path , MAXPATHLEN , ""%s/%s"" , rootfs -> mount , aux + offset ) ; if ( r < 0 || r >= MAXPATHLEN ) { WARN ( ""pathnme<S2SV_blank>too<S2SV_blank>long<S2SV_blank>for<S2SV_blank>\'%s\'"" , mntent -> mnt_dir ) ; return - 1 ; } <S2SV_StartBug> return mount_entry_on_generic ( mntent , path ) ; <S2SV_EndBug> }","<S2SV_ModStart> mntent , path , rootfs -> mount",lxc@lxc/592fd47a6245508b79fe6ac819fe6d3b2c1289be,CVE-2015-1335,https://github.com/lxc/lxc/commit/592fd47a6245508b79fe6ac819fe6d3b2c1289be,2015-10-01T20:59Z
CWE-20,"CWE-20 WORD32 ih264d_read_mmco_commands ( struct _DecStruct * ps_dec ) { dec_bit_stream_t * ps_bitstrm = ps_dec -> ps_bitstrm ; <S2SV_StartBug> dpb_commands_t * ps_dpb_cmds = ps_dec -> ps_dpb_cmds ; <S2SV_EndBug> dec_slice_params_t * ps_slice = ps_dec -> ps_cur_slice ; WORD32 j ; UWORD8 u1_buf_mode ; struct MMCParams * ps_mmc_params ; UWORD32 * pu4_bitstrm_buf = ps_dec -> ps_bitstrm -> pu4_buffer ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; UWORD32 u4_bit_ofst = ps_dec -> ps_bitstrm -> u4_ofst ; ps_slice -> u1_mmco_equalto5 = 0 ; { if ( ps_dec -> u1_nal_unit_type == IDR_SLICE_NAL ) { ps_slice -> u1_no_output_of_prior_pics_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>no_output_of_prior_pics_flag"" , ps_slice -> u1_no_output_of_prior_pics_flag ) ; ps_slice -> u1_long_term_reference_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>long_term_reference_flag"" , ps_slice -> u1_long_term_reference_flag ) ; ps_dpb_cmds -> u1_idr_pic = 1 ; ps_dpb_cmds -> u1_no_output_of_prior_pics_flag = ps_slice -> u1_no_output_of_prior_pics_flag ; ps_dpb_cmds -> u1_long_term_reference_flag = ps_slice -> u1_long_term_reference_flag ; } else { u1_buf_mode = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>adaptive_ref_pic_buffering_flag"" , u1_buf_mode ) ; ps_dpb_cmds -> u1_buf_mode = u1_buf_mode ; j = 0 ; if ( u1_buf_mode == 1 ) { UWORD32 u4_mmco ; UWORD32 u4_diff_pic_num ; UWORD32 u4_lt_idx , u4_max_lt_idx ; u4_mmco = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; while ( u4_mmco != END_OF_MMCO ) { if ( j >= MAX_REF_BUFS ) { # ifdef __ANDROID__ ALOGE ( ""b/25818142"" ) ; android_errorWriteLog ( 0x534e4554 , ""25818142"" ) ; # endif ps_dpb_cmds -> u1_num_of_commands = 0 ; return - 1 ; } ps_mmc_params = & ps_dpb_cmds -> as_mmc_params [ j ] ; ps_mmc_params -> u4_mmco = u4_mmco ; switch ( u4_mmco ) { case MARK_ST_PICNUM_AS_NONREF : u4_diff_pic_num = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; ps_mmc_params -> u4_diff_pic_num = u4_diff_pic_num ; break ; case MARK_LT_INDEX_AS_NONREF : u4_lt_idx = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; ps_mmc_params -> u4_lt_idx = u4_lt_idx ; break ; case MARK_ST_PICNUM_AS_LT_INDEX : u4_diff_pic_num = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; ps_mmc_params -> u4_diff_pic_num = u4_diff_pic_num ; u4_lt_idx = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; ps_mmc_params -> u4_lt_idx = u4_lt_idx ; break ; case SET_MAX_LT_INDEX : { u4_max_lt_idx = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; ps_mmc_params -> u4_max_lt_idx_plus1 = u4_max_lt_idx ; break ; } case RESET_REF_PICTURES : { ps_slice -> u1_mmco_equalto5 = 1 ; break ; } case SET_LT_INDEX : u4_lt_idx = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; ps_mmc_params -> u4_lt_idx = u4_lt_idx ; break ; default : break ; } u4_mmco = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; j ++ ; } ps_dpb_cmds -> u1_num_of_commands = j ; } } ps_dpb_cmds -> u1_dpb_commands_read = 1 ; ps_dpb_cmds -> u1_dpb_commands_read_slc = 1 ; } u4_bit_ofst = ps_dec -> ps_bitstrm -> u4_ofst - u4_bit_ofst ; return u4_bit_ofst ; }",<S2SV_ModStart> * ps_dpb_cmds = & ( ps_dec -> s_dpb_cmds_scratch ) <S2SV_ModEnd> ; dec_slice_params_t *,external@libavc/6c327afb263837bc90760c55c6605b26161a4eb9,CVE-2017-13186,https://android.googlesource.com/platform/external/libavc/+/6c327afb263837bc90760c55c6605b26161a4eb9,2018-01-12T23:29Z
,"CWE-000 int perf_config ( config_fn_t fn , void * data ) { <S2SV_StartBug> int ret = 0 , found = 0 ; <S2SV_EndBug> char * repo_config = NULL ; const char * home = NULL ; if ( config_exclusive_filename ) return perf_config_from_file ( fn , config_exclusive_filename , data ) ; if ( perf_config_system ( ) && ! access ( perf_etc_perfconfig ( ) , R_OK ) ) { ret += perf_config_from_file ( fn , perf_etc_perfconfig ( ) , data ) ; found += 1 ; } home = getenv ( ""HOME"" ) ; if ( perf_config_global ( ) && home ) { char * user_config = strdup ( mkpath ( ""%s/.perfconfig"" , home ) ) ; if ( ! access ( user_config , R_OK ) ) { ret += perf_config_from_file ( fn , user_config , data ) ; found += 1 ; } free ( user_config ) ; } <S2SV_StartBug> repo_config = perf_pathdup ( ""config"" ) ; <S2SV_EndBug> if ( ! access ( repo_config , R_OK ) ) { ret += perf_config_from_file ( fn , repo_config , data ) ; found += 1 ; } free ( repo_config ) ; if ( found == 0 ) return - 1 ; return ret ; }",<S2SV_ModStart> found = 0 <S2SV_ModEnd> ; const char <S2SV_ModStart> ) ; } <S2SV_ModEnd> if ( found,torvalds@linux/aba8d056078e47350d85b06a9cabd5afcc4b72ea,CVE-2011-2905,https://github.com/torvalds/linux/commit/aba8d056078e47350d85b06a9cabd5afcc4b72ea,2013-03-01T12:37Z
CWE-269,"CWE-000 int mwifiex_cmd_append_vsie_tlv ( struct mwifiex_private * priv , u16 vsie_mask , u8 * * buffer ) { int id , ret_len = 0 ; struct mwifiex_ie_types_vendor_param_set * vs_param_set ; if ( ! buffer ) return 0 ; if ( ! ( * buffer ) ) return 0 ; for ( id = 0 ; id < MWIFIEX_MAX_VSIE_NUM ; id ++ ) { if ( priv -> vs_ie [ id ] . mask & vsie_mask ) { vs_param_set = ( struct mwifiex_ie_types_vendor_param_set * ) * buffer ; vs_param_set -> header . type = cpu_to_le16 ( TLV_TYPE_PASSTHROUGH ) ; vs_param_set -> header . len = cpu_to_le16 ( ( ( ( u16 ) priv -> vs_ie [ id ] . ie [ 1 ] ) & 0x00FF ) + 2 ) ; <S2SV_StartBug> memcpy ( vs_param_set -> ie , priv -> vs_ie [ id ] . ie , <S2SV_EndBug> le16_to_cpu ( vs_param_set -> header . len ) ) ; * buffer += le16_to_cpu ( vs_param_set -> header . len ) + sizeof ( struct mwifiex_ie_types_header ) ; ret_len += le16_to_cpu ( vs_param_set -> header . len ) + sizeof ( struct mwifiex_ie_types_header ) ; } } return ret_len ; }","<S2SV_ModStart> 2 ) ; if ( le16_to_cpu ( vs_param_set -> header . len ) > MWIFIEX_MAX_VSIE_LEN ) { mwifiex_dbg ( priv -> adapter , ERROR , ""Invalid<S2SV_blank>param<S2SV_blank>length!\\n"" ) ; break ; }",torvalds@linux/b70261a288ea4d2f4ac7cd04be08a9f0f2de4f4d,CVE-2020-12653,https://github.com/torvalds/linux/commit/b70261a288ea4d2f4ac7cd04be08a9f0f2de4f4d,2020-05-05T06:15Z
CWE-190,"CWE-190 <S2SV_StartBug> int mongo_env_write_socket ( mongo * conn , const void * buf , int len ) { <S2SV_EndBug> const char * cbuf = buf ; # ifdef __APPLE__ int flags = 0 ; # else int flags = MSG_NOSIGNAL ; # endif while ( len ) { <S2SV_StartBug> int sent = send ( conn -> sock , cbuf , len , flags ) ; <S2SV_EndBug> if ( sent == - 1 ) { if ( errno == EPIPE ) conn -> connected = 0 ; __mongo_set_error ( conn , MONGO_IO_ERROR , strerror ( errno ) , errno ) ; return MONGO_ERROR ; } cbuf += sent ; len -= sent ; } return MONGO_OK ; }","<S2SV_ModStart> * buf , size_t <S2SV_ModEnd> len ) { <S2SV_ModStart> len ) { size_t <S2SV_ModEnd> sent = send",10gen-archive@mongo-c-driver-legacy/1a1f5e26a4309480d88598913f9eebf9e9cba8ca,CVE-2020-12135,https://github.com/10gen-archive/mongo-c-driver-legacy/commit/1a1f5e26a4309480d88598913f9eebf9e9cba8ca,2020-04-24T01:15Z
CWE-200,"CWE-200 IMPEG2D_ERROR_CODES_T impeg2d_dec_seq_hdr ( dec_state_t * ps_dec ) { stream_t * ps_stream ; ps_stream = & ps_dec -> s_bit_stream ; UWORD16 u2_height ; UWORD16 u2_width ; if ( impeg2d_bit_stream_nxt ( ps_stream , START_CODE_LEN ) != SEQUENCE_HEADER_CODE ) { impeg2d_bit_stream_flush ( ps_stream , START_CODE_LEN ) ; return IMPEG2D_FRM_HDR_START_CODE_NOT_FOUND ; } impeg2d_bit_stream_flush ( ps_stream , START_CODE_LEN ) ; u2_width = impeg2d_bit_stream_get ( ps_stream , 12 ) ; u2_height = impeg2d_bit_stream_get ( ps_stream , 12 ) ; if ( ( u2_width != ps_dec -> u2_horizontal_size ) || ( u2_height != ps_dec -> u2_vertical_size ) ) { if ( 0 == ps_dec -> u2_header_done ) { ps_dec -> u2_horizontal_size = u2_width ; ps_dec -> u2_vertical_size = u2_height ; if ( 0 == ps_dec -> u4_frm_buf_stride ) { ps_dec -> u4_frm_buf_stride = ( UWORD32 ) ALIGN16 ( u2_width ) ; } } else { if ( ( u2_width > ps_dec -> u2_create_max_width ) || ( u2_height > ps_dec -> u2_create_max_height ) ) { IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_UNSUPPORTED_DIMENSIONS ; ps_dec -> u2_reinit_max_height = u2_height ; ps_dec -> u2_reinit_max_width = u2_width ; return e_error ; } else { return ( IMPEG2D_ERROR_CODES_T ) IVD_RES_CHANGED ; } } } if ( ( ps_dec -> u2_horizontal_size > ps_dec -> u2_create_max_width ) || ( ps_dec -> u2_vertical_size > ps_dec -> u2_create_max_height ) ) { IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_UNSUPPORTED_DIMENSIONS ; return SET_IVD_FATAL_ERROR ( e_error ) ; } ps_dec -> u2_aspect_ratio_info = impeg2d_bit_stream_get ( ps_stream , 4 ) ; <S2SV_StartBug> ps_dec -> u2_frame_rate_code = impeg2d_bit_stream_get ( ps_stream , 4 ) ; <S2SV_EndBug> impeg2d_bit_stream_flush ( ps_stream , 18 ) ; GET_MARKER_BIT ( ps_dec , ps_stream ) ; impeg2d_bit_stream_flush ( ps_stream , 11 ) ; if ( impeg2d_bit_stream_get_bit ( ps_stream ) == 1 ) { UWORD16 i ; for ( i = 0 ; i < NUM_PELS_IN_BLOCK ; i ++ ) { ps_dec -> au1_intra_quant_matrix [ gau1_impeg2_inv_scan_zig_zag [ i ] ] = ( UWORD8 ) impeg2d_bit_stream_get ( ps_stream , 8 ) ; } } else { memcpy ( ps_dec -> au1_intra_quant_matrix , gau1_impeg2_intra_quant_matrix_default , NUM_PELS_IN_BLOCK ) ; } if ( impeg2d_bit_stream_get_bit ( ps_stream ) == 1 ) { UWORD16 i ; for ( i = 0 ; i < NUM_PELS_IN_BLOCK ; i ++ ) { ps_dec -> au1_inter_quant_matrix [ gau1_impeg2_inv_scan_zig_zag [ i ] ] = ( UWORD8 ) impeg2d_bit_stream_get ( ps_stream , 8 ) ; } } else { memcpy ( ps_dec -> au1_inter_quant_matrix , gau1_impeg2_inter_quant_matrix_default , NUM_PELS_IN_BLOCK ) ; } impeg2d_next_start_code ( ps_dec ) ; return ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE ; }",<S2SV_ModStart> 4 ) ; if ( ps_dec -> u2_frame_rate_code > MPEG2_MAX_FRAME_RATE_CODE ) { return IMPEG2D_FRM_HDR_DECODE_ERR ; },external@libmpeg2/f301cff2c1ddd880d9a2c77b22602a137519867b,CVE-2017-0556,https://android.googlesource.com/platform/external/libmpeg2/+/f301cff2c1ddd880d9a2c77b22602a137519867b,2017-04-07T22:59Z
CWE-119,"CWE-119 static inline void header_put_be_3byte ( SF_PRIVATE * psf , int x ) <S2SV_StartBug> { if ( psf -> headindex < SIGNED_SIZEOF ( psf -> header ) - 3 ) <S2SV_EndBug> <S2SV_StartBug> { psf -> header [ psf -> headindex ++ ] = ( x >> 16 ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> header [ psf -> headindex ++ ] = ( x >> 8 ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> header [ psf -> headindex ++ ] = x ; <S2SV_EndBug> <S2SV_StartBug> } ; <S2SV_EndBug> }",<S2SV_ModStart> x ) { <S2SV_ModEnd> psf -> header <S2SV_ModStart> psf -> header . ptr [ <S2SV_ModEnd> psf -> header <S2SV_ModStart> psf -> header . indx <S2SV_ModEnd> ++ ] = <S2SV_ModStart> psf -> header . ptr <S2SV_ModStart> [ psf -> header . indx <S2SV_ModEnd> ++ ] = <S2SV_ModStart> psf -> header . ptr <S2SV_ModStart> [ psf -> header . indx <S2SV_ModEnd> ++ ] = <S2SV_ModStart> x ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>,erikd@libsndfile/708e996c87c5fae77b104ccfeb8f6db784c32074,CVE-2017-7586,https://github.com/erikd/libsndfile/commit/708e996c87c5fae77b104ccfeb8f6db784c32074,2017-04-07T20:59Z
CWE-401,"CWE-000 struct clock_source * dce110_clock_source_create ( struct dc_context * ctx , struct dc_bios * bios , enum clock_source_id id , const struct dce110_clk_src_regs * regs , bool dp_clk_src ) { struct dce110_clk_src * clk_src = kzalloc ( sizeof ( struct dce110_clk_src ) , GFP_KERNEL ) ; if ( ! clk_src ) return NULL ; if ( dce110_clk_src_construct ( clk_src , ctx , bios , id , regs , & cs_shift , & cs_mask ) ) { clk_src -> base . dp_clk_src = dp_clk_src ; return & clk_src -> base ; } <S2SV_StartBug> BREAK_TO_DEBUGGER ( ) ; <S2SV_EndBug> return NULL ; }",<S2SV_ModStart> base ; } kfree ( clk_src ) ;,torvalds@linux/055e547478a11a6360c7ce05e2afc3e366968a12,CVE-2019-19083,https://github.com/torvalds/linux/commit/055e547478a11a6360c7ce05e2afc3e366968a12,2019-11-18T06:15Z
CWE-200,"CWE-200 static void usage ( const char * prog ) { fprintf ( stderr , ""Usage:<S2SV_blank>%s<S2SV_blank>[OPTION...]\\n"" , prog ) ; fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-f,<S2SV_blank>--use-file=FILE<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Use<S2SV_blank>the<S2SV_blank>specified<S2SV_blank>configuration<S2SV_blank>file\\n"" ) ; # if defined _WITH_VRRP_ && defined _WITH_LVS_ fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-P,<S2SV_blank>--vrrp<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Only<S2SV_blank>run<S2SV_blank>with<S2SV_blank>VRRP<S2SV_blank>subsystem\\n"" ) ; fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-C,<S2SV_blank>--check<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Only<S2SV_blank>run<S2SV_blank>with<S2SV_blank>Health-checker<S2SV_blank>subsystem\\n"" ) ; # endif # ifdef _WITH_BFD_ fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-B,<S2SV_blank>--no_bfd<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Don\'t<S2SV_blank>run<S2SV_blank>BFD<S2SV_blank>subsystem\\n"" ) ; # endif fprintf ( stderr , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>--all<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Force<S2SV_blank>all<S2SV_blank>child<S2SV_blank>processes<S2SV_blank>to<S2SV_blank>run,<S2SV_blank>even<S2SV_blank>if<S2SV_blank>have<S2SV_blank>no<S2SV_blank>configuration\\n"" ) ; fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-l,<S2SV_blank>--log-console<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Log<S2SV_blank>messages<S2SV_blank>to<S2SV_blank>local<S2SV_blank>console\\n"" ) ; fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-D,<S2SV_blank>--log-detail<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Detailed<S2SV_blank>log<S2SV_blank>messages\\n"" ) ; fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-S,<S2SV_blank>--log-facility=[0-7]<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Set<S2SV_blank>syslog<S2SV_blank>facility<S2SV_blank>to<S2SV_blank>LOG_LOCAL[0-7]\\n"" ) ; fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-g,<S2SV_blank>--log-file=FILE<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Also<S2SV_blank>log<S2SV_blank>to<S2SV_blank>FILE<S2SV_blank>(default<S2SV_blank>/tmp/keepalived.log)\\n"" ) ; fprintf ( stderr , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>--flush-log-file<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flush<S2SV_blank>log<S2SV_blank>file<S2SV_blank>on<S2SV_blank>write\\n"" ) ; fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-G,<S2SV_blank>--no-syslog<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Don\'t<S2SV_blank>log<S2SV_blank>via<S2SV_blank>syslog\\n"" ) ; <S2SV_StartBug> # ifdef _WITH_VRRP_ <S2SV_EndBug> fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-X,<S2SV_blank>--release-vips<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Drop<S2SV_blank>VIP<S2SV_blank>on<S2SV_blank>transition<S2SV_blank>from<S2SV_blank>signal.\\n"" ) ; fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-V,<S2SV_blank>--dont-release-vrrp<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Don\'t<S2SV_blank>remove<S2SV_blank>VRRP<S2SV_blank>VIPs<S2SV_blank>and<S2SV_blank>VROUTEs<S2SV_blank>on<S2SV_blank>daemon<S2SV_blank>stop\\n"" ) ; # endif # ifdef _WITH_LVS_ fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-I,<S2SV_blank>--dont-release-ipvs<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Don\'t<S2SV_blank>remove<S2SV_blank>IPVS<S2SV_blank>topology<S2SV_blank>on<S2SV_blank>daemon<S2SV_blank>stop\\n"" ) ; # endif fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-R,<S2SV_blank>--dont-respawn<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Don\'t<S2SV_blank>respawn<S2SV_blank>child<S2SV_blank>processes\\n"" ) ; fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-n,<S2SV_blank>--dont-fork<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Don\'t<S2SV_blank>fork<S2SV_blank>the<S2SV_blank>daemon<S2SV_blank>process\\n"" ) ; fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-d,<S2SV_blank>--dump-conf<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Dump<S2SV_blank>the<S2SV_blank>configuration<S2SV_blank>data\\n"" ) ; fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-p,<S2SV_blank>--pid=FILE<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Use<S2SV_blank>specified<S2SV_blank>pidfile<S2SV_blank>for<S2SV_blank>parent<S2SV_blank>process\\n"" ) ; # ifdef _WITH_VRRP_ fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-r,<S2SV_blank>--vrrp_pid=FILE<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Use<S2SV_blank>specified<S2SV_blank>pidfile<S2SV_blank>for<S2SV_blank>VRRP<S2SV_blank>child<S2SV_blank>process\\n"" ) ; # endif # ifdef _WITH_LVS_ fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-c,<S2SV_blank>--checkers_pid=FILE<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Use<S2SV_blank>specified<S2SV_blank>pidfile<S2SV_blank>for<S2SV_blank>checkers<S2SV_blank>child<S2SV_blank>process\\n"" ) ; fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-a,<S2SV_blank>--address-monitoring<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Report<S2SV_blank>all<S2SV_blank>address<S2SV_blank>additions/deletions<S2SV_blank>notified<S2SV_blank>via<S2SV_blank>netlink\\n"" ) ; # endif # ifdef _WITH_BFD_ fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-b,<S2SV_blank>--bfd_pid=FILE<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Use<S2SV_blank>specified<S2SV_blank>pidfile<S2SV_blank>for<S2SV_blank>BFD<S2SV_blank>child<S2SV_blank>process\\n"" ) ; # endif # ifdef _WITH_SNMP_ fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-x,<S2SV_blank>--snmp<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Enable<S2SV_blank>SNMP<S2SV_blank>subsystem\\n"" ) ; fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-A,<S2SV_blank>--snmp-agent-socket=FILE<S2SV_blank>Use<S2SV_blank>the<S2SV_blank>specified<S2SV_blank>socket<S2SV_blank>for<S2SV_blank>master<S2SV_blank>agent\\n"" ) ; # endif # if HAVE_DECL_CLONE_NEWNET fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-s,<S2SV_blank>--namespace=NAME<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Run<S2SV_blank>in<S2SV_blank>network<S2SV_blank>namespace<S2SV_blank>NAME<S2SV_blank>(overrides<S2SV_blank>config)\\n"" ) ; # endif fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-m,<S2SV_blank>--core-dump<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Produce<S2SV_blank>core<S2SV_blank>dump<S2SV_blank>if<S2SV_blank>terminate<S2SV_blank>abnormally\\n"" ) ; fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-M,<S2SV_blank>--core-dump-pattern=PATN<S2SV_blank>Also<S2SV_blank>set<S2SV_blank>/proc/sys/kernel/core_pattern<S2SV_blank>to<S2SV_blank>PATN<S2SV_blank>(default<S2SV_blank>\'core\')\\n"" ) ; # ifdef _MEM_CHECK_LOG_ fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-L,<S2SV_blank>--mem-check-log<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Log<S2SV_blank>malloc/frees<S2SV_blank>to<S2SV_blank>syslog\\n"" ) ; # endif fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-i,<S2SV_blank>--config-id<S2SV_blank>id<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Skip<S2SV_blank>any<S2SV_blank>configuration<S2SV_blank>lines<S2SV_blank>beginning<S2SV_blank>\'@\'<S2SV_blank>that<S2SV_blank>don\'t<S2SV_blank>match<S2SV_blank>id\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>or<S2SV_blank>any<S2SV_blank>lines<S2SV_blank>beginning<S2SV_blank>@^<S2SV_blank>that<S2SV_blank>do<S2SV_blank>match.\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>The<S2SV_blank>config-id<S2SV_blank>defaults<S2SV_blank>to<S2SV_blank>the<S2SV_blank>node<S2SV_blank>name<S2SV_blank>if<S2SV_blank>option<S2SV_blank>not<S2SV_blank>used\\n"" ) ; fprintf ( stderr , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>--signum=SIGFUNC<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Return<S2SV_blank>signal<S2SV_blank>number<S2SV_blank>for<S2SV_blank>STOP,<S2SV_blank>RELOAD,<S2SV_blank>DATA,<S2SV_blank>STATS"" # ifdef _WITH_JSON_ "",<S2SV_blank>JSON"" # endif ""\\n"" ) ; fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-t,<S2SV_blank>--config-test[=LOG_FILE]<S2SV_blank>Check<S2SV_blank>the<S2SV_blank>configuration<S2SV_blank>for<S2SV_blank>obvious<S2SV_blank>errors,<S2SV_blank>output<S2SV_blank>to\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>stderr<S2SV_blank>by<S2SV_blank>default\\n"" ) ; # ifdef _WITH_PERF_ fprintf ( stderr , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>--perf[=PERF_TYPE]<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Collect<S2SV_blank>perf<S2SV_blank>data,<S2SV_blank>PERF_TYPE=all,<S2SV_blank>run(default)<S2SV_blank>or<S2SV_blank>end\\n"" ) ; # endif # ifdef WITH_DEBUG_OPTIONS fprintf ( stderr , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>--debug[=...]<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Enable<S2SV_blank>debug<S2SV_blank>options.<S2SV_blank>p,<S2SV_blank>b,<S2SV_blank>c,<S2SV_blank>v<S2SV_blank>specify<S2SV_blank>parent,<S2SV_blank>bfd,<S2SV_blank>checker<S2SV_blank>and<S2SV_blank>vrrp<S2SV_blank>processes\\n"" ) ; # ifdef _TIMER_CHECK_ fprintf ( stderr , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>T<S2SV_blank>-<S2SV_blank>timer<S2SV_blank>debug\\n"" ) ; # endif # ifdef _SMTP_ALERT_DEBUG_ fprintf ( stderr , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>M<S2SV_blank>-<S2SV_blank>email<S2SV_blank>alert<S2SV_blank>debug\\n"" ) ; # endif # ifdef _EPOLL_DEBUG_ fprintf ( stderr , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>E<S2SV_blank>-<S2SV_blank>epoll<S2SV_blank>debug\\n"" ) ; # endif # ifdef _EPOLL_THREAD_DUMP_ fprintf ( stderr , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>D<S2SV_blank>-<S2SV_blank>epoll<S2SV_blank>thread<S2SV_blank>dump<S2SV_blank>debug\\n"" ) ; # endif # ifdef _VRRP_FD_DEBUG fprintf ( stderr , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>F<S2SV_blank>-<S2SV_blank>vrrp<S2SV_blank>fd<S2SV_blank>dump<S2SV_blank>debug\\n"" ) ; # endif # ifdef _REGEX_DEBUG_ fprintf ( stderr , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>R<S2SV_blank>-<S2SV_blank>regex<S2SV_blank>debug\\n"" ) ; # endif # ifdef _WITH_REGEX_TIMERS_ fprintf ( stderr , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>X<S2SV_blank>-<S2SV_blank>regex<S2SV_blank>timers\\n"" ) ; # endif # ifdef _TSM_DEBUG_ fprintf ( stderr , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>S<S2SV_blank>-<S2SV_blank>TSM<S2SV_blank>debug\\n"" ) ; # endif # ifdef _NETLINK_TIMERS_ fprintf ( stderr , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>N<S2SV_blank>-<S2SV_blank>netlink<S2SV_blank>timer<S2SV_blank>debug\\n"" ) ; # endif fprintf ( stderr , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Example<S2SV_blank>--debug=TpMEvcp\\n"" ) ; # endif fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-v,<S2SV_blank>--version<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Display<S2SV_blank>the<S2SV_blank>version<S2SV_blank>number\\n"" ) ; fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-h,<S2SV_blank>--help<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Display<S2SV_blank>this<S2SV_blank>help<S2SV_blank>message\\n"" ) ; }","<S2SV_ModStart> ""<S2SV_blank><S2SV_blank>-G,<S2SV_blank>--no-syslog<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Don\'t<S2SV_blank>log<S2SV_blank>via<S2SV_blank>syslog\\n"" ) ; fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-u,<S2SV_blank>--umask=MASK<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>umask<S2SV_blank>for<S2SV_blank>file<S2SV_blank>creation<S2SV_blank>(in<S2SV_blank>numeric<S2SV_blank>form)\\n"" ) ;",acassen@keepalived/c6247a9ef2c7b33244ab1d3aa5d629ec49f0a067,CVE-2018-19045,https://github.com/acassen/keepalived/commit/c6247a9ef2c7b33244ab1d3aa5d629ec49f0a067,2018-11-08T20:29Z
CWE-119,"CWE-119 void iperf_on_connect ( struct iperf_test * test ) { time_t now_secs ; const char * rfc1123_fmt = ""%a,<S2SV_blank>%d<S2SV_blank>%b<S2SV_blank>%Y<S2SV_blank>%H:%M:%S<S2SV_blank>GMT"" ; char now_str [ 100 ] ; char ipr [ INET6_ADDRSTRLEN ] ; int port ; struct sockaddr_storage sa ; struct sockaddr_in * sa_inP ; struct sockaddr_in6 * sa_in6P ; socklen_t len ; int opt ; now_secs = time ( ( time_t * ) 0 ) ; ( void ) strftime ( now_str , sizeof ( now_str ) , rfc1123_fmt , gmtime ( & now_secs ) ) ; if ( test -> json_output ) cJSON_AddItemToObject ( test -> json_start , ""timestamp"" , iperf_json_printf ( ""time:<S2SV_blank>%s<S2SV_blank><S2SV_blank>timesecs:<S2SV_blank>%d"" , now_str , ( int64_t ) now_secs ) ) ; else if ( test -> verbose ) iprintf ( test , report_time , now_str ) ; if ( test -> role == 'c' ) { if ( test -> json_output ) cJSON_AddItemToObject ( test -> json_start , ""connecting_to"" , iperf_json_printf ( ""host:<S2SV_blank>%s<S2SV_blank><S2SV_blank>port:<S2SV_blank>%d"" , test -> server_hostname , ( int64_t ) test -> server_port ) ) ; else { iprintf ( test , report_connecting , test -> server_hostname , test -> server_port ) ; if ( test -> reverse ) iprintf ( test , report_reverse , test -> server_hostname ) ; } } else { len = sizeof ( sa ) ; getpeername ( test -> ctrl_sck , ( struct sockaddr * ) & sa , & len ) ; if ( getsockdomain ( test -> ctrl_sck ) == AF_INET ) { sa_inP = ( struct sockaddr_in * ) & sa ; inet_ntop ( AF_INET , & sa_inP -> sin_addr , ipr , sizeof ( ipr ) ) ; port = ntohs ( sa_inP -> sin_port ) ; } else { sa_in6P = ( struct sockaddr_in6 * ) & sa ; inet_ntop ( AF_INET6 , & sa_in6P -> sin6_addr , ipr , sizeof ( ipr ) ) ; port = ntohs ( sa_in6P -> sin6_port ) ; } mapped_v4_to_regular_v4 ( ipr ) ; if ( test -> json_output ) cJSON_AddItemToObject ( test -> json_start , ""accepted_connection"" , iperf_json_printf ( ""host:<S2SV_blank>%s<S2SV_blank><S2SV_blank>port:<S2SV_blank>%d"" , ipr , ( int64_t ) port ) ) ; else iprintf ( test , report_accepted , ipr , port ) ; } if ( test -> json_output ) { cJSON_AddStringToObject ( test -> json_start , ""cookie"" , test -> cookie ) ; if ( test -> protocol -> id == SOCK_STREAM ) { if ( test -> settings -> mss ) <S2SV_StartBug> cJSON_AddIntToObject ( test -> json_start , ""tcp_mss"" , test -> settings -> mss ) ; <S2SV_EndBug> else { len = sizeof ( opt ) ; getsockopt ( test -> ctrl_sck , IPPROTO_TCP , TCP_MAXSEG , & opt , & len ) ; <S2SV_StartBug> cJSON_AddIntToObject ( test -> json_start , ""tcp_mss_default"" , opt ) ; <S2SV_EndBug> } } } else if ( test -> verbose ) { iprintf ( test , report_cookie , test -> cookie ) ; if ( test -> protocol -> id == SOCK_STREAM ) { if ( test -> settings -> mss ) iprintf ( test , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>TCP<S2SV_blank>MSS:<S2SV_blank>%d\\n"" , test -> settings -> mss ) ; else { len = sizeof ( opt ) ; getsockopt ( test -> ctrl_sck , IPPROTO_TCP , TCP_MAXSEG , & opt , & len ) ; iprintf ( test , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>TCP<S2SV_blank>MSS:<S2SV_blank>%d<S2SV_blank>(default)\\n"" , opt ) ; } } } }",<S2SV_ModStart> -> mss ) cJSON_AddNumberToObject <S2SV_ModEnd> ( test -> <S2SV_ModStart> len ) ; cJSON_AddNumberToObject <S2SV_ModEnd> ( test ->,esnet@iperf/91f2fa59e8ed80dfbf400add0164ee0e508e412a,CVE-2016-4303,https://github.com/esnet/iperf/commit/91f2fa59e8ed80dfbf400add0164ee0e508e412a,2016-09-26T14:59Z
CWE-125,"CWE-125 static int rx_cache_find ( const struct rx_header * rxh , const struct ip * ip , int sport , int32_t * opcode ) { int i ; struct rx_cache_entry * rxent ; uint32_t clip ; uint32_t sip ; UNALIGNED_MEMCPY ( & clip , & ip -> ip_dst , sizeof ( uint32_t ) ) ; UNALIGNED_MEMCPY ( & sip , & ip -> ip_src , sizeof ( uint32_t ) ) ; i = rx_cache_hint ; do { rxent = & rx_cache [ i ] ; if ( rxent -> callnum == EXTRACT_32BITS ( & rxh -> callNumber ) && rxent -> client . s_addr == clip && rxent -> server . s_addr == sip && <S2SV_StartBug> rxent -> serviceId == EXTRACT_32BITS ( & rxh -> serviceId ) && <S2SV_EndBug> rxent -> dport == sport ) { rx_cache_hint = i ; * opcode = rxent -> opcode ; return ( 1 ) ; } if ( ++ i >= RX_CACHE_SIZE ) i = 0 ; } while ( i != rx_cache_hint ) ; return ( 0 ) ; }",<S2SV_ModStart> -> serviceId == EXTRACT_16BITS <S2SV_ModEnd> ( & rxh,the-tcpdump-group@tcpdump/c24922e692a52121e853a84ead6b9337f4c08a94,CVE-2018-14466,https://github.com/the-tcpdump-group/tcpdump/commit/c24922e692a52121e853a84ead6b9337f4c08a94,2019-10-03T16:15Z
CWE-362,"CWE-362 static void userfaultfd_event_wait_completion ( struct userfaultfd_ctx * ctx , struct userfaultfd_wait_queue * ewq ) { struct userfaultfd_ctx * release_new_ctx ; if ( WARN_ON_ONCE ( current -> flags & PF_EXITING ) ) goto out ; ewq -> ctx = ctx ; init_waitqueue_entry ( & ewq -> wq , current ) ; release_new_ctx = NULL ; spin_lock ( & ctx -> event_wqh . lock ) ; __add_wait_queue ( & ctx -> event_wqh , & ewq -> wq ) ; for ( ; ; ) { set_current_state ( TASK_KILLABLE ) ; if ( ewq -> msg . event == 0 ) break ; if ( READ_ONCE ( ctx -> released ) || fatal_signal_pending ( current ) ) { __remove_wait_queue ( & ctx -> event_wqh , & ewq -> wq ) ; if ( ewq -> msg . event == UFFD_EVENT_FORK ) { struct userfaultfd_ctx * new ; new = ( struct userfaultfd_ctx * ) ( unsigned long ) ewq -> msg . arg . reserved . reserved1 ; release_new_ctx = new ; } break ; } spin_unlock ( & ctx -> event_wqh . lock ) ; wake_up_poll ( & ctx -> fd_wqh , EPOLLIN ) ; schedule ( ) ; spin_lock ( & ctx -> event_wqh . lock ) ; } __set_current_state ( TASK_RUNNING ) ; spin_unlock ( & ctx -> event_wqh . lock ) ; if ( release_new_ctx ) { struct vm_area_struct * vma ; struct mm_struct * mm = release_new_ctx -> mm ; down_write ( & mm -> mmap_sem ) ; <S2SV_StartBug> for ( vma = mm -> mmap ; vma ; vma = vma -> vm_next ) <S2SV_EndBug> if ( vma -> vm_userfaultfd_ctx . ctx == release_new_ctx ) { vma -> vm_userfaultfd_ctx = NULL_VM_UFFD_CTX ; vma -> vm_flags &= ~ ( VM_UFFD_WP | VM_UFFD_MISSING ) ; } up_write ( & mm -> mmap_sem ) ; userfaultfd_ctx_put ( release_new_ctx ) ; } out : WRITE_ONCE ( ctx -> mmap_changing , false ) ; userfaultfd_ctx_put ( ctx ) ; }",<S2SV_ModStart> mmap_sem ) ; VM_WARN_ON ( ! mmget_still_valid ( mm ) ) ;,torvalds@linux/04f5866e41fb70690e28397487d8bd8eea7d712a,CVE-2019-11599,https://github.com/torvalds/linux/commit/04f5866e41fb70690e28397487d8bd8eea7d712a,2019-04-29T18:29Z
CWE-310,"CWE-000 static void sctp_v6_get_dst ( struct sctp_transport * t , union sctp_addr * saddr , struct flowi * fl , struct sock * sk ) { struct sctp_association * asoc = t -> asoc ; struct dst_entry * dst = NULL ; struct flowi6 * fl6 = & fl -> u . ip6 ; struct sctp_bind_addr * bp ; <S2SV_StartBug> struct sctp_sockaddr_entry * laddr ; <S2SV_EndBug> union sctp_addr * baddr = NULL ; union sctp_addr * daddr = & t -> ipaddr ; union sctp_addr dst_saddr ; <S2SV_StartBug> __u8 matchlen = 0 ; <S2SV_EndBug> __u8 bmatchlen ; sctp_scope_t scope ; memset ( fl6 , 0 , sizeof ( struct flowi6 ) ) ; fl6 -> daddr = daddr -> v6 . sin6_addr ; fl6 -> fl6_dport = daddr -> v6 . sin6_port ; fl6 -> flowi6_proto = IPPROTO_SCTP ; if ( ipv6_addr_type ( & daddr -> v6 . sin6_addr ) & IPV6_ADDR_LINKLOCAL ) fl6 -> flowi6_oif = daddr -> v6 . sin6_scope_id ; pr_debug ( ""%s:<S2SV_blank>dst=%pI6<S2SV_blank>"" , __func__ , & fl6 -> daddr ) ; if ( asoc ) fl6 -> fl6_sport = htons ( asoc -> base . bind_addr . port ) ; if ( saddr ) { fl6 -> saddr = saddr -> v6 . sin6_addr ; fl6 -> fl6_sport = saddr -> v6 . sin6_port ; pr_debug ( ""src=%pI6<S2SV_blank>-<S2SV_blank>"" , & fl6 -> saddr ) ; } <S2SV_StartBug> dst = ip6_dst_lookup_flow ( sk , fl6 , NULL , false ) ; <S2SV_EndBug> if ( ! asoc || saddr ) goto out ; bp = & asoc -> base . bind_addr ; scope = sctp_scope ( daddr ) ; if ( ! IS_ERR ( dst ) ) { sctp_v6_to_addr ( & dst_saddr , & fl6 -> saddr , htons ( bp -> port ) ) ; rcu_read_lock ( ) ; list_for_each_entry_rcu ( laddr , & bp -> address_list , list ) { if ( ! laddr -> valid || ( laddr -> state != SCTP_ADDR_SRC ) ) continue ; if ( ( laddr -> a . sa . sa_family == AF_INET6 ) && ( sctp_v6_cmp_addr ( & dst_saddr , & laddr -> a ) ) ) { rcu_read_unlock ( ) ; goto out ; } } rcu_read_unlock ( ) ; dst_release ( dst ) ; dst = NULL ; } rcu_read_lock ( ) ; list_for_each_entry_rcu ( laddr , & bp -> address_list , list ) { if ( ! laddr -> valid ) continue ; if ( ( laddr -> state == SCTP_ADDR_SRC ) && ( laddr -> a . sa . sa_family == AF_INET6 ) && ( scope <= sctp_scope ( & laddr -> a ) ) ) { bmatchlen = sctp_v6_addr_match_len ( daddr , & laddr -> a ) ; if ( ! baddr || ( matchlen < bmatchlen ) ) { baddr = & laddr -> a ; matchlen = bmatchlen ; } } } rcu_read_unlock ( ) ; if ( baddr ) { fl6 -> saddr = baddr -> v6 . sin6_addr ; fl6 -> fl6_sport = baddr -> v6 . sin6_port ; <S2SV_StartBug> dst = ip6_dst_lookup_flow ( sk , fl6 , NULL , false ) ; <S2SV_EndBug> } out : if ( ! IS_ERR_OR_NULL ( dst ) ) { struct rt6_info * rt ; rt = ( struct rt6_info * ) dst ; t -> dst = dst ; t -> dst_cookie = rt -> rt6i_node ? rt -> rt6i_node -> fn_sernum : 0 ; pr_debug ( ""rt6_dst:%pI6<S2SV_blank>rt6_src:%pI6\\n"" , & rt -> rt6i_dst . addr , & fl6 -> saddr ) ; } else { t -> dst = NULL ; pr_debug ( ""no<S2SV_blank>route\\n"" ) ; } }","<S2SV_ModStart> bp ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct <S2SV_ModStart> sctp_addr dst_saddr ; struct in6_addr * final_p , final ; <S2SV_ModStart> ) ; } final_p = fl6_update_dst ( fl6 , np -> opt , & final ) ; <S2SV_ModStart> , fl6 , final_p <S2SV_ModEnd> , false ) <S2SV_ModStart> . sin6_port ; final_p = fl6_update_dst ( fl6 , np -> opt , & final ) ; <S2SV_ModStart> , fl6 , final_p <S2SV_ModEnd> , false )",torvalds@linux/95ee62083cb6453e056562d91f597552021e6ae7,CVE-2013-4350,https://github.com/torvalds/linux/commit/95ee62083cb6453e056562d91f597552021e6ae7,2013-09-25T10:31Z
CWE-119,"CWE-119 static __u8 * lg_report_fixup ( struct hid_device * hdev , __u8 * rdesc , unsigned int * rsize ) { struct lg_drv_data * drv_data = hid_get_drvdata ( hdev ) ; struct usb_device_descriptor * udesc ; __u16 bcdDevice , rev_maj , rev_min ; <S2SV_StartBug> if ( ( drv_data -> quirks & LG_RDESC ) && * rsize >= 90 && rdesc [ 83 ] == 0x26 && <S2SV_EndBug> rdesc [ 84 ] == 0x8c && rdesc [ 85 ] == 0x02 ) { hid_info ( hdev , ""fixing<S2SV_blank>up<S2SV_blank>Logitech<S2SV_blank>keyboard<S2SV_blank>report<S2SV_blank>descriptor\\n"" ) ; rdesc [ 84 ] = rdesc [ 89 ] = 0x4d ; rdesc [ 85 ] = rdesc [ 90 ] = 0x10 ; } <S2SV_StartBug> if ( ( drv_data -> quirks & LG_RDESC_REL_ABS ) && * rsize >= 50 && <S2SV_EndBug> rdesc [ 32 ] == 0x81 && rdesc [ 33 ] == 0x06 && rdesc [ 49 ] == 0x81 && rdesc [ 50 ] == 0x06 ) { hid_info ( hdev , ""fixing<S2SV_blank>up<S2SV_blank>rel/abs<S2SV_blank>in<S2SV_blank>Logitech<S2SV_blank>report<S2SV_blank>descriptor\\n"" ) ; rdesc [ 33 ] = rdesc [ 50 ] = 0x02 ; } switch ( hdev -> product ) { case USB_DEVICE_ID_LOGITECH_WHEEL : udesc = & ( hid_to_usb_dev ( hdev ) -> descriptor ) ; if ( ! udesc ) { hid_err ( hdev , ""NULL<S2SV_blank>USB<S2SV_blank>device<S2SV_blank>descriptor\\n"" ) ; break ; } bcdDevice = le16_to_cpu ( udesc -> bcdDevice ) ; rev_maj = bcdDevice >> 8 ; rev_min = bcdDevice & 0xff ; if ( rev_maj == 1 && rev_min == 2 && * rsize == DF_RDESC_ORIG_SIZE ) { hid_info ( hdev , ""fixing<S2SV_blank>up<S2SV_blank>Logitech<S2SV_blank>Driving<S2SV_blank>Force<S2SV_blank>report<S2SV_blank>descriptor\\n"" ) ; rdesc = df_rdesc_fixed ; * rsize = sizeof ( df_rdesc_fixed ) ; } break ; case USB_DEVICE_ID_LOGITECH_MOMO_WHEEL : if ( * rsize == MOMO_RDESC_ORIG_SIZE ) { hid_info ( hdev , ""fixing<S2SV_blank>up<S2SV_blank>Logitech<S2SV_blank>Momo<S2SV_blank>Force<S2SV_blank>(Red)<S2SV_blank>report<S2SV_blank>descriptor\\n"" ) ; rdesc = momo_rdesc_fixed ; * rsize = sizeof ( momo_rdesc_fixed ) ; } break ; case USB_DEVICE_ID_LOGITECH_MOMO_WHEEL2 : if ( * rsize == MOMO2_RDESC_ORIG_SIZE ) { hid_info ( hdev , ""fixing<S2SV_blank>up<S2SV_blank>Logitech<S2SV_blank>Momo<S2SV_blank>Racing<S2SV_blank>Force<S2SV_blank>(Black)<S2SV_blank>report<S2SV_blank>descriptor\\n"" ) ; rdesc = momo2_rdesc_fixed ; * rsize = sizeof ( momo2_rdesc_fixed ) ; } break ; case USB_DEVICE_ID_LOGITECH_VIBRATION_WHEEL : if ( * rsize == FV_RDESC_ORIG_SIZE ) { hid_info ( hdev , ""fixing<S2SV_blank>up<S2SV_blank>Logitech<S2SV_blank>Formula<S2SV_blank>Vibration<S2SV_blank>report<S2SV_blank>descriptor\\n"" ) ; rdesc = fv_rdesc_fixed ; * rsize = sizeof ( fv_rdesc_fixed ) ; } break ; case USB_DEVICE_ID_LOGITECH_DFP_WHEEL : if ( * rsize == DFP_RDESC_ORIG_SIZE ) { hid_info ( hdev , ""fixing<S2SV_blank>up<S2SV_blank>Logitech<S2SV_blank>Driving<S2SV_blank>Force<S2SV_blank>Pro<S2SV_blank>report<S2SV_blank>descriptor\\n"" ) ; rdesc = dfp_rdesc_fixed ; * rsize = sizeof ( dfp_rdesc_fixed ) ; } break ; case USB_DEVICE_ID_LOGITECH_WII_WHEEL : if ( * rsize >= 101 && rdesc [ 41 ] == 0x95 && rdesc [ 42 ] == 0x0B && rdesc [ 47 ] == 0x05 && rdesc [ 48 ] == 0x09 ) { hid_info ( hdev , ""fixing<S2SV_blank>up<S2SV_blank>Logitech<S2SV_blank>Speed<S2SV_blank>Force<S2SV_blank>Wireless<S2SV_blank>report<S2SV_blank>descriptor\\n"" ) ; rdesc [ 41 ] = 0x05 ; rdesc [ 42 ] = 0x09 ; rdesc [ 47 ] = 0x95 ; rdesc [ 48 ] = 0x0B ; } break ; } return rdesc ; }",<S2SV_ModStart> * rsize >= 91 <S2SV_ModEnd> && rdesc [ <S2SV_ModStart> * rsize >= 51 <S2SV_ModEnd> && rdesc [,torvalds@linux/4ab25786c87eb20857bbb715c3ae34ec8fd6a214,CVE-2014-3184,https://github.com/torvalds/linux/commit/4ab25786c87eb20857bbb715c3ae34ec8fd6a214,2014-09-28T10:55Z
CWE-125,"CWE-125 static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { <S2SV_StartBug> OPCODE_DESC * opcode_desc ; <S2SV_EndBug> ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }",<S2SV_ModStart> * opcode_desc ; if ( len < 2 ) { return NULL ; },radare@radare2/b35530fa0681b27eba084de5527037ebfb397422,CVE-2018-11377,https://github.com/radare/radare2/commit/b35530fa0681b27eba084de5527037ebfb397422,2018-05-22T19:29Z
CWE-416,CWE-416 void snd_usb_mixer_disconnect ( struct usb_mixer_interface * mixer ) { <S2SV_StartBug> usb_kill_urb ( mixer -> urb ) ; <S2SV_EndBug> usb_kill_urb ( mixer -> rc_urb ) ; <S2SV_StartBug> } <S2SV_EndBug>,<S2SV_ModStart> mixer ) { if ( mixer -> disconnected ) return ; if ( mixer -> urb ) <S2SV_ModStart> urb ) ; if ( mixer -> rc_urb ) <S2SV_ModStart> rc_urb ) ; mixer -> disconnected = true ;,torvalds@linux/124751d5e63c823092060074bd0abaae61aaa9c4,CVE-2017-16527,https://github.com/torvalds/linux/commit/124751d5e63c823092060074bd0abaae61aaa9c4,2017-11-04T01:29Z
CWE-476,"CWE-476 static int pb0100_start ( struct sd * sd ) { int err , packet_size , max_packet_size ; struct usb_host_interface * alt ; struct usb_interface * intf ; struct gspca_dev * gspca_dev = ( struct gspca_dev * ) sd ; struct cam * cam = & sd -> gspca_dev . cam ; u32 mode = cam -> cam_mode [ sd -> gspca_dev . curr_mode ] . priv ; intf = usb_ifnum_to_if ( sd -> gspca_dev . dev , sd -> gspca_dev . iface ) ; alt = usb_altnum_to_altsetting ( intf , sd -> gspca_dev . alt ) ; <S2SV_StartBug> if ( ! alt ) <S2SV_EndBug> return - ENODEV ; packet_size = le16_to_cpu ( alt -> endpoint [ 0 ] . desc . wMaxPacketSize ) ; max_packet_size = sd -> sensor -> max_packet_size [ sd -> gspca_dev . curr_mode ] ; if ( packet_size < max_packet_size ) stv06xx_write_sensor ( sd , PB_ROWSPEED , BIT ( 4 ) | BIT ( 3 ) | BIT ( 1 ) ) ; else stv06xx_write_sensor ( sd , PB_ROWSPEED , BIT ( 5 ) | BIT ( 3 ) | BIT ( 1 ) ) ; if ( mode & PB0100_CROP_TO_VGA ) { stv06xx_write_sensor ( sd , PB_RSTART , 30 ) ; stv06xx_write_sensor ( sd , PB_CSTART , 20 ) ; stv06xx_write_sensor ( sd , PB_RWSIZE , 240 - 1 ) ; stv06xx_write_sensor ( sd , PB_CWSIZE , 320 - 1 ) ; } else { stv06xx_write_sensor ( sd , PB_RSTART , 8 ) ; stv06xx_write_sensor ( sd , PB_CSTART , 4 ) ; stv06xx_write_sensor ( sd , PB_RWSIZE , 288 - 1 ) ; stv06xx_write_sensor ( sd , PB_CWSIZE , 352 - 1 ) ; } if ( mode & PB0100_SUBSAMPLE ) { stv06xx_write_bridge ( sd , STV_Y_CTRL , 0x02 ) ; stv06xx_write_bridge ( sd , STV_X_CTRL , 0x06 ) ; stv06xx_write_bridge ( sd , STV_SCAN_RATE , 0x10 ) ; } else { stv06xx_write_bridge ( sd , STV_Y_CTRL , 0x01 ) ; stv06xx_write_bridge ( sd , STV_X_CTRL , 0x0a ) ; stv06xx_write_bridge ( sd , STV_SCAN_RATE , 0x20 ) ; } err = stv06xx_write_sensor ( sd , PB_CONTROL , BIT ( 5 ) | BIT ( 3 ) | BIT ( 1 ) ) ; gspca_dbg ( gspca_dev , D_STREAM , ""Started<S2SV_blank>stream,<S2SV_blank>status:<S2SV_blank>%d\\n"" , err ) ; return ( err < 0 ) ? err : 0 ; }",<S2SV_ModStart> ( ! alt ) return - ENODEV ; if ( alt -> desc . bNumEndpoints < 1,torvalds@linux/485b06aadb933190f4bc44e006076bc27a23f205,CVE-2020-11609,https://github.com/torvalds/linux/commit/485b06aadb933190f4bc44e006076bc27a23f205,2020-04-07T17:15Z
CWE-200,"CWE-200 static int hash_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct hash_ctx * ctx = ask -> private ; unsigned ds = crypto_ahash_digestsize ( crypto_ahash_reqtfm ( & ctx -> req ) ) ; int err ; if ( len > ds ) len = ds ; else if ( len < ds ) msg -> msg_flags |= MSG_TRUNC ; <S2SV_StartBug> lock_sock ( sk ) ; <S2SV_EndBug> if ( ctx -> more ) { ctx -> more = 0 ; ahash_request_set_crypt ( & ctx -> req , NULL , ctx -> result , 0 ) ; err = af_alg_wait_for_completion ( crypto_ahash_final ( & ctx -> req ) , & ctx -> completion ) ; if ( err ) goto unlock ; } err = memcpy_toiovec ( msg -> msg_iov , ctx -> result , len ) ; unlock : release_sock ( sk ) ; return err ? : len ; }",<S2SV_ModStart> |= MSG_TRUNC ; msg -> msg_namelen = 0 ;,torvalds@linux/72a763d805a48ac8c0bf48fdb510e84c12de51fe,CVE-2013-3076,https://github.com/torvalds/linux/commit/72a763d805a48ac8c0bf48fdb510e84c12de51fe,2013-04-22T11:40Z
CWE-125,"CWE-125 Id repodata_schema2id ( Repodata * data , Id * schema , int create ) { int h , len , i ; Id * sp , cid ; Id * schematahash ; if ( ! * schema ) return 0 ; if ( ( schematahash = data -> schematahash ) == 0 ) { data -> schematahash = schematahash = solv_calloc ( 256 , sizeof ( Id ) ) ; for ( i = 1 ; i < data -> nschemata ; i ++ ) { for ( sp = data -> schemadata + data -> schemata [ i ] , h = 0 ; * sp ; ) h = h * 7 + * sp ++ ; h &= 255 ; schematahash [ h ] = i ; } data -> schemadata = solv_extend_resize ( data -> schemadata , data -> schemadatalen , sizeof ( Id ) , SCHEMATADATA_BLOCK ) ; data -> schemata = solv_extend_resize ( data -> schemata , data -> nschemata , sizeof ( Id ) , SCHEMATA_BLOCK ) ; } for ( sp = schema , len = 0 , h = 0 ; * sp ; len ++ ) h = h * 7 + * sp ++ ; h &= 255 ; len ++ ; cid = schematahash [ h ] ; if ( cid ) { <S2SV_StartBug> if ( ! memcmp ( data -> schemadata + data -> schemata [ cid ] , schema , len * sizeof ( Id ) ) ) <S2SV_EndBug> return cid ; for ( cid = 1 ; cid < data -> nschemata ; cid ++ ) <S2SV_StartBug> if ( ! memcmp ( data -> schemadata + data -> schemata [ cid ] , schema , len * sizeof ( Id ) ) ) <S2SV_EndBug> return cid ; } if ( ! create ) return 0 ; data -> schemadata = solv_extend ( data -> schemadata , data -> schemadatalen , len , sizeof ( Id ) , SCHEMATADATA_BLOCK ) ; data -> schemata = solv_extend ( data -> schemata , data -> nschemata , 1 , sizeof ( Id ) , SCHEMATA_BLOCK ) ; memcpy ( data -> schemadata + data -> schemadatalen , schema , len * sizeof ( Id ) ) ; data -> schemata [ data -> nschemata ] = data -> schemadatalen ; data -> schemadatalen += len ; schematahash [ h ] = data -> nschemata ; # if 0 fprintf ( stderr , ""schema2id:<S2SV_blank>new<S2SV_blank>schema\\n"" ) ; # endif return data -> nschemata ++ ; }",<S2SV_ModStart> { if ( ( data -> schemata [ cid ] + len <= data -> schemadatalen ) && <S2SV_ModStart> ) if ( ( data -> schemata [ cid ] + len <= data -> schemadatalen ) &&,openSUSE@libsolv/fdb9c9c03508990e4583046b590c30d958f272da,CVE-2019-20387,https://github.com/openSUSE/libsolv/commit/fdb9c9c03508990e4583046b590c30d958f272da,2020-01-21T23:15Z
CWE-284,"CWE-284 static void _prolog_error ( batch_job_launch_msg_t * req , int rc ) { char * err_name_ptr , err_name [ 256 ] , path_name [ MAXPATHLEN ] ; char * fmt_char ; int fd ; if ( req -> std_err || req -> std_out ) { if ( req -> std_err ) strncpy ( err_name , req -> std_err , sizeof ( err_name ) ) ; else strncpy ( err_name , req -> std_out , sizeof ( err_name ) ) ; if ( ( fmt_char = strchr ( err_name , ( int ) '%' ) ) && ( fmt_char [ 1 ] == 'j' ) && ! strchr ( fmt_char + 1 , ( int ) '%' ) ) { char tmp_name [ 256 ] ; fmt_char [ 1 ] = 'u' ; snprintf ( tmp_name , sizeof ( tmp_name ) , err_name , req -> job_id ) ; strncpy ( err_name , tmp_name , sizeof ( err_name ) ) ; } } else { snprintf ( err_name , sizeof ( err_name ) , ""slurm-%u.out"" , req -> job_id ) ; } err_name_ptr = err_name ; if ( err_name_ptr [ 0 ] == '/' ) snprintf ( path_name , MAXPATHLEN , ""%s"" , err_name_ptr ) ; else if ( req -> work_dir ) snprintf ( path_name , MAXPATHLEN , ""%s/%s"" , req -> work_dir , err_name_ptr ) ; else snprintf ( path_name , MAXPATHLEN , ""/%s"" , err_name_ptr ) ; <S2SV_StartBug> if ( ( fd = open ( path_name , ( O_CREAT | O_APPEND | O_WRONLY ) , 0644 ) ) == - 1 ) { <S2SV_EndBug> <S2SV_StartBug> error ( ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s:<S2SV_blank>%s"" , path_name , <S2SV_EndBug> slurm_strerror ( errno ) ) ; return ; } snprintf ( err_name , sizeof ( err_name ) , ""Error<S2SV_blank>running<S2SV_blank>slurm<S2SV_blank>prolog:<S2SV_blank>%d\\n"" , WEXITSTATUS ( rc ) ) ; safe_write ( fd , err_name , strlen ( err_name ) ) ; if ( fchown ( fd , ( uid_t ) req -> uid , ( gid_t ) req -> gid ) == - 1 ) { snprintf ( err_name , sizeof ( err_name ) , ""Couldn\'t<S2SV_blank>change<S2SV_blank>fd<S2SV_blank>owner<S2SV_blank>to<S2SV_blank>%u:%u:<S2SV_blank>%m\\n"" , req -> uid , req -> gid ) ; } rwfail : close ( fd ) ; }","<S2SV_ModStart> ( fd = _open_as_other ( path_name , req <S2SV_ModEnd> ) ) == <S2SV_ModStart> { error ( ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s:<S2SV_blank>Permission<S2SV_blank>denied"" , path_name <S2SV_ModEnd> ) ; return",SchedMD@slurm/92362a92fffe60187df61f99ab11c249d44120ee,CVE-2016-10030,https://github.com/SchedMD/slurm/commit/92362a92fffe60187df61f99ab11c249d44120ee,2017-01-05T11:59Z
CWE-190,"CWE-190 static int readContigStripsIntoBuffer ( TIFF * in , uint8 * buf ) { uint8 * bufp = buf ; int32 bytes_read = 0 ; <S2SV_StartBug> uint16 strip , nstrips = TIFFNumberOfStrips ( in ) ; <S2SV_EndBug> uint32 stripsize = TIFFStripSize ( in ) ; uint32 rows = 0 ; uint32 rps = TIFFGetFieldDefaulted ( in , TIFFTAG_ROWSPERSTRIP , & rps ) ; tsize_t scanline_size = TIFFScanlineSize ( in ) ; if ( scanline_size == 0 ) { TIFFError ( """" , ""TIFF<S2SV_blank>scanline<S2SV_blank>size<S2SV_blank>is<S2SV_blank>zero!"" ) ; return 0 ; } for ( strip = 0 ; strip < nstrips ; strip ++ ) { bytes_read = TIFFReadEncodedStrip ( in , strip , bufp , - 1 ) ; rows = bytes_read / scanline_size ; if ( ( strip < ( nstrips - 1 ) ) && ( bytes_read != ( int32 ) stripsize ) ) TIFFError ( """" , ""Strip<S2SV_blank>%d:<S2SV_blank>read<S2SV_blank>%lu<S2SV_blank>bytes,<S2SV_blank>strip<S2SV_blank>size<S2SV_blank>%lu"" , ( int ) strip + 1 , ( unsigned long ) bytes_read , ( unsigned long ) stripsize ) ; if ( bytes_read < 0 && ! ignore ) { TIFFError ( """" , ""Error<S2SV_blank>reading<S2SV_blank>strip<S2SV_blank>%lu<S2SV_blank>after<S2SV_blank>%lu<S2SV_blank>rows"" , ( unsigned long ) strip , ( unsigned long ) rows ) ; return 0 ; } bufp += bytes_read ; } return 1 ; }","<S2SV_ModStart> = 0 ; uint32 <S2SV_ModEnd> strip , nstrips",vadz@libtiff/43c0b81a818640429317c80fea1e66771e85024b,CVE-2016-9538,https://github.com/vadz/libtiff/commit/43c0b81a818640429317c80fea1e66771e85024b#diff-c8b4b355f9b5c06d585b23138e1c185f,2016-11-22T19:59Z
CWE-125,"CWE-125 stmt_ty <S2SV_StartBug> Assign ( asdl_seq * targets , expr_ty value , int lineno , int col_offset , int <S2SV_EndBug> end_lineno , int end_col_offset , PyArena * arena ) { stmt_ty p ; if ( ! value ) { PyErr_SetString ( PyExc_ValueError , ""field<S2SV_blank>value<S2SV_blank>is<S2SV_blank>required<S2SV_blank>for<S2SV_blank>Assign"" ) ; return NULL ; } p = ( stmt_ty ) PyArena_Malloc ( arena , sizeof ( * p ) ) ; if ( ! p ) return NULL ; p -> kind = Assign_kind ; p -> v . Assign . targets = targets ; p -> v . Assign . value = value ; <S2SV_StartBug> p -> lineno = lineno ; <S2SV_EndBug> p -> col_offset = col_offset ; p -> end_lineno = end_lineno ; p -> end_col_offset = end_col_offset ; return p ; }","<S2SV_ModStart> expr_ty value , string type_comment , <S2SV_ModStart> ; p -> v . Assign . type_comment = type_comment ; p ->",python@typed_ast/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,CVE-2019-19275,https://github.com/python/typed_ast/commit/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,2019-11-26T15:15Z
CWE-119,"CWE-119 static int filter_frame ( AVFilterLink * inlink , AVFrame * in ) { PadContext * s = inlink -> dst -> priv ; AVFrame * out ; int needs_copy = frame_needs_copy ( s , in ) ; if ( needs_copy ) { av_log ( inlink -> dst , AV_LOG_DEBUG , ""Direct<S2SV_blank>padding<S2SV_blank>impossible<S2SV_blank>allocating<S2SV_blank>new<S2SV_blank>frame\\n"" ) ; out = ff_get_video_buffer ( inlink -> dst -> outputs [ 0 ] , FFMAX ( inlink -> w , s -> w ) , FFMAX ( inlink -> h , s -> h ) ) ; if ( ! out ) { av_frame_free ( & in ) ; return AVERROR ( ENOMEM ) ; } av_frame_copy_props ( out , in ) ; } else { int i ; out = in ; <S2SV_StartBug> for ( i = 0 ; i < 4 && out -> data [ i ] ; i ++ ) { <S2SV_EndBug> int hsub = s -> draw . hsub [ i ] ; int vsub = s -> draw . vsub [ i ] ; out -> data [ i ] -= ( s -> x >> hsub ) * s -> draw . pixelstep [ i ] + ( s -> y >> vsub ) * out -> linesize [ i ] ; } } if ( s -> y ) { ff_fill_rectangle ( & s -> draw , & s -> color , out -> data , out -> linesize , 0 , 0 , s -> w , s -> y ) ; } if ( s -> h > s -> y + s -> in_h ) { ff_fill_rectangle ( & s -> draw , & s -> color , out -> data , out -> linesize , 0 , s -> y + s -> in_h , s -> w , s -> h - s -> y - s -> in_h ) ; } ff_fill_rectangle ( & s -> draw , & s -> color , out -> data , out -> linesize , 0 , s -> y , s -> x , in -> height ) ; if ( needs_copy ) { ff_copy_rectangle2 ( & s -> draw , out -> data , out -> linesize , in -> data , in -> linesize , s -> x , s -> y , 0 , 0 , in -> width , in -> height ) ; } ff_fill_rectangle ( & s -> draw , & s -> color , out -> data , out -> linesize , s -> x + s -> in_w , s -> y , s -> w - s -> x - s -> in_w , in -> height ) ; out -> width = s -> w ; out -> height = s -> h ; if ( in != out ) av_frame_free ( & in ) ; return ff_filter_frame ( inlink -> dst -> outputs [ 0 ] , out ) ; }",<S2SV_ModStart> [ i ] && out -> linesize [ i ],FFmpeg@FFmpeg/e43a0a232dbf6d3c161823c2e07c52e76227a1bc,CVE-2013-4263,https://github.com/FFmpeg/FFmpeg/commit/e43a0a232dbf6d3c161823c2e07c52e76227a1bc,2013-11-23T17:55Z
CWE-285,"CWE-000 static int __ext4_set_acl ( handle_t * handle , struct inode * inode , int type , struct posix_acl * acl ) { int name_index ; void * value = NULL ; size_t size = 0 ; int error ; switch ( type ) { case ACL_TYPE_ACCESS : name_index = EXT4_XATTR_INDEX_POSIX_ACL_ACCESS ; if ( acl ) { <S2SV_StartBug> error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; <S2SV_EndBug> if ( error < 0 ) return error ; else { inode -> i_ctime = ext4_current_time ( inode ) ; ext4_mark_inode_dirty ( handle , inode ) ; <S2SV_StartBug> if ( error == 0 ) <S2SV_EndBug> acl = NULL ; } } break ; case ACL_TYPE_DEFAULT : name_index = EXT4_XATTR_INDEX_POSIX_ACL_DEFAULT ; if ( ! S_ISDIR ( inode -> i_mode ) ) return acl ? - EACCES : 0 ; break ; default : return - EINVAL ; } if ( acl ) { value = ext4_acl_to_disk ( acl , & size ) ; if ( IS_ERR ( value ) ) return ( int ) PTR_ERR ( value ) ; } error = ext4_xattr_set_handle ( handle , inode , name_index , """" , value , size , 0 ) ; kfree ( value ) ; if ( ! error ) set_cached_acl ( inode , type , acl ) ; return error ; }","<S2SV_ModStart> { error = posix_acl_update_mode ( inode <S2SV_ModEnd> , & inode <S2SV_ModStart> inode -> i_mode , & acl ) ; if ( error ) return error ; <S2SV_ModEnd> inode -> i_ctime <S2SV_ModStart> inode ) ; <S2SV_ModEnd> } break ;",torvalds@linux/073931017b49d9458aa351605b43a7e34598caef,CVE-2016-7097,https://github.com/torvalds/linux/commit/073931017b49d9458aa351605b43a7e34598caef,2016-10-16T21:59Z
CWE-119,"CWE-119 static vpx_codec_err_t ctrl_set_active_map ( vpx_codec_alg_priv_t * ctx , <S2SV_StartBug> int ctr_id , va_list args ) { <S2SV_EndBug> vpx_active_map_t * const map = va_arg ( args , vpx_active_map_t * ) ; if ( map ) { <S2SV_StartBug> if ( ! vp9_set_active_map ( ctx -> cpi , map -> active_map , map -> rows , map -> cols ) ) <S2SV_EndBug> return VPX_CODEC_OK ; else return VPX_CODEC_INVALID_PARAM ; } else { return VPX_CODEC_INVALID_PARAM ; } }","<S2SV_ModStart> * ctx , <S2SV_ModEnd> va_list args ) <S2SV_ModStart> -> active_map , ( int ) <S2SV_ModStart> -> rows , ( int )",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-264,"CWE-264 static __init int hardware_setup ( void ) { int r = - ENOMEM , i , msr ; rdmsrl_safe ( MSR_EFER , & host_efer ) ; for ( i = 0 ; i < ARRAY_SIZE ( vmx_msr_index ) ; ++ i ) kvm_define_shared_msr ( i , vmx_msr_index [ i ] ) ; vmx_io_bitmap_a = ( unsigned long * ) __get_free_page ( GFP_KERNEL ) ; if ( ! vmx_io_bitmap_a ) return r ; vmx_io_bitmap_b = ( unsigned long * ) __get_free_page ( GFP_KERNEL ) ; if ( ! vmx_io_bitmap_b ) goto out ; vmx_msr_bitmap_legacy = ( unsigned long * ) __get_free_page ( GFP_KERNEL ) ; if ( ! vmx_msr_bitmap_legacy ) goto out1 ; vmx_msr_bitmap_legacy_x2apic = ( unsigned long * ) __get_free_page ( GFP_KERNEL ) ; if ( ! vmx_msr_bitmap_legacy_x2apic ) goto out2 ; vmx_msr_bitmap_longmode = ( unsigned long * ) __get_free_page ( GFP_KERNEL ) ; if ( ! vmx_msr_bitmap_longmode ) goto out3 ; vmx_msr_bitmap_longmode_x2apic = ( unsigned long * ) __get_free_page ( GFP_KERNEL ) ; if ( ! vmx_msr_bitmap_longmode_x2apic ) goto out4 ; if ( nested ) { vmx_msr_bitmap_nested = ( unsigned long * ) __get_free_page ( GFP_KERNEL ) ; if ( ! vmx_msr_bitmap_nested ) goto out5 ; } vmx_vmread_bitmap = ( unsigned long * ) __get_free_page ( GFP_KERNEL ) ; if ( ! vmx_vmread_bitmap ) goto out6 ; vmx_vmwrite_bitmap = ( unsigned long * ) __get_free_page ( GFP_KERNEL ) ; if ( ! vmx_vmwrite_bitmap ) goto out7 ; memset ( vmx_vmread_bitmap , 0xff , PAGE_SIZE ) ; memset ( vmx_vmwrite_bitmap , 0xff , PAGE_SIZE ) ; memset ( vmx_io_bitmap_a , 0xff , PAGE_SIZE ) ; clear_bit ( 0x80 , vmx_io_bitmap_a ) ; memset ( vmx_io_bitmap_b , 0xff , PAGE_SIZE ) ; memset ( vmx_msr_bitmap_legacy , 0xff , PAGE_SIZE ) ; memset ( vmx_msr_bitmap_longmode , 0xff , PAGE_SIZE ) ; if ( nested ) memset ( vmx_msr_bitmap_nested , 0xff , PAGE_SIZE ) ; if ( setup_vmcs_config ( & vmcs_config ) < 0 ) { r = - EIO ; goto out8 ; } if ( boot_cpu_has ( X86_FEATURE_NX ) ) kvm_enable_efer_bits ( EFER_NX ) ; if ( ! cpu_has_vmx_vpid ( ) ) enable_vpid = 0 ; if ( ! cpu_has_vmx_shadow_vmcs ( ) ) enable_shadow_vmcs = 0 ; if ( enable_shadow_vmcs ) init_vmcs_shadow_fields ( ) ; if ( ! cpu_has_vmx_ept ( ) || ! cpu_has_vmx_ept_4levels ( ) ) { enable_ept = 0 ; enable_unrestricted_guest = 0 ; enable_ept_ad_bits = 0 ; } if ( ! cpu_has_vmx_ept_ad_bits ( ) ) enable_ept_ad_bits = 0 ; if ( ! cpu_has_vmx_unrestricted_guest ( ) ) enable_unrestricted_guest = 0 ; if ( ! cpu_has_vmx_flexpriority ( ) ) flexpriority_enabled = 0 ; if ( ! flexpriority_enabled ) kvm_x86_ops -> set_apic_access_page_addr = NULL ; if ( ! cpu_has_vmx_tpr_shadow ( ) ) kvm_x86_ops -> update_cr8_intercept = NULL ; if ( enable_ept && ! cpu_has_vmx_ept_2m_page ( ) ) kvm_disable_largepages ( ) ; if ( ! cpu_has_vmx_ple ( ) ) ple_gap = 0 ; if ( ! cpu_has_vmx_apicv ( ) ) enable_apicv = 0 ; if ( cpu_has_vmx_tsc_scaling ( ) ) { kvm_has_tsc_control = true ; kvm_max_tsc_scaling_ratio = KVM_VMX_TSC_MULTIPLIER_MAX ; kvm_tsc_scaling_ratio_frac_bits = 48 ; } vmx_disable_intercept_for_msr ( MSR_FS_BASE , false ) ; vmx_disable_intercept_for_msr ( MSR_GS_BASE , false ) ; vmx_disable_intercept_for_msr ( MSR_KERNEL_GS_BASE , true ) ; vmx_disable_intercept_for_msr ( MSR_IA32_SYSENTER_CS , false ) ; vmx_disable_intercept_for_msr ( MSR_IA32_SYSENTER_ESP , false ) ; vmx_disable_intercept_for_msr ( MSR_IA32_SYSENTER_EIP , false ) ; vmx_disable_intercept_for_msr ( MSR_IA32_BNDCFGS , true ) ; memcpy ( vmx_msr_bitmap_legacy_x2apic , vmx_msr_bitmap_legacy , PAGE_SIZE ) ; memcpy ( vmx_msr_bitmap_longmode_x2apic , vmx_msr_bitmap_longmode , PAGE_SIZE ) ; set_bit ( 0 , vmx_vpid_bitmap ) ; <S2SV_StartBug> if ( enable_apicv ) { <S2SV_EndBug> for ( msr = 0x800 ; msr <= 0x8ff ; msr ++ ) vmx_disable_intercept_msr_read_x2apic ( msr ) ; vmx_enable_intercept_msr_read_x2apic ( 0x802 ) ; vmx_enable_intercept_msr_read_x2apic ( 0x839 ) ; vmx_disable_intercept_msr_write_x2apic ( 0x808 ) ; vmx_disable_intercept_msr_write_x2apic ( 0x80b ) ; vmx_disable_intercept_msr_write_x2apic ( 0x83f ) ; <S2SV_StartBug> } <S2SV_EndBug> if ( enable_ept ) { kvm_mmu_set_mask_ptes ( 0ull , ( enable_ept_ad_bits ) ? VMX_EPT_ACCESS_BIT : 0ull , ( enable_ept_ad_bits ) ? VMX_EPT_DIRTY_BIT : 0ull , 0ull , VMX_EPT_EXECUTABLE_MASK ) ; ept_set_mmio_spte_mask ( ) ; kvm_enable_tdp ( ) ; } else kvm_disable_tdp ( ) ; update_ple_window_actual_max ( ) ; if ( ! enable_ept || ! enable_ept_ad_bits || ! cpu_has_vmx_pml ( ) ) enable_pml = 0 ; if ( ! enable_pml ) { kvm_x86_ops -> slot_enable_log_dirty = NULL ; kvm_x86_ops -> slot_disable_log_dirty = NULL ; kvm_x86_ops -> flush_log_dirty = NULL ; kvm_x86_ops -> enable_log_dirty_pt_masked = NULL ; } kvm_set_posted_intr_wakeup_handler ( wakeup_handler ) ; return alloc_kvm_area ( ) ; out8 : free_page ( ( unsigned long ) vmx_vmwrite_bitmap ) ; out7 : free_page ( ( unsigned long ) vmx_vmread_bitmap ) ; out6 : if ( nested ) free_page ( ( unsigned long ) vmx_msr_bitmap_nested ) ; out5 : free_page ( ( unsigned long ) vmx_msr_bitmap_longmode_x2apic ) ; out4 : free_page ( ( unsigned long ) vmx_msr_bitmap_longmode ) ; out3 : free_page ( ( unsigned long ) vmx_msr_bitmap_legacy_x2apic ) ; out2 : free_page ( ( unsigned long ) vmx_msr_bitmap_legacy ) ; out1 : free_page ( ( unsigned long ) vmx_io_bitmap_b ) ; out : free_page ( ( unsigned long ) vmx_io_bitmap_a ) ; return r ; }",<S2SV_ModStart> vmx_vpid_bitmap ) ; <S2SV_ModEnd> for ( msr <S2SV_ModStart> 0x83f ) ; <S2SV_ModEnd> if ( enable_ept,torvalds@linux/3ce424e45411cf5a13105e0386b6ecf6eeb4f66f,CVE-2016-4440,https://github.com/torvalds/linux/commit/3ce424e45411cf5a13105e0386b6ecf6eeb4f66f,2016-06-27T10:59Z
CWE-399,"CWE-399 int hugetlb_reserve_pages ( struct inode * inode , long from , long to , struct vm_area_struct * vma , vm_flags_t vm_flags ) { long ret , chg ; struct hstate * h = hstate_inode ( inode ) ; struct hugepage_subpool * spool = subpool_inode ( inode ) ; if ( vm_flags & VM_NORESERVE ) return 0 ; if ( ! vma || vma -> vm_flags & VM_MAYSHARE ) chg = region_chg ( & inode -> i_mapping -> private_list , from , to ) ; else { struct resv_map * resv_map = resv_map_alloc ( ) ; if ( ! resv_map ) return - ENOMEM ; chg = to - from ; set_vma_resv_map ( vma , resv_map ) ; set_vma_resv_flags ( vma , HPAGE_RESV_OWNER ) ; } if ( chg < 0 ) <S2SV_StartBug> return chg ; <S2SV_EndBug> if ( hugepage_subpool_get_pages ( spool , chg ) ) <S2SV_StartBug> return - ENOSPC ; <S2SV_EndBug> <S2SV_StartBug> ret = hugetlb_acct_memory ( h , chg ) ; <S2SV_EndBug> if ( ret < 0 ) { hugepage_subpool_put_pages ( spool , chg ) ; <S2SV_StartBug> return ret ; <S2SV_EndBug> } if ( ! vma || vma -> vm_flags & VM_MAYSHARE ) region_add ( & inode -> i_mapping -> private_list , from , to ) ; return 0 ; <S2SV_StartBug> } <S2SV_EndBug>",<S2SV_ModStart> < 0 ) { ret = chg ; goto out_err ; } <S2SV_ModEnd> if ( hugepage_subpool_get_pages <S2SV_ModStart> chg ) ) { ret = <S2SV_ModEnd> - ENOSPC ; <S2SV_ModStart> - ENOSPC ; goto out_err ; } <S2SV_ModStart> chg ) ; goto out_err <S2SV_ModEnd> ; } if <S2SV_ModStart> return 0 ; out_err : resv_map_put ( vma ) ; return ret ;,torvalds@linux/c50ac050811d6485616a193eb0f37bfbd191cc89,CVE-2012-2390,https://github.com/torvalds/linux/commit/c50ac050811d6485616a193eb0f37bfbd191cc89,2012-06-13T10:24Z
CWE-119,"CWE-119 static int pit_ioport_read ( struct kvm_io_device * this , gpa_t addr , int len , void * data ) { struct kvm_pit * pit = dev_to_pit ( this ) ; struct kvm_kpit_state * pit_state = & pit -> pit_state ; struct kvm * kvm = pit -> kvm ; int ret , count ; struct kvm_kpit_channel_state * s ; if ( ! pit_in_range ( addr ) ) return - EOPNOTSUPP ; addr &= KVM_PIT_CHANNEL_MASK ; <S2SV_StartBug> s = & pit_state -> channels [ addr ] ; <S2SV_EndBug> mutex_lock ( & pit_state -> lock ) ; if ( s -> status_latched ) { s -> status_latched = 0 ; ret = s -> status ; } else if ( s -> count_latched ) { switch ( s -> count_latched ) { default : case RW_STATE_LSB : ret = s -> latched_count & 0xff ; s -> count_latched = 0 ; break ; case RW_STATE_MSB : ret = s -> latched_count >> 8 ; s -> count_latched = 0 ; break ; case RW_STATE_WORD0 : ret = s -> latched_count & 0xff ; s -> count_latched = RW_STATE_MSB ; break ; } } else { switch ( s -> read_state ) { default : case RW_STATE_LSB : count = pit_get_count ( kvm , addr ) ; ret = count & 0xff ; break ; case RW_STATE_MSB : count = pit_get_count ( kvm , addr ) ; ret = ( count >> 8 ) & 0xff ; break ; case RW_STATE_WORD0 : count = pit_get_count ( kvm , addr ) ; ret = count & 0xff ; s -> read_state = RW_STATE_WORD1 ; break ; case RW_STATE_WORD1 : count = pit_get_count ( kvm , addr ) ; ret = ( count >> 8 ) & 0xff ; s -> read_state = RW_STATE_WORD0 ; break ; } } if ( len > sizeof ( ret ) ) len = sizeof ( ret ) ; memcpy ( data , ( char * ) & ret , len ) ; mutex_unlock ( & pit_state -> lock ) ; return 0 ; }",<S2SV_ModStart> &= KVM_PIT_CHANNEL_MASK ; if ( addr == 3 ) return 0 ;,torvalds@linux/ee73f656a604d5aa9df86a97102e4e462dd79924,CVE-2015-3214,https://github.com/torvalds/linux/commit/ee73f656a604d5aa9df86a97102e4e462dd79924,2015-08-31T10:59Z
CWE-119,"CWE-119 static int adjust_scalar_min_max_vals ( struct bpf_verifier_env * env , struct bpf_insn * insn , struct bpf_reg_state * dst_reg , struct bpf_reg_state src_reg ) { struct bpf_reg_state * regs = cur_regs ( env ) ; u8 opcode = BPF_OP ( insn -> code ) ; bool src_known , dst_known ; s64 smin_val , smax_val ; u64 umin_val , umax_val ; <S2SV_StartBug> if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { <S2SV_EndBug> coerce_reg_to_size ( dst_reg , 4 ) ; coerce_reg_to_size ( & src_reg , 4 ) ; } smin_val = src_reg . smin_value ; smax_val = src_reg . smax_value ; umin_val = src_reg . umin_value ; umax_val = src_reg . umax_value ; src_known = tnum_is_const ( src_reg . var_off ) ; dst_known = tnum_is_const ( dst_reg -> var_off ) ; switch ( opcode ) { case BPF_ADD : if ( signed_add_overflows ( dst_reg -> smin_value , smin_val ) || signed_add_overflows ( dst_reg -> smax_value , smax_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value += smin_val ; dst_reg -> smax_value += smax_val ; } if ( dst_reg -> umin_value + umin_val < umin_val || dst_reg -> umax_value + umax_val < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value += umin_val ; dst_reg -> umax_value += umax_val ; } dst_reg -> var_off = tnum_add ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_SUB : if ( signed_sub_overflows ( dst_reg -> smin_value , smax_val ) || signed_sub_overflows ( dst_reg -> smax_value , smin_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value -= smax_val ; dst_reg -> smax_value -= smin_val ; } if ( dst_reg -> umin_value < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value -= umax_val ; dst_reg -> umax_value -= umin_val ; } dst_reg -> var_off = tnum_sub ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_MUL : dst_reg -> var_off = tnum_mul ( dst_reg -> var_off , src_reg . var_off ) ; if ( smin_val < 0 || dst_reg -> smin_value < 0 ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } if ( umax_val > U32_MAX || dst_reg -> umax_value > U32_MAX ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } dst_reg -> umin_value *= umin_val ; dst_reg -> umax_value *= umax_val ; if ( dst_reg -> umax_value > S64_MAX ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } break ; case BPF_AND : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value & src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_and ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = dst_reg -> var_off . value ; dst_reg -> umax_value = min ( dst_reg -> umax_value , umax_val ) ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_OR : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value | src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_or ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = max ( dst_reg -> umin_value , umin_val ) ; dst_reg -> umax_value = dst_reg -> var_off . value | dst_reg -> var_off . mask ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_LSH : <S2SV_StartBug> if ( umax_val > 63 ) { <S2SV_EndBug> mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; if ( dst_reg -> umax_value > 1ULL << ( 63 - umax_val ) ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value <<= umin_val ; dst_reg -> umax_value <<= umax_val ; } if ( src_known ) dst_reg -> var_off = tnum_lshift ( dst_reg -> var_off , umin_val ) ; else dst_reg -> var_off = tnum_lshift ( tnum_unknown , umin_val ) ; __update_reg_bounds ( dst_reg ) ; break ; case BPF_RSH : <S2SV_StartBug> if ( umax_val > 63 ) { <S2SV_EndBug> mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; if ( src_known ) dst_reg -> var_off = tnum_rshift ( dst_reg -> var_off , umin_val ) ; else dst_reg -> var_off = tnum_rshift ( tnum_unknown , umin_val ) ; dst_reg -> umin_value >>= umax_val ; dst_reg -> umax_value >>= umin_val ; __update_reg_bounds ( dst_reg ) ; break ; default : mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } <S2SV_StartBug> __reg_deduce_bounds ( dst_reg ) ; <S2SV_EndBug> __reg_bound_offset ( dst_reg ) ; return 0 ; }","<S2SV_ModStart> , umax_val ; u64 insn_bitness = <S2SV_ModEnd> ( BPF_CLASS ( <S2SV_ModStart> -> code ) == BPF_ALU64 ) ? 64 : 32 ; <S2SV_ModEnd> smin_val = src_reg <S2SV_ModStart> if ( umax_val >= insn_bitness <S2SV_ModEnd> ) { mark_reg_unknown <S2SV_ModStart> if ( umax_val >= insn_bitness <S2SV_ModEnd> ) { mark_reg_unknown <S2SV_ModStart> break ; } if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { coerce_reg_to_size ( dst_reg , 4 ) ; coerce_reg_to_size ( & src_reg , 4 ) ; }",torvalds@linux/468f6eafa6c44cb2c5d8aad35e12f06c240a812a,CVE-2017-17852,https://github.com/torvalds/linux/commit/468f6eafa6c44cb2c5d8aad35e12f06c240a812a,2017-12-27T17:08Z
CWE-119,"CWE-119 static vpx_codec_err_t ctrl_get_reference ( vpx_codec_alg_priv_t * ctx , <S2SV_StartBug> int ctr_id , va_list args ) { <S2SV_EndBug> <S2SV_StartBug> vp9_ref_frame_t * frame = va_arg ( args , vp9_ref_frame_t * ) ; <S2SV_EndBug> if ( frame != NULL ) { <S2SV_StartBug> YV12_BUFFER_CONFIG * fb ; <S2SV_EndBug> <S2SV_StartBug> vp9_get_reference_enc ( ctx -> cpi , frame -> idx , & fb ) ; <S2SV_EndBug> yuvconfig2image ( & frame -> img , fb , NULL ) ; return VPX_CODEC_OK ; } else { return VPX_CODEC_INVALID_PARAM ; } }","<S2SV_ModStart> * ctx , <S2SV_ModEnd> va_list args ) <S2SV_ModStart> { vp9_ref_frame_t * const <S2SV_ModStart> YV12_BUFFER_CONFIG * fb = get_ref_frame ( & <S2SV_ModEnd> ctx -> cpi <S2SV_ModStart> ctx -> cpi -> common <S2SV_ModStart> frame -> idx ) ; if ( fb == NULL ) return VPX_CODEC_ERROR <S2SV_ModEnd> ; yuvconfig2image (",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-284,"CWE-284 void preproc_mount_mnt_dir ( void ) { if ( ! tmpfs_mounted ) { if ( arg_debug ) printf ( ""Mounting<S2SV_blank>tmpfs<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>directory\\n"" , RUN_MNT_DIR ) ; if ( mount ( ""tmpfs"" , RUN_MNT_DIR , ""tmpfs"" , MS_NOSUID | MS_STRICTATIME , ""mode=755,gid=0"" ) < 0 ) errExit ( ""mounting<S2SV_blank>/run/firejail/mnt"" ) ; tmpfs_mounted = 1 ; fs_logger2 ( ""tmpfs"" , RUN_MNT_DIR ) ; # ifdef HAVE_SECCOMP <S2SV_StartBug> if ( arg_seccomp_block_secondary ) <S2SV_EndBug> copy_file ( PATH_SECCOMP_BLOCK_SECONDARY , RUN_SECCOMP_BLOCK_SECONDARY , getuid ( ) , getgid ( ) , 0644 ) ; else { copy_file ( PATH_SECCOMP_32 , RUN_SECCOMP_32 , getuid ( ) , getgid ( ) , 0644 ) ; } if ( arg_allow_debuggers ) copy_file ( PATH_SECCOMP_DEFAULT_DEBUG , RUN_SECCOMP_CFG , getuid ( ) , getgid ( ) , 0644 ) ; else copy_file ( PATH_SECCOMP_DEFAULT , RUN_SECCOMP_CFG , getuid ( ) , getgid ( ) , 0644 ) ; if ( arg_memory_deny_write_execute ) copy_file ( PATH_SECCOMP_MDWX , RUN_SECCOMP_MDWX , getuid ( ) , getgid ( ) , 0644 ) ; create_empty_file_as_root ( RUN_SECCOMP_PROTOCOL , 0644 ) ; if ( set_perms ( RUN_SECCOMP_PROTOCOL , getuid ( ) , getgid ( ) , 0644 ) ) errExit ( ""set_perms"" ) ; create_empty_file_as_root ( RUN_SECCOMP_POSTEXEC , 0644 ) ; if ( set_perms ( RUN_SECCOMP_POSTEXEC , getuid ( ) , getgid ( ) , 0644 ) ) errExit ( ""set_perms"" ) ; # endif } }","<S2SV_ModStart> # ifdef HAVE_SECCOMP create_empty_dir_as_root ( RUN_SECCOMP_DIR , 0755 ) ;",netblue30@firejail/eecf35c2f8249489a1d3e512bb07f0d427183134,CVE-2019-12589,https://github.com/netblue30/firejail/commit/eecf35c2f8249489a1d3e512bb07f0d427183134,2019-06-03T03:29Z
CWE-119,"CWE-119 static long ioctl_file_dedupe_range ( struct file * file , void __user * arg ) { struct file_dedupe_range __user * argp = arg ; struct file_dedupe_range * same = NULL ; int ret ; unsigned long size ; u16 count ; if ( get_user ( count , & argp -> dest_count ) ) { ret = - EFAULT ; goto out ; } size = offsetof ( struct file_dedupe_range __user , info [ count ] ) ; same = memdup_user ( argp , size ) ; if ( IS_ERR ( same ) ) { ret = PTR_ERR ( same ) ; same = NULL ; goto out ; } <S2SV_StartBug> ret = vfs_dedupe_file_range ( file , same ) ; <S2SV_EndBug> if ( ret ) goto out ; ret = copy_to_user ( argp , same , size ) ; if ( ret ) ret = - EFAULT ; out : kfree ( same ) ; return ret ; }",<S2SV_ModStart> out ; } same -> dest_count = count ;,torvalds@linux/10eec60ce79187686e052092e5383c99b4420a20,CVE-2016-6516,https://github.com/torvalds/linux/commit/10eec60ce79187686e052092e5383c99b4420a20,2016-08-06T20:59Z
CWE-119,"CWE-119 static int filter_frame ( AVFilterLink * inlink , AVFrame * in ) { unsigned x , y ; AVFilterContext * ctx = inlink -> dst ; VignetteContext * s = ctx -> priv ; AVFilterLink * outlink = inlink -> dst -> outputs [ 0 ] ; AVFrame * out ; out = ff_get_video_buffer ( outlink , outlink -> w , outlink -> h ) ; if ( ! out ) { av_frame_free ( & in ) ; return AVERROR ( ENOMEM ) ; } av_frame_copy_props ( out , in ) ; if ( s -> eval_mode == EVAL_MODE_FRAME ) update_context ( s , inlink , in ) ; if ( s -> desc -> flags & AV_PIX_FMT_FLAG_RGB ) { uint8_t * dst = out -> data [ 0 ] ; const uint8_t * src = in -> data [ 0 ] ; const float * fmap = s -> fmap ; const int dst_linesize = out -> linesize [ 0 ] ; const int src_linesize = in -> linesize [ 0 ] ; const int fmap_linesize = s -> fmap_linesize ; for ( y = 0 ; y < inlink -> h ; y ++ ) { uint8_t * dstp = dst ; const uint8_t * srcp = src ; for ( x = 0 ; x < inlink -> w ; x ++ , dstp += 3 , srcp += 3 ) { const float f = fmap [ x ] ; dstp [ 0 ] = av_clip_uint8 ( srcp [ 0 ] * f + get_dither_value ( s ) ) ; dstp [ 1 ] = av_clip_uint8 ( srcp [ 1 ] * f + get_dither_value ( s ) ) ; dstp [ 2 ] = av_clip_uint8 ( srcp [ 2 ] * f + get_dither_value ( s ) ) ; } dst += dst_linesize ; src += src_linesize ; fmap += fmap_linesize ; } } else { int plane ; <S2SV_StartBug> for ( plane = 0 ; plane < 4 && in -> data [ plane ] ; plane ++ ) { <S2SV_EndBug> uint8_t * dst = out -> data [ plane ] ; const uint8_t * src = in -> data [ plane ] ; const float * fmap = s -> fmap ; const int dst_linesize = out -> linesize [ plane ] ; const int src_linesize = in -> linesize [ plane ] ; const int fmap_linesize = s -> fmap_linesize ; const int chroma = plane == 1 || plane == 2 ; const int hsub = chroma ? s -> desc -> log2_chroma_w : 0 ; const int vsub = chroma ? s -> desc -> log2_chroma_h : 0 ; const int w = FF_CEIL_RSHIFT ( inlink -> w , hsub ) ; const int h = FF_CEIL_RSHIFT ( inlink -> h , vsub ) ; for ( y = 0 ; y < h ; y ++ ) { uint8_t * dstp = dst ; const uint8_t * srcp = src ; for ( x = 0 ; x < w ; x ++ ) { const double dv = get_dither_value ( s ) ; if ( chroma ) * dstp ++ = av_clip_uint8 ( fmap [ x << hsub ] * ( * srcp ++ - 127 ) + 127 + dv ) ; else * dstp ++ = av_clip_uint8 ( fmap [ x ] * * srcp ++ + dv ) ; } dst += dst_linesize ; src += src_linesize ; fmap += fmap_linesize << vsub ; } } } return ff_filter_frame ( outlink , out ) ; }",<S2SV_ModStart> in -> data [ plane ] && in -> linesize,FFmpeg@FFmpeg/e43a0a232dbf6d3c161823c2e07c52e76227a1bc,CVE-2013-4263,https://github.com/FFmpeg/FFmpeg/commit/e43a0a232dbf6d3c161823c2e07c52e76227a1bc,2013-11-23T17:55Z
CWE-787,"CWE-787 grub_ssize_t grub_fshelp_read_file ( grub_disk_t disk , grub_fshelp_node_t node , void ( * read_hook ) ( grub_disk_addr_t sector , unsigned offset , unsigned length , void * closure ) , void * closure , int flags , grub_off_t pos , grub_size_t len , char * buf , grub_disk_addr_t ( * get_block ) ( grub_fshelp_node_t node , grub_disk_addr_t block ) , grub_off_t filesize , int log2blocksize ) { grub_disk_addr_t i , blockcnt ; int blocksize = 1 << ( log2blocksize + GRUB_DISK_SECTOR_BITS ) ; if ( pos + len > filesize ) len = filesize - pos ; <S2SV_StartBug> blockcnt = ( ( len + pos ) + blocksize - 1 ) >> <S2SV_EndBug> ( log2blocksize + GRUB_DISK_SECTOR_BITS ) ; for ( i = pos >> ( log2blocksize + GRUB_DISK_SECTOR_BITS ) ; i < blockcnt ; i ++ ) { grub_disk_addr_t blknr ; int blockoff = pos & ( blocksize - 1 ) ; int blockend = blocksize ; int skipfirst = 0 ; blknr = get_block ( node , i ) ; if ( grub_errno ) return - 1 ; blknr = blknr << log2blocksize ; if ( i == blockcnt - 1 ) { blockend = ( len + pos ) & ( blocksize - 1 ) ; if ( ! blockend ) blockend = blocksize ; } if ( i == ( pos >> ( log2blocksize + GRUB_DISK_SECTOR_BITS ) ) ) { skipfirst = blockoff ; blockend -= skipfirst ; } if ( blknr ) { disk -> read_hook = read_hook ; disk -> closure = closure ; grub_hack_lastoff = blknr * 512 ; grub_disk_read_ex ( disk , blknr , skipfirst , blockend , buf , flags ) ; disk -> read_hook = 0 ; if ( grub_errno ) return - 1 ; } else if ( buf ) grub_memset ( buf , 0 , blockend ) ; if ( buf ) buf += blocksize - skipfirst ; } return len ; }",<S2SV_ModStart> - pos ; if ( len < 1 || len == 0xffffffff ) { return - 1 ; },radare@radare2/796dd28aaa6b9fa76d99c42c4d5ff8b257cc2191,CVE-2017-9949,https://github.com/radare/radare2/commit/796dd28aaa6b9fa76d99c42c4d5ff8b257cc2191,2017-06-26T20:29Z
,"CWE-000 void ping_unhash ( struct sock * sk ) { struct inet_sock * isk = inet_sk ( sk ) ; pr_debug ( ""ping_unhash(isk=%p,isk->num=%u)\\n"" , isk , isk -> inet_num ) ; <S2SV_StartBug> if ( sk_hashed ( sk ) ) { <S2SV_EndBug> <S2SV_StartBug> write_lock_bh ( & ping_table . lock ) ; <S2SV_EndBug> hlist_nulls_del ( & sk -> sk_nulls_node ) ; sk_nulls_node_init ( & sk -> sk_nulls_node ) ; sock_put ( sk ) ; isk -> inet_num = 0 ; isk -> inet_sport = 0 ; sock_prot_inuse_add ( sock_net ( sk ) , sk -> sk_prot , - 1 ) ; <S2SV_StartBug> write_unlock_bh ( & ping_table . lock ) ; <S2SV_EndBug> } <S2SV_StartBug> } <S2SV_EndBug>",<S2SV_ModStart> inet_num ) ; write_lock_bh ( & ping_table . lock ) ; <S2SV_ModStart> ) ) { <S2SV_ModEnd> hlist_nulls_del ( & <S2SV_ModStart> 1 ) ; } <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>,torvalds@linux/43a6684519ab0a6c52024b5e25322476cabad893,CVE-2017-2671,https://github.com/torvalds/linux/commit/43a6684519ab0a6c52024b5e25322476cabad893,2017-04-05T06:59Z
,"CWE-000 static struct sk_buff * udp6_ufo_fragment ( struct sk_buff * skb , u32 features ) { struct sk_buff * segs = ERR_PTR ( - EINVAL ) ; unsigned int mss ; unsigned int unfrag_ip6hlen , unfrag_len ; struct frag_hdr * fptr ; u8 * mac_start , * prevhdr ; u8 nexthdr ; u8 frag_hdr_sz = sizeof ( struct frag_hdr ) ; int offset ; __wsum csum ; mss = skb_shinfo ( skb ) -> gso_size ; if ( unlikely ( skb -> len <= mss ) ) goto out ; if ( skb_gso_ok ( skb , features | NETIF_F_GSO_ROBUST ) ) { int type = skb_shinfo ( skb ) -> gso_type ; if ( unlikely ( type & ~ ( SKB_GSO_UDP | SKB_GSO_DODGY ) || ! ( type & ( SKB_GSO_UDP ) ) ) ) goto out ; skb_shinfo ( skb ) -> gso_segs = DIV_ROUND_UP ( skb -> len , mss ) ; segs = NULL ; goto out ; } offset = skb_checksum_start_offset ( skb ) ; csum = skb_checksum ( skb , offset , skb -> len - offset , 0 ) ; offset += skb -> csum_offset ; * ( __sum16 * ) ( skb -> data + offset ) = csum_fold ( csum ) ; skb -> ip_summed = CHECKSUM_NONE ; if ( ( skb_mac_header ( skb ) < skb -> head + frag_hdr_sz ) && pskb_expand_head ( skb , frag_hdr_sz , 0 , GFP_ATOMIC ) ) goto out ; unfrag_ip6hlen = ip6_find_1stfragopt ( skb , & prevhdr ) ; nexthdr = * prevhdr ; * prevhdr = NEXTHDR_FRAGMENT ; unfrag_len = skb_network_header ( skb ) - skb_mac_header ( skb ) + unfrag_ip6hlen ; mac_start = skb_mac_header ( skb ) ; memmove ( mac_start - frag_hdr_sz , mac_start , unfrag_len ) ; skb -> mac_header -= frag_hdr_sz ; skb -> network_header -= frag_hdr_sz ; fptr = ( struct frag_hdr * ) ( skb_network_header ( skb ) + unfrag_ip6hlen ) ; fptr -> nexthdr = nexthdr ; fptr -> reserved = 0 ; <S2SV_StartBug> ipv6_select_ident ( fptr ) ; <S2SV_EndBug> segs = skb_segment ( skb , features ) ; out : return segs ; }","<S2SV_ModStart> ipv6_select_ident ( fptr , ( struct rt6_info * ) skb_dst ( skb )",torvalds@linux/87c48fa3b4630905f98268dde838ee43626a060c,CVE-2011-2699,https://github.com/torvalds/linux/commit/87c48fa3b4630905f98268dde838ee43626a060c,2012-05-24T23:55Z
CWE-787,"CWE-787 int mwifiex_ret_wmm_get_status ( struct mwifiex_private * priv , const struct host_cmd_ds_command * resp ) { u8 * curr = ( u8 * ) & resp -> params . get_wmm_status ; uint16_t resp_len = le16_to_cpu ( resp -> size ) , tlv_len ; int mask = IEEE80211_WMM_IE_AP_QOSINFO_PARAM_SET_CNT_MASK ; bool valid = true ; struct mwifiex_ie_types_data * tlv_hdr ; struct mwifiex_ie_types_wmm_queue_status * tlv_wmm_qstatus ; struct ieee_types_wmm_parameter * wmm_param_ie = NULL ; struct mwifiex_wmm_ac_status * ac_status ; mwifiex_dbg ( priv -> adapter , INFO , ""info:<S2SV_blank>WMM:<S2SV_blank>WMM_GET_STATUS<S2SV_blank>cmdresp<S2SV_blank>received:<S2SV_blank>%d\\n"" , resp_len ) ; while ( ( resp_len >= sizeof ( tlv_hdr -> header ) ) && valid ) { tlv_hdr = ( struct mwifiex_ie_types_data * ) curr ; tlv_len = le16_to_cpu ( tlv_hdr -> header . len ) ; if ( resp_len < tlv_len + sizeof ( tlv_hdr -> header ) ) break ; switch ( le16_to_cpu ( tlv_hdr -> header . type ) ) { case TLV_TYPE_WMMQSTATUS : tlv_wmm_qstatus = ( struct mwifiex_ie_types_wmm_queue_status * ) tlv_hdr ; mwifiex_dbg ( priv -> adapter , CMD , ""info:<S2SV_blank>CMD_RESP:<S2SV_blank>WMM_GET_STATUS:\\t"" ""QSTATUS<S2SV_blank>TLV:<S2SV_blank>%d,<S2SV_blank>%d,<S2SV_blank>%d\\n"" , tlv_wmm_qstatus -> queue_index , tlv_wmm_qstatus -> flow_required , tlv_wmm_qstatus -> disabled ) ; ac_status = & priv -> wmm . ac_status [ tlv_wmm_qstatus -> queue_index ] ; ac_status -> disabled = tlv_wmm_qstatus -> disabled ; ac_status -> flow_required = tlv_wmm_qstatus -> flow_required ; ac_status -> flow_created = tlv_wmm_qstatus -> flow_created ; break ; case WLAN_EID_VENDOR_SPECIFIC : wmm_param_ie = ( struct ieee_types_wmm_parameter * ) ( curr + 2 ) ; wmm_param_ie -> vend_hdr . len = ( u8 ) tlv_len ; wmm_param_ie -> vend_hdr . element_id = WLAN_EID_VENDOR_SPECIFIC ; mwifiex_dbg ( priv -> adapter , CMD , ""info:<S2SV_blank>CMD_RESP:<S2SV_blank>WMM_GET_STATUS:\\t"" ""WMM<S2SV_blank>Parameter<S2SV_blank>Set<S2SV_blank>Count:<S2SV_blank>%d\\n"" , wmm_param_ie -> qos_info_bitmap & mask ) ; <S2SV_StartBug> memcpy ( ( u8 * ) & priv -> curr_bss_params . bss_descriptor . <S2SV_EndBug> wmm_ie , wmm_param_ie , wmm_param_ie -> vend_hdr . len + 2 ) ; break ; default : valid = false ; break ; } curr += ( tlv_len + sizeof ( tlv_hdr -> header ) ) ; resp_len -= ( tlv_len + sizeof ( tlv_hdr -> header ) ) ; } mwifiex_wmm_setup_queue_priorities ( priv , wmm_param_ie ) ; mwifiex_wmm_setup_ac_downgrade ( priv ) ; return 0 ; }",<S2SV_ModStart> mask ) ; if ( wmm_param_ie -> vend_hdr . len + 2 > sizeof ( struct ieee_types_wmm_parameter ) ) break ;,torvalds@linux/3a9b153c5591548612c3955c9600a98150c81875,CVE-2020-12654,https://github.com/torvalds/linux/commit/3a9b153c5591548612c3955c9600a98150c81875,2020-05-05T05:15Z
CWE-284,"CWE-284 static int accept_server_socket ( int sfd ) { struct sockaddr_un remote ; struct pollfd pfd ; int fd ; socklen_t len = sizeof ( struct sockaddr_un ) ; BTIF_TRACE_EVENT ( ""accept<S2SV_blank>fd<S2SV_blank>%d"" , sfd ) ; pfd . fd = sfd ; pfd . events = POLLIN ; <S2SV_StartBug> if ( poll ( & pfd , 1 , 0 ) == 0 ) <S2SV_EndBug> { BTIF_TRACE_EVENT ( ""accept<S2SV_blank>poll<S2SV_blank>timeout"" ) ; return - 1 ; } <S2SV_StartBug> if ( ( fd = accept ( sfd , ( struct sockaddr * ) & remote , & len ) ) == - 1 ) <S2SV_EndBug> { BTIF_TRACE_ERROR ( ""sock<S2SV_blank>accept<S2SV_blank>failed<S2SV_blank>(%s)"" , strerror ( errno ) ) ; return - 1 ; } return fd ; }","<S2SV_ModStart> ; if ( TEMP_FAILURE_RETRY ( <S2SV_ModStart> 1 , 0 ) <S2SV_ModStart> ( fd = TEMP_FAILURE_RETRY ( <S2SV_ModStart> , & len )",system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z
NVD-CWE-noinfo,"CWE-000 static int uECC_sign_with_k ( const uint8_t * private_key , const uint8_t * message_hash , unsigned hash_size , uECC_word_t * k , uint8_t * signature , uECC_Curve curve ) { uECC_word_t tmp [ uECC_MAX_WORDS ] ; uECC_word_t s [ uECC_MAX_WORDS ] ; uECC_word_t * k2 [ 2 ] = { tmp , s } ; <S2SV_StartBug> # if uECC_VLI_NATIVE_LITTLE_ENDIAN <S2SV_EndBug> uECC_word_t * p = ( uECC_word_t * ) signature ; # else uECC_word_t p [ uECC_MAX_WORDS * 2 ] ; # endif uECC_word_t carry ; wordcount_t num_words = curve -> num_words ; wordcount_t num_n_words = BITS_TO_WORDS ( curve -> num_n_bits ) ; bitcount_t num_n_bits = curve -> num_n_bits ; if ( uECC_vli_isZero ( k , num_words ) || uECC_vli_cmp ( curve -> n , k , num_n_words ) != 1 ) { return 0 ; } carry = regularize_k ( k , tmp , s , curve ) ; <S2SV_StartBug> EccPoint_mult ( p , curve -> G , k2 [ ! carry ] , 0 , num_n_bits + 1 , curve ) ; <S2SV_EndBug> if ( uECC_vli_isZero ( p , num_words ) ) { return 0 ; } if ( ! g_rng_function ) { uECC_vli_clear ( tmp , num_n_words ) ; tmp [ 0 ] = 1 ; } else if ( ! uECC_generate_random_int ( tmp , curve -> n , num_n_words ) ) { return 0 ; } uECC_vli_modMult ( k , k , tmp , curve -> n , num_n_words ) ; uECC_vli_modInv ( k , k , curve -> n , num_n_words ) ; uECC_vli_modMult ( k , k , tmp , curve -> n , num_n_words ) ; # if uECC_VLI_NATIVE_LITTLE_ENDIAN == 0 uECC_vli_nativeToBytes ( signature , curve -> num_bytes , p ) ; # endif # if uECC_VLI_NATIVE_LITTLE_ENDIAN bcopy ( ( uint8_t * ) tmp , private_key , BITS_TO_BYTES ( curve -> num_n_bits ) ) ; # else uECC_vli_bytesToNative ( tmp , private_key , BITS_TO_BYTES ( curve -> num_n_bits ) ) ; # endif s [ num_n_words - 1 ] = 0 ; uECC_vli_set ( s , p , num_words ) ; uECC_vli_modMult ( s , tmp , s , curve -> n , num_n_words ) ; bits2int ( tmp , message_hash , hash_size , curve ) ; uECC_vli_modAdd ( s , tmp , s , curve -> n , num_n_words ) ; uECC_vli_modMult ( s , s , k , curve -> n , num_n_words ) ; if ( uECC_vli_numBits ( s , num_n_words ) > ( bitcount_t ) curve -> num_bytes * 8 ) { return 0 ; } # if uECC_VLI_NATIVE_LITTLE_ENDIAN bcopy ( ( uint8_t * ) signature + curve -> num_bytes , ( uint8_t * ) s , curve -> num_bytes ) ; # else uECC_vli_nativeToBytes ( signature + curve -> num_bytes , curve -> num_bytes , s ) ; # endif return 1 ; }","<S2SV_ModStart> s } ; uECC_word_t * initial_Z = 0 ; <S2SV_ModStart> curve ) ; if ( g_rng_function ) { if ( ! uECC_generate_random_int ( k2 [ carry ] , curve -> p , num_words ) ) { return 0 ; } initial_Z = k2 [ carry ] ; } <S2SV_ModStart> carry ] , initial_Z <S2SV_ModEnd> , num_n_bits +",kmackay@micro-ecc/1b5f5cea5145c96dd8791b9b2c41424fc74c2172,CVE-2020-27209,https://github.com/kmackay/micro-ecc/commit/1b5f5cea5145c96dd8791b9b2c41424fc74c2172,2021-05-20T21:15Z
CWE-119,"CWE-119 WORD32 ih264d_parse_islice ( dec_struct_t * ps_dec , UWORD16 u2_first_mb_in_slice ) { dec_pic_params_t * ps_pps = ps_dec -> ps_cur_pps ; dec_slice_params_t * ps_slice = ps_dec -> ps_cur_slice ; UWORD32 * pu4_bitstrm_buf = ps_dec -> ps_bitstrm -> pu4_buffer ; UWORD32 * pu4_bitstrm_ofst = & ps_dec -> ps_bitstrm -> u4_ofst ; UWORD32 u4_temp ; WORD32 i_temp ; WORD32 ret ; if ( ps_slice -> u1_nal_ref_idc != 0 ) { if ( ! ps_dec -> ps_dpb_cmds -> u1_dpb_commands_read ) <S2SV_StartBug> ps_dec -> u4_bitoffset = ih264d_read_mmco_commands ( <S2SV_EndBug> ps_dec ) ; else ps_dec -> ps_bitstrm -> u4_ofst += ps_dec -> u4_bitoffset ; } i_temp = ps_pps -> u1_pic_init_qp + ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( ( i_temp < 0 ) || ( i_temp > 51 ) ) return ERROR_INV_RANGE_QP_T ; ps_slice -> u1_slice_qp = i_temp ; COPYTHECONTEXT ( ""SH:<S2SV_blank>slice_qp_delta"" , ps_slice -> u1_slice_qp - ps_pps -> u1_pic_init_qp ) ; if ( ps_pps -> u1_deblocking_filter_parameters_present_flag == 1 ) { u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>disable_deblocking_filter_idc"" , u4_temp ) ; if ( u4_temp > SLICE_BOUNDARY_DBLK_DISABLED ) { return ERROR_INV_SLICE_HDR_T ; } ps_slice -> u1_disable_dblk_filter_idc = u4_temp ; if ( u4_temp != 1 ) { i_temp = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) << 1 ; if ( ( MIN_DBLK_FIL_OFF > i_temp ) || ( i_temp > MAX_DBLK_FIL_OFF ) ) { return ERROR_INV_SLICE_HDR_T ; } ps_slice -> i1_slice_alpha_c0_offset = i_temp ; COPYTHECONTEXT ( ""SH:<S2SV_blank>slice_alpha_c0_offset_div2"" , ps_slice -> i1_slice_alpha_c0_offset >> 1 ) ; i_temp = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) << 1 ; if ( ( MIN_DBLK_FIL_OFF > i_temp ) || ( i_temp > MAX_DBLK_FIL_OFF ) ) { return ERROR_INV_SLICE_HDR_T ; } ps_slice -> i1_slice_beta_offset = i_temp ; COPYTHECONTEXT ( ""SH:<S2SV_blank>slice_beta_offset_div2"" , ps_slice -> i1_slice_beta_offset >> 1 ) ; } else { ps_slice -> i1_slice_alpha_c0_offset = 0 ; ps_slice -> i1_slice_beta_offset = 0 ; } } else { ps_slice -> u1_disable_dblk_filter_idc = 0 ; ps_slice -> i1_slice_alpha_c0_offset = 0 ; ps_slice -> i1_slice_beta_offset = 0 ; } ps_dec -> u2_mv_2mb [ 0 ] = 0 ; ps_dec -> u2_mv_2mb [ 1 ] = 0 ; ps_dec -> u1_slice_header_done = 2 ; if ( ps_pps -> u1_entropy_coding_mode ) { SWITCHOFFTRACE ; SWITCHONTRACECABAC ; if ( ps_dec -> ps_cur_slice -> u1_mbaff_frame_flag ) { ps_dec -> pf_get_mb_info = ih264d_get_mb_info_cabac_mbaff ; } else ps_dec -> pf_get_mb_info = ih264d_get_mb_info_cabac_nonmbaff ; ret = ih264d_parse_islice_data_cabac ( ps_dec , ps_slice , u2_first_mb_in_slice ) ; if ( ret != OK ) return ret ; SWITCHONTRACE ; SWITCHOFFTRACECABAC ; } else { if ( ps_dec -> ps_cur_slice -> u1_mbaff_frame_flag ) { ps_dec -> pf_get_mb_info = ih264d_get_mb_info_cavlc_mbaff ; } else ps_dec -> pf_get_mb_info = ih264d_get_mb_info_cavlc_nonmbaff ; ret = ih264d_parse_islice_data_cavlc ( ps_dec , ps_slice , u2_first_mb_in_slice ) ; if ( ret != OK ) return ret ; } return OK ; }",<S2SV_ModStart> -> u1_dpb_commands_read ) { i_temp = ih264d_read_mmco_commands ( ps_dec ) ; if ( i_temp < 0 ) { return ERROR_DBP_MANAGER_T ; } <S2SV_ModStart> -> u4_bitoffset = i_temp ; } <S2SV_ModEnd> else ps_dec ->,external@libavc/943323f1d9d3dd5c2634deb26cbe72343ca6b3db,CVE-2016-0842,https://android.googlesource.com/platform/external/libavc/+/943323f1d9d3dd5c2634deb26cbe72343ca6b3db,2016-04-18T00:59Z
CWE-416,"CWE-416 static long ion_ioctl ( struct file * filp , unsigned int cmd , unsigned long arg ) { struct ion_client * client = filp -> private_data ; struct ion_device * dev = client -> dev ; struct ion_handle * cleanup_handle = NULL ; int ret = 0 ; unsigned int dir ; union { struct ion_fd_data fd ; struct ion_allocation_data allocation ; struct ion_handle_data handle ; struct ion_custom_data custom ; } data ; dir = ion_ioctl_dir ( cmd ) ; if ( _IOC_SIZE ( cmd ) > sizeof ( data ) ) return - EINVAL ; if ( dir & _IOC_WRITE ) if ( copy_from_user ( & data , ( void __user * ) arg , _IOC_SIZE ( cmd ) ) ) return - EFAULT ; switch ( cmd ) { case ION_IOC_ALLOC : { struct ion_handle * handle ; handle = ion_alloc ( client , data . allocation . len , data . allocation . align , data . allocation . heap_id_mask , data . allocation . flags ) ; if ( IS_ERR ( handle ) ) return PTR_ERR ( handle ) ; data . allocation . handle = handle -> id ; cleanup_handle = handle ; break ; } case ION_IOC_FREE : { struct ion_handle * handle ; <S2SV_StartBug> handle = ion_handle_get_by_id ( client , data . handle . handle ) ; <S2SV_EndBug> <S2SV_StartBug> if ( IS_ERR ( handle ) ) <S2SV_EndBug> return PTR_ERR ( handle ) ; <S2SV_StartBug> ion_free ( client , handle ) ; <S2SV_EndBug> ion_handle_put ( handle ) ; break ; } case ION_IOC_SHARE : case ION_IOC_MAP : { struct ion_handle * handle ; handle = ion_handle_get_by_id ( client , data . handle . handle ) ; if ( IS_ERR ( handle ) ) return PTR_ERR ( handle ) ; data . fd . fd = ion_share_dma_buf_fd ( client , handle ) ; ion_handle_put ( handle ) ; if ( data . fd . fd < 0 ) ret = data . fd . fd ; break ; } case ION_IOC_IMPORT : { struct ion_handle * handle ; handle = ion_import_dma_buf_fd ( client , data . fd . fd ) ; if ( IS_ERR ( handle ) ) ret = PTR_ERR ( handle ) ; else data . handle . handle = handle -> id ; break ; } case ION_IOC_SYNC : { ret = ion_sync_for_device ( client , data . fd . fd ) ; break ; } case ION_IOC_CUSTOM : { if ( ! dev -> custom_ioctl ) return - ENOTTY ; ret = dev -> custom_ioctl ( client , data . custom . cmd , data . custom . arg ) ; break ; } default : return - ENOTTY ; } if ( dir & _IOC_READ ) { if ( copy_to_user ( ( void __user * ) arg , & data , _IOC_SIZE ( cmd ) ) ) { if ( cleanup_handle ) ion_free ( client , cleanup_handle ) ; return - EFAULT ; } } return ret ; }","<S2SV_ModStart> * handle ; mutex_lock ( & client -> lock ) ; handle = ion_handle_get_by_id_nolock <S2SV_ModEnd> ( client , <S2SV_ModStart> handle ) ) { mutex_unlock ( & client -> lock ) ; <S2SV_ModStart> handle ) ; } ion_free_nolock ( client , handle ) ; ion_handle_put_nolock ( handle ) ; mutex_unlock ( & client -> lock <S2SV_ModEnd> ) ; break",torvalds@linux/9590232bb4f4cc824f3425a6e1349afbe6d6d2b7,CVE-2016-9120,https://github.com/torvalds/linux/commit/9590232bb4f4cc824f3425a6e1349afbe6d6d2b7,2016-12-08T21:59Z
CWE-787,"CWE-787 WORD32 ixheaacd_real_synth_filt ( ia_esbr_hbe_txposer_struct * ptr_hbe_txposer , WORD32 num_columns , FLOAT32 qmf_buf_real [ ] [ 64 ] , FLOAT32 qmf_buf_imag [ ] [ 64 ] ) { WORD32 i , j , k , l , idx ; FLOAT32 g [ 640 ] ; FLOAT32 w [ 640 ] ; FLOAT32 synth_out [ 128 ] ; FLOAT32 accu_r ; WORD32 synth_size = ptr_hbe_txposer -> synth_size ; FLOAT32 * ptr_cos_tab_trans_qmf = ( FLOAT32 * ) & ixheaacd_cos_table_trans_qmf [ 0 ] [ 0 ] + ptr_hbe_txposer -> k_start * 32 ; FLOAT32 * buffer = ptr_hbe_txposer -> synth_buf ; for ( idx = 0 ; idx < num_columns ; idx ++ ) { FLOAT32 loc_qmf_buf [ 64 ] ; FLOAT32 * synth_buf_r = loc_qmf_buf ; FLOAT32 * out_buf = ptr_hbe_txposer -> ptr_input_buf + ( idx + 1 ) * ptr_hbe_txposer -> synth_size ; FLOAT32 * synth_cos_tab = ptr_hbe_txposer -> synth_cos_tab ; const FLOAT32 * interp_window_coeff = ptr_hbe_txposer -> synth_wind_coeff ; if ( ptr_hbe_txposer -> k_start < 0 ) return - 1 ; for ( k = 0 ; k < synth_size ; k ++ ) { WORD32 ki = ptr_hbe_txposer -> k_start + k ; synth_buf_r [ k ] = ( FLOAT32 ) ( ptr_cos_tab_trans_qmf [ ( k << 1 ) + 0 ] * qmf_buf_real [ idx ] [ ki ] + ptr_cos_tab_trans_qmf [ ( k << 1 ) + 1 ] * qmf_buf_imag [ idx ] [ ki ] ) ; synth_buf_r [ k + ptr_hbe_txposer -> synth_size ] = 0 ; } for ( l = ( 20 * synth_size - 1 ) ; l >= 2 * synth_size ; l -- ) { buffer [ l ] = buffer [ l - 2 * synth_size ] ; } if ( synth_size == 20 ) { FLOAT32 * psynth_cos_tab = synth_cos_tab ; for ( l = 0 ; l < ( synth_size + 1 ) ; l ++ ) { accu_r = 0.0 ; for ( k = 0 ; k < synth_size ; k ++ ) { accu_r += synth_buf_r [ k ] * psynth_cos_tab [ k ] ; } buffer [ 0 + l ] = accu_r ; buffer [ synth_size - l ] = accu_r ; psynth_cos_tab = psynth_cos_tab + synth_size ; } for ( l = ( synth_size + 1 ) ; l < ( 2 * synth_size - synth_size / 2 ) ; l ++ ) { accu_r = 0.0 ; for ( k = 0 ; k < synth_size ; k ++ ) { accu_r += synth_buf_r [ k ] * psynth_cos_tab [ k ] ; } buffer [ 0 + l ] = accu_r ; buffer [ 3 * synth_size - l ] = - accu_r ; psynth_cos_tab = psynth_cos_tab + synth_size ; } accu_r = 0.0 ; for ( k = 0 ; k < synth_size ; k ++ ) { accu_r += synth_buf_r [ k ] * psynth_cos_tab [ k ] ; } buffer [ 3 * synth_size >> 1 ] = accu_r ; } else { FLOAT32 tmp ; FLOAT32 * ptr_u = synth_out ; WORD32 kmax = ( synth_size >> 1 ) ; FLOAT32 * syn_buf = & buffer [ kmax ] ; kmax += synth_size ; <S2SV_StartBug> if ( ixheaacd_real_synth_fft != NULL ) <S2SV_EndBug> <S2SV_StartBug> ( * ixheaacd_real_synth_fft ) ( synth_buf_r , synth_out , synth_size * 2 ) ; <S2SV_EndBug> else return - 1 ; for ( k = 0 ; k < kmax ; k ++ ) { tmp = ( ( * ptr_u ++ ) * ( * synth_cos_tab ++ ) ) ; tmp -= ( ( * ptr_u ++ ) * ( * synth_cos_tab ++ ) ) ; * syn_buf ++ = tmp ; } syn_buf = & buffer [ 0 ] ; kmax -= synth_size ; for ( k = 0 ; k < kmax ; k ++ ) { tmp = ( ( * ptr_u ++ ) * ( * synth_cos_tab ++ ) ) ; tmp -= ( ( * ptr_u ++ ) * ( * synth_cos_tab ++ ) ) ; * syn_buf ++ = tmp ; } } for ( i = 0 ; i < 5 ; i ++ ) { memcpy ( & g [ ( 2 * i + 0 ) * synth_size ] , & buffer [ ( 4 * i + 0 ) * synth_size ] , sizeof ( FLOAT32 ) * synth_size ) ; memcpy ( & g [ ( 2 * i + 1 ) * synth_size ] , & buffer [ ( 4 * i + 3 ) * synth_size ] , sizeof ( FLOAT32 ) * synth_size ) ; } for ( k = 0 ; k < 10 * synth_size ; k ++ ) { w [ k ] = g [ k ] * interp_window_coeff [ k ] ; } for ( i = 0 ; i < synth_size ; i ++ ) { accu_r = 0.0 ; for ( j = 0 ; j < 10 ; j ++ ) { accu_r = accu_r + w [ synth_size * j + i ] ; } out_buf [ i ] = ( FLOAT32 ) accu_r ; } } return 0 ; }","<S2SV_ModStart> ; if ( ptr_hbe_txposer -> <S2SV_ModStart> ) ( * ( ptr_hbe_txposer -> ixheaacd_real_synth_fft ) ) <S2SV_ModEnd> ( synth_buf_r ,",external@libxaac/04e8cd58f075bec5892e369c8deebca9c67e855c,CVE-2018-9496,https://android.googlesource.com/platform/external/libxaac/+/04e8cd58f075bec5892e369c8deebca9c67e855c,2018-10-02T19:29Z
CWE-399,"CWE-399 static void hugetlb_vm_op_close ( struct vm_area_struct * vma ) { struct hstate * h = hstate_vma ( vma ) ; struct resv_map * reservations = vma_resv_map ( vma ) ; struct hugepage_subpool * spool = subpool_vma ( vma ) ; unsigned long reserve ; unsigned long start ; unsigned long end ; if ( reservations ) { start = vma_hugecache_offset ( h , vma , vma -> vm_start ) ; end = vma_hugecache_offset ( h , vma , vma -> vm_end ) ; reserve = ( end - start ) - region_count ( & reservations -> regions , start , end ) ; <S2SV_StartBug> kref_put ( & reservations -> refs , resv_map_release ) ; <S2SV_EndBug> if ( reserve ) { hugetlb_acct_memory ( h , - reserve ) ; hugepage_subpool_put_pages ( spool , reserve ) ; } } }",<S2SV_ModStart> end ) ; resv_map_put ( vma <S2SV_ModEnd> ) ; if,torvalds@linux/c50ac050811d6485616a193eb0f37bfbd191cc89,CVE-2012-2390,https://github.com/torvalds/linux/commit/c50ac050811d6485616a193eb0f37bfbd191cc89,2012-06-13T10:24Z
CWE-190,"CWE-190 static void addArgumentToVtab ( Parse * pParse ) { if ( pParse -> sArg . z && pParse -> pNewTable ) { const char * z = ( const char * ) pParse -> sArg . z ; int n = pParse -> sArg . n ; sqlite3 * db = pParse -> db ; <S2SV_StartBug> addModuleArgument ( db , pParse -> pNewTable , sqlite3DbStrNDup ( db , z , n ) ) ; <S2SV_EndBug> } }","<S2SV_ModStart> ; addModuleArgument ( pParse <S2SV_ModEnd> , pParse ->",chromium@chromium/517ac71c9ee27f856f9becde8abea7d1604af9d4,CVE-2019-5827,https://github.com/chromium/chromium/commit/517ac71c9ee27f856f9becde8abea7d1604af9d4,2019-06-27T17:15Z
CWE-119,"CWE-119 int sc_file_set_sec_attr ( sc_file_t * file , const u8 * sec_attr , size_t sec_attr_len ) { u8 * tmp ; if ( ! sc_file_valid ( file ) ) { return SC_ERROR_INVALID_ARGUMENTS ; } <S2SV_StartBug> if ( sec_attr == NULL ) { <S2SV_EndBug> if ( file -> sec_attr != NULL ) free ( file -> sec_attr ) ; file -> sec_attr = NULL ; file -> sec_attr_len = 0 ; return 0 ; } tmp = ( u8 * ) realloc ( file -> sec_attr , sec_attr_len ) ; if ( ! tmp ) { if ( file -> sec_attr ) free ( file -> sec_attr ) ; file -> sec_attr = NULL ; file -> sec_attr_len = 0 ; return SC_ERROR_OUT_OF_MEMORY ; } file -> sec_attr = tmp ; memcpy ( file -> sec_attr , sec_attr , sec_attr_len ) ; file -> sec_attr_len = sec_attr_len ; return 0 ; }",<S2SV_ModStart> sec_attr == NULL || sec_attr_len,OpenSC@OpenSC/360e95d45ac4123255a4c796db96337f332160ad,CVE-2018-16391,https://github.com/OpenSC/OpenSC/commit/360e95d45ac4123255a4c796db96337f332160ad#diff-477b7a40136bb418b10ce271c8664536,2018-09-03T14:29Z
CWE-20,"CWE-20 void enc624j600UpdateMacConfig ( NetInterface * interface ) { uint16_t duplexMode ; <S2SV_StartBug> duplexMode = enc624j600ReadReg ( interface , ENC624J600_REG_ESTAT ) & ESTAT_PHYDPX ; <S2SV_EndBug> if ( duplexMode ) { <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_MACON2 , MACON2_DEFER | <S2SV_EndBug> MACON2_PADCFG2 | MACON2_PADCFG0 | MACON2_TXCRCEN | MACON2_R1 | MACON2_FULDPX ) ; <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_MABBIPG , 0x15 ) ; <S2SV_EndBug> } else { <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_MACON2 , MACON2_DEFER | <S2SV_EndBug> MACON2_PADCFG2 | MACON2_PADCFG0 | MACON2_TXCRCEN | MACON2_R1 ) ; <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_MABBIPG , 0x12 ) ; <S2SV_EndBug> } }","<S2SV_ModStart> ( interface , ENC624J600_ESTAT ) & ENC624J600_ESTAT_PHYDPX <S2SV_ModEnd> ; if ( <S2SV_ModStart> ( interface , ENC624J600_MACON2 , ENC624J600_MACON2_DEFER | ENC624J600_MACON2_PADCFG_AUTO | ENC624J600_MACON2_TXCRCEN | ENC624J600_MACON2_R1_DEFAULT | ENC624J600_MACON2_FULDPX <S2SV_ModEnd> ) ; enc624j600WriteReg <S2SV_ModStart> ( interface , ENC624J600_MABBIPG , ENC624J600_MABBIPG_BBIPG_DEFAULT_FD <S2SV_ModEnd> ) ; } <S2SV_ModStart> ( interface , ENC624J600_MACON2 , ENC624J600_MACON2_DEFER | ENC624J600_MACON2_PADCFG_AUTO | ENC624J600_MACON2_TXCRCEN | ENC624J600_MACON2_R1_DEFAULT <S2SV_ModEnd> ) ; enc624j600WriteReg <S2SV_ModStart> ( interface , ENC624J600_MABBIPG , ENC624J600_MABBIPG_BBIPG_DEFAULT_HD <S2SV_ModEnd> ) ; }",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z
,"CWE-000 static struct sk_buff * xfrm_state_netlink ( struct sk_buff * in_skb , struct xfrm_state * x , u32 seq ) { struct xfrm_dump_info info ; <S2SV_StartBug> struct sk_buff * skb ; <S2SV_EndBug> skb = nlmsg_new ( NLMSG_DEFAULT_SIZE , GFP_ATOMIC ) ; if ( ! skb ) return ERR_PTR ( - ENOMEM ) ; info . in_skb = in_skb ; info . out_skb = skb ; info . nlmsg_seq = seq ; info . nlmsg_flags = 0 ; <S2SV_StartBug> if ( dump_one_state ( x , 0 , & info ) ) { <S2SV_EndBug> kfree_skb ( skb ) ; <S2SV_StartBug> return NULL ; <S2SV_EndBug> } return skb ; }",<S2SV_ModStart> sk_buff * skb ; int err <S2SV_ModStart> = 0 ; err = <S2SV_ModEnd> dump_one_state ( x <S2SV_ModStart> & info ) ; if ( err <S2SV_ModStart> ) ; return ERR_PTR ( err ) <S2SV_ModEnd> ; } return,torvalds@linux/864745d291b5ba80ea0bd0edcbe67273de368836,CVE-2013-1826,https://github.com/torvalds/linux/commit/864745d291b5ba80ea0bd0edcbe67273de368836,2013-03-22T11:59Z
CWE-310,"CWE-000 int use_conf ( char * test_path ) { int ret ; size_t flags = 0 ; char filename [ 1024 ] , errstr [ 1024 ] ; char * buffer ; FILE * infile , * conffile ; json_t * json ; json_error_t error ; sprintf ( filename , ""%s%cinput"" , test_path , dir_sep ) ; if ( ! ( infile = fopen ( filename , ""rb"" ) ) ) { fprintf ( stderr , ""Could<S2SV_blank>not<S2SV_blank>open<S2SV_blank>\\""%s\\""\\n"" , filename ) ; return 2 ; } sprintf ( filename , ""%s%cenv"" , test_path , dir_sep ) ; conffile = fopen ( filename , ""rb"" ) ; if ( conffile ) { read_conf ( conffile ) ; fclose ( conffile ) ; } if ( conf . indent < 0 || conf . indent > 255 ) { fprintf ( stderr , ""invalid<S2SV_blank>value<S2SV_blank>for<S2SV_blank>JSON_INDENT:<S2SV_blank>%d\\n"" , conf . indent ) ; return 2 ; } if ( conf . indent ) flags |= JSON_INDENT ( conf . indent ) ; if ( conf . compact ) flags |= JSON_COMPACT ; if ( conf . ensure_ascii ) flags |= JSON_ENSURE_ASCII ; if ( conf . preserve_order ) flags |= JSON_PRESERVE_ORDER ; if ( conf . sort_keys ) flags |= JSON_SORT_KEYS ; <S2SV_StartBug> if ( conf . strip ) { <S2SV_EndBug> buffer = loadfile ( infile ) ; json = json_loads ( strip ( buffer ) , 0 , & error ) ; free ( buffer ) ; } else json = json_loadf ( infile , 0 , & error ) ; fclose ( infile ) ; if ( ! json ) { sprintf ( errstr , ""%d<S2SV_blank>%d<S2SV_blank>%d\\n%s\\n"" , error . line , error . column , error . position , error . text ) ; ret = cmpfile ( errstr , test_path , ""error"" ) ; return ret ; } buffer = json_dumps ( json , flags ) ; ret = cmpfile ( buffer , test_path , ""output"" ) ; free ( buffer ) ; json_decref ( json ) ; return ret ; }",<S2SV_ModStart> ( conf . have_hashseed ) json_object_seed ( conf . hashseed ) ; if ( conf .,akheron@jansson/8f80c2d83808150724d31793e6ade92749b1faa4,CVE-2013-6401,https://github.com/akheron/jansson/commit/8f80c2d83808150724d31793e6ade92749b1faa4,2014-03-21T01:04Z
CWE-362,"CWE-362 static int ext4_ext_handle_uninitialized_extents ( handle_t * handle , struct inode * inode , struct ext4_map_blocks * map , struct ext4_ext_path * path , int flags , unsigned int allocated , ext4_fsblk_t newblock ) { int ret = 0 ; int err = 0 ; ext4_io_end_t * io = ext4_inode_aio ( inode ) ; ext_debug ( ""ext4_ext_handle_uninitialized_extents:<S2SV_blank>inode<S2SV_blank>%lu,<S2SV_blank>logical<S2SV_blank>"" ""block<S2SV_blank>%llu,<S2SV_blank>max_blocks<S2SV_blank>%u,<S2SV_blank>flags<S2SV_blank>%x,<S2SV_blank>allocated<S2SV_blank>%u\\n"" , inode -> i_ino , ( unsigned long long ) map -> m_lblk , map -> m_len , flags , allocated ) ; ext4_ext_show_leaf ( inode , path ) ; trace_ext4_ext_handle_uninitialized_extents ( inode , map , allocated , newblock ) ; if ( ( flags & EXT4_GET_BLOCKS_PRE_IO ) ) { ret = ext4_split_unwritten_extents ( handle , inode , map , path , flags ) ; if ( ret <= 0 ) goto out ; if ( io ) ext4_set_io_unwritten_flag ( inode , io ) ; else ext4_set_inode_state ( inode , EXT4_STATE_DIO_UNWRITTEN ) ; if ( ext4_should_dioread_nolock ( inode ) ) map -> m_flags |= EXT4_MAP_UNINIT ; goto out ; } if ( ( flags & EXT4_GET_BLOCKS_CONVERT ) ) { <S2SV_StartBug> ret = ext4_convert_unwritten_extents_endio ( handle , inode , <S2SV_EndBug> path ) ; if ( ret >= 0 ) { ext4_update_inode_fsync_trans ( handle , inode , 1 ) ; err = check_eofblocks_fl ( handle , inode , map -> m_lblk , path , map -> m_len ) ; } else err = ret ; goto out2 ; } if ( flags & EXT4_GET_BLOCKS_UNINIT_EXT ) goto map_out ; if ( ( flags & EXT4_GET_BLOCKS_CREATE ) == 0 ) { map -> m_flags |= EXT4_MAP_UNWRITTEN ; goto out1 ; } ret = ext4_ext_convert_to_initialized ( handle , inode , map , path ) ; if ( ret >= 0 ) ext4_update_inode_fsync_trans ( handle , inode , 1 ) ; out : if ( ret <= 0 ) { err = ret ; goto out2 ; } else allocated = ret ; map -> m_flags |= EXT4_MAP_NEW ; if ( allocated > map -> m_len ) { unmap_underlying_metadata_blocks ( inode -> i_sb -> s_bdev , newblock + map -> m_len , allocated - map -> m_len ) ; allocated = map -> m_len ; } if ( flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE ) { unsigned int reserved_clusters ; reserved_clusters = get_reserved_cluster_alloc ( inode , map -> m_lblk , map -> m_len ) ; if ( reserved_clusters ) ext4_da_update_reserve_space ( inode , reserved_clusters , 0 ) ; } map_out : map -> m_flags |= EXT4_MAP_MAPPED ; if ( ( flags & EXT4_GET_BLOCKS_KEEP_SIZE ) == 0 ) { err = check_eofblocks_fl ( handle , inode , map -> m_lblk , path , map -> m_len ) ; if ( err < 0 ) goto out2 ; } out1 : if ( allocated > map -> m_len ) allocated = map -> m_len ; ext4_ext_show_leaf ( inode , path ) ; map -> m_pblk = newblock ; map -> m_len = allocated ; out2 : if ( path ) { ext4_ext_drop_refs ( path ) ; kfree ( path ) ; } return err ? err : allocated ; }","<S2SV_ModStart> , inode , map ,",torvalds@linux/dee1f973ca341c266229faa5a1a5bb268bed3531,CVE-2012-4508,https://github.com/torvalds/linux/commit/dee1f973ca341c266229faa5a1a5bb268bed3531,2012-12-21T11:47Z
CWE-404,"CWE-000 static int omninet_open ( struct tty_struct * tty , struct usb_serial_port * port ) { <S2SV_StartBug> struct usb_serial * serial = port -> serial ; <S2SV_EndBug> struct usb_serial_port * wport ; wport = serial -> port [ 1 ] ; tty_port_tty_set ( & wport -> port , tty ) ; return usb_serial_generic_open ( tty , port ) ; }",<S2SV_ModStart> port ) { <S2SV_ModEnd> return usb_serial_generic_open (,torvalds@linux/30572418b445d85fcfe6c8fe84c947d2606767d8,CVE-2017-8925,https://github.com/torvalds/linux/commit/30572418b445d85fcfe6c8fe84c947d2606767d8,2017-05-12T21:29Z
CWE-125,"CWE-125 static stmt_ty ast_for_funcdef ( struct compiling * c , const node * n , asdl_seq * decorator_seq ) { return ast_for_funcdef_impl ( c , n , decorator_seq , <S2SV_StartBug> 0 ) ; <S2SV_EndBug> }","<S2SV_ModStart> , decorator_seq , false <S2SV_ModEnd> ) ; }",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z
CWE-125,"CWE-125 char * messageFindArgument ( const message * m , const char * variable ) { int i ; size_t len ; assert ( m != NULL ) ; assert ( variable != NULL ) ; len = strlen ( variable ) ; for ( i = 0 ; i < m -> numberOfArguments ; i ++ ) { const char * ptr ; ptr = messageGetArgument ( m , i ) ; if ( ( ptr == NULL ) || ( * ptr == '\\0' ) ) continue ; # ifdef CL_DEBUG cli_dbgmsg ( ""messageFindArgument:<S2SV_blank>compare<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>%s<S2SV_blank>with<S2SV_blank>%s\\n"" , ( unsigned long ) len , variable , ptr ) ; # endif if ( strncasecmp ( ptr , variable , len ) == 0 ) { ptr = & ptr [ len ] ; while ( isspace ( * ptr ) ) ptr ++ ; if ( * ptr != '=' ) { cli_dbgmsg ( ""messageFindArgument:<S2SV_blank>no<S2SV_blank>\'=\'<S2SV_blank>sign<S2SV_blank>found<S2SV_blank>in<S2SV_blank>MIME<S2SV_blank>header<S2SV_blank>\'%s\'<S2SV_blank>(%s)\\n"" , variable , messageGetArgument ( m , i ) ) ; return NULL ; } <S2SV_StartBug> if ( ( * ++ ptr == \'""\' ) && ( strchr ( & ptr [ 1 ] , \'""\' ) != NULL ) ) { <S2SV_EndBug> char * ret = cli_strdup ( ++ ptr ) ; char * p ; if ( ret == NULL ) return NULL ; if ( ( p = strchr ( ret , \'""\' ) ) != NULL ) { ret [ strlen ( ret ) - 1 ] = '\\0' ; * p = '\\0' ; } return ret ; } return cli_strdup ( ptr ) ; } } return NULL ; }",<S2SV_ModStart> if ( ( strlen ( ptr ) > 2 ) && (,vrtadmin@clamav-devel/586a5180287262070637c8943f2f7efd652e4a2c,CVE-2017-6418,https://github.com/vrtadmin/clamav-devel/commit/586a5180287262070637c8943f2f7efd652e4a2c,2017-08-07T03:29Z
CWE-125,"CWE-125 void qedi_dbg_notice ( struct qedi_dbg_ctx * qedi , const char * func , u32 line , const char * fmt , ... ) { va_list va ; <S2SV_StartBug> struct va_format vaf ; <S2SV_EndBug> char nfunc [ 32 ] ; memset ( nfunc , 0 , sizeof ( nfunc ) ) ; memcpy ( nfunc , func , sizeof ( nfunc ) - 1 ) ; va_start ( va , fmt ) ; vaf . fmt = fmt ; vaf . va = & va ; if ( ! ( qedi_dbg_log & QEDI_LOG_NOTICE ) ) goto ret ; if ( likely ( qedi ) && likely ( qedi -> pdev ) ) pr_notice ( ""[%s]:[%s:%d]:%d:<S2SV_blank>%pV"" , <S2SV_StartBug> dev_name ( & qedi -> pdev -> dev ) , nfunc , line , <S2SV_EndBug> qedi -> host_no , & vaf ) ; else <S2SV_StartBug> pr_notice ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , nfunc , line , & vaf ) ; <S2SV_EndBug> ret : va_end ( va ) ; }","<S2SV_ModStart> struct va_format vaf <S2SV_ModEnd> ; va_start ( <S2SV_ModStart> dev ) , func <S2SV_ModEnd> , line , <S2SV_ModStart> ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , func <S2SV_ModEnd> , line ,",torvalds@linux/c09581a52765a85f19fc35340127396d5e3379cc,CVE-2019-15090,https://github.com/torvalds/linux/commit/c09581a52765a85f19fc35340127396d5e3379cc,2019-08-16T00:15Z
CWE-20,"CWE-20 static int check_symlinks ( struct archive_write_disk * a ) { <S2SV_StartBug> # if ! defined ( HAVE_LSTAT ) <S2SV_EndBug> ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; <S2SV_StartBug> r = lstat ( a -> name , & st ) ; <S2SV_EndBug> <S2SV_StartBug> if ( r != 0 ) { <S2SV_EndBug> if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { <S2SV_StartBug> archive_set_error ( & a -> archive , errno , <S2SV_EndBug> ""Could<S2SV_blank>not<S2SV_blank>remove<S2SV_blank>symlink<S2SV_blank>%s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; <S2SV_StartBug> } <S2SV_EndBug> a -> pst = NULL ; <S2SV_StartBug> if ( ! S_ISLNK ( a -> mode ) ) { <S2SV_EndBug> archive_set_error ( & a -> archive , 0 , ""Removing<S2SV_blank>symlink<S2SV_blank>%s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot<S2SV_blank>remove<S2SV_blank>intervening<S2SV_blank>symlink<S2SV_blank>%s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot<S2SV_blank>extract<S2SV_blank>through<S2SV_blank>symlink<S2SV_blank>%s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }","<S2SV_ModStart> a ) { struct archive_string error_string ; int error_number ; int rc ; archive_string_init ( & error_string ) ; rc = check_symlinks_fsobj <S2SV_ModEnd> ( a -> <S2SV_ModStart> name , & error_number , & error_string , a -> flags <S2SV_ModEnd> ) ; if <S2SV_ModStart> ; if ( rc != ARCHIVE_OK <S2SV_ModEnd> ) { archive_set_error <S2SV_ModStart> -> archive , error_number , ""%s"" , error_string . s <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } archive_string_free ( & error_string ) ; <S2SV_ModStart> = NULL ; return rc ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>",libarchive@libarchive/dfd6b54ce33960e420fb206d8872fb759b577ad9,CVE-2016-5418,https://github.com/libarchive/libarchive/commit/dfd6b54ce33960e420fb206d8872fb759b577ad9,2016-09-21T14:25Z
CWE-119,"CWE-119 static inline int object_common2 ( UNSERIALIZE_PARAMETER , long elements ) { zval * retval_ptr = NULL ; zval fname ; if ( Z_TYPE_PP ( rval ) != IS_OBJECT ) { return 0 ; } if ( ! process_nested_data ( UNSERIALIZE_PASSTHRU , Z_OBJPROP_PP ( rval ) , elements , 1 ) ) { if ( Z_TYPE_PP ( rval ) == IS_OBJECT ) { zend_hash_clean ( Z_OBJPROP_PP ( rval ) ) ; <S2SV_StartBug> } <S2SV_EndBug> ZVAL_NULL ( * rval ) ; return 0 ; } if ( Z_TYPE_PP ( rval ) != IS_OBJECT ) { return 0 ; } if ( Z_OBJCE_PP ( rval ) != PHP_IC_ENTRY && zend_hash_exists ( & Z_OBJCE_PP ( rval ) -> function_table , ""__wakeup"" , sizeof ( ""__wakeup"" ) ) ) { INIT_PZVAL ( & fname ) ; ZVAL_STRINGL ( & fname , ""__wakeup"" , sizeof ( ""__wakeup"" ) - 1 , 0 ) ; BG ( serialize_lock ) ++ ; call_user_function_ex ( CG ( function_table ) , rval , & fname , & retval_ptr , 0 , 0 , 1 , NULL TSRMLS_CC ) ; BG ( serialize_lock ) -- ; } if ( retval_ptr ) { zval_ptr_dtor ( & retval_ptr ) ; } if ( EG ( exception ) ) { return 0 ; } return finish_nested_data ( UNSERIALIZE_PASSTHRU ) ; }",<S2SV_ModStart> ) ) ; zend_object_store_ctor_failed ( * rval TSRMLS_CC ) ;,php@php-src/6a7cc8ff85827fa9ac715b3a83c2d9147f33cd43,CVE-2016-7411,https://github.com/php/php-src/commit/6a7cc8ff85827fa9ac715b3a83c2d9147f33cd43?w=1,2016-09-17T21:59Z
CWE-200,"CWE-200 static void * __alloc_from_pool ( size_t size , struct page * * ret_page , gfp_t flags ) { unsigned long val ; void * ptr = NULL ; if ( ! atomic_pool ) { WARN ( 1 , ""coherent<S2SV_blank>pool<S2SV_blank>not<S2SV_blank>initialised!\\n"" ) ; return NULL ; } val = gen_pool_alloc ( atomic_pool , size ) ; if ( val ) { phys_addr_t phys = gen_pool_virt_to_phys ( atomic_pool , val ) ; * ret_page = phys_to_page ( phys ) ; ptr = ( void * ) val ; <S2SV_StartBug> if ( flags & __GFP_ZERO ) <S2SV_EndBug> memset ( ptr , 0 , size ) ; } return ptr ; }",<S2SV_ModStart> ) val ; <S2SV_ModEnd> memset ( ptr,torvalds@linux/6829e274a623187c24f7cfc0e3d35f25d087fcc5,CVE-2015-8950,https://github.com/torvalds/linux/commit/6829e274a623187c24f7cfc0e3d35f25d087fcc5,2016-10-10T10:59Z
,"CWE-000 static inline int ip6_ufo_append_data ( struct sock * sk , int getfrag ( void * from , char * to , int offset , int len , int odd , struct sk_buff * skb ) , void * from , int length , int hh_len , int fragheaderlen , <S2SV_StartBug> int transhdrlen , int mtu , unsigned int flags ) <S2SV_EndBug> { struct sk_buff * skb ; int err ; if ( ( skb = skb_peek_tail ( & sk -> sk_write_queue ) ) == NULL ) { skb = sock_alloc_send_skb ( sk , hh_len + fragheaderlen + transhdrlen + 20 , ( flags & MSG_DONTWAIT ) , & err ) ; if ( skb == NULL ) return - ENOMEM ; skb_reserve ( skb , hh_len ) ; skb_put ( skb , fragheaderlen + transhdrlen ) ; skb_reset_network_header ( skb ) ; skb -> transport_header = skb -> network_header + fragheaderlen ; skb -> ip_summed = CHECKSUM_PARTIAL ; skb -> csum = 0 ; } err = skb_append_datato_frags ( sk , skb , getfrag , from , ( length - transhdrlen ) ) ; if ( ! err ) { struct frag_hdr fhdr ; skb_shinfo ( skb ) -> gso_size = ( mtu - fragheaderlen - sizeof ( struct frag_hdr ) ) & ~ 7 ; skb_shinfo ( skb ) -> gso_type = SKB_GSO_UDP ; <S2SV_StartBug> ipv6_select_ident ( & fhdr ) ; <S2SV_EndBug> skb_shinfo ( skb ) -> ip6_frag_id = fhdr . identification ; __skb_queue_tail ( & sk -> sk_write_queue , skb ) ; return 0 ; } kfree_skb ( skb ) ; return err ; }","<S2SV_ModStart> unsigned int flags , struct rt6_info * rt <S2SV_ModStart> ( & fhdr , rt",torvalds@linux/87c48fa3b4630905f98268dde838ee43626a060c,CVE-2011-2699,https://github.com/torvalds/linux/commit/87c48fa3b4630905f98268dde838ee43626a060c,2012-05-24T23:55Z
CWE-125,"CWE-125 static const struct usb_cdc_union_desc * ims_pcu_get_cdc_union_desc ( struct usb_interface * intf ) { const void * buf = intf -> altsetting -> extra ; size_t buflen = intf -> altsetting -> extralen ; struct usb_cdc_union_desc * union_desc ; if ( ! buf ) { dev_err ( & intf -> dev , ""Missing<S2SV_blank>descriptor<S2SV_blank>data\\n"" ) ; return NULL ; } if ( ! buflen ) { dev_err ( & intf -> dev , ""Zero<S2SV_blank>length<S2SV_blank>descriptor\\n"" ) ; return NULL ; } <S2SV_StartBug> while ( buflen > 0 ) { <S2SV_EndBug> union_desc = ( struct usb_cdc_union_desc * ) buf ; if ( union_desc -> bDescriptorType == USB_DT_CS_INTERFACE && union_desc -> bDescriptorSubType == USB_CDC_UNION_TYPE ) { dev_dbg ( & intf -> dev , ""Found<S2SV_blank>union<S2SV_blank>header\\n"" ) ; <S2SV_StartBug> return union_desc ; <S2SV_EndBug> } buflen -= union_desc -> bLength ; buf += union_desc -> bLength ; } dev_err ( & intf -> dev , ""Missing<S2SV_blank>CDC<S2SV_blank>union<S2SV_blank>descriptor\\n"" ) ; return NULL ; }","<S2SV_ModStart> while ( buflen >= sizeof ( * union_desc ) ) { union_desc = ( struct usb_cdc_union_desc * ) buf ; if ( union_desc -> bLength > buflen ) { dev_err ( & intf -> dev , ""Too<S2SV_blank>large<S2SV_blank>descriptor\\n"" ) ; return NULL ; } <S2SV_ModEnd> if ( union_desc <S2SV_ModStart> ""Found<S2SV_blank>union<S2SV_blank>header\\n"" ) ; if ( union_desc -> bLength >= sizeof ( * union_desc ) ) return union_desc ; dev_err ( & intf -> dev , ""Union<S2SV_blank>descriptor<S2SV_blank>to<S2SV_blank>short<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%zd\\n)"" , union_desc -> bLength , sizeof ( * union_desc ) ) ; return NULL <S2SV_ModEnd> ; } buflen",torvalds@linux/ea04efee7635c9120d015dcdeeeb6988130cb67a,CVE-2017-16645,https://github.com/torvalds/linux/commit/ea04efee7635c9120d015dcdeeeb6988130cb67a,2017-11-07T23:29Z
CWE-284,"CWE-284 void btsock_rfc_signaled ( UNUSED_ATTR int fd , int flags , uint32_t user_id ) { pthread_mutex_lock ( & slot_lock ) ; rfc_slot_t * slot = find_rfc_slot_by_id ( user_id ) ; if ( ! slot ) goto out ; bool need_close = false ; if ( flags & SOCK_THREAD_FD_RD && ! slot -> f . server ) { if ( slot -> f . connected ) { int size = 0 ; <S2SV_StartBug> if ( ! ( flags & SOCK_THREAD_FD_EXCEPTION ) || ( ioctl ( slot -> fd , FIONREAD , & size ) == 0 && size ) ) <S2SV_EndBug> <S2SV_StartBug> pthread_mutex_unlock ( & slot_lock ) ; <S2SV_EndBug> <S2SV_StartBug> BTA_JvRfcommWrite ( slot -> rfc_handle , slot -> id ) ; <S2SV_EndBug> } else { LOG_ERROR ( ""%s<S2SV_blank>socket<S2SV_blank>signaled<S2SV_blank>for<S2SV_blank>read<S2SV_blank>while<S2SV_blank>disconnected,<S2SV_blank>slot:<S2SV_blank>%d,<S2SV_blank>channel:<S2SV_blank>%d"" , __func__ , slot -> id , slot -> scn ) ; need_close = true ; } } if ( flags & SOCK_THREAD_FD_WR ) { if ( ! slot -> f . connected || ! flush_incoming_que_on_wr_signal ( slot ) ) { LOG_ERROR ( ""%s<S2SV_blank>socket<S2SV_blank>signaled<S2SV_blank>for<S2SV_blank>write<S2SV_blank>while<S2SV_blank>disconnected<S2SV_blank>(or<S2SV_blank>write<S2SV_blank>failure),<S2SV_blank>slot:<S2SV_blank>%d,<S2SV_blank>channel:<S2SV_blank>%d"" , __func__ , slot -> id , slot -> scn ) ; need_close = true ; } } if ( need_close || ( flags & SOCK_THREAD_FD_EXCEPTION ) ) { int size = 0 ; <S2SV_StartBug> if ( need_close || ioctl ( slot -> fd , FIONREAD , & size ) != 0 || ! size ) <S2SV_EndBug> cleanup_rfc_slot ( slot ) ; } out : ; pthread_mutex_unlock ( & slot_lock ) ; }","<S2SV_ModStart> ) || ( TEMP_FAILURE_RETRY ( <S2SV_ModStart> & size ) ) <S2SV_ModStart> size ) ) { <S2SV_ModEnd> BTA_JvRfcommWrite ( slot <S2SV_ModStart> id ) ; } <S2SV_ModStart> ( need_close || TEMP_FAILURE_RETRY ( <S2SV_ModStart> , & size )",system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z
CWE-787,"CWE-787 static int track_header ( VividasDemuxContext * viv , AVFormatContext * s , uint8_t * buf , int size ) { int i , j , ret ; int64_t off ; int val_1 ; int num_video ; AVIOContext pb0 , * pb = & pb0 ; ffio_init_context ( pb , buf , size , 0 , NULL , NULL , NULL , NULL ) ; ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; val_1 = ffio_read_varlen ( pb ) ; for ( i = 0 ; i < val_1 ; i ++ ) { int c = avio_r8 ( pb ) ; if ( avio_feof ( pb ) ) return AVERROR_EOF ; for ( j = 0 ; j < c ; j ++ ) { if ( avio_feof ( pb ) ) return AVERROR_EOF ; avio_r8 ( pb ) ; avio_r8 ( pb ) ; } } avio_r8 ( pb ) ; off = avio_tell ( pb ) ; off += ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; num_video = avio_r8 ( pb ) ; avio_seek ( pb , off , SEEK_SET ) ; if ( num_video != 1 ) { av_log ( s , AV_LOG_ERROR , ""number<S2SV_blank>of<S2SV_blank>video<S2SV_blank>tracks<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>not<S2SV_blank>1\\n"" , num_video ) ; return AVERROR_PATCHWELCOME ; } for ( i = 0 ; i < num_video ; i ++ ) { AVStream * st = avformat_new_stream ( s , NULL ) ; int num , den ; if ( ! st ) return AVERROR ( ENOMEM ) ; st -> id = i ; st -> codecpar -> codec_type = AVMEDIA_TYPE_VIDEO ; st -> codecpar -> codec_id = AV_CODEC_ID_VP6 ; off = avio_tell ( pb ) ; off += ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; avio_r8 ( pb ) ; num = avio_rl32 ( pb ) ; den = avio_rl32 ( pb ) ; avpriv_set_pts_info ( st , 64 , num , den ) ; st -> nb_frames = avio_rl32 ( pb ) ; st -> codecpar -> width = avio_rl16 ( pb ) ; st -> codecpar -> height = avio_rl16 ( pb ) ; avio_r8 ( pb ) ; avio_rl32 ( pb ) ; avio_seek ( pb , off , SEEK_SET ) ; } off = avio_tell ( pb ) ; off += ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; viv -> num_audio = avio_r8 ( pb ) ; avio_seek ( pb , off , SEEK_SET ) ; if ( viv -> num_audio != 1 ) av_log ( s , AV_LOG_WARNING , ""number<S2SV_blank>of<S2SV_blank>audio<S2SV_blank>tracks<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>not<S2SV_blank>1\\n"" , viv -> num_audio ) ; for ( i = 0 ; i < viv -> num_audio ; i ++ ) { int q ; AVStream * st = avformat_new_stream ( s , NULL ) ; if ( ! st ) return AVERROR ( ENOMEM ) ; st -> id = num_video + i ; st -> codecpar -> codec_type = AVMEDIA_TYPE_AUDIO ; st -> codecpar -> codec_id = AV_CODEC_ID_VORBIS ; off = avio_tell ( pb ) ; off += ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; avio_r8 ( pb ) ; avio_rl16 ( pb ) ; st -> codecpar -> channels = avio_rl16 ( pb ) ; st -> codecpar -> sample_rate = avio_rl32 ( pb ) ; avio_seek ( pb , 10 , SEEK_CUR ) ; q = avio_r8 ( pb ) ; avio_seek ( pb , q , SEEK_CUR ) ; avio_r8 ( pb ) ; if ( avio_tell ( pb ) < off ) { int num_data ; <S2SV_StartBug> int xd_size = 0 ; <S2SV_EndBug> int data_len [ 256 ] ; int offset = 1 ; uint8_t * p ; ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; ffio_read_varlen ( pb ) ; num_data = avio_r8 ( pb ) ; for ( j = 0 ; j < num_data ; j ++ ) { uint64_t len = ffio_read_varlen ( pb ) ; if ( len > INT_MAX / 2 - xd_size ) { return AVERROR_INVALIDDATA ; } data_len [ j ] = len ; <S2SV_StartBug> xd_size += len ; <S2SV_EndBug> } ret = ff_alloc_extradata ( st -> codecpar , 64 + xd_size + xd_size / 255 ) ; if ( ret < 0 ) return ret ; p = st -> codecpar -> extradata ; p [ 0 ] = 2 ; for ( j = 0 ; j < num_data - 1 ; j ++ ) { unsigned delta = av_xiphlacing ( & p [ offset ] , data_len [ j ] ) ; <S2SV_StartBug> if ( delta > data_len [ j ] ) { <S2SV_EndBug> return AVERROR_INVALIDDATA ; } offset += delta ; } for ( j = 0 ; j < num_data ; j ++ ) { int ret = avio_read ( pb , & p [ offset ] , data_len [ j ] ) ; if ( ret < data_len [ j ] ) { st -> codecpar -> extradata_size = 0 ; av_freep ( & st -> codecpar -> extradata ) ; break ; } <S2SV_StartBug> offset += data_len [ j ] ; <S2SV_EndBug> } if ( offset < st -> codecpar -> extradata_size ) st -> codecpar -> extradata_size = offset ; } } return 0 ; }","<S2SV_ModStart> int xd_size = 1 <S2SV_ModEnd> ; int data_len <S2SV_ModStart> xd_size += len + 1 + len / 255 ; } ret = ff_alloc_extradata ( st -> codecpar , xd_size <S2SV_ModEnd> ) ; if <S2SV_ModStart> ] ) ; av_assert0 ( delta <= xd_size - offset ) ; <S2SV_ModEnd> offset += delta <S2SV_ModStart> break ; } av_assert0 ( data_len [ j ] <= xd_size - offset ) ;",FFmpeg@FFmpeg/27a99e2c7d450fef15594671eef4465c8a166bd7,CVE-2020-35964,https://github.com/FFmpeg/FFmpeg/commit/27a99e2c7d450fef15594671eef4465c8a166bd7,2021-01-03T19:15Z
CWE-617,"CWE-000 krb5_error_code kdc_process_s4u2proxy_req ( kdc_realm_t * kdc_active_realm , krb5_kdc_req * request , const krb5_enc_tkt_part * t2enc , const krb5_db_entry * server , krb5_const_principal server_princ , krb5_const_principal proxy_princ , const char * * status ) { krb5_error_code errcode ; if ( request -> kdc_options & ( NON_TGT_OPTION | KDC_OPT_ENC_TKT_IN_SKEY ) ) { <S2SV_StartBug> return KRB5KDC_ERR_BADOPTION ; <S2SV_EndBug> } if ( ! krb5_principal_compare ( kdc_context , server -> princ , <S2SV_StartBug> server_princ ) ) { <S2SV_EndBug> return KRB5KDC_ERR_SERVER_NOMATCH ; } if ( ! isflagset ( t2enc -> flags , TKT_FLG_FORWARDABLE ) ) { * status = ""EVIDENCE_TKT_NOT_FORWARDABLE"" ; return KRB5_TKT_NOT_FORWARDABLE ; } errcode = check_allowed_to_delegate_to ( kdc_context , t2enc -> client , server , proxy_princ ) ; if ( errcode ) { * status = ""NOT_ALLOWED_TO_DELEGATE"" ; return errcode ; } return 0 ; }","<S2SV_ModStart> ) ) { * status = ""INVALID_S4U2PROXY_OPTIONS"" ; <S2SV_ModStart> ) ) { * status = ""EVIDENCE_TICKET_MISMATCH"" ;",krb5@krb5/ffb35baac6981f9e8914f8f3bffd37f284b85970,CVE-2017-11368,https://github.com/krb5/krb5/commit/ffb35baac6981f9e8914f8f3bffd37f284b85970,2017-08-09T18:29Z
CWE-125,"CWE-125 int parse_file ( FILE * input_file , char * directory , char * body_filename , char * body_pref , int flags ) { uint32 d ; uint16 key ; Attr * attr = NULL ; File * file = NULL ; int rtf_size = 0 , html_size = 0 ; MessageBody body ; memset ( & body , '\\0' , sizeof ( MessageBody ) ) ; g_flags = flags ; d = geti32 ( input_file ) ; if ( d != TNEF_SIGNATURE ) { fprintf ( stdout , ""Seems<S2SV_blank>not<S2SV_blank>to<S2SV_blank>be<S2SV_blank>a<S2SV_blank>TNEF<S2SV_blank>file\\n"" ) ; return 1 ; } key = geti16 ( input_file ) ; debug_print ( ""TNEF<S2SV_blank>Key:<S2SV_blank>%hx\\n"" , key ) ; while ( data_left ( input_file ) ) { attr = read_object ( input_file ) ; if ( attr == NULL ) break ; if ( attr -> name == attATTACHRENDDATA ) { if ( file ) { file_write ( file , directory ) ; file_free ( file ) ; } else { file = CHECKED_XCALLOC ( File , 1 ) ; } } switch ( attr -> lvl_type ) { case LVL_MESSAGE : if ( attr -> name == attBODY ) { body . text_body = get_text_data ( attr ) ; } else if ( attr -> name == attMAPIPROPS ) { MAPI_Attr * * mapi_attrs = mapi_attr_read ( attr -> len , attr -> buf ) ; if ( mapi_attrs ) { int i ; for ( i = 0 ; mapi_attrs [ i ] ; i ++ ) { MAPI_Attr * a = mapi_attrs [ i ] ; <S2SV_StartBug> if ( a -> name == MAPI_BODY_HTML ) <S2SV_EndBug> { body . html_bodies = get_html_data ( a ) ; html_size = a -> num_values ; } <S2SV_StartBug> else if ( a -> name == MAPI_RTF_COMPRESSED ) <S2SV_EndBug> { body . rtf_bodies = get_rtf_data ( a ) ; rtf_size = a -> num_values ; } } mapi_attr_free_list ( mapi_attrs ) ; XFREE ( mapi_attrs ) ; } } break ; case LVL_ATTACHMENT : file_add_attr ( file , attr ) ; break ; default : fprintf ( stderr , ""Invalid<S2SV_blank>lvl<S2SV_blank>type<S2SV_blank>on<S2SV_blank>attribute:<S2SV_blank>%d\\n"" , attr -> lvl_type ) ; return 1 ; break ; } attr_free ( attr ) ; XFREE ( attr ) ; } if ( file ) { file_write ( file , directory ) ; file_free ( file ) ; XFREE ( file ) ; } if ( flags & SAVEBODY ) { int i = 0 ; int all_flag = 0 ; if ( strcmp ( body_pref , ""all"" ) == 0 ) { all_flag = 1 ; body_pref = ""rht"" ; } for ( ; i < 3 ; i ++ ) { File * * files = get_body_files ( body_filename , body_pref [ i ] , & body ) ; if ( files ) { int j = 0 ; for ( ; files [ j ] ; j ++ ) { file_write ( files [ j ] , directory ) ; file_free ( files [ j ] ) ; XFREE ( files [ j ] ) ; } XFREE ( files ) ; if ( ! all_flag ) break ; } } } if ( body . text_body ) { free_bodies ( body . text_body , 1 ) ; XFREE ( body . text_body ) ; } if ( rtf_size > 0 ) { free_bodies ( body . rtf_bodies , rtf_size ) ; XFREE ( body . rtf_bodies ) ; } if ( html_size > 0 ) { free_bodies ( body . html_bodies , html_size ) ; XFREE ( body . html_bodies ) ; } return 0 ; }",<S2SV_ModStart> ( a -> type == szMAPI_BINARY && a -> <S2SV_ModStart> else if ( a -> type == szMAPI_BINARY &&,verdammelt@tnef/8dccf79857ceeb7a6d3e42c1e762e7b865d5344d,CVE-2017-6309,https://github.com/verdammelt/tnef/commit/8dccf79857ceeb7a6d3e42c1e762e7b865d5344d,2017-02-24T04:59Z
CWE-532,"CWE-000 int _pam_parse ( int argc , const char * * argv ) { int ctrl = 0 ; const char * current_secret = NULL ; memset ( tac_srv , 0 , sizeof ( tacplus_server_t ) * TAC_PLUS_MAXSERVERS ) ; memset ( & tac_srv_addr , 0 , sizeof ( struct addrinfo ) * TAC_PLUS_MAXSERVERS ) ; memset ( & tac_sock_addr , 0 , sizeof ( struct sockaddr ) * TAC_PLUS_MAXSERVERS ) ; memset ( & tac_sock6_addr , 0 , sizeof ( struct sockaddr_in6 ) * TAC_PLUS_MAXSERVERS ) ; tac_srv_no = 0 ; tac_service [ 0 ] = 0 ; tac_protocol [ 0 ] = 0 ; tac_prompt [ 0 ] = 0 ; tac_login [ 0 ] = 0 ; for ( ctrl = 0 ; argc -- > 0 ; ++ argv ) { if ( ! strcmp ( * argv , ""debug"" ) ) { ctrl |= PAM_TAC_DEBUG ; } else if ( ! strcmp ( * argv , ""use_first_pass"" ) ) { ctrl |= PAM_TAC_USE_FIRST_PASS ; } else if ( ! strcmp ( * argv , ""try_first_pass"" ) ) { ctrl |= PAM_TAC_TRY_FIRST_PASS ; } else if ( ! strncmp ( * argv , ""service="" , 8 ) ) { xstrcpy ( tac_service , * argv + 8 , sizeof ( tac_service ) ) ; } else if ( ! strncmp ( * argv , ""protocol="" , 9 ) ) { xstrcpy ( tac_protocol , * argv + 9 , sizeof ( tac_protocol ) ) ; } else if ( ! strncmp ( * argv , ""prompt="" , 7 ) ) { xstrcpy ( tac_prompt , * argv + 7 , sizeof ( tac_prompt ) ) ; unsigned long chr ; for ( chr = 0 ; chr < strlen ( tac_prompt ) ; chr ++ ) { if ( tac_prompt [ chr ] == '_' ) { tac_prompt [ chr ] = '<S2SV_blank>' ; } } } else if ( ! strncmp ( * argv , ""login="" , 6 ) ) { xstrcpy ( tac_login , * argv + 6 , sizeof ( tac_login ) ) ; } else if ( ! strcmp ( * argv , ""acct_all"" ) ) { ctrl |= PAM_TAC_ACCT ; } else if ( ! strncmp ( * argv , ""server="" , 7 ) ) { if ( tac_srv_no < TAC_PLUS_MAXSERVERS ) { struct addrinfo hints , * servers , * server ; int rv ; char * close_bracket , * server_name , * port , server_buf [ 256 ] ; memset ( & hints , 0 , sizeof hints ) ; memset ( & server_buf , 0 , sizeof ( server_buf ) ) ; hints . ai_family = AF_UNSPEC ; hints . ai_socktype = SOCK_STREAM ; if ( strlen ( * argv + 7 ) >= sizeof ( server_buf ) ) { _pam_log ( LOG_ERR , ""server<S2SV_blank>address<S2SV_blank>too<S2SV_blank>long,<S2SV_blank>sorry"" ) ; continue ; } strcpy ( server_buf , * argv + 7 ) ; if ( * server_buf == '[' && ( close_bracket = strchr ( server_buf , ']' ) ) != NULL ) { server_name = server_buf + 1 ; _pam_log ( LOG_ERR , ""reading<S2SV_blank>server<S2SV_blank>address<S2SV_blank>as:<S2SV_blank>%s<S2SV_blank>"" , server_name ) ; port = strchr ( close_bracket , ':' ) ; * close_bracket = '\\0' ; } else { server_name = server_buf ; port = strchr ( server_buf , ':' ) ; } if ( port != NULL ) { * port = '\\0' ; port ++ ; } _pam_log ( LOG_DEBUG , ""sending<S2SV_blank>server<S2SV_blank>address<S2SV_blank>to<S2SV_blank>getaddrinfo<S2SV_blank>as:<S2SV_blank>%s<S2SV_blank>"" , server_name ) ; if ( ( rv = getaddrinfo ( server_name , ( port == NULL ) ? ""49"" : port , & hints , & servers ) ) == 0 ) { for ( server = servers ; server != NULL && tac_srv_no < TAC_PLUS_MAXSERVERS ; server = server -> ai_next ) { set_tac_srv_addr ( tac_srv_no , server ) ; set_tac_srv_key ( tac_srv_no , current_secret ) ; tac_srv_no ++ ; } _pam_log ( LOG_DEBUG , ""%s:<S2SV_blank>server<S2SV_blank>index<S2SV_blank>%d<S2SV_blank>"" , __FUNCTION__ , tac_srv_no ) ; freeaddrinfo ( servers ) ; } else { _pam_log ( LOG_ERR , ""skip<S2SV_blank>invalid<S2SV_blank>server:<S2SV_blank>%s<S2SV_blank>(getaddrinfo:<S2SV_blank>%s)"" , server_name , gai_strerror ( rv ) ) ; } } else { _pam_log ( LOG_ERR , ""maximum<S2SV_blank>number<S2SV_blank>of<S2SV_blank>servers<S2SV_blank>(%d)<S2SV_blank>exceeded,<S2SV_blank>skipping"" , TAC_PLUS_MAXSERVERS ) ; } } else if ( ! strncmp ( * argv , ""secret="" , 7 ) ) { current_secret = * argv + 7 ; if ( tac_srv_no == 0 ) { _pam_log ( LOG_ERR , ""secret<S2SV_blank>set<S2SV_blank>but<S2SV_blank>no<S2SV_blank>servers<S2SV_blank>configured<S2SV_blank>yet"" ) ; } else { set_tac_srv_key ( tac_srv_no - 1 , current_secret ) ; } } else if ( ! strncmp ( * argv , ""timeout="" , 8 ) ) { # ifdef HAVE_STRTOL tac_timeout = strtol ( * argv + 8 , NULL , 10 ) ; # else tac_timeout = atoi ( * argv + 8 ) ; # endif if ( tac_timeout == LONG_MAX ) { _pam_log ( LOG_ERR , ""timeout<S2SV_blank>parameter<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>parsed<S2SV_blank>as<S2SV_blank>integer:<S2SV_blank>%s"" , * argv ) ; tac_timeout = 0 ; } else { tac_readtimeout_enable = 1 ; } } else { _pam_log ( LOG_WARNING , ""unrecognized<S2SV_blank>option:<S2SV_blank>%s"" , * argv ) ; } } if ( ctrl & PAM_TAC_DEBUG ) { unsigned long n ; _pam_log ( LOG_DEBUG , ""%d<S2SV_blank>servers<S2SV_blank>defined"" , tac_srv_no ) ; for ( n = 0 ; n < tac_srv_no ; n ++ ) { <S2SV_StartBug> _pam_log ( LOG_DEBUG , ""server[%lu]<S2SV_blank>{<S2SV_blank>addr=%s,<S2SV_blank>key=\'%s\'<S2SV_blank>}"" , n , tac_ntop ( tac_srv [ n ] . addr -> ai_addr ) , <S2SV_EndBug> tac_srv [ n ] . key ) ; } _pam_log ( LOG_DEBUG , ""tac_service=\'%s\'"" , tac_service ) ; _pam_log ( LOG_DEBUG , ""tac_protocol=\'%s\'"" , tac_protocol ) ; _pam_log ( LOG_DEBUG , ""tac_prompt=\'%s\'"" , tac_prompt ) ; _pam_log ( LOG_DEBUG , ""tac_login=\'%s\'"" , tac_login ) ; } return ctrl ; }","<S2SV_ModStart> ( LOG_DEBUG , ""server[%lu]<S2SV_blank>{<S2SV_blank>addr=%s,<S2SV_blank>key=\'********\'<S2SV_blank>}"" <S2SV_ModEnd> , n , <S2SV_ModStart> -> ai_addr ) <S2SV_ModEnd> ) ; }",kravietz@pam_tacplus/4a9852c31c2fd0c0e72fbb689a586aabcfb11cb0,CVE-2020-13881,https://github.com/kravietz/pam_tacplus/commit/4a9852c31c2fd0c0e72fbb689a586aabcfb11cb0,2020-06-06T19:15Z
CWE-362,"CWE-362 void flush_tlb_page ( struct vm_area_struct * vma , unsigned long start ) { struct mm_struct * mm = vma -> vm_mm ; preempt_disable ( ) ; if ( current -> active_mm == mm ) { <S2SV_StartBug> if ( current -> mm ) <S2SV_EndBug> __flush_tlb_one ( start ) ; <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> leave_mm ( smp_processor_id ( ) ) ; <S2SV_EndBug> } if ( cpumask_any_but ( mm_cpumask ( mm ) , smp_processor_id ( ) ) < nr_cpu_ids ) flush_tlb_others ( mm_cpumask ( mm ) , mm , start , 0UL ) ; preempt_enable ( ) ; }",<S2SV_ModStart> -> mm ) { <S2SV_ModStart> start ) ; } else { <S2SV_ModEnd> leave_mm ( smp_processor_id <S2SV_ModStart> ) ) ; smp_mb ( ) ; },torvalds@linux/71b3c126e61177eb693423f2e18a1914205b165e,CVE-2016-2069,https://github.com/torvalds/linux/commit/71b3c126e61177eb693423f2e18a1914205b165e,2016-04-27T17:59Z
CWE-119,"CWE-119 static int get_registers ( pegasus_t * pegasus , __u16 indx , __u16 size , void * data ) { <S2SV_StartBug> int ret ; <S2SV_EndBug> ret = usb_control_msg ( pegasus -> usb , usb_rcvctrlpipe ( pegasus -> usb , 0 ) , PEGASUS_REQ_GET_REGS , PEGASUS_REQT_READ , 0 , <S2SV_StartBug> indx , data , size , 1000 ) ; <S2SV_EndBug> if ( ret < 0 ) netif_dbg ( pegasus , drv , pegasus -> net , ""%s<S2SV_blank>returned<S2SV_blank>%d\\n"" , __func__ , ret ) ; <S2SV_StartBug> return ret ; <S2SV_EndBug> }","<S2SV_ModStart> data ) { u8 * buf ; int ret ; buf = kmalloc ( size , GFP_NOIO ) ; if ( ! buf ) return - ENOMEM <S2SV_ModEnd> ; ret = <S2SV_ModStart> , indx , buf <S2SV_ModEnd> , size , <S2SV_ModStart> ret ) ; else if ( ret <= size ) memcpy ( data , buf , ret ) ; kfree ( buf ) ;",torvalds@linux/5593523f968bc86d42a035c6df47d5e0979b5ace,CVE-2017-8068,https://github.com/torvalds/linux/commit/5593523f968bc86d42a035c6df47d5e0979b5ace,2017-04-23T05:59Z
CWE-416,"CWE-416 static void smp_task_timedout ( struct timer_list * t ) { struct sas_task_slow * slow = from_timer ( slow , t , timer ) ; struct sas_task * task = slow -> task ; unsigned long flags ; spin_lock_irqsave ( & task -> task_state_lock , flags ) ; <S2SV_StartBug> if ( ! ( task -> task_state_flags & SAS_TASK_STATE_DONE ) ) <S2SV_EndBug> <S2SV_StartBug> task -> task_state_flags |= SAS_TASK_STATE_ABORTED ; <S2SV_EndBug> spin_unlock_irqrestore ( & task -> task_state_lock , flags ) ; complete ( & task -> slow_task -> completion ) ; <S2SV_StartBug> } <S2SV_EndBug>","<S2SV_ModStart> SAS_TASK_STATE_DONE ) ) { <S2SV_ModStart> task_state_flags |= SAS_TASK_STATE_ABORTED <S2SV_ModEnd> ; complete ( <S2SV_ModStart> ) ; } spin_unlock_irqrestore ( & task -> task_state_lock , flags ) ; }",torvalds@linux/b90cd6f2b905905fb42671009dc0e27c310a16ae,CVE-2018-20836,https://github.com/torvalds/linux/commit/b90cd6f2b905905fb42671009dc0e27c310a16ae,2019-05-07T14:29Z
CWE-125,"CWE-125 static void rpl_dio_print ( netdissect_options * ndo , const u_char * bp , u_int length ) { const struct nd_rpl_dio * dio = ( const struct nd_rpl_dio * ) bp ; const char * dagid_str ; ND_TCHECK ( * dio ) ; dagid_str = ip6addr_string ( ndo , dio -> rpl_dagid ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>[dagid:%s,seq:%u,instance:%u,rank:%u,%smop:%s,prf:%u]"" , dagid_str , dio -> rpl_dtsn , dio -> rpl_instanceid , EXTRACT_16BITS ( & dio -> rpl_dagrank ) , RPL_DIO_GROUNDED ( dio -> rpl_mopprf ) ? ""grounded,"" : """" , tok2str ( rpl_mop_values , ""mop%u"" , RPL_DIO_MOP ( dio -> rpl_mopprf ) ) , RPL_DIO_PRF ( dio -> rpl_mopprf ) ) ) ; if ( ndo -> ndo_vflag > 1 ) { const struct rpl_dio_genoption * opt = ( const struct rpl_dio_genoption * ) & dio [ 1 ] ; rpl_dio_printopt ( ndo , opt , length ) ; } return ; trunc : <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>[|truncated]"" ) ) ; <S2SV_EndBug> return ; }","<S2SV_ModStart> ( ndo , ""%s"" , rpl_tstr <S2SV_ModEnd> ) ) ;",the-tcpdump-group@tcpdump/d7505276842e85bfd067fa21cdb32b8a2dc3c5e4,CVE-2018-14882,https://github.com/the-tcpdump-group/tcpdump/commit/d7505276842e85bfd067fa21cdb32b8a2dc3c5e4,2019-10-03T16:15Z
CWE-310,"CWE-000 static int sctp_v6_xmit ( struct sk_buff * skb , struct sctp_transport * transport ) { struct sock * sk = skb -> sk ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; <S2SV_StartBug> struct flowi6 fl6 ; <S2SV_EndBug> memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = transport -> ipaddr . v6 . sin6_addr ; fl6 . saddr = transport -> saddr . v6 . sin6_addr ; fl6 . flowlabel = np -> flow_label ; IP6_ECN_flow_xmit ( sk , fl6 . flowlabel ) ; if ( ipv6_addr_type ( & fl6 . saddr ) & IPV6_ADDR_LINKLOCAL ) fl6 . flowi6_oif = transport -> saddr . v6 . sin6_scope_id ; else fl6 . flowi6_oif = sk -> sk_bound_dev_if ; if ( np -> opt && np -> opt -> srcrt ) { struct rt0_hdr * rt0 = ( struct rt0_hdr * ) np -> opt -> srcrt ; fl6 . daddr = * rt0 -> addr ; } pr_debug ( ""%s:<S2SV_blank>skb:%p,<S2SV_blank>len:%d,<S2SV_blank>src:%pI6<S2SV_blank>dst:%pI6\\n"" , __func__ , skb , <S2SV_StartBug> skb -> len , & fl6 . saddr , & fl6 . daddr ) ; <S2SV_EndBug> <S2SV_StartBug> SCTP_INC_STATS ( sock_net ( sk ) , SCTP_MIB_OUTSCTPPACKS ) ; <S2SV_EndBug> if ( ! ( transport -> param_flags & SPP_PMTUD_ENABLE ) ) skb -> local_df = 1 ; <S2SV_StartBug> return ip6_xmit ( sk , skb , & fl6 , np -> opt , np -> tclass ) ; <S2SV_EndBug> }","<S2SV_ModStart> ; struct flowi6 * fl6 = & transport -> fl . u . ip6 ; <S2SV_ModEnd> pr_debug ( ""%s:<S2SV_blank>skb:%p,<S2SV_blank>len:%d,<S2SV_blank>src:%pI6<S2SV_blank>dst:%pI6\\n"" <S2SV_ModStart> , & fl6 -> <S2SV_ModEnd> saddr , & <S2SV_ModStart> , & fl6 -> <S2SV_ModEnd> daddr ) ; <S2SV_ModStart> daddr ) ; IP6_ECN_flow_xmit ( sk , fl6 -> flowlabel <S2SV_ModEnd> ) ; if <S2SV_ModStart> = 1 ; SCTP_INC_STATS ( sock_net ( sk ) , SCTP_MIB_OUTSCTPPACKS ) ; <S2SV_ModStart> , skb , <S2SV_ModEnd> fl6 , np",torvalds@linux/95ee62083cb6453e056562d91f597552021e6ae7,CVE-2013-4350,https://github.com/torvalds/linux/commit/95ee62083cb6453e056562d91f597552021e6ae7,2013-09-25T10:31Z
CWE-119,"CWE-119 <S2SV_StartBug> int file_is_y4m ( const char detect [ 4 ] ) { <S2SV_EndBug> if ( memcmp ( detect , ""YUV4"" , 4 ) == 0 ) { return 1 ; } return 0 ; }",<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-476,"CWE-476 static irqreturn_t i8042_interrupt ( int irq , void * dev_id ) { struct i8042_port * port ; struct serio * serio ; unsigned long flags ; unsigned char str , data ; unsigned int dfl ; unsigned int port_no ; bool filtered ; int ret = 1 ; spin_lock_irqsave ( & i8042_lock , flags ) ; str = i8042_read_status ( ) ; if ( unlikely ( ~ str & I8042_STR_OBF ) ) { spin_unlock_irqrestore ( & i8042_lock , flags ) ; if ( irq ) dbg ( ""Interrupt<S2SV_blank>%d,<S2SV_blank>without<S2SV_blank>any<S2SV_blank>data\\n"" , irq ) ; ret = 0 ; goto out ; } data = i8042_read_data ( ) ; if ( i8042_mux_present && ( str & I8042_STR_AUXDATA ) ) { static unsigned long last_transmit ; static unsigned char last_str ; dfl = 0 ; if ( str & I8042_STR_MUXERR ) { dbg ( ""MUX<S2SV_blank>error,<S2SV_blank>status<S2SV_blank>is<S2SV_blank>%02x,<S2SV_blank>data<S2SV_blank>is<S2SV_blank>%02x\\n"" , str , data ) ; switch ( data ) { default : if ( time_before ( jiffies , last_transmit + HZ / 10 ) ) { str = last_str ; break ; } case 0xfc : case 0xfd : case 0xfe : dfl = SERIO_TIMEOUT ; data = 0xfe ; break ; case 0xff : dfl = SERIO_PARITY ; data = 0xfe ; break ; } } port_no = I8042_MUX_PORT_NO + ( ( str >> 6 ) & 3 ) ; last_str = str ; last_transmit = jiffies ; } else { dfl = ( ( str & I8042_STR_PARITY ) ? SERIO_PARITY : 0 ) | ( ( str & I8042_STR_TIMEOUT && ! i8042_notimeout ) ? SERIO_TIMEOUT : 0 ) ; port_no = ( str & I8042_STR_AUXDATA ) ? I8042_AUX_PORT_NO : I8042_KBD_PORT_NO ; } port = & i8042_ports [ port_no ] ; serio = port -> exists ? port -> serio : NULL ; filter_dbg ( port -> driver_bound , data , ""<-<S2SV_blank>i8042<S2SV_blank>(interrupt,<S2SV_blank>%d,<S2SV_blank>%d%s%s)\\n"" , port_no , irq , dfl & SERIO_PARITY ? "",<S2SV_blank>bad<S2SV_blank>parity"" : """" , dfl & SERIO_TIMEOUT ? "",<S2SV_blank>timeout"" : """" ) ; filtered = i8042_filter ( data , str , serio ) ; spin_unlock_irqrestore ( & i8042_lock , flags ) ; <S2SV_StartBug> if ( likely ( port -> exists && ! filtered ) ) <S2SV_EndBug> serio_interrupt ( serio , data , dfl ) ; out : return IRQ_RETVAL ( ret ) ; }",<S2SV_ModStart> ( likely ( serio <S2SV_ModEnd> && ! filtered,torvalds@linux/340d394a789518018f834ff70f7534fc463d3226,CVE-2017-18079,https://github.com/torvalds/linux/commit/340d394a789518018f834ff70f7534fc463d3226,2018-01-29T05:29Z
CWE-119,"CWE-119 static int read_compressed_header ( VP9Decoder * pbi , const uint8_t * data , size_t partition_size ) { VP9_COMMON * const cm = & pbi -> common ; MACROBLOCKD * const xd = & pbi -> mb ; <S2SV_StartBug> FRAME_CONTEXT * const fc = & cm -> fc ; <S2SV_EndBug> vp9_reader r ; int k ; <S2SV_StartBug> if ( vp9_reader_init ( & r , data , partition_size ) ) <S2SV_EndBug> vpx_internal_error ( & cm -> error , VPX_CODEC_MEM_ERROR , ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>bool<S2SV_blank>decoder<S2SV_blank>0"" ) ; cm -> tx_mode = xd -> lossless ? ONLY_4X4 : read_tx_mode ( & r ) ; if ( cm -> tx_mode == TX_MODE_SELECT ) read_tx_mode_probs ( & fc -> tx_probs , & r ) ; read_coef_probs ( fc , cm -> tx_mode , & r ) ; for ( k = 0 ; k < SKIP_CONTEXTS ; ++ k ) vp9_diff_update_prob ( & r , & fc -> skip_probs [ k ] ) ; if ( ! frame_is_intra_only ( cm ) ) { nmv_context * const nmvc = & fc -> nmvc ; int i , j ; read_inter_mode_probs ( fc , & r ) ; if ( cm -> interp_filter == SWITCHABLE ) read_switchable_interp_probs ( fc , & r ) ; for ( i = 0 ; i < INTRA_INTER_CONTEXTS ; i ++ ) vp9_diff_update_prob ( & r , & fc -> intra_inter_prob [ i ] ) ; cm -> reference_mode = read_frame_reference_mode ( cm , & r ) ; if ( cm -> reference_mode != SINGLE_REFERENCE ) setup_compound_reference_mode ( cm ) ; read_frame_reference_mode_probs ( cm , & r ) ; for ( j = 0 ; j < BLOCK_SIZE_GROUPS ; j ++ ) for ( i = 0 ; i < INTRA_MODES - 1 ; ++ i ) vp9_diff_update_prob ( & r , & fc -> y_mode_prob [ j ] [ i ] ) ; for ( j = 0 ; j < PARTITION_CONTEXTS ; ++ j ) for ( i = 0 ; i < PARTITION_TYPES - 1 ; ++ i ) vp9_diff_update_prob ( & r , & fc -> partition_prob [ j ] [ i ] ) ; read_mv_probs ( nmvc , cm -> allow_high_precision_mv , & r ) ; } <S2SV_StartBug> return vp9_reader_has_error ( & r ) ; <S2SV_EndBug> }","<S2SV_ModStart> const fc = cm -> fc ; vpx_reader <S2SV_ModEnd> r ; int <S2SV_ModStart> ; if ( vpx_reader_init <S2SV_ModEnd> ( & r <S2SV_ModStart> data , partition_size , pbi -> decrypt_cb , pbi -> decrypt_state <S2SV_ModStart> ; } return vpx_reader_has_error <S2SV_ModEnd> ( & r",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-189,"CWE-189 static void nfs4_xdr_enc_getacl ( struct rpc_rqst * req , struct xdr_stream * xdr , struct nfs_getaclargs * args ) { struct compound_hdr hdr = { . minorversion = nfs4_xdr_minorversion ( & args -> seq_args ) , } ; uint32_t replen ; encode_compound_hdr ( xdr , req , & hdr ) ; encode_sequence ( xdr , & args -> seq_args , & hdr ) ; encode_putfh ( xdr , args -> fh , & hdr ) ; <S2SV_StartBug> replen = hdr . replen + op_decode_hdr_maxsz + nfs4_fattr_bitmap_maxsz + 1 ; <S2SV_EndBug> encode_getattr_two ( xdr , FATTR4_WORD0_ACL , 0 , & hdr ) ; xdr_inline_pages ( & req -> rq_rcv_buf , replen << 2 , args -> acl_pages , args -> acl_pgbase , args -> acl_len ) ; <S2SV_StartBug> encode_nops ( & hdr ) ; <S2SV_EndBug> }","<S2SV_ModStart> + op_decode_hdr_maxsz + <S2SV_ModEnd> 1 ; encode_getattr_two <S2SV_ModStart> acl_len ) ; xdr_set_scratch_buffer ( xdr , page_address ( args -> acl_scratch ) , PAGE_SIZE ) ;",torvalds@linux/bf118a342f10dafe44b14451a1392c3254629a1f,CVE-2011-4131,https://github.com/torvalds/linux/commit/bf118a342f10dafe44b14451a1392c3254629a1f,2012-05-17T11:00Z
CWE-190,"CWE-190 static int burl_normalize_2F_to_slash_fix ( buffer * b , int qs , int i ) { char * const s = b -> ptr ; const int blen = ( int ) buffer_string_length ( b ) ; const int used = qs < 0 ? blen : qs ; int j = i ; for ( ; i < used ; ++ i , ++ j ) { s [ j ] = s [ i ] ; if ( s [ i ] == '%' && s [ i + 1 ] == '2' && s [ i + 2 ] == 'F' ) { s [ j ] = '/' ; i += 2 ; } } if ( qs >= 0 ) { <S2SV_StartBug> memmove ( s + j , s + qs , blen - qs ) ; <S2SV_EndBug> <S2SV_StartBug> j += blen - qs ; <S2SV_EndBug> } buffer_string_set_length ( b , j ) ; return qs ; }","<S2SV_ModStart> 0 ) { const int qslen = blen - qs ; <S2SV_ModStart> + qs , ( size_t ) qslen ) ; qs = j <S2SV_ModEnd> ; j += <S2SV_ModStart> ; j += qslen <S2SV_ModEnd> ; } buffer_string_set_length",lighttpd@lighttpd1.4/32120d5b8b3203fc21ccb9eafb0eaf824bb59354,CVE-2019-11072,https://github.com/lighttpd/lighttpd1.4/commit/32120d5b8b3203fc21ccb9eafb0eaf824bb59354,2019-04-10T22:29Z
CWE-189,"CWE-189 void jiffies_to_timespec ( const unsigned long jiffies , struct timespec * value ) { <S2SV_StartBug> u64 nsec = ( u64 ) jiffies * TICK_NSEC ; <S2SV_EndBug> <S2SV_StartBug> value -> tv_sec = div_long_long_rem ( nsec , NSEC_PER_SEC , & value -> tv_nsec ) ; <S2SV_EndBug> }","<S2SV_ModStart> value ) { u32 rem ; value -> tv_sec = div_u64_rem ( <S2SV_ModEnd> ( u64 ) <S2SV_ModStart> jiffies * TICK_NSEC , NSEC_PER_SEC , & rem ) <S2SV_ModStart> ; value -> tv_nsec = rem <S2SV_ModEnd> ; } <S2SV_null>",torvalds@linux/f8bd2258e2d520dff28c855658bd24bdafb5102d,CVE-2011-3209,https://github.com/torvalds/linux/commit/f8bd2258e2d520dff28c855658bd24bdafb5102d,2012-10-03T11:02Z
CWE-284,"CWE-284 int sock_send_all ( int sock_fd , const uint8_t * buf , int len ) { int s = len ; int ret ; while ( s ) { <S2SV_StartBug> do ret = send ( sock_fd , buf , s , 0 ) ; <S2SV_EndBug> while ( ret < 0 && errno == EINTR ) ; if ( ret <= 0 ) { BTIF_TRACE_ERROR ( ""sock<S2SV_blank>fd:%d<S2SV_blank>send<S2SV_blank>errno:%d,<S2SV_blank>ret:%d"" , sock_fd , errno , ret ) ; return - 1 ; } buf += ret ; s -= ret ; } return len ; }","<S2SV_ModStart> do ret = TEMP_FAILURE_RETRY ( <S2SV_ModStart> s , 0 )",system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z
CWE-20,"CWE-20 int processCommand ( redisClient * c ) { struct redisCommand * cmd ; if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown<S2SV_blank>command<S2SV_blank>\'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments<S2SV_blank>for<S2SV_blank>\'%s\'<S2SV_blank>command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation<S2SV_blank>not<S2SV_blank>permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>when<S2SV_blank>used<S2SV_blank>memory<S2SV_blank>><S2SV_blank>\'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only<S2SV_blank>(P)SUBSCRIBE<S2SV_blank>/<S2SV_blank>(P)UNSUBSCRIBE<S2SV_blank>/<S2SV_blank>QUIT<S2SV_blank>allowed<S2SV_blank>in<S2SV_blank>this<S2SV_blank>context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link<S2SV_blank>with<S2SV_blank>MASTER<S2SV_blank>is<S2SV_blank>down<S2SV_blank>and<S2SV_blank>slave-serve-stale-data<S2SV_blank>is<S2SV_blank>set<S2SV_blank>to<S2SV_blank>no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { <S2SV_StartBug> if ( server . vm_enabled && server . vm_max_threads > 0 && <S2SV_EndBug> blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }",<S2SV_ModStart> ( server . ds_enabled && <S2SV_ModEnd> blockClientOnSwappedKeys ( c,antirez@redis/697af434fbeb2e3ba2ba9687cd283ed1a2734fa5,CVE-2013-0178,https://github.com/antirez/redis/commit/697af434fbeb2e3ba2ba9687cd283ed1a2734fa5,2019-11-01T19:15Z
CWE-125,"CWE-125 PyObject * ast2obj_withitem ( void * _o ) { withitem_ty o = ( withitem_ty ) _o ; PyObject * result = NULL , * value = NULL ; if ( ! o ) { <S2SV_StartBug> Py_INCREF ( Py_None ) ; <S2SV_EndBug> return Py_None ; } result = PyType_GenericNew ( withitem_type , NULL , NULL ) ; if ( ! result ) return NULL ; value = ast2obj_expr ( o -> context_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_context_expr , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> optional_vars ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_optional_vars , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; return result ; failed : Py_XDECREF ( value ) ; Py_XDECREF ( result ) ; return NULL ; }",<S2SV_ModStart> o ) { Py_RETURN_NONE <S2SV_ModEnd> ; } result,python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z
CWE-119,"CWE-119 static int xmlParse3986Port ( xmlURIPtr uri , const char * * str ) { const char * cur = * str ; unsigned port = 0 ; if ( ISA_DIGIT ( cur ) ) { while ( ISA_DIGIT ( cur ) ) { port = port * 10 + ( * cur - '0' ) ; cur ++ ; } if ( uri != NULL ) <S2SV_StartBug> uri -> port = port & INT_MAX ; <S2SV_EndBug> * str = cur ; return ( 0 ) ; } return ( 1 ) ; }",<S2SV_ModStart> = port & USHRT_MAX <S2SV_ModEnd> ; * str,external@libxml2/51e0cb2e5ec18eaf6fb331bc573ff27b743898f4,CVE-2017-7376,https://android.googlesource.com/platform/external/libxml2/+/51e0cb2e5ec18eaf6fb331bc573ff27b743898f4,2018-02-19T19:29Z
CWE-119,"CWE-119 <S2SV_StartBug> void ftoa_bounded_extra ( JsVarFloat val , char * str , size_t len , int radix , int fractionalDigits ) { <S2SV_EndBug> const JsVarFloat stopAtError = 0.0000001 ; <S2SV_StartBug> if ( isnan ( val ) ) strncpy ( str , ""NaN"" , len ) ; <S2SV_EndBug> else if ( ! isfinite ( val ) ) { <S2SV_StartBug> if ( val < 0 ) strncpy ( str , ""-Infinity"" , len ) ; <S2SV_EndBug> <S2SV_StartBug> else strncpy ( str , ""Infinity"" , len ) ; <S2SV_EndBug> } else { if ( val < 0 ) { if ( -- len <= 0 ) { * str = 0 ; return ; } * ( str ++ ) = '-' ; val = - val ; } if ( ( ( JsVarInt ) ( val + stopAtError ) ) == ( 1 + ( JsVarInt ) val ) ) val = ( JsVarFloat ) ( 1 + ( JsVarInt ) val ) ; JsVarFloat d = 1 ; while ( d * radix <= val ) d *= radix ; while ( d >= 1 ) { int v = ( int ) ( val / d ) ; val -= v * d ; if ( -- len <= 0 ) { * str = 0 ; return ; } * ( str ++ ) = itoch ( v ) ; d /= radix ; } # ifndef USE_NO_FLOATS if ( ( ( fractionalDigits < 0 ) && val > 0 ) || fractionalDigits > 0 ) { bool hasPt = false ; val *= radix ; while ( ( ( fractionalDigits < 0 ) && ( fractionalDigits > - 12 ) && ( val > stopAtError ) ) || ( fractionalDigits > 0 ) ) { int v = ( int ) ( val + ( ( fractionalDigits == 1 ) ? 0.4 : 0.00000001 ) ) ; val = ( val - v ) * radix ; if ( v == radix ) v = radix - 1 ; if ( ! hasPt ) { hasPt = true ; if ( -- len <= 0 ) { * str = 0 ; return ; } * ( str ++ ) = '.' ; } if ( -- len <= 0 ) { * str = 0 ; return ; } * ( str ++ ) = itoch ( v ) ; fractionalDigits -- ; } } # endif * ( str ++ ) = 0 ; } }","<S2SV_ModStart> fractionalDigits ) { assert ( len > 9 ) ; <S2SV_ModStart> val ) ) strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , ""NaN"" <S2SV_ModEnd> ) ; else <S2SV_ModStart> < 0 ) strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , ""-Infinity"" <S2SV_ModEnd> ) ; else <S2SV_ModStart> ) ; else strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , ""Infinity"" <S2SV_ModEnd> ) ; }",espruino@Espruino/0a7619875bf79877907205f6bee08465b89ff10b,CVE-2018-11595,https://github.com/espruino/Espruino/commit/0a7619875bf79877907205f6bee08465b89ff10b,2018-05-31T16:29Z
CWE-399,"CWE-399 xmlAttrPtr xsltAttrTemplateProcess ( xsltTransformContextPtr ctxt , xmlNodePtr target , xmlAttrPtr attr ) { const xmlChar * value ; xmlAttrPtr ret ; if ( ( ctxt == NULL ) || ( attr == NULL ) || ( target == NULL ) ) return ( NULL ) ; if ( attr -> type != XML_ATTRIBUTE_NODE ) return ( NULL ) ; # ifdef XSLT_REFACTORED if ( attr -> psvi == xsltXSLTAttrMarker ) return ( NULL ) ; # else if ( ( attr -> ns != NULL ) && xmlStrEqual ( attr -> ns -> href , XSLT_NAMESPACE ) ) return ( NULL ) ; # endif if ( attr -> children != NULL ) { if ( ( attr -> children -> type != XML_TEXT_NODE ) || ( attr -> children -> next != NULL ) ) { xsltTransformError ( ctxt , NULL , attr -> parent , ""Internal<S2SV_blank>error:<S2SV_blank>The<S2SV_blank>children<S2SV_blank>of<S2SV_blank>an<S2SV_blank>attribute<S2SV_blank>node<S2SV_blank>of<S2SV_blank>a<S2SV_blank>"" ""literal<S2SV_blank>result<S2SV_blank>element<S2SV_blank>are<S2SV_blank>not<S2SV_blank>in<S2SV_blank>the<S2SV_blank>expected<S2SV_blank>form.\\n"" ) ; return ( NULL ) ; } value = attr -> children -> content ; if ( value == NULL ) value = xmlDictLookup ( ctxt -> dict , BAD_CAST """" , 0 ) ; } else value = xmlDictLookup ( ctxt -> dict , BAD_CAST """" , 0 ) ; ret = target -> properties ; while ( ret != NULL ) { if ( ( ( attr -> ns != NULL ) == ( ret -> ns != NULL ) ) && xmlStrEqual ( ret -> name , attr -> name ) && ( ( attr -> ns == NULL ) || xmlStrEqual ( ret -> ns -> href , attr -> ns -> href ) ) ) { break ; } ret = ret -> next ; } if ( ret != NULL ) { xmlFreeNodeList ( ret -> children ) ; ret -> children = ret -> last = NULL ; if ( ( ret -> ns != NULL ) && ( ! xmlStrEqual ( ret -> ns -> prefix , attr -> ns -> prefix ) ) ) { ret -> ns = xsltGetNamespace ( ctxt , attr -> parent , attr -> ns , target ) ; } } else { if ( attr -> ns != NULL ) ret = xmlNewNsProp ( target , xsltGetNamespace ( ctxt , attr -> parent , attr -> ns , target ) , attr -> name , NULL ) ; else ret = xmlNewNsProp ( target , NULL , attr -> name , NULL ) ; } if ( ret != NULL ) { xmlNodePtr text ; text = xmlNewText ( NULL ) ; if ( text != NULL ) { ret -> last = ret -> children = text ; text -> parent = ( xmlNodePtr ) ret ; text -> doc = ret -> doc ; if ( attr -> psvi != NULL ) { xmlChar * val ; val = xsltEvalAVT ( ctxt , attr -> psvi , attr -> parent ) ; if ( val == NULL ) { if ( attr -> ns ) { xsltTransformError ( ctxt , NULL , attr -> parent , ""Internal<S2SV_blank>error:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>evaluate<S2SV_blank>the<S2SV_blank>AVT<S2SV_blank>"" ""of<S2SV_blank>attribute<S2SV_blank>\'{%s}%s\'.\\n"" , attr -> ns -> href , attr -> name ) ; } else { xsltTransformError ( ctxt , NULL , attr -> parent , ""Internal<S2SV_blank>error:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>evaluate<S2SV_blank>the<S2SV_blank>AVT<S2SV_blank>"" ""of<S2SV_blank>attribute<S2SV_blank>\'%s\'.\\n"" , attr -> name ) ; } text -> content = xmlStrdup ( BAD_CAST """" ) ; } else { text -> content = val ; } } else if ( ( ctxt -> internalized ) && ( target != NULL ) && ( target -> doc != NULL ) && <S2SV_StartBug> ( target -> doc -> dict == ctxt -> dict ) ) { <S2SV_EndBug> text -> content = ( xmlChar * ) value ; } else { text -> content = xmlStrdup ( value ) ; } } } else { if ( attr -> ns ) { xsltTransformError ( ctxt , NULL , attr -> parent , ""Internal<S2SV_blank>error:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>attribute<S2SV_blank>\'{%s}%s\'.\\n"" , attr -> ns -> href , attr -> name ) ; } else { xsltTransformError ( ctxt , NULL , attr -> parent , ""Internal<S2SV_blank>error:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>attribute<S2SV_blank>\'%s\'.\\n"" , attr -> name ) ; } } return ( ret ) ; }","<S2SV_ModStart> -> dict ) && xmlDictOwns ( ctxt -> dict , value )",chromium@chromium/2de493f4a1d48952e09230a0c32ccbd45db973b2,CVE-2012-2893,https://github.com/chromium/chromium/commit/2de493f4a1d48952e09230a0c32ccbd45db973b2,2012-09-26T10:56Z
CWE-125,"CWE-125 static u_int ieee802_11_print ( netdissect_options * ndo , const u_char * p , u_int length , u_int orig_caplen , int pad , u_int fcslen ) { uint16_t fc ; u_int caplen , hdrlen , meshdrlen ; struct lladdr_info src , dst ; int llc_hdrlen ; caplen = orig_caplen ; if ( length < fcslen ) { ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return caplen ; } length -= fcslen ; if ( caplen > length ) { fcslen = caplen - length ; caplen -= fcslen ; ndo -> ndo_snapend -= fcslen ; } if ( caplen < IEEE802_11_FC_LEN ) { ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return orig_caplen ; } fc = EXTRACT_LE_16BITS ( p ) ; hdrlen = extract_header_length ( ndo , fc ) ; if ( hdrlen == 0 ) { return ( 0 ) ; } if ( pad ) hdrlen = roundup2 ( hdrlen , 4 ) ; if ( ndo -> ndo_Hflag && FC_TYPE ( fc ) == T_DATA && DATA_FRAME_IS_QOS ( FC_SUBTYPE ( fc ) ) ) { <S2SV_StartBug> meshdrlen = extract_mesh_header_length ( p + hdrlen ) ; <S2SV_EndBug> hdrlen += meshdrlen ; } else meshdrlen = 0 ; if ( caplen < hdrlen ) { ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return hdrlen ; } if ( ndo -> ndo_eflag ) ieee_802_11_hdr_print ( ndo , fc , p , hdrlen , meshdrlen ) ; length -= hdrlen ; caplen -= hdrlen ; p += hdrlen ; src . addr_string = etheraddr_string ; dst . addr_string = etheraddr_string ; switch ( FC_TYPE ( fc ) ) { case T_MGMT : get_mgmt_src_dst_mac ( p - hdrlen , & src . addr , & dst . addr ) ; if ( ! mgmt_body_print ( ndo , fc , src . addr , p , length ) ) { ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return hdrlen ; } break ; case T_CTRL : if ( ! ctrl_body_print ( ndo , fc , p - hdrlen ) ) { ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return hdrlen ; } break ; case T_DATA : if ( DATA_FRAME_IS_NULL ( FC_SUBTYPE ( fc ) ) ) return hdrlen ; if ( FC_PROTECTED ( fc ) ) { ND_PRINT ( ( ndo , ""Data"" ) ) ; if ( ! wep_print ( ndo , p ) ) { ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return hdrlen ; } } else { get_data_src_dst_mac ( fc , p - hdrlen , & src . addr , & dst . addr ) ; llc_hdrlen = llc_print ( ndo , p , length , caplen , & src , & dst ) ; if ( llc_hdrlen < 0 ) { if ( ! ndo -> ndo_suppress_default_print ) ND_DEFAULTPRINT ( p , caplen ) ; llc_hdrlen = - llc_hdrlen ; } hdrlen += llc_hdrlen ; } break ; default : break ; } return hdrlen ; }","<S2SV_ModStart> ) ) { if ( caplen < hdrlen + 1 ) { ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return hdrlen ; }",the-tcpdump-group@tcpdump/4846b3c5d0a850e860baf4f07340495d29837d09,CVE-2018-16227,https://github.com/the-tcpdump-group/tcpdump/commit/4846b3c5d0a850e860baf4f07340495d29837d09,2019-10-03T16:15Z
CWE-189,"CWE-189 int kvm_iommu_map_pages ( struct kvm * kvm , struct kvm_memory_slot * slot ) { gfn_t gfn , end_gfn ; pfn_t pfn ; int r = 0 ; struct iommu_domain * domain = kvm -> arch . iommu_domain ; int flags ; if ( ! domain ) return 0 ; gfn = slot -> base_gfn ; end_gfn = gfn + slot -> npages ; flags = IOMMU_READ ; if ( ! ( slot -> flags & KVM_MEM_READONLY ) ) flags |= IOMMU_WRITE ; if ( ! kvm -> arch . iommu_noncoherent ) flags |= IOMMU_CACHE ; while ( gfn < end_gfn ) { unsigned long page_size ; if ( iommu_iova_to_phys ( domain , gfn_to_gpa ( gfn ) ) ) { gfn += 1 ; continue ; } page_size = kvm_host_page_size ( kvm , gfn ) ; while ( ( gfn + ( page_size >> PAGE_SHIFT ) ) > end_gfn ) page_size >>= 1 ; while ( ( gfn << PAGE_SHIFT ) & ( page_size - 1 ) ) page_size >>= 1 ; while ( __gfn_to_hva_memslot ( slot , gfn ) & ( page_size - 1 ) ) page_size >>= 1 ; pfn = kvm_pin_pages ( slot , gfn , page_size ) ; if ( is_error_noslot_pfn ( pfn ) ) { gfn += 1 ; continue ; } r = iommu_map ( domain , gfn_to_gpa ( gfn ) , pfn_to_hpa ( pfn ) , page_size , flags ) ; if ( r ) { printk ( KERN_ERR ""kvm_iommu_map_address:"" ""iommu<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>map<S2SV_blank>pfn=%llx\\n"" , pfn ) ; <S2SV_StartBug> goto unmap_pages ; <S2SV_EndBug> } gfn += page_size >> PAGE_SHIFT ; } return 0 ; unmap_pages : <S2SV_StartBug> kvm_iommu_put_pages ( kvm , slot -> base_gfn , gfn ) ; <S2SV_EndBug> return r ; }","<S2SV_ModStart> pfn ) ; kvm_unpin_pages ( kvm , pfn , page_size ) ; <S2SV_ModStart> base_gfn , gfn - slot -> base_gfn",torvalds@linux/350b8bdd689cd2ab2c67c8a86a0be86cfa0751a7,CVE-2014-3601,https://github.com/torvalds/linux/commit/350b8bdd689cd2ab2c67c8a86a0be86cfa0751a7,2014-09-01T01:55Z
CWE-787,"CWE-787 static inline int l2cap_connect_rsp ( struct l2cap_conn * conn , struct l2cap_cmd_hdr * cmd , u8 * data ) { struct l2cap_conn_rsp * rsp = ( struct l2cap_conn_rsp * ) data ; u16 scid , dcid , result , status ; struct sock * sk ; u8 req [ 128 ] ; scid = __le16_to_cpu ( rsp -> scid ) ; dcid = __le16_to_cpu ( rsp -> dcid ) ; result = __le16_to_cpu ( rsp -> result ) ; status = __le16_to_cpu ( rsp -> status ) ; BT_DBG ( ""dcid<S2SV_blank>0x%4.4x<S2SV_blank>scid<S2SV_blank>0x%4.4x<S2SV_blank>result<S2SV_blank>0x%2.2x<S2SV_blank>status<S2SV_blank>0x%2.2x"" , dcid , scid , result , status ) ; if ( scid ) { sk = l2cap_get_chan_by_scid ( & conn -> chan_list , scid ) ; if ( ! sk ) return 0 ; } else { sk = l2cap_get_chan_by_ident ( & conn -> chan_list , cmd -> ident ) ; if ( ! sk ) return 0 ; } switch ( result ) { case L2CAP_CR_SUCCESS : sk -> sk_state = BT_CONFIG ; l2cap_pi ( sk ) -> ident = 0 ; l2cap_pi ( sk ) -> dcid = dcid ; l2cap_pi ( sk ) -> conf_state |= L2CAP_CONF_REQ_SENT ; l2cap_pi ( sk ) -> conf_state &= ~ L2CAP_CONF_CONNECT_PEND ; l2cap_send_cmd ( conn , l2cap_get_ident ( conn ) , L2CAP_CONF_REQ , l2cap_build_conf_req ( sk , req ) , req ) ; <S2SV_StartBug> break ; <S2SV_EndBug> case L2CAP_CR_PEND : l2cap_pi ( sk ) -> conf_state |= L2CAP_CONF_CONNECT_PEND ; break ; default : l2cap_chan_del ( sk , ECONNREFUSED ) ; break ; } bh_unlock_sock ( sk ) ; return 0 ; }",<S2SV_ModStart> req ) ; l2cap_pi ( sk ) -> num_conf_req ++ ;,torvalds@linux/f2fcfcd670257236ebf2088bbdf26f6a8ef459fe,CVE-2017-1000251,https://github.com/torvalds/linux/commit/f2fcfcd670257236ebf2088bbdf26f6a8ef459fe,2017-09-12T17:29Z
CWE-119,"CWE-119 GPLOT * gplotRead ( const char * filename ) { <S2SV_StartBug> char buf [ L_BUF_SIZE ] ; <S2SV_EndBug> char * rootname , * title , * xlabel , * ylabel , * ignores ; l_int32 outformat , ret , version , ignore ; FILE * fp ; GPLOT * gplot ; PROCNAME ( ""gplotRead"" ) ; if ( ! filename ) return ( GPLOT * ) ERROR_PTR ( ""filename<S2SV_blank>not<S2SV_blank>defined"" , procName , NULL ) ; if ( ( fp = fopenReadStream ( filename ) ) == NULL ) return ( GPLOT * ) ERROR_PTR ( ""stream<S2SV_blank>not<S2SV_blank>opened"" , procName , NULL ) ; ret = fscanf ( fp , ""Gplot<S2SV_blank>Version<S2SV_blank>%d\\n"" , & version ) ; if ( ret != 1 ) { fclose ( fp ) ; return ( GPLOT * ) ERROR_PTR ( ""not<S2SV_blank>a<S2SV_blank>gplot<S2SV_blank>file"" , procName , NULL ) ; } if ( version != GPLOT_VERSION_NUMBER ) { fclose ( fp ) ; return ( GPLOT * ) ERROR_PTR ( ""invalid<S2SV_blank>gplot<S2SV_blank>version"" , procName , NULL ) ; } <S2SV_StartBug> ignore = fscanf ( fp , ""Rootname:<S2SV_blank>%s\\n"" , buf ) ; <S2SV_EndBug> rootname = stringNew ( buf ) ; ignore = fscanf ( fp , ""Output<S2SV_blank>format:<S2SV_blank>%d\\n"" , & outformat ) ; <S2SV_StartBug> ignores = fgets ( buf , L_BUF_SIZE , fp ) ; <S2SV_EndBug> title = stringNew ( buf + 7 ) ; title [ strlen ( title ) - 1 ] = '\\0' ; <S2SV_StartBug> ignores = fgets ( buf , L_BUF_SIZE , fp ) ; <S2SV_EndBug> xlabel = stringNew ( buf + 14 ) ; xlabel [ strlen ( xlabel ) - 1 ] = '\\0' ; <S2SV_StartBug> ignores = fgets ( buf , L_BUF_SIZE , fp ) ; <S2SV_EndBug> ylabel = stringNew ( buf + 14 ) ; ylabel [ strlen ( ylabel ) - 1 ] = '\\0' ; gplot = gplotCreate ( rootname , outformat , title , xlabel , ylabel ) ; LEPT_FREE ( rootname ) ; LEPT_FREE ( title ) ; LEPT_FREE ( xlabel ) ; LEPT_FREE ( ylabel ) ; if ( ! gplot ) { fclose ( fp ) ; return ( GPLOT * ) ERROR_PTR ( ""gplot<S2SV_blank>not<S2SV_blank>made"" , procName , NULL ) ; } sarrayDestroy ( & gplot -> cmddata ) ; sarrayDestroy ( & gplot -> datanames ) ; sarrayDestroy ( & gplot -> plotdata ) ; sarrayDestroy ( & gplot -> plottitles ) ; numaDestroy ( & gplot -> plotstyles ) ; <S2SV_StartBug> ignore = fscanf ( fp , ""Commandfile<S2SV_blank>name:<S2SV_blank>%s\\n"" , buf ) ; <S2SV_EndBug> stringReplace ( & gplot -> cmdname , buf ) ; ignore = fscanf ( fp , ""\\nCommandfile<S2SV_blank>data:"" ) ; gplot -> cmddata = sarrayReadStream ( fp ) ; ignore = fscanf ( fp , ""\\nDatafile<S2SV_blank>names:"" ) ; gplot -> datanames = sarrayReadStream ( fp ) ; ignore = fscanf ( fp , ""\\nPlot<S2SV_blank>data:"" ) ; gplot -> plotdata = sarrayReadStream ( fp ) ; ignore = fscanf ( fp , ""\\nPlot<S2SV_blank>titles:"" ) ; gplot -> plottitles = sarrayReadStream ( fp ) ; ignore = fscanf ( fp , ""\\nPlot<S2SV_blank>styles:"" ) ; gplot -> plotstyles = numaReadStream ( fp ) ; ignore = fscanf ( fp , ""Number<S2SV_blank>of<S2SV_blank>plots:<S2SV_blank>%d\\n"" , & gplot -> nplots ) ; <S2SV_StartBug> ignore = fscanf ( fp , ""Output<S2SV_blank>file<S2SV_blank>name:<S2SV_blank>%s\\n"" , buf ) ; <S2SV_EndBug> stringReplace ( & gplot -> outname , buf ) ; ignore = fscanf ( fp , ""Axis<S2SV_blank>scaling:<S2SV_blank>%d\\n"" , & gplot -> scaling ) ; fclose ( fp ) ; return gplot ; }","<S2SV_ModStart> char buf [ L_BUFSIZE <S2SV_ModEnd> ] ; char <S2SV_ModStart> ( fp , ""Rootname:<S2SV_blank>%511s\\n"" <S2SV_ModEnd> , buf ) <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , fp ) <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , fp ) <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , fp ) <S2SV_ModStart> ( fp , ""Commandfile<S2SV_blank>name:<S2SV_blank>%511s\\n"" <S2SV_ModEnd> , buf ) <S2SV_ModStart> ( fp , ""Output<S2SV_blank>file<S2SV_blank>name:<S2SV_blank>%511s\\n"" <S2SV_ModEnd> , buf )",DanBloomberg@leptonica/ee301cb2029db8a6289c5295daa42bba7715e99a,CVE-2018-7186,https://github.com/DanBloomberg/leptonica/commit/ee301cb2029db8a6289c5295daa42bba7715e99a,2018-02-16T16:29Z
CWE-119,"CWE-119 <S2SV_StartBug> static void <S2SV_EndBug> swabHorDiff16 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { uint16 * wp = ( uint16 * ) cp0 ; tmsize_t wc = cc / 2 ; <S2SV_StartBug> horDiff16 ( tif , cp0 , cc ) ; <S2SV_EndBug> TIFFSwabArrayOfShort ( wp , wc ) ; <S2SV_StartBug> } <S2SV_EndBug>","<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> swabHorDiff16 ( TIFF <S2SV_ModStart> / 2 ; if ( ! <S2SV_ModStart> , cc ) ) return 0 <S2SV_ModStart> wc ) ; return 1 ;",vadz@libtiff/3ca657a8793dd011bf869695d72ad31c779c3cc1,CVE-2016-9535,https://github.com/vadz/libtiff/commit/3ca657a8793dd011bf869695d72ad31c779c3cc1,2016-11-22T19:59Z
CWE-399,"CWE-399 static void init_vmcb ( struct vcpu_svm * svm ) { struct vmcb_control_area * control = & svm -> vmcb -> control ; struct vmcb_save_area * save = & svm -> vmcb -> save ; svm -> vcpu . fpu_active = 1 ; svm -> vcpu . arch . hflags = 0 ; set_cr_intercept ( svm , INTERCEPT_CR0_READ ) ; set_cr_intercept ( svm , INTERCEPT_CR3_READ ) ; set_cr_intercept ( svm , INTERCEPT_CR4_READ ) ; set_cr_intercept ( svm , INTERCEPT_CR0_WRITE ) ; set_cr_intercept ( svm , INTERCEPT_CR3_WRITE ) ; set_cr_intercept ( svm , INTERCEPT_CR4_WRITE ) ; set_cr_intercept ( svm , INTERCEPT_CR8_WRITE ) ; set_dr_intercepts ( svm ) ; set_exception_intercept ( svm , PF_VECTOR ) ; set_exception_intercept ( svm , UD_VECTOR ) ; set_exception_intercept ( svm , MC_VECTOR ) ; <S2SV_StartBug> set_exception_intercept ( svm , AC_VECTOR ) ; <S2SV_EndBug> set_intercept ( svm , INTERCEPT_INTR ) ; set_intercept ( svm , INTERCEPT_NMI ) ; set_intercept ( svm , INTERCEPT_SMI ) ; set_intercept ( svm , INTERCEPT_SELECTIVE_CR0 ) ; set_intercept ( svm , INTERCEPT_RDPMC ) ; set_intercept ( svm , INTERCEPT_CPUID ) ; set_intercept ( svm , INTERCEPT_INVD ) ; set_intercept ( svm , INTERCEPT_HLT ) ; set_intercept ( svm , INTERCEPT_INVLPG ) ; set_intercept ( svm , INTERCEPT_INVLPGA ) ; set_intercept ( svm , INTERCEPT_IOIO_PROT ) ; set_intercept ( svm , INTERCEPT_MSR_PROT ) ; set_intercept ( svm , INTERCEPT_TASK_SWITCH ) ; set_intercept ( svm , INTERCEPT_SHUTDOWN ) ; set_intercept ( svm , INTERCEPT_VMRUN ) ; set_intercept ( svm , INTERCEPT_VMMCALL ) ; set_intercept ( svm , INTERCEPT_VMLOAD ) ; set_intercept ( svm , INTERCEPT_VMSAVE ) ; set_intercept ( svm , INTERCEPT_STGI ) ; set_intercept ( svm , INTERCEPT_CLGI ) ; set_intercept ( svm , INTERCEPT_SKINIT ) ; set_intercept ( svm , INTERCEPT_WBINVD ) ; set_intercept ( svm , INTERCEPT_MONITOR ) ; set_intercept ( svm , INTERCEPT_MWAIT ) ; set_intercept ( svm , INTERCEPT_XSETBV ) ; control -> iopm_base_pa = iopm_base ; control -> msrpm_base_pa = __pa ( svm -> msrpm ) ; control -> int_ctl = V_INTR_MASKING_MASK ; init_seg ( & save -> es ) ; init_seg ( & save -> ss ) ; init_seg ( & save -> ds ) ; init_seg ( & save -> fs ) ; init_seg ( & save -> gs ) ; save -> cs . selector = 0xf000 ; save -> cs . base = 0xffff0000 ; save -> cs . attrib = SVM_SELECTOR_READ_MASK | SVM_SELECTOR_P_MASK | SVM_SELECTOR_S_MASK | SVM_SELECTOR_CODE_MASK ; save -> cs . limit = 0xffff ; save -> gdtr . limit = 0xffff ; save -> idtr . limit = 0xffff ; init_sys_seg ( & save -> ldtr , SEG_TYPE_LDT ) ; init_sys_seg ( & save -> tr , SEG_TYPE_BUSY_TSS16 ) ; svm_set_efer ( & svm -> vcpu , 0 ) ; save -> dr6 = 0xffff0ff0 ; kvm_set_rflags ( & svm -> vcpu , 2 ) ; save -> rip = 0x0000fff0 ; svm -> vcpu . arch . regs [ VCPU_REGS_RIP ] = save -> rip ; svm_set_cr0 ( & svm -> vcpu , X86_CR0_NW | X86_CR0_CD | X86_CR0_ET ) ; kvm_mmu_reset_context ( & svm -> vcpu ) ; save -> cr4 = X86_CR4_PAE ; if ( npt_enabled ) { control -> nested_ctl = 1 ; clr_intercept ( svm , INTERCEPT_INVLPG ) ; clr_exception_intercept ( svm , PF_VECTOR ) ; clr_cr_intercept ( svm , INTERCEPT_CR3_READ ) ; clr_cr_intercept ( svm , INTERCEPT_CR3_WRITE ) ; save -> g_pat = svm -> vcpu . arch . pat ; save -> cr3 = 0 ; save -> cr4 = 0 ; } svm -> asid_generation = 0 ; svm -> nested . vmcb = 0 ; svm -> vcpu . arch . hflags = 0 ; if ( boot_cpu_has ( X86_FEATURE_PAUSEFILTER ) ) { control -> pause_filter_count = 3000 ; set_intercept ( svm , INTERCEPT_PAUSE ) ; } mark_all_dirty ( svm -> vmcb ) ; enable_gif ( svm ) ; }","<S2SV_ModStart> svm , AC_VECTOR ) ; set_exception_intercept ( svm , DB_VECTOR",torvalds@linux/cbdb967af3d54993f5814f1cee0ed311a055377d,CVE-2015-8104,https://github.com/torvalds/linux/commit/cbdb967af3d54993f5814f1cee0ed311a055377d,2015-11-16T11:59Z
CWE-401,"CWE-000 int rtl_usb_probe ( struct usb_interface * intf , const struct usb_device_id * id , struct rtl_hal_cfg * rtl_hal_cfg ) { int err ; struct ieee80211_hw * hw = NULL ; struct rtl_priv * rtlpriv = NULL ; struct usb_device * udev ; struct rtl_usb_priv * usb_priv ; hw = ieee80211_alloc_hw ( sizeof ( struct rtl_priv ) + sizeof ( struct rtl_usb_priv ) , & rtl_ops ) ; if ( ! hw ) { WARN_ONCE ( true , ""rtl_usb:<S2SV_blank>ieee80211<S2SV_blank>alloc<S2SV_blank>failed\\n"" ) ; return - ENOMEM ; } rtlpriv = hw -> priv ; rtlpriv -> hw = hw ; rtlpriv -> usb_data = kcalloc ( RTL_USB_MAX_RX_COUNT , sizeof ( u32 ) , GFP_KERNEL ) ; <S2SV_StartBug> if ( ! rtlpriv -> usb_data ) <S2SV_EndBug> return - ENOMEM ; <S2SV_StartBug> spin_lock_init ( & rtlpriv -> locks . usb_lock ) ; <S2SV_EndBug> INIT_WORK ( & rtlpriv -> works . fill_h2c_cmd , rtl_fill_h2c_cmd_work_callback ) ; INIT_WORK ( & rtlpriv -> works . lps_change_work , rtl_lps_change_work_callback ) ; rtlpriv -> usb_data_index = 0 ; init_completion ( & rtlpriv -> firmware_loading_complete ) ; SET_IEEE80211_DEV ( hw , & intf -> dev ) ; udev = interface_to_usbdev ( intf ) ; usb_get_dev ( udev ) ; usb_priv = rtl_usbpriv ( hw ) ; memset ( usb_priv , 0 , sizeof ( * usb_priv ) ) ; usb_priv -> dev . intf = intf ; usb_priv -> dev . udev = udev ; usb_set_intfdata ( intf , hw ) ; rtlpriv -> rtlhal . interface = INTF_USB ; rtlpriv -> cfg = rtl_hal_cfg ; rtlpriv -> intf_ops = & rtl_usb_ops ; _rtl_usb_io_handler_init ( & udev -> dev , hw ) ; rtlpriv -> cfg -> ops -> read_chip_version ( hw ) ; rtlpriv -> cfg -> ops -> read_eeprom_info ( hw ) ; err = _rtl_usb_init ( hw ) ; if ( err ) goto error_out2 ; rtl_usb_init_sw ( hw ) ; err = rtl_init_core ( hw ) ; if ( err ) { pr_err ( ""Can\'t<S2SV_blank>allocate<S2SV_blank>sw<S2SV_blank>for<S2SV_blank>mac80211\\n"" ) ; goto error_out2 ; } if ( rtlpriv -> cfg -> ops -> init_sw_vars ( hw ) ) { pr_err ( ""Can\'t<S2SV_blank>init_sw_vars\\n"" ) ; goto error_out ; } rtlpriv -> cfg -> ops -> init_sw_leds ( hw ) ; err = ieee80211_register_hw ( hw ) ; if ( err ) { pr_err ( ""Can\'t<S2SV_blank>register<S2SV_blank>mac80211<S2SV_blank>hw.\\n"" ) ; err = - ENODEV ; goto error_out ; } rtlpriv -> mac80211 . mac80211_registered = 1 ; set_bit ( RTL_STATUS_INTERFACE_START , & rtlpriv -> status ) ; return 0 ; error_out : rtl_deinit_core ( hw ) ; error_out2 : _rtl_usb_io_handler_release ( hw ) ; usb_put_dev ( udev ) ; <S2SV_StartBug> complete ( & rtlpriv -> firmware_loading_complete ) ; <S2SV_EndBug> return - ENODEV ; }",<S2SV_ModStart> -> usb_data ) { ieee80211_free_hw ( hw ) ; <S2SV_ModStart> - ENOMEM ; } <S2SV_ModStart> rtlpriv -> firmware_loading_complete ) ; kfree ( rtlpriv -> usb_data,torvalds@linux/3f93616951138a598d930dcaec40f2bfd9ce43bb,CVE-2019-19063,https://github.com/torvalds/linux/commit/3f93616951138a598d930dcaec40f2bfd9ce43bb,2019-11-18T06:15Z
CWE-200,"CWE-200 static int __fpu__restore_sig ( void __user * buf , void __user * buf_fx , int size ) { int ia32_fxstate = ( buf != buf_fx ) ; struct task_struct * tsk = current ; struct fpu * fpu = & tsk -> thread . fpu ; int state_size = fpu_kernel_xstate_size ; u64 xfeatures = 0 ; int fx_only = 0 ; ia32_fxstate &= ( IS_ENABLED ( CONFIG_X86_32 ) || IS_ENABLED ( CONFIG_IA32_EMULATION ) ) ; if ( ! buf ) { fpu__clear ( fpu ) ; return 0 ; } if ( ! access_ok ( VERIFY_READ , buf , size ) ) return - EACCES ; fpu__activate_curr ( fpu ) ; if ( ! static_cpu_has ( X86_FEATURE_FPU ) ) return fpregs_soft_set ( current , NULL , 0 , sizeof ( struct user_i387_ia32_struct ) , NULL , buf ) != 0 ; if ( use_xsave ( ) ) { struct _fpx_sw_bytes fx_sw_user ; if ( unlikely ( check_for_xstate ( buf_fx , buf_fx , & fx_sw_user ) ) ) { state_size = sizeof ( struct fxregs_state ) ; fx_only = 1 ; trace_x86_fpu_xstate_check_failed ( fpu ) ; } else { state_size = fx_sw_user . xstate_size ; xfeatures = fx_sw_user . xfeatures ; } } if ( ia32_fxstate ) { struct fpu * fpu = & tsk -> thread . fpu ; struct user_i387_ia32_struct env ; int err = 0 ; fpu__drop ( fpu ) ; <S2SV_StartBug> if ( using_compacted_format ( ) ) <S2SV_EndBug> err = copy_user_to_xstate ( & fpu -> state . xsave , buf_fx ) ; <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> err = __copy_from_user ( & fpu -> state . xsave , buf_fx , state_size ) ; <S2SV_EndBug> if ( err || __copy_from_user ( & env , buf , sizeof ( env ) ) ) { fpstate_init ( & fpu -> state ) ; trace_x86_fpu_init_state ( fpu ) ; err = - 1 ; } else { sanitize_restored_xstate ( tsk , & env , xfeatures , fx_only ) ; } fpu -> fpstate_active = 1 ; preempt_disable ( ) ; fpu__restore ( fpu ) ; preempt_enable ( ) ; return err ; } else { user_fpu_begin ( ) ; if ( copy_user_to_fpregs_zeroing ( buf_fx , xfeatures , fx_only ) ) { fpu__clear ( fpu ) ; return - 1 ; } } return 0 ; }","<S2SV_ModStart> ( ) ) { <S2SV_ModStart> buf_fx ) ; } else { <S2SV_ModEnd> err = __copy_from_user <S2SV_ModStart> state_size ) ; if ( ! err && state_size > offsetof ( struct xregs_state , header ) && fpu -> state . xsave . header . xcomp_bv ) err = - EINVAL ; }",torvalds@linux/814fb7bb7db5433757d76f4c4502c96fc53b0b5e,CVE-2017-15537,https://github.com/torvalds/linux/commit/814fb7bb7db5433757d76f4c4502c96fc53b0b5e,2017-10-17T18:29Z
CWE-787,"CWE-787 void avcodec_align_dimensions2 ( AVCodecContext * s , int * width , int * height , int linesize_align [ AV_NUM_DATA_POINTERS ] ) { int i ; int w_align = 1 ; int h_align = 1 ; AVPixFmtDescriptor const * desc = av_pix_fmt_desc_get ( s -> pix_fmt ) ; if ( desc ) { w_align = 1 << desc -> log2_chroma_w ; h_align = 1 << desc -> log2_chroma_h ; } switch ( s -> pix_fmt ) { case AV_PIX_FMT_YUV420P : case AV_PIX_FMT_YUYV422 : case AV_PIX_FMT_YVYU422 : case AV_PIX_FMT_UYVY422 : case AV_PIX_FMT_YUV422P : case AV_PIX_FMT_YUV440P : case AV_PIX_FMT_YUV444P : case AV_PIX_FMT_GBRP : case AV_PIX_FMT_GBRAP : case AV_PIX_FMT_GRAY8 : case AV_PIX_FMT_GRAY16BE : case AV_PIX_FMT_GRAY16LE : case AV_PIX_FMT_YUVJ420P : case AV_PIX_FMT_YUVJ422P : case AV_PIX_FMT_YUVJ440P : case AV_PIX_FMT_YUVJ444P : case AV_PIX_FMT_YUVA420P : case AV_PIX_FMT_YUVA422P : case AV_PIX_FMT_YUVA444P : case AV_PIX_FMT_YUV420P9LE : case AV_PIX_FMT_YUV420P9BE : case AV_PIX_FMT_YUV420P10LE : case AV_PIX_FMT_YUV420P10BE : case AV_PIX_FMT_YUV420P12LE : case AV_PIX_FMT_YUV420P12BE : case AV_PIX_FMT_YUV420P14LE : case AV_PIX_FMT_YUV420P14BE : case AV_PIX_FMT_YUV420P16LE : case AV_PIX_FMT_YUV420P16BE : case AV_PIX_FMT_YUVA420P9LE : case AV_PIX_FMT_YUVA420P9BE : case AV_PIX_FMT_YUVA420P10LE : case AV_PIX_FMT_YUVA420P10BE : case AV_PIX_FMT_YUVA420P16LE : case AV_PIX_FMT_YUVA420P16BE : case AV_PIX_FMT_YUV422P9LE : case AV_PIX_FMT_YUV422P9BE : case AV_PIX_FMT_YUV422P10LE : case AV_PIX_FMT_YUV422P10BE : case AV_PIX_FMT_YUV422P12LE : case AV_PIX_FMT_YUV422P12BE : case AV_PIX_FMT_YUV422P14LE : case AV_PIX_FMT_YUV422P14BE : case AV_PIX_FMT_YUV422P16LE : case AV_PIX_FMT_YUV422P16BE : case AV_PIX_FMT_YUVA422P9LE : case AV_PIX_FMT_YUVA422P9BE : case AV_PIX_FMT_YUVA422P10LE : case AV_PIX_FMT_YUVA422P10BE : case AV_PIX_FMT_YUVA422P16LE : case AV_PIX_FMT_YUVA422P16BE : case AV_PIX_FMT_YUV440P10LE : case AV_PIX_FMT_YUV440P10BE : case AV_PIX_FMT_YUV440P12LE : case AV_PIX_FMT_YUV440P12BE : case AV_PIX_FMT_YUV444P9LE : case AV_PIX_FMT_YUV444P9BE : case AV_PIX_FMT_YUV444P10LE : case AV_PIX_FMT_YUV444P10BE : case AV_PIX_FMT_YUV444P12LE : case AV_PIX_FMT_YUV444P12BE : case AV_PIX_FMT_YUV444P14LE : case AV_PIX_FMT_YUV444P14BE : case AV_PIX_FMT_YUV444P16LE : case AV_PIX_FMT_YUV444P16BE : case AV_PIX_FMT_YUVA444P9LE : case AV_PIX_FMT_YUVA444P9BE : case AV_PIX_FMT_YUVA444P10LE : case AV_PIX_FMT_YUVA444P10BE : case AV_PIX_FMT_YUVA444P16LE : case AV_PIX_FMT_YUVA444P16BE : case AV_PIX_FMT_GBRP9LE : case AV_PIX_FMT_GBRP9BE : case AV_PIX_FMT_GBRP10LE : case AV_PIX_FMT_GBRP10BE : case AV_PIX_FMT_GBRP12LE : case AV_PIX_FMT_GBRP12BE : case AV_PIX_FMT_GBRP14LE : case AV_PIX_FMT_GBRP14BE : case AV_PIX_FMT_GBRP16LE : case AV_PIX_FMT_GBRP16BE : case AV_PIX_FMT_GBRAP12LE : case AV_PIX_FMT_GBRAP12BE : case AV_PIX_FMT_GBRAP16LE : case AV_PIX_FMT_GBRAP16BE : w_align = 16 ; h_align = 16 * 2 ; break ; case AV_PIX_FMT_YUV411P : case AV_PIX_FMT_YUVJ411P : case AV_PIX_FMT_UYYVYY411 : w_align = 32 ; h_align = 16 * 2 ; break ; case AV_PIX_FMT_YUV410P : if ( s -> codec_id == AV_CODEC_ID_SVQ1 ) { w_align = 64 ; h_align = 64 ; } break ; case AV_PIX_FMT_RGB555 : if ( s -> codec_id == AV_CODEC_ID_RPZA ) { w_align = 4 ; h_align = 4 ; } <S2SV_StartBug> break ; <S2SV_EndBug> case AV_PIX_FMT_PAL8 : case AV_PIX_FMT_BGR8 : case AV_PIX_FMT_RGB8 : if ( s -> codec_id == AV_CODEC_ID_SMC || s -> codec_id == AV_CODEC_ID_CINEPAK ) { w_align = 4 ; h_align = 4 ; } <S2SV_StartBug> if ( s -> codec_id == AV_CODEC_ID_JV ) { <S2SV_EndBug> w_align = 8 ; h_align = 8 ; } break ; case AV_PIX_FMT_BGR24 : if ( ( s -> codec_id == AV_CODEC_ID_MSZH ) || ( s -> codec_id == AV_CODEC_ID_ZLIB ) ) { w_align = 4 ; h_align = 4 ; } break ; case AV_PIX_FMT_RGB24 : if ( s -> codec_id == AV_CODEC_ID_CINEPAK ) { w_align = 4 ; h_align = 4 ; } break ; default : break ; } if ( s -> codec_id == AV_CODEC_ID_IFF_ILBM ) { w_align = FFMAX ( w_align , 8 ) ; } * width = FFALIGN ( * width , w_align ) ; * height = FFALIGN ( * height , h_align ) ; if ( s -> codec_id == AV_CODEC_ID_H264 || s -> lowres ) { * height += 2 ; * width = FFMAX ( * width , 32 ) ; } for ( i = 0 ; i < 4 ; i ++ ) linesize_align [ i ] = STRIDE_ALIGN ; }",<S2SV_ModStart> 4 ; } if ( s -> codec_id == AV_CODEC_ID_INTERPLAY_VIDEO ) { w_align = 8 ; h_align = 8 ; } <S2SV_ModStart> codec_id == AV_CODEC_ID_JV || s -> codec_id == AV_CODEC_ID_INTERPLAY_VIDEO,FFmpeg@FFmpeg/2080bc33717955a0e4268e738acf8c1eeddbf8cb,CVE-2017-7865,https://github.com/FFmpeg/FFmpeg/commit/2080bc33717955a0e4268e738acf8c1eeddbf8cb,2017-04-14T04:59Z
CWE-1187,"CWE-000 static int parsegid ( const char * s , gid_t * gid ) { struct group * gr ; <S2SV_StartBug> const char * errstr ; <S2SV_EndBug> if ( ( gr = getgrnam ( s ) ) != NULL ) { * gid = gr -> gr_gid ; return 0 ; } # if ! defined ( __linux__ ) && ! defined ( __NetBSD__ ) * gid = strtonum ( s , 0 , GID_MAX , & errstr ) ; <S2SV_StartBug> # else <S2SV_EndBug> sscanf ( s , ""%d"" , gid ) ; <S2SV_StartBug> # endif <S2SV_EndBug> if ( errstr ) return - 1 ; <S2SV_StartBug> return 0 ; <S2SV_EndBug> }",<S2SV_ModStart> * gr ; # if ! defined ( __linux__ ) && ! defined ( __NetBSD__ ) <S2SV_ModStart> char * errstr = NULL ; # else int status ; # endif <S2SV_ModEnd> if ( ( <S2SV_ModStart> errstr ) ; if ( errstr ) return - 1 ; # else status = <S2SV_ModEnd> sscanf ( s <S2SV_ModStart> gid ) ; if ( status != 1 <S2SV_ModEnd> ) return - <S2SV_ModStart> - 1 ; # endif,slicer69@doas/2f83222829448e5bc4c9391d607ec265a1e06531,CVE-2019-15900,https://github.com/slicer69/doas/commit/2f83222829448e5bc4c9391d607ec265a1e06531,2019-10-18T16:15Z
CWE-119,"CWE-119 <S2SV_StartBug> static void save_context ( VP9_COMP * cpi , int mi_row , int mi_col , <S2SV_EndBug> ENTROPY_CONTEXT a [ 16 * MAX_MB_PLANE ] , ENTROPY_CONTEXT l [ 16 * MAX_MB_PLANE ] , PARTITION_CONTEXT sa [ 8 ] , PARTITION_CONTEXT sl [ 8 ] , BLOCK_SIZE bsize ) { <S2SV_StartBug> const MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> const MACROBLOCKD * const xd = & x -> e_mbd ; int p ; const int num_4x4_blocks_wide = num_4x4_blocks_wide_lookup [ bsize ] ; const int num_4x4_blocks_high = num_4x4_blocks_high_lookup [ bsize ] ; int mi_width = num_8x8_blocks_wide_lookup [ bsize ] ; int mi_height = num_8x8_blocks_high_lookup [ bsize ] ; for ( p = 0 ; p < MAX_MB_PLANE ; ++ p ) { <S2SV_StartBug> vpx_memcpy ( <S2SV_EndBug> a + num_4x4_blocks_wide * p , xd -> above_context [ p ] + ( mi_col * 2 >> xd -> plane [ p ] . subsampling_x ) , ( sizeof ( ENTROPY_CONTEXT ) * num_4x4_blocks_wide ) >> xd -> plane [ p ] . subsampling_x ) ; <S2SV_StartBug> vpx_memcpy ( <S2SV_EndBug> l + num_4x4_blocks_high * p , xd -> left_context [ p ] + ( ( mi_row & MI_MASK ) * 2 >> xd -> plane [ p ] . subsampling_y ) , ( sizeof ( ENTROPY_CONTEXT ) * num_4x4_blocks_high ) >> xd -> plane [ p ] . subsampling_y ) ; } <S2SV_StartBug> vpx_memcpy ( sa , xd -> above_seg_context + mi_col , <S2SV_EndBug> sizeof ( * xd -> above_seg_context ) * mi_width ) ; <S2SV_StartBug> vpx_memcpy ( sl , xd -> left_seg_context + ( mi_row & MI_MASK ) , <S2SV_EndBug> sizeof ( xd -> left_seg_context [ 0 ] ) * mi_height ) ; }","<S2SV_ModStart> void save_context ( MACROBLOCK * const x <S2SV_ModEnd> , int mi_row <S2SV_ModStart> ) { const <S2SV_ModEnd> MACROBLOCKD * const <S2SV_ModStart> p ) { memcpy <S2SV_ModEnd> ( a + <S2SV_ModStart> subsampling_x ) ; memcpy <S2SV_ModEnd> ( l + <S2SV_ModStart> ) ; } memcpy <S2SV_ModEnd> ( sa , <S2SV_ModStart> mi_width ) ; memcpy <S2SV_ModEnd> ( sl ,",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-125,"CWE-125 static void <S2SV_StartBug> l2tp_bearer_type_print ( netdissect_options * ndo , const u_char * dat ) <S2SV_EndBug> { <S2SV_StartBug> const uint32_t * ptr = ( const uint32_t * ) dat ; <S2SV_EndBug> if ( EXTRACT_32BITS ( ptr ) & L2TP_BEARER_TYPE_ANALOG_MASK ) { ND_PRINT ( ( ndo , ""A"" ) ) ; } if ( EXTRACT_32BITS ( ptr ) & L2TP_BEARER_TYPE_DIGITAL_MASK ) { ND_PRINT ( ( ndo , ""D"" ) ) ; } }","<S2SV_ModStart> u_char * dat , u_int length <S2SV_ModStart> ) dat ; if ( length < 4 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; }",the-tcpdump-group@tcpdump/cc4a7391c616be7a64ed65742ef9ed3f106eb165,CVE-2017-13006,https://github.com/the-tcpdump-group/tcpdump/commit/cc4a7391c616be7a64ed65742ef9ed3f106eb165,2017-09-14T06:29Z
CWE-362,"CWE-362 struct sta_info * sta_info_alloc ( struct ieee80211_sub_if_data * sdata , const u8 * addr , gfp_t gfp ) { struct ieee80211_local * local = sdata -> local ; struct sta_info * sta ; struct timespec uptime ; struct ieee80211_tx_latency_bin_ranges * tx_latency ; int i ; sta = kzalloc ( sizeof ( * sta ) + local -> hw . sta_data_size , gfp ) ; if ( ! sta ) return NULL ; rcu_read_lock ( ) ; tx_latency = rcu_dereference ( local -> tx_latency ) ; if ( tx_latency ) { sta -> tx_lat = kzalloc ( IEEE80211_NUM_TIDS * sizeof ( struct ieee80211_tx_latency_stat ) , GFP_ATOMIC ) ; if ( ! sta -> tx_lat ) { rcu_read_unlock ( ) ; goto free ; } if ( tx_latency -> n_ranges ) { for ( i = 0 ; i < IEEE80211_NUM_TIDS ; i ++ ) { sta -> tx_lat [ i ] . bin_count = tx_latency -> n_ranges + 1 ; sta -> tx_lat [ i ] . bins = kcalloc ( sta -> tx_lat [ i ] . bin_count , sizeof ( u32 ) , GFP_ATOMIC ) ; if ( ! sta -> tx_lat [ i ] . bins ) { rcu_read_unlock ( ) ; goto free ; } } } } rcu_read_unlock ( ) ; <S2SV_StartBug> spin_lock_init ( & sta -> lock ) ; <S2SV_EndBug> INIT_WORK ( & sta -> drv_unblock_wk , sta_unblock ) ; INIT_WORK ( & sta -> ampdu_mlme . work , ieee80211_ba_session_work ) ; mutex_init ( & sta -> ampdu_mlme . mtx ) ; # ifdef CONFIG_MAC80211_MESH if ( ieee80211_vif_is_mesh ( & sdata -> vif ) && ! sdata -> u . mesh . user_mpm ) init_timer ( & sta -> plink_timer ) ; sta -> nonpeer_pm = NL80211_MESH_POWER_ACTIVE ; # endif memcpy ( sta -> sta . addr , addr , ETH_ALEN ) ; sta -> local = local ; sta -> sdata = sdata ; sta -> last_rx = jiffies ; sta -> sta_state = IEEE80211_STA_NONE ; do_posix_clock_monotonic_gettime ( & uptime ) ; sta -> last_connected = uptime . tv_sec ; ewma_init ( & sta -> avg_signal , 1024 , 8 ) ; for ( i = 0 ; i < ARRAY_SIZE ( sta -> chain_signal_avg ) ; i ++ ) ewma_init ( & sta -> chain_signal_avg [ i ] , 1024 , 8 ) ; if ( sta_prepare_rate_control ( local , sta , gfp ) ) goto free ; for ( i = 0 ; i < IEEE80211_NUM_TIDS ; i ++ ) { sta -> timer_to_tid [ i ] = i ; } for ( i = 0 ; i < IEEE80211_NUM_ACS ; i ++ ) { skb_queue_head_init ( & sta -> ps_tx_buf [ i ] ) ; skb_queue_head_init ( & sta -> tx_filtered [ i ] ) ; } for ( i = 0 ; i < IEEE80211_NUM_TIDS ; i ++ ) sta -> last_seq_ctrl [ i ] = cpu_to_le16 ( USHRT_MAX ) ; sta -> sta . smps_mode = IEEE80211_SMPS_OFF ; if ( sdata -> vif . type == NL80211_IFTYPE_AP || sdata -> vif . type == NL80211_IFTYPE_AP_VLAN ) { struct ieee80211_supported_band * sband = local -> hw . wiphy -> bands [ ieee80211_get_sdata_band ( sdata ) ] ; u8 smps = ( sband -> ht_cap . cap & IEEE80211_HT_CAP_SM_PS ) >> IEEE80211_HT_CAP_SM_PS_SHIFT ; switch ( smps ) { case WLAN_HT_SMPS_CONTROL_DISABLED : sta -> known_smps_mode = IEEE80211_SMPS_OFF ; break ; case WLAN_HT_SMPS_CONTROL_STATIC : sta -> known_smps_mode = IEEE80211_SMPS_STATIC ; break ; case WLAN_HT_SMPS_CONTROL_DYNAMIC : sta -> known_smps_mode = IEEE80211_SMPS_DYNAMIC ; break ; default : WARN_ON ( 1 ) ; } } sta_dbg ( sdata , ""Allocated<S2SV_blank>STA<S2SV_blank>%pM\\n"" , sta -> sta . addr ) ; return sta ; free : if ( sta -> tx_lat ) { for ( i = 0 ; i < IEEE80211_NUM_TIDS ; i ++ ) kfree ( sta -> tx_lat [ i ] . bins ) ; kfree ( sta -> tx_lat ) ; } kfree ( sta ) ; return NULL ; }",<S2SV_ModStart> sta -> lock ) ; spin_lock_init ( & sta -> ps_lock,torvalds@linux/1d147bfa64293b2723c4fec50922168658e613ba,CVE-2014-2706,https://github.com/torvalds/linux/commit/1d147bfa64293b2723c4fec50922168658e613ba,2014-04-14T23:55Z
CWE-20,"CWE-20 error_t rawSocketSendIpPacket ( Socket * socket , const SocketMsg * message , uint_t flags ) { error_t error ; size_t offset ; NetBuffer * buffer ; NetInterface * interface ; IpPseudoHeader pseudoHeader ; NetTxAncillary ancillary ; <S2SV_StartBug> interface = socket -> interface ; <S2SV_EndBug> buffer = ipAllocBuffer ( 0 , & offset ) ; if ( buffer == NULL ) return ERROR_OUT_OF_MEMORY ; do { error = netBufferAppend ( buffer , message -> data , message -> length ) ; if ( error ) break ; # if ( IPV4_SUPPORT == ENABLED ) if ( message -> destIpAddr . length == sizeof ( Ipv4Addr ) ) { Ipv4Addr srcIpAddr ; error = ipv4SelectSourceAddr ( & interface , message -> destIpAddr . ipv4Addr , & srcIpAddr ) ; if ( error ) break ; pseudoHeader . length = sizeof ( Ipv4PseudoHeader ) ; pseudoHeader . ipv4Data . srcAddr = srcIpAddr ; pseudoHeader . ipv4Data . destAddr = message -> destIpAddr . ipv4Addr ; pseudoHeader . ipv4Data . reserved = 0 ; pseudoHeader . ipv4Data . protocol = socket -> protocol ; pseudoHeader . ipv4Data . length = htons ( message -> length ) ; } else # endif # if ( IPV6_SUPPORT == ENABLED ) if ( message -> destIpAddr . length == sizeof ( Ipv6Addr ) ) { error = ipv6SelectSourceAddr ( & interface , & message -> destIpAddr . ipv6Addr , & pseudoHeader . ipv6Data . srcAddr ) ; if ( error ) break ; pseudoHeader . length = sizeof ( Ipv6PseudoHeader ) ; pseudoHeader . ipv6Data . destAddr = message -> destIpAddr . ipv6Addr ; pseudoHeader . ipv6Data . length = htonl ( message -> length ) ; pseudoHeader . ipv6Data . reserved [ 0 ] = 0 ; pseudoHeader . ipv6Data . reserved [ 1 ] = 0 ; pseudoHeader . ipv6Data . reserved [ 2 ] = 0 ; pseudoHeader . ipv6Data . nextHeader = socket -> protocol ; } else # endif { error = ERROR_FAILURE ; break ; } ancillary = NET_DEFAULT_TX_ANCILLARY ; if ( message -> ttl != 0 ) { ancillary . ttl = message -> ttl ; } else if ( ipIsMulticastAddr ( & message -> destIpAddr ) ) { ancillary . ttl = socket -> multicastTtl ; } else { ancillary . ttl = socket -> ttl ; } if ( flags & SOCKET_FLAG_DONT_ROUTE ) { ancillary . dontRoute = TRUE ; } # if ( IP_DIFF_SERV_SUPPORT == ENABLED ) ancillary . dscp = socket -> dscp ; # endif # if ( ETH_SUPPORT == ENABLED ) ancillary . srcMacAddr = message -> srcMacAddr ; ancillary . destMacAddr = message -> destMacAddr ; # endif # if ( ETH_VLAN_SUPPORT == ENABLED ) ancillary . vlanPcp = socket -> vlanPcp ; ancillary . vlanDei = socket -> vlanDei ; # endif # if ( ETH_VMAN_SUPPORT == ENABLED ) ancillary . vmanPcp = socket -> vmanPcp ; ancillary . vmanDei = socket -> vmanDei ; # endif # if ( ETH_PORT_TAGGING_SUPPORT == ENABLED ) ancillary . port = message -> switchPort ; # endif # if ( ETH_TIMESTAMP_SUPPORT == ENABLED ) ancillary . timestampId = message -> timestampId ; # endif error = ipSendDatagram ( interface , & pseudoHeader , buffer , offset , & ancillary ) ; if ( error ) break ; } while ( 0 ) ; netBufferFree ( buffer ) ; return error ; }",<S2SV_ModStart> NetTxAncillary ancillary ; if ( message -> interface != NULL ) { interface = message -> interface ; } else { interface = socket -> interface ; } <S2SV_ModEnd> buffer = ipAllocBuffer,Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z
CWE-354,CWE-000 void recovery_delete_character ( void ) <S2SV_StartBug> { <S2SV_EndBug> if ( strlen ( mnemonic ) > 0 ) { mnemonic [ strlen ( mnemonic ) - 1 ] = '\\0' ; } next_character ( ) ; },"<S2SV_ModStart> void ) { if ( ! recovery_started ) { recovery_abort ( ) ; fsm_sendFailure ( FailureType_Failure_UnexpectedMessage , ""Not<S2SV_blank>in<S2SV_blank>Recovery<S2SV_blank>mode"" ) ; layoutHome ( ) ; return ; }",keepkey@keepkey-firmware/769714fcb569e7a4faff9530a2d9ac1f9d6e5680,CVE-2019-18672,https://github.com/keepkey/keepkey-firmware/commit/769714fcb569e7a4faff9530a2d9ac1f9d6e5680,2019-12-06T18:15Z
CWE-399,"CWE-399 int genl_register_family ( struct genl_family * family ) { int err , i ; int start = GENL_START_ALLOC , end = GENL_MAX_ID ; err = genl_validate_ops ( family ) ; if ( err ) return err ; genl_lock_all ( ) ; if ( genl_family_find_byname ( family -> name ) ) { err = - EEXIST ; goto errout_locked ; } if ( family == & genl_ctrl ) { start = end = GENL_ID_CTRL ; } else if ( strcmp ( family -> name , ""pmcraid"" ) == 0 ) { start = end = GENL_ID_PMCRAID ; } else if ( strcmp ( family -> name , ""VFS_DQUOT"" ) == 0 ) { start = end = GENL_ID_VFS_DQUOT ; } if ( family -> maxattr && ! family -> parallel_ops ) { family -> attrbuf = kmalloc_array ( family -> maxattr + 1 , sizeof ( struct nlattr * ) , GFP_KERNEL ) ; if ( family -> attrbuf == NULL ) { err = - ENOMEM ; goto errout_locked ; } } else family -> attrbuf = NULL ; family -> id = idr_alloc ( & genl_fam_idr , family , start , end + 1 , GFP_KERNEL ) ; if ( family -> id < 0 ) { err = family -> id ; <S2SV_StartBug> goto errout_locked ; <S2SV_EndBug> } err = genl_validate_assign_mc_groups ( family ) ; if ( err ) goto errout_remove ; genl_unlock_all ( ) ; genl_ctrl_event ( CTRL_CMD_NEWFAMILY , family , NULL , 0 ) ; for ( i = 0 ; i < family -> n_mcgrps ; i ++ ) genl_ctrl_event ( CTRL_CMD_NEWMCAST_GRP , family , & family -> mcgrps [ i ] , family -> mcgrp_offset + i ) ; return 0 ; errout_remove : idr_remove ( & genl_fam_idr , family -> id ) ; <S2SV_StartBug> kfree ( family -> attrbuf ) ; <S2SV_EndBug> errout_locked : genl_unlock_all ( ) ; return err ; }",<S2SV_ModStart> id ; goto errout_free <S2SV_ModEnd> ; } err <S2SV_ModStart> id ) ; errout_free :,torvalds@linux/ceabee6c59943bdd5e1da1a6a20dc7ee5f8113a2,CVE-2019-15921,https://github.com/torvalds/linux/commit/ceabee6c59943bdd5e1da1a6a20dc7ee5f8113a2,2019-09-04T19:15Z
CWE-20,"CWE-20 size_t cdf_count_chain ( const cdf_sat_t * sat , cdf_secid_t sid , size_t size ) { size_t i , j ; <S2SV_StartBug> cdf_secid_t maxsector = ( cdf_secid_t ) ( sat -> sat_len * size ) ; <S2SV_EndBug> DPRINTF ( ( ""Chain:"" ) ) ; for ( j = i = 0 ; sid >= 0 ; i ++ , j ++ ) { DPRINTF ( ( ""<S2SV_blank>%d"" , sid ) ) ; if ( j >= CDF_LOOP_LIMIT ) { DPRINTF ( ( ""Counting<S2SV_blank>chain<S2SV_blank>loop<S2SV_blank>limit"" ) ) ; errno = EFTYPE ; return ( size_t ) - 1 ; } <S2SV_StartBug> if ( sid > maxsector ) { <S2SV_EndBug> DPRINTF ( ( ""Sector<S2SV_blank>%d<S2SV_blank>><S2SV_blank>%d\\n"" , sid , maxsector ) ) ; errno = EFTYPE ; return ( size_t ) - 1 ; } sid = CDF_TOLE4 ( ( uint32_t ) sat -> sat_tab [ sid ] ) ; } if ( i == 0 ) { DPRINTF ( ( ""<S2SV_blank>none,<S2SV_blank>sid:<S2SV_blank>%d\\n"" , sid ) ) ; return ( size_t ) - 1 ; } DPRINTF ( ( ""\\n"" ) ) ; return i ; }","<S2SV_ModStart> ( cdf_secid_t ) ( <S2SV_ModStart> * size ) / sizeof ( maxsector ) ) <S2SV_ModStart> if ( sid >= maxsector ) { DPRINTF ( ( ""Sector<S2SV_blank>%d<S2SV_blank>>=<S2SV_blank>%d\\n"" <S2SV_ModEnd> , sid ,",file@file/40bade80cbe2af1d0b2cd0420cebd5d5905a2382,CVE-2014-3480,https://github.com/file/file/commit/40bade80cbe2af1d0b2cd0420cebd5d5905a2382,2014-07-09T11:07Z
CWE-416,"CWE-416 struct sock * cookie_v6_check ( struct sock * sk , struct sk_buff * skb ) { struct tcp_options_received tcp_opt ; struct inet_request_sock * ireq ; struct tcp_request_sock * treq ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct tcp_sock * tp = tcp_sk ( sk ) ; const struct tcphdr * th = tcp_hdr ( skb ) ; __u32 cookie = ntohl ( th -> ack_seq ) - 1 ; struct sock * ret = sk ; struct request_sock * req ; int mss ; struct dst_entry * dst ; __u8 rcv_wscale ; if ( ! sysctl_tcp_syncookies || ! th -> ack || th -> rst ) goto out ; if ( tcp_synq_no_recent_overflow ( sk ) ) goto out ; mss = __cookie_v6_check ( ipv6_hdr ( skb ) , th , cookie ) ; if ( mss == 0 ) { NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_SYNCOOKIESFAILED ) ; goto out ; } NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_SYNCOOKIESRECV ) ; memset ( & tcp_opt , 0 , sizeof ( tcp_opt ) ) ; tcp_parse_options ( skb , & tcp_opt , 0 , NULL ) ; if ( ! cookie_timestamp_decode ( & tcp_opt ) ) goto out ; ret = NULL ; req = inet_reqsk_alloc ( & tcp6_request_sock_ops , sk , false ) ; if ( ! req ) goto out ; ireq = inet_rsk ( req ) ; treq = tcp_rsk ( req ) ; treq -> tfo_listener = false ; if ( security_inet_conn_request ( sk , skb , req ) ) goto out_free ; req -> mss = mss ; ireq -> ir_rmt_port = th -> source ; ireq -> ir_num = ntohs ( th -> dest ) ; ireq -> ir_v6_rmt_addr = ipv6_hdr ( skb ) -> saddr ; ireq -> ir_v6_loc_addr = ipv6_hdr ( skb ) -> daddr ; if ( ipv6_opt_accepted ( sk , skb , & TCP_SKB_CB ( skb ) -> header . h6 ) || np -> rxopt . bits . rxinfo || np -> rxopt . bits . rxoinfo || np -> rxopt . bits . rxhlim || np -> rxopt . bits . rxohlim ) { atomic_inc ( & skb -> users ) ; ireq -> pktopts = skb ; } ireq -> ir_iif = sk -> sk_bound_dev_if ; if ( ! sk -> sk_bound_dev_if && ipv6_addr_type ( & ireq -> ir_v6_rmt_addr ) & IPV6_ADDR_LINKLOCAL ) ireq -> ir_iif = tcp_v6_iif ( skb ) ; ireq -> ir_mark = inet_request_mark ( sk , skb ) ; req -> num_retrans = 0 ; ireq -> snd_wscale = tcp_opt . snd_wscale ; ireq -> sack_ok = tcp_opt . sack_ok ; ireq -> wscale_ok = tcp_opt . wscale_ok ; ireq -> tstamp_ok = tcp_opt . saw_tstamp ; req -> ts_recent = tcp_opt . saw_tstamp ? tcp_opt . rcv_tsval : 0 ; treq -> snt_synack . v64 = 0 ; treq -> rcv_isn = ntohl ( th -> seq ) - 1 ; treq -> snt_isn = cookie ; { struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = IPPROTO_TCP ; fl6 . daddr = ireq -> ir_v6_rmt_addr ; <S2SV_StartBug> final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; <S2SV_EndBug> fl6 . saddr = ireq -> ir_v6_loc_addr ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = ireq -> ir_mark ; fl6 . fl6_dport = ireq -> ir_rmt_port ; fl6 . fl6_sport = inet_sk ( sk ) -> inet_sport ; security_req_classify_flow ( req , flowi6_to_flowi ( & fl6 ) ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) goto out_free ; } req -> rsk_window_clamp = tp -> window_clamp ? : dst_metric ( dst , RTAX_WINDOW ) ; tcp_select_initial_window ( tcp_full_space ( sk ) , req -> mss , & req -> rsk_rcv_wnd , & req -> rsk_window_clamp , ireq -> wscale_ok , & rcv_wscale , dst_metric ( dst , RTAX_INITRWND ) ) ; ireq -> rcv_wscale = rcv_wscale ; ireq -> ecn_ok = cookie_ecn_ok ( & tcp_opt , sock_net ( sk ) , dst ) ; ret = tcp_get_cookie_sock ( sk , skb , req , dst ) ; out : return ret ; out_free : reqsk_free ( req ) ; return NULL ; }","<S2SV_ModStart> & fl6 , rcu_dereference ( <S2SV_ModStart> np -> opt )",torvalds@linux/45f6fad84cc305103b28d73482b344d7f5b76f39,CVE-2016-3841,https://github.com/torvalds/linux/commit/45f6fad84cc305103b28d73482b344d7f5b76f39,2016-08-06T20:59Z
,"CWE-000 static void sas_init_port ( struct asd_sas_port * port , struct sas_ha_struct * sas_ha , int i ) { memset ( port , 0 , sizeof ( * port ) ) ; port -> id = i ; INIT_LIST_HEAD ( & port -> dev_list ) ; INIT_LIST_HEAD ( & port -> disco_list ) ; INIT_LIST_HEAD ( & port -> destroy_list ) ; <S2SV_StartBug> spin_lock_init ( & port -> phy_list_lock ) ; <S2SV_EndBug> INIT_LIST_HEAD ( & port -> phy_list ) ; port -> ha = sas_ha ; spin_lock_init ( & port -> dev_list_lock ) ; }",<S2SV_ModStart> destroy_list ) ; INIT_LIST_HEAD ( & port -> sas_port_del_list ) ;,torvalds@linux/0558f33c06bb910e2879e355192227a8e8f0219d,CVE-2017-18232,https://github.com/torvalds/linux/commit/0558f33c06bb910e2879e355192227a8e8f0219d,2018-03-15T04:29Z
CWE-674,"CWE-000 static void bgp_update_print ( netdissect_options * ndo , const u_char * dat , int length ) { struct bgp bgp ; const u_char * p ; int withdrawn_routes_len ; int len ; int i ; ND_TCHECK2 ( dat [ 0 ] , BGP_SIZE ) ; if ( length < BGP_SIZE ) goto trunc ; memcpy ( & bgp , dat , BGP_SIZE ) ; p = dat + BGP_SIZE ; length -= BGP_SIZE ; ND_TCHECK2 ( p [ 0 ] , 2 ) ; if ( length < 2 ) goto trunc ; withdrawn_routes_len = EXTRACT_16BITS ( p ) ; p += 2 ; length -= 2 ; if ( withdrawn_routes_len ) { ND_TCHECK2 ( p [ 0 ] , withdrawn_routes_len ) ; if ( length < withdrawn_routes_len ) goto trunc ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Withdrawn<S2SV_blank>routes:<S2SV_blank>%d<S2SV_blank>bytes"" , withdrawn_routes_len ) ) ; p += withdrawn_routes_len ; length -= withdrawn_routes_len ; } ND_TCHECK2 ( p [ 0 ] , 2 ) ; if ( length < 2 ) goto trunc ; len = EXTRACT_16BITS ( p ) ; p += 2 ; length -= 2 ; if ( withdrawn_routes_len == 0 && len == 0 && length == 0 ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>End-of-Rib<S2SV_blank>Marker<S2SV_blank>(empty<S2SV_blank>NLRI)"" ) ) ; return ; } if ( len ) { while ( len ) { int aflags , atype , alenlen , alen ; ND_TCHECK2 ( p [ 0 ] , 2 ) ; if ( len < 2 ) goto trunc ; if ( length < 2 ) goto trunc ; aflags = * p ; atype = * ( p + 1 ) ; p += 2 ; len -= 2 ; length -= 2 ; alenlen = bgp_attr_lenlen ( aflags , p ) ; ND_TCHECK2 ( p [ 0 ] , alenlen ) ; if ( len < alenlen ) goto trunc ; if ( length < alenlen ) goto trunc ; alen = bgp_attr_len ( aflags , p ) ; p += alenlen ; len -= alenlen ; length -= alenlen ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>length:<S2SV_blank>%u"" , tok2str ( bgp_attr_values , ""Unknown<S2SV_blank>Attribute"" , atype ) , atype , alen ) ) ; if ( aflags ) { ND_PRINT ( ( ndo , "",<S2SV_blank>Flags<S2SV_blank>[%s%s%s%s"" , aflags & 0x80 ? ""O"" : """" , aflags & 0x40 ? ""T"" : """" , aflags & 0x20 ? ""P"" : """" , aflags & 0x10 ? ""E"" : """" ) ) ; if ( aflags & 0xf ) ND_PRINT ( ( ndo , ""+%x"" , aflags & 0xf ) ) ; ND_PRINT ( ( ndo , ""]:<S2SV_blank>"" ) ) ; } if ( len < alen ) goto trunc ; if ( length < alen ) goto trunc ; <S2SV_StartBug> if ( ! bgp_attr_print ( ndo , atype , p , alen ) ) <S2SV_EndBug> goto trunc ; p += alen ; len -= alen ; length -= alen ; } } if ( length ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Updated<S2SV_blank>routes:"" ) ) ; while ( length ) { char buf [ MAXHOSTNAMELEN + 100 ] ; i = decode_prefix4 ( ndo , p , length , buf , sizeof ( buf ) ) ; if ( i == - 1 ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; break ; } else if ( i == - 2 ) goto trunc ; else if ( i == - 3 ) goto trunc ; else { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; p += i ; length -= i ; } } } return ; trunc : ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; }","<S2SV_ModStart> p , alen , 0",the-tcpdump-group@tcpdump/af2cf04a9394c1a56227c2289ae8da262828294a,CVE-2018-16300,https://github.com/the-tcpdump-group/tcpdump/commit/af2cf04a9394c1a56227c2289ae8da262828294a,2019-10-03T16:15Z
CWE-119,"CWE-119 static void videobuf_vm_open ( struct vm_area_struct * vma ) { struct videobuf_mapping * map = vma -> vm_private_data ; <S2SV_StartBug> dprintk ( 2 , ""vm_open<S2SV_blank>%p<S2SV_blank>[count=%d,vma=%08lx-%08lx]\\n"" , map , <S2SV_EndBug> map -> count , vma -> vm_start , vma -> vm_end ) ; map -> count ++ ; }","<S2SV_ModStart> ( 2 , ""vm_open<S2SV_blank>%p<S2SV_blank>[count=%u,vma=%08lx-%08lx]\\n"" <S2SV_ModEnd> , map ,",torvalds@linux/0b29669c065f60501e7289e1950fa2a618962358,CVE-2007-6761,https://github.com/torvalds/linux/commit/0b29669c065f60501e7289e1950fa2a618962358,2017-04-24T06:59Z
CWE-119,"CWE-119 void vp9_pack_bitstream ( VP9_COMP * cpi , uint8_t * dest , size_t * size ) { uint8_t * data = dest ; size_t first_part_size , uncompressed_hdr_size ; <S2SV_StartBug> struct vp9_write_bit_buffer wb = { data , 0 } ; <S2SV_EndBug> <S2SV_StartBug> struct vp9_write_bit_buffer saved_wb ; <S2SV_EndBug> write_uncompressed_header ( cpi , & wb ) ; saved_wb = wb ; <S2SV_StartBug> vp9_wb_write_literal ( & wb , 0 , 16 ) ; <S2SV_EndBug> <S2SV_StartBug> uncompressed_hdr_size = vp9_rb_bytes_written ( & wb ) ; <S2SV_EndBug> data += uncompressed_hdr_size ; <S2SV_StartBug> vp9_compute_update_table ( ) ; <S2SV_EndBug> vp9_clear_system_state ( ) ; first_part_size = write_compressed_header ( cpi , data ) ; data += first_part_size ; <S2SV_StartBug> vp9_wb_write_literal ( & saved_wb , ( int ) first_part_size , 16 ) ; <S2SV_EndBug> data += encode_tiles ( cpi , data ) ; * size = data - dest ; }",<S2SV_ModStart> uncompressed_hdr_size ; struct vpx_write_bit_buffer <S2SV_ModEnd> wb = { <S2SV_ModStart> } ; struct vpx_write_bit_buffer <S2SV_ModEnd> saved_wb ; write_uncompressed_header <S2SV_ModStart> = wb ; vpx_wb_write_literal <S2SV_ModEnd> ( & wb <S2SV_ModStart> ; uncompressed_hdr_size = vpx_wb_bytes_written <S2SV_ModEnd> ( & wb <S2SV_ModStart> += uncompressed_hdr_size ; vpx_clear_system_state <S2SV_ModEnd> ( ) ; <S2SV_ModStart> += first_part_size ; vpx_wb_write_literal <S2SV_ModEnd> ( & saved_wb,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-787,"CWE-787 char * enl_ipc_get ( const char * msg_data ) { static char * message = NULL ; <S2SV_StartBug> static unsigned short len = 0 ; <S2SV_EndBug> char buff [ 13 ] , * ret_msg = NULL ; register unsigned char i ; unsigned char blen ; if ( msg_data == IPC_TIMEOUT ) { return ( IPC_TIMEOUT ) ; } for ( i = 0 ; i < 12 ; i ++ ) { buff [ i ] = msg_data [ i ] ; } buff [ 12 ] = 0 ; blen = strlen ( buff ) ; if ( message != NULL ) { len += blen ; message = ( char * ) erealloc ( message , len + 1 ) ; strcat ( message , buff ) ; } else { len = blen ; message = ( char * ) emalloc ( len + 1 ) ; strcpy ( message , buff ) ; } if ( blen < 12 ) { ret_msg = message ; message = NULL ; D ( ( ""Received<S2SV_blank>complete<S2SV_blank>reply:<S2SV_blank><S2SV_blank>\\""%s\\""\\n"" , ret_msg ) ) ; } return ( ret_msg ) ; }",<S2SV_ModStart> NULL ; static size_t <S2SV_ModEnd> len = 0,derf@feh/f7a547b7ef8fc8ebdeaa4c28515c9d72e592fb6d,CVE-2017-7875,https://github.com/derf/feh/commit/f7a547b7ef8fc8ebdeaa4c28515c9d72e592fb6d,2017-04-14T18:59Z
CWE-119,"CWE-119 static void scsi_free_request ( SCSIRequest * req ) { SCSIDiskReq * r = DO_UPCAST ( SCSIDiskReq , req , req ) ; <S2SV_StartBug> qemu_vfree ( r -> iov . iov_base ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>",<S2SV_ModStart> req ) ; if ( r -> iov . iov_base ) { <S2SV_ModStart> ) ; } },bonzini@qemu/7285477ab11831b1cf56e45878a89170dd06d9b9,CVE-2011-3346,https://github.com/bonzini/qemu/commit/7285477ab11831b1cf56e45878a89170dd06d9b9,2014-04-01T06:35Z
CWE-119,"CWE-119 static void down2_symeven ( const uint8_t * const input , int length , uint8_t * output ) { <S2SV_StartBug> static const int16_t * filter = vp9_down2_symeven_half_filter ; <S2SV_EndBug> const int filter_len_half = sizeof ( vp9_down2_symeven_half_filter ) / 2 ; int i , j ; uint8_t * optr = output ; int l1 = filter_len_half ; int l2 = ( length - filter_len_half ) ; l1 += ( l1 & 1 ) ; l2 += ( l2 & 1 ) ; if ( l1 > l2 ) { for ( i = 0 ; i < length ; i += 2 ) { int sum = ( 1 << ( FILTER_BITS - 1 ) ) ; for ( j = 0 ; j < filter_len_half ; ++ j ) { sum += ( input [ ( i - j < 0 ? 0 : i - j ) ] + input [ ( i + 1 + j >= length ? length - 1 : i + 1 + j ) ] ) * filter [ j ] ; } sum >>= FILTER_BITS ; * optr ++ = clip_pixel ( sum ) ; } } else { for ( i = 0 ; i < l1 ; i += 2 ) { int sum = ( 1 << ( FILTER_BITS - 1 ) ) ; for ( j = 0 ; j < filter_len_half ; ++ j ) { sum += ( input [ ( i - j < 0 ? 0 : i - j ) ] + input [ i + 1 + j ] ) * filter [ j ] ; } sum >>= FILTER_BITS ; * optr ++ = clip_pixel ( sum ) ; } for ( ; i < l2 ; i += 2 ) { int sum = ( 1 << ( FILTER_BITS - 1 ) ) ; for ( j = 0 ; j < filter_len_half ; ++ j ) { sum += ( input [ i - j ] + input [ i + 1 + j ] ) * filter [ j ] ; } sum >>= FILTER_BITS ; * optr ++ = clip_pixel ( sum ) ; } for ( ; i < length ; i += 2 ) { int sum = ( 1 << ( FILTER_BITS - 1 ) ) ; for ( j = 0 ; j < filter_len_half ; ++ j ) { sum += ( input [ i - j ] + input [ ( i + 1 + j >= length ? length - 1 : i + 1 + j ) ] ) * filter [ j ] ; } sum >>= FILTER_BITS ; * optr ++ = clip_pixel ( sum ) ; } } }",<S2SV_ModStart> output ) { <S2SV_ModEnd> const int16_t *,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-119,"CWE-119 static __u8 * pl_report_fixup ( struct hid_device * hdev , __u8 * rdesc , unsigned int * rsize ) { <S2SV_StartBug> if ( * rsize >= 60 && rdesc [ 39 ] == 0x2a && rdesc [ 40 ] == 0xf5 && <S2SV_EndBug> rdesc [ 41 ] == 0x00 && rdesc [ 59 ] == 0x26 && rdesc [ 60 ] == 0xf9 && rdesc [ 61 ] == 0x00 ) { hid_info ( hdev , ""fixing<S2SV_blank>up<S2SV_blank>Petalynx<S2SV_blank>Maxter<S2SV_blank>Remote<S2SV_blank>report<S2SV_blank>descriptor\\n"" ) ; rdesc [ 60 ] = 0xfa ; rdesc [ 40 ] = 0xfa ; } return rdesc ; }",<S2SV_ModStart> * rsize >= 62 <S2SV_ModEnd> && rdesc [,torvalds@linux/4ab25786c87eb20857bbb715c3ae34ec8fd6a214,CVE-2014-3184,https://github.com/torvalds/linux/commit/4ab25786c87eb20857bbb715c3ae34ec8fd6a214,2014-09-28T10:55Z
CWE-189,"CWE-189 static struct vm_area_struct * vma_to_resize ( unsigned long addr , unsigned long old_len , unsigned long new_len , unsigned long * p ) { struct mm_struct * mm = current -> mm ; struct vm_area_struct * vma = find_vma ( mm , addr ) ; if ( ! vma || vma -> vm_start > addr ) goto Efault ; if ( is_vm_hugetlb_page ( vma ) ) goto Einval ; if ( old_len > vma -> vm_end - addr ) goto Efault ; <S2SV_StartBug> if ( vma -> vm_flags & ( VM_DONTEXPAND | VM_PFNMAP ) ) { <S2SV_EndBug> if ( new_len > old_len ) goto Efault ; } if ( vma -> vm_flags & VM_LOCKED ) { unsigned long locked , lock_limit ; locked = mm -> locked_vm << PAGE_SHIFT ; lock_limit = rlimit ( RLIMIT_MEMLOCK ) ; locked += new_len - old_len ; if ( locked > lock_limit && ! capable ( CAP_IPC_LOCK ) ) goto Eagain ; } if ( ! may_expand_vm ( mm , ( new_len - old_len ) >> PAGE_SHIFT ) ) goto Enomem ; if ( vma -> vm_flags & VM_ACCOUNT ) { unsigned long charged = ( new_len - old_len ) >> PAGE_SHIFT ; if ( security_vm_enough_memory ( charged ) ) goto Efault ; * p = charged ; } return vma ; Efault : return ERR_PTR ( - EFAULT ) ; Einval : return ERR_PTR ( - EINVAL ) ; Enomem : return ERR_PTR ( - ENOMEM ) ; Eagain : return ERR_PTR ( - EAGAIN ) ; }",<S2SV_ModStart> ; if ( new_len > old_len ) { unsigned long pgoff ; if ( <S2SV_ModStart> VM_PFNMAP ) ) goto Efault ; pgoff = ( addr - vma -> vm_start ) >> PAGE_SHIFT ; pgoff += vma -> vm_pgoff ; if ( pgoff + ( new_len >> PAGE_SHIFT ) < pgoff ) goto Einval <S2SV_ModEnd> ; } if,torvalds@linux/982134ba62618c2d69fbbbd166d0a11ee3b7e3d8,CVE-2011-2496,https://github.com/torvalds/linux/commit/982134ba62618c2d69fbbbd166d0a11ee3b7e3d8,2012-06-13T10:24Z
CWE-476,"CWE-476 static int hi3660_stub_clk_probe ( struct platform_device * pdev ) { struct device * dev = & pdev -> dev ; struct resource * res ; unsigned int i ; int ret ; stub_clk_chan . cl . dev = dev ; stub_clk_chan . cl . tx_done = NULL ; stub_clk_chan . cl . tx_block = false ; stub_clk_chan . cl . knows_txdone = false ; stub_clk_chan . mbox = mbox_request_channel ( & stub_clk_chan . cl , 0 ) ; if ( IS_ERR ( stub_clk_chan . mbox ) ) return PTR_ERR ( stub_clk_chan . mbox ) ; res = platform_get_resource ( pdev , IORESOURCE_MEM , 0 ) ; <S2SV_StartBug> freq_reg = devm_ioremap ( dev , res -> start , resource_size ( res ) ) ; <S2SV_EndBug> if ( ! freq_reg ) return - ENOMEM ; freq_reg += HI3660_STUB_CLOCK_DATA ; for ( i = 0 ; i < HI3660_CLK_STUB_NUM ; i ++ ) { ret = devm_clk_hw_register ( & pdev -> dev , & hi3660_stub_clks [ i ] . hw ) ; if ( ret ) return ret ; } return devm_of_clk_add_hw_provider ( & pdev -> dev , hi3660_stub_clk_hw_get , hi3660_stub_clks ) ; }",<S2SV_ModStart> 0 ) ; if ( ! res ) return - EINVAL ;,torvalds@linux/9903e41ae1f5d50c93f268ca3304d4d7c64b9311,CVE-2018-10074,https://github.com/torvalds/linux/commit/9903e41ae1f5d50c93f268ca3304d4d7c64b9311,2018-04-12T18:29Z
,"CWE-000 static void sas_scsi_clear_queue_lu ( struct list_head * error_q , struct scsi_cmnd * my_cmd ) { struct scsi_cmnd * cmd , * n ; list_for_each_entry_safe ( cmd , n , error_q , eh_entry ) { if ( cmd -> device -> sdev_target == my_cmd -> device -> sdev_target && cmd -> device -> lun == my_cmd -> device -> lun ) <S2SV_StartBug> sas_eh_defer_cmd ( cmd ) ; <S2SV_EndBug> } }",<S2SV_ModStart> -> lun ) sas_eh_finish_cmd <S2SV_ModEnd> ( cmd ),torvalds@linux/318aaf34f1179b39fa9c30fa0f3288b645beee39,CVE-2018-10021,https://github.com/torvalds/linux/commit/318aaf34f1179b39fa9c30fa0f3288b645beee39,2018-04-11T17:29Z
CWE-119,CWE-119 void vp8_denoiser_free ( VP8_DENOISER * denoiser ) { int i ; assert ( denoiser ) ; for ( i = 0 ; i < MAX_REF_FRAMES ; i ++ ) { vp8_yv12_de_alloc_frame_buffer ( & denoiser -> yv12_running_avg [ i ] ) ; } vp8_yv12_de_alloc_frame_buffer ( & denoiser -> yv12_mc_running_avg ) ; <S2SV_StartBug> } <S2SV_EndBug>,<S2SV_ModStart> yv12_mc_running_avg ) ; vp8_yv12_de_alloc_frame_buffer ( & denoiser -> yv12_last_source ) ; vpx_free ( denoiser -> denoise_state ) ;,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-476,"CWE-476 static int f2fs_mpage_readpages ( struct address_space * mapping , struct list_head * pages , struct page * page , unsigned nr_pages , bool is_readahead ) { struct bio * bio = NULL ; sector_t last_block_in_bio = 0 ; struct inode * inode = mapping -> host ; struct f2fs_map_blocks map ; int ret = 0 ; map . m_pblk = 0 ; map . m_lblk = 0 ; map . m_len = 0 ; map . m_flags = 0 ; map . m_next_pgofs = NULL ; map . m_next_extent = NULL ; map . m_seg_type = NO_CHECK_TYPE ; map . m_may_create = false ; for ( ; nr_pages ; nr_pages -- ) { if ( pages ) { page = list_last_entry ( pages , struct page , lru ) ; prefetchw ( & page -> flags ) ; list_del ( & page -> lru ) ; if ( add_to_page_cache_lru ( page , mapping , <S2SV_StartBug> page -> index , <S2SV_EndBug> readahead_gfp_mask ( mapping ) ) ) goto next_page ; } ret = f2fs_read_single_page ( inode , page , nr_pages , & map , & bio , & last_block_in_bio , is_readahead ) ; if ( ret ) { SetPageError ( page ) ; zero_user_segment ( page , 0 , PAGE_SIZE ) ; unlock_page ( page ) ; } next_page : if ( pages ) put_page ( page ) ; } BUG_ON ( pages && ! list_empty ( pages ) ) ; if ( bio ) __submit_bio ( F2FS_I_SB ( inode ) , bio , DATA ) ; return pages ? 0 : ret ; }","<S2SV_ModStart> , mapping , page_index ( page ) <S2SV_ModEnd> , readahead_gfp_mask (",torvalds@linux/4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6,CVE-2019-19815,https://github.com/torvalds/linux/commit/4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6,2019-12-17T07:15Z
CWE-284,"CWE-284 static reactor_status_t run_reactor ( reactor_t * reactor , int iterations ) { assert ( reactor != NULL ) ; reactor -> run_thread = pthread_self ( ) ; reactor -> is_running = true ; struct epoll_event events [ MAX_EVENTS ] ; for ( int i = 0 ; iterations == 0 || i < iterations ; ++ i ) { pthread_mutex_lock ( & reactor -> list_lock ) ; list_clear ( reactor -> invalidation_list ) ; pthread_mutex_unlock ( & reactor -> list_lock ) ; int ret ; do { <S2SV_StartBug> ret = epoll_wait ( reactor -> epoll_fd , events , MAX_EVENTS , - 1 ) ; <S2SV_EndBug> } while ( ret == - 1 && errno == EINTR ) ; if ( ret == - 1 ) { LOG_ERROR ( ""%s<S2SV_blank>error<S2SV_blank>in<S2SV_blank>epoll_wait:<S2SV_blank>%s"" , __func__ , strerror ( errno ) ) ; reactor -> is_running = false ; return REACTOR_STATUS_ERROR ; } for ( int j = 0 ; j < ret ; ++ j ) { if ( events [ j ] . data . ptr == NULL ) { eventfd_t value ; eventfd_read ( reactor -> event_fd , & value ) ; reactor -> is_running = false ; return REACTOR_STATUS_STOP ; } reactor_object_t * object = ( reactor_object_t * ) events [ j ] . data . ptr ; pthread_mutex_lock ( & reactor -> list_lock ) ; if ( list_contains ( reactor -> invalidation_list , object ) ) { pthread_mutex_unlock ( & reactor -> list_lock ) ; continue ; } pthread_mutex_lock ( & object -> lock ) ; pthread_mutex_unlock ( & reactor -> list_lock ) ; reactor -> object_removed = false ; if ( events [ j ] . events & ( EPOLLIN | EPOLLHUP | EPOLLRDHUP | EPOLLERR ) && object -> read_ready ) object -> read_ready ( object -> context ) ; if ( ! reactor -> object_removed && events [ j ] . events & EPOLLOUT && object -> write_ready ) object -> write_ready ( object -> context ) ; pthread_mutex_unlock ( & object -> lock ) ; if ( reactor -> object_removed ) { pthread_mutex_destroy ( & object -> lock ) ; osi_free ( object ) ; } } } reactor -> is_running = false ; return REACTOR_STATUS_DONE ; }","<S2SV_ModStart> { ret = TEMP_FAILURE_RETRY ( <S2SV_ModStart> , - 1 )",system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z
CWE-119,"CWE-119 void vp8_setup_key_frame ( VP8_COMP * cpi ) { vp8_default_coef_probs ( & cpi -> common ) ; <S2SV_StartBug> vpx_memcpy ( cpi -> common . fc . mvc , vp8_default_mv_context , sizeof ( vp8_default_mv_context ) ) ; <S2SV_EndBug> { int flag [ 2 ] = { 1 , 1 } ; vp8_build_component_cost_table ( cpi -> mb . mvcost , ( const MV_CONTEXT * ) cpi -> common . fc . mvc , flag ) ; } <S2SV_StartBug> vpx_memcpy ( & cpi -> lfc_a , & cpi -> common . fc , sizeof ( cpi -> common . fc ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & cpi -> lfc_g , & cpi -> common . fc , sizeof ( cpi -> common . fc ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & cpi -> lfc_n , & cpi -> common . fc , sizeof ( cpi -> common . fc ) ) ; <S2SV_EndBug> cpi -> common . filter_level = cpi -> common . base_qindex * 3 / 8 ; if ( cpi -> auto_gold ) cpi -> frames_till_gf_update_due = cpi -> baseline_gf_interval ; else cpi -> frames_till_gf_update_due = DEFAULT_GF_INTERVAL ; cpi -> common . refresh_golden_frame = 1 ; cpi -> common . refresh_alt_ref_frame = 1 ; }",<S2SV_ModStart> common ) ; memcpy <S2SV_ModEnd> ( cpi -> <S2SV_ModStart> ) ; } memcpy <S2SV_ModEnd> ( & cpi <S2SV_ModStart> ) ) ; memcpy <S2SV_ModEnd> ( & cpi <S2SV_ModStart> ) ) ; memcpy <S2SV_ModEnd> ( & cpi,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-20,"CWE-20 static void llc_sap_rcv ( struct llc_sap * sap , struct sk_buff * skb , struct sock * sk ) { struct llc_sap_state_ev * ev = llc_sap_ev ( skb ) ; ev -> type = LLC_SAP_EV_TYPE_PDU ; ev -> reason = 0 ; <S2SV_StartBug> skb -> sk = sk ; <S2SV_EndBug> llc_sap_state_process ( sap , skb ) ; }",<S2SV_ModStart> = 0 ; skb_orphan ( skb ) ; sock_hold ( sk ) ; <S2SV_ModStart> sk = sk ; skb -> destructor = sock_efree,torvalds@linux/8b74d439e1697110c5e5c600643e823eb1dd0762,CVE-2017-6345,https://github.com/torvalds/linux/commit/8b74d439e1697110c5e5c600643e823eb1dd0762,2017-03-01T20:59Z
CWE-189,"CWE-189 static int __dwc3_gadget_kick_transfer ( struct dwc3_ep * dep ) { struct dwc3_gadget_ep_cmd_params params ; struct dwc3_request * req ; int starting ; int ret ; u32 cmd ; if ( ! dwc3_calc_trbs_left ( dep ) ) return 0 ; starting = ! ( dep -> flags & DWC3_EP_BUSY ) ; dwc3_prepare_trbs ( dep ) ; req = next_request ( & dep -> started_list ) ; if ( ! req ) { dep -> flags |= DWC3_EP_PENDING_REQUEST ; return 0 ; } memset ( & params , 0 , sizeof ( params ) ) ; if ( starting ) { params . param0 = upper_32_bits ( req -> trb_dma ) ; params . param1 = lower_32_bits ( req -> trb_dma ) ; cmd = DWC3_DEPCMD_STARTTRANSFER ; if ( usb_endpoint_xfer_isoc ( dep -> endpoint . desc ) ) cmd |= DWC3_DEPCMD_PARAM ( dep -> frame_number ) ; } else { cmd = DWC3_DEPCMD_UPDATETRANSFER | DWC3_DEPCMD_PARAM ( dep -> resource_index ) ; } ret = dwc3_send_gadget_ep_cmd ( dep , cmd , & params ) ; if ( ret < 0 ) { if ( req -> trb ) memset ( req -> trb , 0 , sizeof ( struct dwc3_trb ) ) ; dep -> queued_requests -- ; <S2SV_StartBug> dwc3_gadget_giveback ( dep , req , ret ) ; <S2SV_EndBug> return ret ; } dep -> flags |= DWC3_EP_BUSY ; if ( starting ) { dep -> resource_index = dwc3_gadget_ep_get_transfer_index ( dep ) ; WARN_ON_ONCE ( ! dep -> resource_index ) ; } return 0 ; }","<S2SV_ModStart> queued_requests -- ; dwc3_gadget_del_and_unmap_request <S2SV_ModEnd> ( dep ,",torvalds@linux/c91815b596245fd7da349ecc43c8def670d2269e,CVE-2019-14763,https://github.com/torvalds/linux/commit/c91815b596245fd7da349ecc43c8def670d2269e,2019-08-07T22:15Z
CWE-125,"CWE-125 static Image * ExtractPostscript ( Image * image , const ImageInfo * image_info , MagickOffsetType PS_Offset , ssize_t PS_Size , ExceptionInfo * exception ) { char postscript_file [ MaxTextExtent ] ; const MagicInfo * magic_info ; FILE * ps_file ; ImageInfo * clone_info ; Image * image2 ; unsigned char magick [ 2 * MaxTextExtent ] ; if ( ( clone_info = CloneImageInfo ( image_info ) ) == NULL ) return ( image ) ; clone_info -> blob = ( void * ) NULL ; clone_info -> length = 0 ; ( void ) AcquireUniqueFilename ( postscript_file ) ; ps_file = fopen_utf8 ( postscript_file , ""wb"" ) ; if ( ps_file == ( FILE * ) NULL ) goto FINISH ; ( void ) SeekBlob ( image , PS_Offset , SEEK_SET ) ; ( void ) ReadBlob ( image , 2 * MaxTextExtent , magick ) ; ( void ) SeekBlob ( image , PS_Offset , SEEK_SET ) ; while ( PS_Size -- > 0 ) { ( void ) fputc ( ReadBlobByte ( image ) , ps_file ) ; } ( void ) fclose ( ps_file ) ; magic_info = GetMagicInfo ( magick , 2 * MaxTextExtent , exception ) ; if ( magic_info == ( const MagicInfo * ) NULL ) goto FINISH_UNL ; if ( exception -> severity != UndefinedException ) goto FINISH_UNL ; if ( magic_info -> name == ( char * ) NULL ) goto FINISH_UNL ; <S2SV_StartBug> ( void ) CopyMagickMemory ( clone_info -> magick , magic_info -> name , MaxTextExtent ) ; <S2SV_EndBug> FormatLocaleString ( clone_info -> filename , MaxTextExtent , ""%s"" , postscript_file ) ; image2 = ReadImage ( clone_info , exception ) ; if ( ! image2 ) goto FINISH_UNL ; ( void ) CopyMagickMemory ( image2 -> filename , image -> filename , MaxTextExtent ) ; ( void ) CopyMagickMemory ( image2 -> magick_filename , image -> magick_filename , MaxTextExtent ) ; ( void ) CopyMagickMemory ( image2 -> magick , image -> magick , MaxTextExtent ) ; image2 -> depth = image -> depth ; DestroyBlob ( image2 ) ; image2 -> blob = ReferenceBlob ( image -> blob ) ; if ( ( image -> rows == 0 ) || ( image -> columns == 0 ) ) DeleteImageFromList ( & image ) ; AppendImageToList ( & image , image2 ) ; FINISH_UNL : ( void ) RelinquishUniqueFileResource ( postscript_file ) ; FINISH : DestroyImageInfo ( clone_info ) ; return ( image ) ; }",<S2SV_ModStart> ( void ) strncpy <S2SV_ModEnd> ( clone_info ->,ImageMagick@ImageMagick/a251039393f423c7858e63cab6aa98d17b8b7a41,CVE-2016-7527,https://github.com/ImageMagick/ImageMagick/commit/a251039393f423c7858e63cab6aa98d17b8b7a41,2017-04-20T18:59Z
CWE-119,"CWE-119 static int64_t http_seek_internal ( URLContext * h , int64_t off , int whence , int force_reconnect ) { HTTPContext * s = h -> priv_data ; URLContext * old_hd = s -> hd ; <S2SV_StartBug> int64_t old_off = s -> off ; <S2SV_EndBug> uint8_t old_buf [ BUFFER_SIZE ] ; int old_buf_size , ret ; AVDictionary * options = NULL ; if ( whence == AVSEEK_SIZE ) return s -> filesize ; else if ( ! force_reconnect && ( ( whence == SEEK_CUR && off == 0 ) || ( whence == SEEK_SET && off == s -> off ) ) ) return s -> off ; <S2SV_StartBug> else if ( ( s -> filesize == - 1 && whence == SEEK_END ) ) <S2SV_EndBug> return AVERROR ( ENOSYS ) ; if ( whence == SEEK_CUR ) off += s -> off ; else if ( whence == SEEK_END ) off += s -> filesize ; else if ( whence != SEEK_SET ) return AVERROR ( EINVAL ) ; if ( off < 0 ) return AVERROR ( EINVAL ) ; s -> off = off ; if ( s -> off && h -> is_streamed ) return AVERROR ( ENOSYS ) ; old_buf_size = s -> buf_end - s -> buf_ptr ; memcpy ( old_buf , s -> buf_ptr , old_buf_size ) ; s -> hd = NULL ; if ( ( ret = http_open_cnx ( h , & options ) ) < 0 ) { av_dict_free ( & options ) ; memcpy ( s -> buffer , old_buf , old_buf_size ) ; s -> buf_ptr = s -> buffer ; s -> buf_end = s -> buffer + old_buf_size ; s -> hd = old_hd ; s -> off = old_off ; return ret ; } av_dict_free ( & options ) ; ffurl_close ( old_hd ) ; return off ; }",<S2SV_ModStart> -> hd ; uint64_t <S2SV_ModEnd> old_off = s <S2SV_ModStart> -> filesize == UINT64_MAX <S2SV_ModEnd> && whence ==,FFmpeg@FFmpeg/2a05c8f813de6f2278827734bf8102291e7484aa,CVE-2016-10190,https://github.com/FFmpeg/FFmpeg/commit/2a05c8f813de6f2278827734bf8102291e7484aa,2017-02-09T15:59Z
NVD-CWE-Other,"CWE-000 static int rose_parse_ccitt ( unsigned char * p , struct rose_facilities_struct * facilities , int len ) { unsigned char l , n = 0 ; char callsign [ 11 ] ; do { switch ( * p & 0xC0 ) { case 0x00 : p += 2 ; n += 2 ; len -= 2 ; break ; case 0x40 : p += 3 ; n += 3 ; len -= 3 ; break ; case 0x80 : p += 4 ; n += 4 ; len -= 4 ; break ; case 0xC0 : l = p [ 1 ] ; <S2SV_StartBug> if ( * p == FAC_CCITT_DEST_NSAP ) { <S2SV_EndBug> memcpy ( & facilities -> source_addr , p + 7 , ROSE_ADDR_LEN ) ; memcpy ( callsign , p + 12 , l - 10 ) ; callsign [ l - 10 ] = '\\0' ; asc2ax ( & facilities -> source_call , callsign ) ; } if ( * p == FAC_CCITT_SRC_NSAP ) { memcpy ( & facilities -> dest_addr , p + 7 , ROSE_ADDR_LEN ) ; memcpy ( callsign , p + 12 , l - 10 ) ; callsign [ l - 10 ] = '\\0' ; asc2ax ( & facilities -> dest_call , callsign ) ; } p += l + 2 ; n += l + 2 ; len -= l + 2 ; break ; } } while ( * p != 0x00 && len > 0 ) ; return n ; }",<S2SV_ModStart> ; if ( l < 10 || l > 20 ) return - 1 ; if (,torvalds@linux/be20250c13f88375345ad99950190685eda51eb8,CVE-2011-1493,https://github.com/torvalds/linux/commit/be20250c13f88375345ad99950190685eda51eb8,2012-06-21T23:55Z
CWE-399,"CWE-399 struct sctp_chunk * sctp_inq_pop ( struct sctp_inq * queue ) { struct sctp_chunk * chunk ; sctp_chunkhdr_t * ch = NULL ; if ( ( chunk = queue -> in_progress ) ) { if ( chunk -> singleton || chunk -> end_of_packet || chunk -> pdiscard ) { sctp_chunk_free ( chunk ) ; chunk = queue -> in_progress = NULL ; } else { ch = ( sctp_chunkhdr_t * ) chunk -> chunk_end ; skb_pull ( chunk -> skb , chunk -> chunk_end - chunk -> skb -> data ) ; <S2SV_StartBug> if ( skb_headlen ( chunk -> skb ) < sizeof ( sctp_chunkhdr_t ) ) { <S2SV_EndBug> sctp_chunk_free ( chunk ) ; chunk = queue -> in_progress = NULL ; } } } if ( ! chunk ) { struct list_head * entry ; if ( list_empty ( & queue -> in_chunk_list ) ) return NULL ; entry = queue -> in_chunk_list . next ; chunk = queue -> in_progress = list_entry ( entry , struct sctp_chunk , list ) ; list_del_init ( entry ) ; chunk -> singleton = 1 ; ch = ( sctp_chunkhdr_t * ) chunk -> skb -> data ; chunk -> data_accepted = 0 ; } chunk -> chunk_hdr = ch ; chunk -> chunk_end = ( ( __u8 * ) ch ) + WORD_ROUND ( ntohs ( ch -> length ) ) ; if ( unlikely ( skb_is_nonlinear ( chunk -> skb ) ) ) { if ( chunk -> chunk_end > skb_tail_pointer ( chunk -> skb ) ) chunk -> chunk_end = skb_tail_pointer ( chunk -> skb ) ; } skb_pull ( chunk -> skb , sizeof ( sctp_chunkhdr_t ) ) ; chunk -> subh . v = NULL ; <S2SV_StartBug> if ( chunk -> chunk_end < skb_tail_pointer ( chunk -> skb ) ) { <S2SV_EndBug> chunk -> singleton = 0 ; } else if ( chunk -> chunk_end > skb_tail_pointer ( chunk -> skb ) ) { <S2SV_StartBug> sctp_chunk_free ( chunk ) ; <S2SV_EndBug> chunk = queue -> in_progress = NULL ; return NULL ; } else { chunk -> end_of_packet = 1 ; } pr_debug ( ""+++sctp_inq_pop+++<S2SV_blank>chunk:%p[%s],<S2SV_blank>length:%d,<S2SV_blank>skb->len:%d\\n"" , chunk , sctp_cname ( SCTP_ST_CHUNK ( chunk -> chunk_hdr -> type ) ) , ntohs ( chunk -> chunk_hdr -> length ) , chunk -> skb -> len ) ; return chunk ; }","<S2SV_ModStart> data ) ; <S2SV_ModEnd> } } if <S2SV_ModStart> chunk -> chunk_end + sizeof ( sctp_chunkhdr_t ) <S2SV_ModStart> ) ) { chunk -> pdiscard = 1 ; chunk -> chunk_end = skb_tail_pointer ( chunk -> skb ) ; } else { chunk -> end_of_packet = 1 ; } pr_debug ( ""+++sctp_inq_pop+++<S2SV_blank>chunk:%p[%s],<S2SV_blank>length:%d,<S2SV_blank>skb->len:%d\\n"" , chunk , sctp_cname ( SCTP_ST_CHUNK ( chunk -> chunk_hdr -> type ) ) , ntohs ( chunk -> chunk_hdr -> length ) , chunk -> skb -> len ) ; return <S2SV_ModEnd> chunk ; }",torvalds@linux/26b87c7881006311828bb0ab271a551a62dcceb4,CVE-2014-3688,https://github.com/torvalds/linux/commit/26b87c7881006311828bb0ab271a551a62dcceb4,2014-11-30T01:59Z
CWE-362,"CWE-362 static int faultin_page ( struct task_struct * tsk , struct vm_area_struct * vma , unsigned long address , unsigned int * flags , int * nonblocking ) { unsigned int fault_flags = 0 ; int ret ; if ( ( * flags & ( FOLL_POPULATE | FOLL_MLOCK ) ) == FOLL_MLOCK ) return - ENOENT ; if ( ( * flags & FOLL_POPULATE ) && ( stack_guard_page_start ( vma , address ) || stack_guard_page_end ( vma , address + PAGE_SIZE ) ) ) return - ENOENT ; if ( * flags & FOLL_WRITE ) fault_flags |= FAULT_FLAG_WRITE ; if ( * flags & FOLL_REMOTE ) fault_flags |= FAULT_FLAG_REMOTE ; if ( nonblocking ) fault_flags |= FAULT_FLAG_ALLOW_RETRY ; if ( * flags & FOLL_NOWAIT ) fault_flags |= FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_RETRY_NOWAIT ; if ( * flags & FOLL_TRIED ) { VM_WARN_ON_ONCE ( fault_flags & FAULT_FLAG_ALLOW_RETRY ) ; fault_flags |= FAULT_FLAG_TRIED ; } ret = handle_mm_fault ( vma , address , fault_flags ) ; if ( ret & VM_FAULT_ERROR ) { if ( ret & VM_FAULT_OOM ) return - ENOMEM ; if ( ret & ( VM_FAULT_HWPOISON | VM_FAULT_HWPOISON_LARGE ) ) return * flags & FOLL_HWPOISON ? - EHWPOISON : - EFAULT ; if ( ret & ( VM_FAULT_SIGBUS | VM_FAULT_SIGSEGV ) ) return - EFAULT ; BUG ( ) ; } if ( tsk ) { if ( ret & VM_FAULT_MAJOR ) tsk -> maj_flt ++ ; else tsk -> min_flt ++ ; } if ( ret & VM_FAULT_RETRY ) { if ( nonblocking ) * nonblocking = 0 ; return - EBUSY ; } if ( ( ret & VM_FAULT_WRITE ) && ! ( vma -> vm_flags & VM_WRITE ) ) <S2SV_StartBug> * flags &= ~ FOLL_WRITE ; <S2SV_EndBug> return 0 ; }",<S2SV_ModStart> ) * flags |= FOLL_COW <S2SV_ModEnd> ; return 0,torvalds@linux/19be0eaffa3ac7d8eb6784ad9bdbc7d67ed8e619,CVE-2016-5195,https://github.com/torvalds/linux/commit/19be0eaffa3ac7d8eb6784ad9bdbc7d67ed8e619,2016-11-10T21:59Z
,"CWE-000 static int userfaultfd_unregister ( struct userfaultfd_ctx * ctx , unsigned long arg ) { struct mm_struct * mm = ctx -> mm ; struct vm_area_struct * vma , * prev , * cur ; int ret ; struct uffdio_range uffdio_unregister ; unsigned long new_flags ; bool found ; unsigned long start , end , vma_end ; const void __user * buf = ( void __user * ) arg ; ret = - EFAULT ; if ( copy_from_user ( & uffdio_unregister , buf , sizeof ( uffdio_unregister ) ) ) goto out ; ret = validate_range ( mm , uffdio_unregister . start , uffdio_unregister . len ) ; if ( ret ) goto out ; start = uffdio_unregister . start ; end = start + uffdio_unregister . len ; ret = - ENOMEM ; if ( ! mmget_not_zero ( mm ) ) goto out ; down_write ( & mm -> mmap_sem ) ; vma = find_vma_prev ( mm , start , & prev ) ; if ( ! vma ) goto out_unlock ; ret = - EINVAL ; if ( vma -> vm_start >= end ) goto out_unlock ; if ( is_vm_hugetlb_page ( vma ) ) { unsigned long vma_hpagesize = vma_kernel_pagesize ( vma ) ; if ( start & ( vma_hpagesize - 1 ) ) goto out_unlock ; } found = false ; ret = - EINVAL ; for ( cur = vma ; cur && cur -> vm_start < end ; cur = cur -> vm_next ) { cond_resched ( ) ; BUG_ON ( ! ! cur -> vm_userfaultfd_ctx . ctx ^ ! ! ( cur -> vm_flags & ( VM_UFFD_MISSING | VM_UFFD_WP ) ) ) ; if ( ! vma_can_userfault ( cur ) ) goto out_unlock ; found = true ; } BUG_ON ( ! found ) ; if ( vma -> vm_start < start ) prev = vma ; ret = 0 ; do { cond_resched ( ) ; BUG_ON ( ! vma_can_userfault ( vma ) ) ; <S2SV_StartBug> if ( ! vma -> vm_userfaultfd_ctx . ctx ) <S2SV_EndBug> goto skip ; if ( vma -> vm_start > start ) start = vma -> vm_start ; vma_end = min ( end , vma -> vm_end ) ; if ( userfaultfd_missing ( vma ) ) { struct userfaultfd_wake_range range ; range . start = start ; range . len = vma_end - start ; wake_userfault ( vma -> vm_userfaultfd_ctx . ctx , & range ) ; } new_flags = vma -> vm_flags & ~ ( VM_UFFD_MISSING | VM_UFFD_WP ) ; prev = vma_merge ( mm , prev , start , vma_end , new_flags , vma -> anon_vma , vma -> vm_file , vma -> vm_pgoff , vma_policy ( vma ) , NULL_VM_UFFD_CTX ) ; if ( prev ) { vma = prev ; goto next ; } if ( vma -> vm_start < start ) { ret = split_vma ( mm , vma , start , 1 ) ; if ( ret ) break ; } if ( vma -> vm_end > end ) { ret = split_vma ( mm , vma , end , 0 ) ; if ( ret ) break ; } next : vma -> vm_flags = new_flags ; vma -> vm_userfaultfd_ctx = NULL_VM_UFFD_CTX ; skip : prev = vma ; start = vma -> vm_end ; vma = vma -> vm_next ; } while ( vma && vma -> vm_start < end ) ; out_unlock : up_write ( & mm -> mmap_sem ) ; mmput ( mm ) ; out : return ret ; }",<S2SV_ModStart> ) ) ; WARN_ON ( ! ( vma -> vm_flags & VM_MAYWRITE ) ) ;,torvalds@linux/29ec90660d68bbdd69507c1c8b4e33aa299278b1,CVE-2018-18397,https://github.com/torvalds/linux/commit/29ec90660d68bbdd69507c1c8b4e33aa299278b1,2018-12-12T10:29Z
CWE-310,"CWE-000 static void test_simple ( ) { json_set_alloc_funcs ( my_malloc , my_free ) ; create_and_free_complex_object ( ) ; <S2SV_StartBug> if ( malloc_called != 20 || free_called != 20 ) <S2SV_EndBug> fail ( ""Custom<S2SV_blank>allocation<S2SV_blank>failed"" ) ; }",<S2SV_ModStart> ( malloc_called != 1 <S2SV_ModEnd> || free_called != <S2SV_ModStart> || free_called != 1 <S2SV_ModEnd> ) fail (,akheron@jansson/8f80c2d83808150724d31793e6ade92749b1faa4,CVE-2013-6401,https://github.com/akheron/jansson/commit/8f80c2d83808150724d31793e6ade92749b1faa4,2014-03-21T01:04Z
CWE-20,"CWE-20 static gboolean netscreen_read ( wtap * wth , int * err , gchar * * err_info , gint64 * data_offset ) { gint64 offset ; <S2SV_StartBug> int pkt_len ; <S2SV_EndBug> <S2SV_StartBug> char line [ NETSCREEN_LINE_LENGTH ] ; <S2SV_EndBug> char cap_int [ NETSCREEN_MAX_INT_NAME_LENGTH ] ; gboolean cap_dir ; char cap_dst [ 13 ] ; offset = netscreen_seek_next_packet ( wth , err , err_info , line ) ; if ( offset < 0 ) return FALSE ; <S2SV_StartBug> pkt_len = parse_netscreen_rec_hdr ( & wth -> phdr , line , cap_int , & cap_dir , <S2SV_EndBug> cap_dst , err , err_info ) ; if ( pkt_len == - 1 ) return FALSE ; <S2SV_StartBug> if ( ! parse_netscreen_hex_dump ( wth -> fh , pkt_len , cap_int , <S2SV_EndBug> <S2SV_StartBug> cap_dst , & wth -> phdr , wth -> frame_buffer , err , err_info ) ) <S2SV_EndBug> return FALSE ; if ( wth -> file_encap == WTAP_ENCAP_UNKNOWN ) wth -> file_encap = wth -> phdr . pkt_encap ; else { if ( wth -> file_encap != wth -> phdr . pkt_encap ) wth -> file_encap = WTAP_ENCAP_PER_PACKET ; } * data_offset = offset ; return TRUE ; }","<S2SV_ModStart> gint64 offset ; <S2SV_ModEnd> char line [ <S2SV_ModStart> line [ NETSCREEN_LINE_LENGTH <S2SV_ModEnd> ] ; offset <S2SV_ModStart> return FALSE ; <S2SV_ModEnd> if ( ! <S2SV_ModStart> if ( ! parse_netscreen_packet <S2SV_ModEnd> ( wth -> <S2SV_ModStart> wth -> fh <S2SV_ModEnd> , & wth <S2SV_ModStart> wth -> frame_buffer , line",wireshark@wireshark/6a140eca7b78b230f1f90a739a32257476513c78,CVE-2016-5357,https://github.com/wireshark/wireshark/commit/6a140eca7b78b230f1f90a739a32257476513c78,2016-08-07T16:59Z
CWE-476,"CWE-476 static ssize_t o2nm_node_local_store ( struct config_item * item , const char * page , size_t count ) { struct o2nm_node * node = to_o2nm_node ( item ) ; <S2SV_StartBug> struct o2nm_cluster * cluster = to_o2nm_cluster_from_node ( node ) ; <S2SV_EndBug> unsigned long tmp ; char * p = ( char * ) page ; ssize_t ret ; tmp = simple_strtoul ( p , & p , 0 ) ; if ( ! p || ( * p && ( * p != '\\n' ) ) ) return - EINVAL ; tmp = ! ! tmp ; if ( ! test_bit ( O2NM_NODE_ATTR_ADDRESS , & node -> nd_set_attributes ) || ! test_bit ( O2NM_NODE_ATTR_NUM , & node -> nd_set_attributes ) || ! test_bit ( O2NM_NODE_ATTR_PORT , & node -> nd_set_attributes ) ) return - EINVAL ; <S2SV_StartBug> if ( tmp && tmp == cluster -> cl_has_local && <S2SV_EndBug> cluster -> cl_local_node != node -> nd_num ) <S2SV_StartBug> return - EBUSY ; <S2SV_EndBug> <S2SV_StartBug> if ( tmp && ! cluster -> cl_has_local ) { <S2SV_EndBug> ret = o2net_start_listening ( node ) ; if ( ret ) <S2SV_StartBug> return ret ; <S2SV_EndBug> } if ( ! tmp && cluster -> cl_has_local && cluster -> cl_local_node == node -> nd_num ) { o2net_stop_listening ( node ) ; cluster -> cl_local_node = O2NM_INVALID_NODE_NUM ; } node -> nd_local = tmp ; if ( node -> nd_local ) { cluster -> cl_has_local = tmp ; cluster -> cl_local_node = node -> nd_num ; } <S2SV_StartBug> return count ; <S2SV_EndBug> }",<S2SV_ModStart> o2nm_cluster * cluster <S2SV_ModEnd> ; unsigned long <S2SV_ModStart> - EINVAL ; o2nm_lock_subsystem ( ) ; cluster = to_o2nm_cluster_from_node ( node ) ; if ( ! cluster ) { ret = - EINVAL ; goto out ; } <S2SV_ModStart> -> nd_num ) { ret = <S2SV_ModEnd> - EBUSY ; <S2SV_ModStart> - EBUSY ; goto out ; } <S2SV_ModStart> ( ret ) goto out <S2SV_ModEnd> ; } if <S2SV_ModStart> nd_num ; } ret = count ; out : o2nm_unlock_subsystem ( ) ; return ret <S2SV_ModEnd> ; } <S2SV_null>,torvalds@linux/853bc26a7ea39e354b9f8889ae7ad1492ffa28d2,CVE-2017-18216,https://github.com/torvalds/linux/commit/853bc26a7ea39e354b9f8889ae7ad1492ffa28d2,2018-03-05T18:29Z
CWE-119,"CWE-119 static vpx_codec_err_t ctrl_get_display_size ( vpx_codec_alg_priv_t * ctx , <S2SV_StartBug> int ctrl_id , va_list args ) { <S2SV_EndBug> int * const display_size = va_arg ( args , int * ) ; <S2SV_StartBug> if ( display_size ) { <S2SV_EndBug> <S2SV_StartBug> if ( ctx -> pbi ) { <S2SV_EndBug> <S2SV_StartBug> const VP9_COMMON * const cm = & ctx -> pbi -> common ; <S2SV_EndBug> display_size [ 0 ] = cm -> display_width ; display_size [ 1 ] = cm -> display_height ; <S2SV_StartBug> } else { <S2SV_EndBug> return VPX_CODEC_ERROR ; } <S2SV_StartBug> return VPX_CODEC_OK ; <S2SV_EndBug> } else { return VPX_CODEC_INVALID_PARAM ; } <S2SV_StartBug> } <S2SV_EndBug>","<S2SV_ModStart> * ctx , <S2SV_ModEnd> va_list args ) <S2SV_ModStart> ; if ( ctx -> frame_parallel_decode ) { set_error_detail ( ctx , ""Not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>frame<S2SV_blank>parallel<S2SV_blank>decode"" ) ; return VPX_CODEC_INCAPABLE ; } if ( <S2SV_ModStart> ( ctx -> frame_workers ) { VPxWorker * const worker = ctx -> frame_workers ; FrameWorkerData * const frame_worker_data = ( FrameWorkerData * ) worker -> data1 ; <S2SV_ModEnd> const VP9_COMMON * <S2SV_ModStart> cm = & frame_worker_data <S2SV_ModEnd> -> pbi -> <S2SV_ModStart> -> display_height ; return VPX_CODEC_OK ; <S2SV_ModStart> VPX_CODEC_ERROR ; } } <S2SV_ModEnd> return VPX_CODEC_INVALID_PARAM ; <S2SV_ModStart> VPX_CODEC_INVALID_PARAM ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-399,"CWE-399 void hugetlb_unreserve_pages ( struct inode * inode , long offset , long freed ) { struct hstate * h = hstate_inode ( inode ) ; long chg = region_truncate ( & inode -> i_mapping -> private_list , offset ) ; <S2SV_StartBug> spin_lock ( & inode -> i_lock ) ; <S2SV_EndBug> inode -> i_blocks -= ( blocks_per_huge_page ( h ) * freed ) ; spin_unlock ( & inode -> i_lock ) ; <S2SV_StartBug> hugetlb_put_quota ( inode -> i_mapping , ( chg - freed ) ) ; <S2SV_EndBug> hugetlb_acct_memory ( h , - ( chg - freed ) ) ; }","<S2SV_ModStart> offset ) ; struct hugepage_subpool * spool = subpool_inode ( inode ) ; <S2SV_ModStart> i_lock ) ; hugepage_subpool_put_pages ( spool <S2SV_ModEnd> , ( chg",torvalds@linux/90481622d75715bfcb68501280a917dbfe516029,CVE-2012-2133,https://github.com/torvalds/linux/commit/90481622d75715bfcb68501280a917dbfe516029,2012-07-03T16:40Z
CWE-119,"CWE-119 <S2SV_StartBug> void * H264SwDecMalloc ( u32 size ) <S2SV_EndBug> { # if defined ( CHECK_MEMORY_USAGE ) static u32 numBytes = 0 ; <S2SV_StartBug> numBytes += size ; <S2SV_EndBug> DEBUG ( ( ""Allocated<S2SV_blank>%d<S2SV_blank>bytes,<S2SV_blank>total<S2SV_blank>%d\\n"" , size , numBytes ) ) ; # endif <S2SV_StartBug> return malloc ( size ) ; <S2SV_EndBug> }","<S2SV_ModStart> ( u32 size , u32 num ) { if ( size > UINT32_MAX / num ) { return NULL ; } <S2SV_ModEnd> # if defined <S2SV_ModStart> numBytes += size * num <S2SV_ModStart> malloc ( size * num",frameworks@av/2b6f22dc64d456471a1dc6df09d515771d1427c8,CVE-2016-2463,https://android.googlesource.com/platform/frameworks/av/+/2b6f22dc64d456471a1dc6df09d515771d1427c8,2016-06-13T01:59Z
CWE-125,"CWE-125 static int get_debug_info ( struct PE_ ( r_bin_pe_obj_t ) * bin , PE_ ( image_debug_directory_entry ) * dbg_dir_entry , ut8 * dbg_data , int dbg_data_len , SDebugInfo * res ) { # define SIZEOF_FILE_NAME 255 int i = 0 ; const char * basename ; if ( ! dbg_data ) { return 0 ; } switch ( dbg_dir_entry -> Type ) { case IMAGE_DEBUG_TYPE_CODEVIEW : if ( ! strncmp ( ( char * ) dbg_data , ""RSDS"" , 4 ) ) { SCV_RSDS_HEADER rsds_hdr ; init_rsdr_hdr ( & rsds_hdr ) ; if ( ! get_rsds ( dbg_data , dbg_data_len , & rsds_hdr ) ) { bprintf ( ""Warning:<S2SV_blank>Cannot<S2SV_blank>read<S2SV_blank>PE<S2SV_blank>debug<S2SV_blank>info\\n"" ) ; return 0 ; } snprintf ( res -> guidstr , GUIDSTR_LEN , ""%08x%04x%04x%02x%02x%02x%02x%02x%02x%02x%02x%x"" , rsds_hdr . guid . data1 , rsds_hdr . guid . data2 , rsds_hdr . guid . data3 , rsds_hdr . guid . data4 [ 0 ] , rsds_hdr . guid . data4 [ 1 ] , rsds_hdr . guid . data4 [ 2 ] , rsds_hdr . guid . data4 [ 3 ] , rsds_hdr . guid . data4 [ 4 ] , rsds_hdr . guid . data4 [ 5 ] , rsds_hdr . guid . data4 [ 6 ] , rsds_hdr . guid . data4 [ 7 ] , rsds_hdr . age ) ; basename = r_file_basename ( ( char * ) rsds_hdr . file_name ) ; strncpy ( res -> file_name , ( const char * ) basename , sizeof ( res -> file_name ) ) ; res -> file_name [ sizeof ( res -> file_name ) - 1 ] = 0 ; rsds_hdr . free ( ( struct SCV_RSDS_HEADER * ) & rsds_hdr ) ; } else if ( strncmp ( ( const char * ) dbg_data , ""NB10"" , 4 ) == 0 ) { <S2SV_StartBug> SCV_NB10_HEADER nb10_hdr ; <S2SV_EndBug> init_cv_nb10_header ( & nb10_hdr ) ; get_nb10 ( dbg_data , & nb10_hdr ) ; snprintf ( res -> guidstr , sizeof ( res -> guidstr ) , <S2SV_StartBug> ""%x%x"" , nb10_hdr . timestamp , nb10_hdr . age ) ; <S2SV_EndBug> strncpy ( res -> file_name , ( const char * ) <S2SV_StartBug> nb10_hdr . file_name , sizeof ( res -> file_name ) - 1 ) ; <S2SV_EndBug> res -> file_name [ sizeof ( res -> file_name ) - 1 ] = 0 ; nb10_hdr . free ( ( struct SCV_NB10_HEADER * ) & nb10_hdr ) ; } else { bprintf ( ""CodeView<S2SV_blank>section<S2SV_blank>not<S2SV_blank>NB10<S2SV_blank>or<S2SV_blank>RSDS\\n"" ) ; return 0 ; } break ; default : return 0 ; } while ( i < 33 ) { res -> guidstr [ i ] = toupper ( ( int ) res -> guidstr [ i ] ) ; i ++ ; } return 1 ; }","<S2SV_ModStart> 0 ) { if ( dbg_data_len < 20 ) { eprintf ( ""Truncated<S2SV_blank>NB10<S2SV_blank>entry,<S2SV_blank>not<S2SV_blank>enough<S2SV_blank>data<S2SV_blank>to<S2SV_blank>parse\\n"" ) ; return 0 ; } SCV_NB10_HEADER nb10_hdr = { { 0 } } <S2SV_ModEnd> ; init_cv_nb10_header ( <S2SV_ModStart> age ) ; res -> file_name [ 0 ] = 0 ; if ( nb10_hdr . file_name ) { <S2SV_ModStart> 1 ) ; }",radare@radare2/4e1cf0d3e6f6fe2552a269def0af1cd2403e266c,CVE-2018-11379,https://github.com/radare/radare2/commit/4e1cf0d3e6f6fe2552a269def0af1cd2403e266c,2018-05-22T19:29Z
CWE-119,"CWE-119 <S2SV_StartBug> static void read_inter_mode_probs ( FRAME_CONTEXT * fc , vp9_reader * r ) { <S2SV_EndBug> int i , j ; for ( i = 0 ; i < INTER_MODE_CONTEXTS ; ++ i ) for ( j = 0 ; j < INTER_MODES - 1 ; ++ j ) vp9_diff_update_prob ( r , & fc -> inter_mode_probs [ i ] [ j ] ) ; }","<S2SV_ModStart> * fc , vpx_reader <S2SV_ModEnd> * r )",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-787,"CWE-787 void pdf_get_version ( FILE * fp , pdf_t * pdf ) { <S2SV_StartBug> char * header , * c ; <S2SV_EndBug> <S2SV_StartBug> header = get_header ( fp ) ; <S2SV_EndBug> if ( ( c = strstr ( header , ""%PDF-"" ) ) && <S2SV_StartBug> ( c + strlen ( ""%PDF-M.m"" ) + 2 ) ) <S2SV_EndBug> { pdf -> pdf_major_version = atoi ( c + strlen ( ""%PDF-"" ) ) ; pdf -> pdf_minor_version = atoi ( c + strlen ( ""%PDF-M."" ) ) ; } free ( header ) ; }",<S2SV_ModStart> char * header <S2SV_ModEnd> = get_header ( <S2SV_ModStart> ( fp ) ; const char * c <S2SV_ModStart> ) && ( ( c + 6 ) [ 0 ] == '.' ) && isdigit ( ( c + 5 ) [ 0 ] ) && isdigit ( ( c + 7 ) [ 0 ] <S2SV_ModEnd> ) ) {,enferex@pdfresurrect/1b422459f07353adce2878806d5247d9e91fb397,CVE-2020-20740,https://github.com/enferex/pdfresurrect/commit/1b422459f07353adce2878806d5247d9e91fb397,2020-11-20T19:15Z
CWE-119,"CWE-119 void mp_encode_lua_table_as_map ( lua_State * L , mp_buf * buf , int level ) { <S2SV_StartBug> size_t len = 0 ; <S2SV_EndBug> lua_pushnil ( L ) ; while ( lua_next ( L , - 2 ) ) { lua_pop ( L , 1 ) ; len ++ ; } mp_encode_map ( L , buf , len ) ; lua_pushnil ( L ) ; while ( lua_next ( L , - 2 ) ) { lua_pushvalue ( L , - 2 ) ; mp_encode_lua_type ( L , buf , level + 1 ) ; mp_encode_lua_type ( L , buf , level + 1 ) ; } }","<S2SV_ModStart> len = 0 ; luaL_checkstack ( L , 3 , ""in<S2SV_blank>function<S2SV_blank>mp_encode_lua_table_as_map"" )",antirez@redis/5ccb6f7a791bf3490357b00a898885759d98bab0,CVE-2018-11218,https://github.com/antirez/redis/commit/5ccb6f7a791bf3490357b00a898885759d98bab0,2018-06-17T17:29Z
CWE-20,"CWE-20 error_t httpParseRequestLine ( HttpConnection * connection , char_t * requestLine ) { error_t error ; char_t * token ; char_t * p ; char_t * s ; token = osStrtok_r ( requestLine , ""<S2SV_blank>\\r\\n"" , & p ) ; if ( token == NULL ) return ERROR_INVALID_REQUEST ; error = strSafeCopy ( connection -> request . method , token , HTTP_SERVER_METHOD_MAX_LEN ) ; if ( error ) return ERROR_INVALID_REQUEST ; token = osStrtok_r ( NULL , ""<S2SV_blank>\\r\\n"" , & p ) ; if ( token == NULL ) return ERROR_INVALID_REQUEST ; <S2SV_StartBug> s = strchr ( token , '?' ) ; <S2SV_EndBug> if ( s != NULL ) { * s = '\\0' ; error = httpDecodePercentEncodedString ( token , connection -> request . uri , HTTP_SERVER_URI_MAX_LEN ) ; if ( error ) return ERROR_INVALID_REQUEST ; if ( osStrlen ( s + 1 ) > HTTP_SERVER_QUERY_STRING_MAX_LEN ) return ERROR_INVALID_REQUEST ; osStrcpy ( connection -> request . queryString , s + 1 ) ; } else { error = httpDecodePercentEncodedString ( token , connection -> request . uri , HTTP_SERVER_URI_MAX_LEN ) ; if ( error ) return ERROR_INVALID_REQUEST ; connection -> request . queryString [ 0 ] = '\\0' ; } if ( ! osStrcasecmp ( connection -> request . uri , ""/"" ) ) osStrcpy ( connection -> request . uri , connection -> settings -> defaultDocument ) ; pathCanonicalize ( connection -> request . uri ) ; token = osStrtok_r ( NULL , ""<S2SV_blank>\\r\\n"" , & p ) ; if ( token == NULL ) { connection -> request . version = HTTP_VERSION_0_9 ; connection -> request . keepAlive = FALSE ; } else if ( ! osStrcasecmp ( token , ""HTTP/1.0"" ) ) { connection -> request . version = HTTP_VERSION_1_0 ; connection -> request . keepAlive = FALSE ; } else if ( ! osStrcasecmp ( token , ""HTTP/1.1"" ) ) { connection -> request . version = HTTP_VERSION_1_1 ; connection -> request . keepAlive = TRUE ; } else { return ERROR_INVALID_REQUEST ; } return NO_ERROR ; }","<S2SV_ModStart> ; s = osStrchr <S2SV_ModEnd> ( token ,",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z
CWE-617,CWE-000 void pci_lintr_deassert ( struct pci_vdev * dev ) { <S2SV_StartBug> assert ( dev -> lintr . pin > 0 ) ; <S2SV_EndBug> pthread_mutex_lock ( & dev -> lintr . lock ) ; if ( dev -> lintr . state == ASSERTED ) { dev -> lintr . state = IDLE ; pci_irq_deassert ( dev ) ; } else if ( dev -> lintr . state == PENDING ) dev -> lintr . state = IDLE ; pthread_mutex_unlock ( & dev -> lintr . lock ) ; },"<S2SV_ModStart> dev ) { if <S2SV_ModEnd> ( dev -> <S2SV_ModStart> lintr . pin <= 0 ) { pr_warn ( ""%s:<S2SV_blank>Invalid<S2SV_blank>intr<S2SV_blank>pin<S2SV_blank>on<S2SV_blank>dev<S2SV_blank>[%s]\\n"" , __func__ , dev -> name ) ; return ; } <S2SV_ModEnd> pthread_mutex_lock ( &",projectacrn@acrn-hypervisor/2b3dedfb9ba13f15887f22b935d373f36c9a59fa,CVE-2019-18844,https://github.com/projectacrn/acrn-hypervisor/commit/2b3dedfb9ba13f15887f22b935d373f36c9a59fa,2019-11-13T20:15Z
CWE-617,"CWE-000 void deinit_pci ( struct vmctx * ctx ) { struct pci_vdev_ops * ops ; struct businfo * bi ; struct slotinfo * si ; struct funcinfo * fi ; int bus , slot , func ; size_t lowmem ; struct mem_range mr ; bzero ( & mr , sizeof ( struct mem_range ) ) ; mr . name = ""PCI<S2SV_blank>ECFG"" ; mr . base = PCI_EMUL_ECFG_BASE ; mr . size = PCI_EMUL_ECFG_SIZE ; unregister_mem ( & mr ) ; lowmem = vm_get_lowmem_size ( ctx ) ; bzero ( & mr , sizeof ( struct mem_range ) ) ; mr . name = ""PCI<S2SV_blank>hole<S2SV_blank>(32-bit)"" ; mr . base = lowmem ; mr . size = ( 4ULL * 1024 * 1024 * 1024 ) - lowmem ; unregister_mem_fallback ( & mr ) ; bzero ( & mr , sizeof ( struct mem_range ) ) ; mr . name = ""PCI<S2SV_blank>hole<S2SV_blank>(64-bit)"" ; mr . base = PCI_EMUL_MEMBASE64 ; mr . size = PCI_EMUL_MEMLIMIT64 - PCI_EMUL_MEMBASE64 ; unregister_mem_fallback ( & mr ) ; for ( bus = 0 ; bus < MAXBUSES ; bus ++ ) { bi = pci_businfo [ bus ] ; if ( bi == NULL ) continue ; for ( slot = 0 ; slot < MAXSLOTS ; slot ++ ) { si = & bi -> slotinfo [ slot ] ; for ( func = 0 ; func < MAXFUNCS ; func ++ ) { fi = & si -> si_funcs [ func ] ; if ( fi -> fi_name == NULL ) continue ; ops = pci_emul_finddev ( fi -> fi_name ) ; <S2SV_StartBug> assert ( ops != NULL ) ; <S2SV_EndBug> pr_notice ( ""pci<S2SV_blank>deinit<S2SV_blank>%s\\n"" , fi -> fi_name ) ; pci_emul_deinit ( ctx , ops , bus , slot , func , fi ) ; } } } }","<S2SV_ModStart> fi_name ) ; if ( ! ops ) { pr_warn ( ""No<S2SV_blank>driver<S2SV_blank>for<S2SV_blank>device<S2SV_blank>[%s]\\n"" , fi -> fi_name ) ; continue ; } <S2SV_ModEnd> pr_notice ( ""pci<S2SV_blank>deinit<S2SV_blank>%s\\n""",projectacrn@acrn-hypervisor/2b3dedfb9ba13f15887f22b935d373f36c9a59fa,CVE-2019-18844,https://github.com/projectacrn/acrn-hypervisor/commit/2b3dedfb9ba13f15887f22b935d373f36c9a59fa,2019-11-13T20:15Z
CWE-264,CWE-264 int rpc_type_of_NPPVariable ( int variable ) { int type ; switch ( variable ) { case NPPVpluginNameString : case NPPVpluginDescriptionString : <S2SV_StartBug> case NPPVformValue : <S2SV_EndBug> type = RPC_TYPE_STRING ; break ; case NPPVpluginWindowSize : case NPPVpluginTimerInterval : type = RPC_TYPE_INT32 ; break ; case NPPVpluginNeedsXEmbed : case NPPVpluginWindowBool : case NPPVpluginTransparentBool : case NPPVjavascriptPushCallerBool : case NPPVpluginKeepLibraryInMemory : <S2SV_StartBug> type = RPC_TYPE_BOOLEAN ; <S2SV_EndBug> break ; case NPPVpluginScriptableNPObject : type = RPC_TYPE_NP_OBJECT ; break ; default : type = RPC_ERROR_GENERIC ; break ; } return type ; },<S2SV_ModStart> : case NPPVformValue : case NPPVpluginNativeAccessibleAtkPlugId <S2SV_ModStart> case NPPVpluginKeepLibraryInMemory : case NPPVpluginUrlRequestsDisplayedBool : case NPPVpluginWantsAllNetworkStreams : case NPPVpluginCancelSrcStream : case NPPVSupportsAdvancedKeyHandling :,davidben@nspluginwrapper/7e4ab8e1189846041f955e6c83f72bc1624e7a98,CVE-2011-2486,https://github.com/davidben/nspluginwrapper/commit/7e4ab8e1189846041f955e6c83f72bc1624e7a98,2012-11-19T12:10Z
CWE-119,"CWE-119 static void adapt_coef_probs ( VP9_COMMON * cm , TX_SIZE tx_size , unsigned int count_sat , unsigned int update_factor ) { const FRAME_CONTEXT * pre_fc = & cm -> frame_contexts [ cm -> frame_context_idx ] ; <S2SV_StartBug> vp9_coeff_probs_model * const probs = cm -> fc . coef_probs [ tx_size ] ; <S2SV_EndBug> const vp9_coeff_probs_model * const pre_probs = pre_fc -> coef_probs [ tx_size ] ; vp9_coeff_count_model * counts = cm -> counts . coef [ tx_size ] ; unsigned int ( * eob_counts ) [ REF_TYPES ] [ COEF_BANDS ] [ COEFF_CONTEXTS ] = cm -> counts . eob_branch [ tx_size ] ; int i , j , k , l , m ; for ( i = 0 ; i < PLANE_TYPES ; ++ i ) for ( j = 0 ; j < REF_TYPES ; ++ j ) for ( k = 0 ; k < COEF_BANDS ; ++ k ) for ( l = 0 ; l < BAND_COEFF_CONTEXTS ( k ) ; ++ l ) { const int n0 = counts [ i ] [ j ] [ k ] [ l ] [ ZERO_TOKEN ] ; const int n1 = counts [ i ] [ j ] [ k ] [ l ] [ ONE_TOKEN ] ; const int n2 = counts [ i ] [ j ] [ k ] [ l ] [ TWO_TOKEN ] ; const int neob = counts [ i ] [ j ] [ k ] [ l ] [ EOB_MODEL_TOKEN ] ; const unsigned int branch_ct [ UNCONSTRAINED_NODES ] [ 2 ] = { { neob , eob_counts [ i ] [ j ] [ k ] [ l ] - neob } , { n0 , n1 + n2 } , { n1 , n2 } } ; for ( m = 0 ; m < UNCONSTRAINED_NODES ; ++ m ) probs [ i ] [ j ] [ k ] [ l ] [ m ] = merge_probs ( pre_probs [ i ] [ j ] [ k ] [ l ] [ m ] , branch_ct [ m ] , count_sat , update_factor ) ; } }",<S2SV_ModStart> cm -> fc -> <S2SV_ModEnd> coef_probs [ tx_size,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-399,"CWE-399 static Image * ReadSIXELImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char * sixel_buffer ; Image * image ; MagickBooleanType status ; register char * p ; register ssize_t x ; register Quantum * q ; size_t length ; ssize_t i , j , y ; unsigned char * sixel_pixels , * sixel_palette ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } length = MagickPathExtent ; sixel_buffer = ( char * ) AcquireQuantumMemory ( ( size_t ) length + MagickPathExtent , sizeof ( * sixel_buffer ) ) ; p = sixel_buffer ; if ( sixel_buffer != ( char * ) NULL ) while ( ReadBlobString ( image , p ) != ( char * ) NULL ) { if ( ( * p == '#' ) && ( ( p == sixel_buffer ) || ( * ( p - 1 ) == '\\n' ) ) ) continue ; if ( ( * p == '}' ) && ( * ( p + 1 ) == ';' ) ) break ; p += strlen ( p ) ; if ( ( size_t ) ( p - sixel_buffer + MagickPathExtent + 1 ) < length ) continue ; length <<= 1 ; sixel_buffer = ( char * ) ResizeQuantumMemory ( sixel_buffer , length + MagickPathExtent + 1 , sizeof ( * sixel_buffer ) ) ; if ( sixel_buffer == ( char * ) NULL ) break ; p = sixel_buffer + strlen ( sixel_buffer ) ; } if ( sixel_buffer == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; sixel_buffer [ length ] = '\\0' ; if ( sixel_decode ( image , ( unsigned char * ) sixel_buffer , & sixel_pixels , & image -> columns , & image -> rows , & sixel_palette , & image -> colors , exception ) == MagickFalse ) { <S2SV_StartBug> sixel_buffer = ( char * ) RelinquishMagickMemory ( sixel_buffer ) ; <S2SV_EndBug> ThrowReaderException ( CorruptImageError , ""CorruptImage"" ) ; } sixel_buffer = ( char * ) RelinquishMagickMemory ( sixel_buffer ) ; image -> depth = 24 ; image -> storage_class = PseudoClass ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) { sixel_pixels = ( unsigned char * ) RelinquishMagickMemory ( sixel_pixels ) ; sixel_palette = ( unsigned char * ) RelinquishMagickMemory ( sixel_palette ) ; return ( DestroyImageList ( image ) ) ; } if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) { sixel_pixels = ( unsigned char * ) RelinquishMagickMemory ( sixel_pixels ) ; sixel_palette = ( unsigned char * ) RelinquishMagickMemory ( sixel_palette ) ; ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } for ( i = 0 ; i < ( ssize_t ) image -> colors ; ++ i ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( sixel_palette [ i * 4 + 0 ] ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( sixel_palette [ i * 4 + 1 ] ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( sixel_palette [ i * 4 + 2 ] ) ; } j = 0 ; if ( image_info -> ping == MagickFalse ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { j = ( ssize_t ) sixel_pixels [ y * image -> columns + x ] ; SetPixelIndex ( image , j , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } if ( y < ( ssize_t ) image -> rows ) { sixel_pixels = ( unsigned char * ) RelinquishMagickMemory ( sixel_pixels ) ; sixel_palette = ( unsigned char * ) RelinquishMagickMemory ( sixel_palette ) ; ThrowReaderException ( CorruptImageError , ""NotEnoughPixelData"" ) ; } } sixel_pixels = ( unsigned char * ) RelinquishMagickMemory ( sixel_pixels ) ; sixel_palette = ( unsigned char * ) RelinquishMagickMemory ( sixel_palette ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }",<S2SV_ModStart> RelinquishMagickMemory ( sixel_buffer ) ; sixel_pixels = ( unsigned char * ) RelinquishMagickMemory ( sixel_pixels,ImageMagick@ImageMagick/748a03651e5b138bcaf160d15133de2f4b1b89ce,CVE-2019-7396,https://github.com/ImageMagick/ImageMagick/commit/748a03651e5b138bcaf160d15133de2f4b1b89ce,2019-02-05T00:29Z
CWE-264,"CWE-264 static int walk_pmd_range ( pud_t * pud , unsigned long addr , unsigned long end , struct mm_walk * walk ) { pmd_t * pmd ; unsigned long next ; int err = 0 ; pmd = pmd_offset ( pud , addr ) ; do { again : next = pmd_addr_end ( addr , end ) ; if ( pmd_none ( * pmd ) ) { if ( walk -> pte_hole ) err = walk -> pte_hole ( addr , next , walk ) ; if ( err ) break ; continue ; } if ( walk -> pmd_entry ) err = walk -> pmd_entry ( pmd , addr , next , walk ) ; if ( err ) break ; if ( ! walk -> pte_entry ) continue ; split_huge_page_pmd ( walk -> mm , pmd ) ; <S2SV_StartBug> if ( pmd_none_or_clear_bad ( pmd ) ) <S2SV_EndBug> goto again ; err = walk_pte_range ( pmd , addr , next , walk ) ; if ( err ) break ; } while ( pmd ++ , addr = next , addr != end ) ; return err ; }",<S2SV_ModStart> ; if ( pmd_none_or_trans_huge_or_clear_bad <S2SV_ModEnd> ( pmd ),torvalds@linux/4a1d704194a441bf83c636004a479e01360ec850,CVE-2012-1179,https://github.com/torvalds/linux/commit/4a1d704194a441bf83c636004a479e01360ec850,2012-05-17T11:00Z
CWE-125,"CWE-125 static MagickBooleanType ReadPSDChannelPixels ( Image * image , const size_t channels , const size_t row , const ssize_t type , const unsigned char * pixels , ExceptionInfo * exception ) { Quantum pixel ; register const unsigned char * p ; register Quantum * q ; register ssize_t x ; size_t packet_size ; unsigned short nibble ; p = pixels ; q = GetAuthenticPixels ( image , 0 , row , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) return MagickFalse ; packet_size = GetPSDPacketSize ( image ) ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( packet_size == 1 ) pixel = ScaleCharToQuantum ( * p ++ ) ; else { p = PushShortPixel ( MSBEndian , p , & nibble ) ; pixel = ScaleShortToQuantum ( nibble ) ; } <S2SV_StartBug> switch ( type ) <S2SV_EndBug> { case - 1 : { SetPixelAlpha ( image , pixel , q ) ; break ; } case - 2 : case 0 : { SetPixelRed ( image , pixel , q ) ; if ( channels == 1 || type == - 2 ) SetPixelGray ( image , pixel , q ) ; if ( image -> storage_class == PseudoClass ) { if ( packet_size == 1 ) SetPixelIndex ( image , ScaleQuantumToChar ( pixel ) , q ) ; else SetPixelIndex ( image , ScaleQuantumToShort ( pixel ) , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) ConstrainColormapIndex ( image , GetPixelIndex ( image , q ) , exception ) , q ) ; if ( image -> depth == 1 ) { ssize_t bit , number_bits ; number_bits = image -> columns - x ; if ( number_bits > 8 ) number_bits = 8 ; for ( bit = 0 ; bit < number_bits ; bit ++ ) { <S2SV_StartBug> SetPixelIndex ( image , ( ( ( unsigned char ) pixel ) & <S2SV_EndBug> <S2SV_StartBug> ( 0x01 << ( 7 - bit ) ) ) != 0 ? 0 : 255 , q ) ; <S2SV_EndBug> SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) ConstrainColormapIndex ( image , GetPixelIndex ( image , q ) , exception ) , q ) ; q += GetPixelChannels ( image ) ; x ++ ; } <S2SV_StartBug> x -- ; <S2SV_EndBug> continue ; } } <S2SV_StartBug> break ; <S2SV_EndBug> } case 1 : { if ( image -> storage_class == PseudoClass ) SetPixelAlpha ( image , pixel , q ) ; else SetPixelGreen ( image , pixel , q ) ; break ; } case 2 : { if ( image -> storage_class == PseudoClass ) SetPixelAlpha ( image , pixel , q ) ; else SetPixelBlue ( image , pixel , q ) ; break ; } case 3 : { if ( image -> colorspace == CMYKColorspace ) SetPixelBlack ( image , pixel , q ) ; else if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , pixel , q ) ; break ; } case 4 : { if ( ( IssRGBCompatibleColorspace ( image -> colorspace ) != MagickFalse ) && ( channels > 3 ) ) break ; if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , pixel , q ) ; break ; } default : break ; } q += GetPixelChannels ( image ) ; } return ( SyncAuthenticPixels ( image , exception ) ) ; }","<S2SV_ModStart> ) ; } if ( image -> depth > 1 ) { SetPSDPixel ( image , channels , type , packet_size , pixel , q , exception ) ; q += GetPixelChannels ( image ) ; } else <S2SV_ModEnd> { ssize_t bit <S2SV_ModStart> ++ ) { SetPSDPixel ( image , channels , type , packet_size <S2SV_ModEnd> , ( ( <S2SV_ModStart> 255 , q , exception <S2SV_ModEnd> ) ; q <S2SV_ModStart> ++ ; } if ( x != image -> columns ) <S2SV_ModStart> ; } } <S2SV_ModEnd> return ( SyncAuthenticPixels",ImageMagick@ImageMagick/280215b9936d145dd5ee91403738ccce1333cab1,CVE-2016-7514,https://github.com/ImageMagick/ImageMagick/commit/280215b9936d145dd5ee91403738ccce1333cab1,2017-04-20T18:59Z
CWE-190,"CWE-190 static BOOL gdi_Bitmap_Decompress ( rdpContext * context , rdpBitmap * bitmap , const BYTE * pSrcData , UINT32 DstWidth , UINT32 DstHeight , UINT32 bpp , UINT32 length , BOOL compressed , UINT32 codecId ) { UINT32 SrcSize = length ; rdpGdi * gdi = context -> gdi ; <S2SV_StartBug> bitmap -> compressed = FALSE ; <S2SV_EndBug> bitmap -> format = gdi -> dstFormat ; <S2SV_StartBug> bitmap -> length = DstWidth * DstHeight * GetBytesPerPixel ( bitmap -> format ) ; <S2SV_EndBug> bitmap -> data = ( BYTE * ) _aligned_malloc ( bitmap -> length , 16 ) ; if ( ! bitmap -> data ) return FALSE ; if ( compressed ) { if ( bpp < 32 ) { if ( ! interleaved_decompress ( context -> codecs -> interleaved , pSrcData , SrcSize , DstWidth , DstHeight , bpp , bitmap -> data , bitmap -> format , 0 , 0 , 0 , DstWidth , DstHeight , & gdi -> palette ) ) return FALSE ; } else { if ( ! planar_decompress ( context -> codecs -> planar , pSrcData , SrcSize , DstWidth , DstHeight , bitmap -> data , bitmap -> format , 0 , 0 , 0 , DstWidth , DstHeight , TRUE ) ) return FALSE ; } } else { const UINT32 SrcFormat = gdi_get_pixel_format ( bpp ) ; const size_t sbpp = GetBytesPerPixel ( SrcFormat ) ; const size_t dbpp = GetBytesPerPixel ( bitmap -> format ) ; if ( ( sbpp == 0 ) || ( dbpp == 0 ) ) return FALSE ; else { const size_t dstSize = SrcSize * dbpp / sbpp ; if ( dstSize < bitmap -> length ) return FALSE ; } if ( ! freerdp_image_copy ( bitmap -> data , bitmap -> format , 0 , 0 , 0 , DstWidth , DstHeight , pSrcData , SrcFormat , 0 , 0 , 0 , & gdi -> palette , FREERDP_FLIP_VERTICAL ) ) return FALSE ; } return TRUE ; }",<S2SV_ModStart> -> gdi ; UINT32 size = DstWidth * DstHeight ; <S2SV_ModStart> -> dstFormat ; if ( ( GetBytesPerPixel ( bitmap -> format ) == 0 ) || ( DstWidth == 0 ) || ( DstHeight == 0 ) || ( DstWidth > UINT32_MAX / DstHeight ) || ( size > ( UINT32_MAX / GetBytesPerPixel ( bitmap -> format ) ) ) ) return FALSE ; size *= GetBytesPerPixel ( bitmap -> format ) ; <S2SV_ModStart> -> length = size <S2SV_ModEnd> ; bitmap ->,FreeRDP@FreeRDP/09b9d4f1994a674c4ec85b4947aa656eda1aed8a,CVE-2018-8787,https://github.com/FreeRDP/FreeRDP/commit/09b9d4f1994a674c4ec85b4947aa656eda1aed8a,2018-11-29T18:29Z
CWE-787,"CWE-787 static int hmac_create ( struct crypto_template * tmpl , struct rtattr * * tb ) { struct shash_instance * inst ; struct crypto_alg * alg ; struct shash_alg * salg ; int err ; int ds ; int ss ; err = crypto_check_attr_type ( tb , CRYPTO_ALG_TYPE_SHASH ) ; if ( err ) return err ; salg = shash_attr_alg ( tb [ 1 ] , 0 , 0 ) ; if ( IS_ERR ( salg ) ) return PTR_ERR ( salg ) ; <S2SV_StartBug> err = - EINVAL ; <S2SV_EndBug> <S2SV_StartBug> ds = salg -> digestsize ; <S2SV_EndBug> <S2SV_StartBug> ss = salg -> statesize ; <S2SV_EndBug> alg = & salg -> base ; if ( ds > alg -> cra_blocksize || ss < alg -> cra_blocksize ) goto out_put_alg ; inst = shash_alloc_instance ( ""hmac"" , alg ) ; err = PTR_ERR ( inst ) ; if ( IS_ERR ( inst ) ) goto out_put_alg ; err = crypto_init_shash_spawn ( shash_instance_ctx ( inst ) , salg , shash_crypto_instance ( inst ) ) ; if ( err ) goto out_free_inst ; inst -> alg . base . cra_priority = alg -> cra_priority ; inst -> alg . base . cra_blocksize = alg -> cra_blocksize ; inst -> alg . base . cra_alignmask = alg -> cra_alignmask ; ss = ALIGN ( ss , alg -> cra_alignmask + 1 ) ; inst -> alg . digestsize = ds ; inst -> alg . statesize = ss ; inst -> alg . base . cra_ctxsize = sizeof ( struct hmac_ctx ) + ALIGN ( ss * 2 , crypto_tfm_ctx_alignment ( ) ) ; inst -> alg . base . cra_init = hmac_init_tfm ; inst -> alg . base . cra_exit = hmac_exit_tfm ; inst -> alg . init = hmac_init ; inst -> alg . update = hmac_update ; inst -> alg . final = hmac_final ; inst -> alg . finup = hmac_finup ; inst -> alg . export = hmac_export ; inst -> alg . import = hmac_import ; inst -> alg . setkey = hmac_setkey ; err = shash_register_instance ( tmpl , inst ) ; if ( err ) { out_free_inst : shash_free_instance ( shash_crypto_instance ( inst ) ) ; } out_put_alg : crypto_mod_put ( alg ) ; return err ; }",<S2SV_ModStart> salg ) ; alg = & salg -> base ; <S2SV_ModStart> - EINVAL ; if ( crypto_shash_alg_has_setkey ( salg ) ) goto out_put_alg ; <S2SV_ModStart> salg -> statesize <S2SV_ModEnd> ; if (,torvalds@linux/af3ff8045bbf3e32f1a448542e73abb4c8ceb6f1,CVE-2017-17806,https://github.com/torvalds/linux/commit/af3ff8045bbf3e32f1a448542e73abb4c8ceb6f1,2017-12-20T23:29Z
CWE-119,"CWE-119 static inline int check_entry_size_and_hooks ( struct arpt_entry * e , struct xt_table_info * newinfo , const unsigned char * base , const unsigned char * limit , const unsigned int * hook_entries , const unsigned int * underflows , unsigned int valid_hooks ) { unsigned int h ; int err ; if ( ( unsigned long ) e % __alignof__ ( struct arpt_entry ) != 0 || ( unsigned char * ) e + sizeof ( struct arpt_entry ) >= limit || ( unsigned char * ) e + e -> next_offset > limit ) { duprintf ( ""Bad<S2SV_blank>offset<S2SV_blank>%p\\n"" , e ) ; return - EINVAL ; } if ( e -> next_offset < sizeof ( struct arpt_entry ) + sizeof ( struct xt_entry_target ) ) { duprintf ( ""checking:<S2SV_blank>element<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%u\\n"" , e , e -> next_offset ) ; return - EINVAL ; } err = check_entry ( e ) ; if ( err ) return err ; for ( h = 0 ; h < NF_ARP_NUMHOOKS ; h ++ ) { if ( ! ( valid_hooks & ( 1 << h ) ) ) continue ; if ( ( unsigned char * ) e - base == hook_entries [ h ] ) newinfo -> hook_entry [ h ] = hook_entries [ h ] ; if ( ( unsigned char * ) e - base == underflows [ h ] ) { if ( ! check_underflow ( e ) ) { <S2SV_StartBug> pr_err ( ""Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>"" <S2SV_EndBug> ""use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>"" ""ACCEPT/DROP\\n"" ) ; return - EINVAL ; } newinfo -> underflow [ h ] = underflows [ h ] ; } } e -> counters = ( ( struct xt_counters ) { 0 , 0 } ) ; e -> comefrom = 0 ; return 0 ; }","<S2SV_ModStart> ) ) { pr_debug <S2SV_ModEnd> ( ""Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>"" ""use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>""",torvalds@linux/54d83fc74aa9ec72794373cb47432c5f7fb1a309,CVE-2016-3134,https://github.com/torvalds/linux/commit/54d83fc74aa9ec72794373cb47432c5f7fb1a309,2016-04-27T17:59Z
CWE-119,"CWE-119 static plist_t parse_bin_node ( struct bplist_data * bplist , const char * * object ) { uint16_t type = 0 ; uint64_t size = 0 ; if ( ! object ) return NULL ; type = ( * * object ) & BPLIST_MASK ; size = ( * * object ) & BPLIST_FILL ; ( * object ) ++ ; if ( size == BPLIST_FILL ) { switch ( type ) { case BPLIST_DATA : case BPLIST_STRING : case BPLIST_UNICODE : case BPLIST_ARRAY : case BPLIST_SET : case BPLIST_DICT : { uint16_t next_size = * * object & BPLIST_FILL ; if ( ( * * object & BPLIST_MASK ) != BPLIST_UINT ) { PLIST_BIN_ERR ( ""%s:<S2SV_blank>invalid<S2SV_blank>size<S2SV_blank>node<S2SV_blank>type<S2SV_blank>for<S2SV_blank>node<S2SV_blank>type<S2SV_blank>0x%02x:<S2SV_blank>found<S2SV_blank>0x%02x,<S2SV_blank>expected<S2SV_blank>0x%02x\\n"" , __func__ , type , * * object & BPLIST_MASK , BPLIST_UINT ) ; return NULL ; } ( * object ) ++ ; next_size = 1 << next_size ; if ( * object + next_size > bplist -> offset_table ) { PLIST_BIN_ERR ( ""%s:<S2SV_blank>size<S2SV_blank>node<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>for<S2SV_blank>node<S2SV_blank>type<S2SV_blank>0x%02x<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" , __func__ , type ) ; return NULL ; } size = UINT_TO_HOST ( * object , next_size ) ; ( * object ) += next_size ; break ; } default : break ; } } switch ( type ) { case BPLIST_NULL : switch ( size ) { case BPLIST_TRUE : { plist_data_t data = plist_new_plist_data ( ) ; data -> type = PLIST_BOOLEAN ; data -> boolval = TRUE ; data -> length = 1 ; return node_create ( NULL , data ) ; } case BPLIST_FALSE : { plist_data_t data = plist_new_plist_data ( ) ; data -> type = PLIST_BOOLEAN ; data -> boolval = FALSE ; data -> length = 1 ; return node_create ( NULL , data ) ; } case BPLIST_NULL : default : return NULL ; } case BPLIST_UINT : if ( * object + ( uint64_t ) ( 1 << size ) > bplist -> offset_table ) { PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_UINT<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" , __func__ ) ; return NULL ; } return parse_uint_node ( object , size ) ; case BPLIST_REAL : if ( * object + ( uint64_t ) ( 1 << size ) > bplist -> offset_table ) { PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_REAL<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" , __func__ ) ; return NULL ; } return parse_real_node ( object , size ) ; case BPLIST_DATE : if ( 3 != size ) { PLIST_BIN_ERR ( ""%s:<S2SV_blank>invalid<S2SV_blank>data<S2SV_blank>size<S2SV_blank>for<S2SV_blank>BPLIST_DATE<S2SV_blank>node\\n"" , __func__ ) ; return NULL ; } if ( * object + ( uint64_t ) ( 1 << size ) > bplist -> offset_table ) { PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_DATE<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" , __func__ ) ; return NULL ; } return parse_date_node ( object , size ) ; case BPLIST_DATA : <S2SV_StartBug> if ( * object + size > bplist -> offset_table ) { <S2SV_EndBug> PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_DATA<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" , __func__ ) ; return NULL ; } return parse_data_node ( object , size ) ; case BPLIST_STRING : <S2SV_StartBug> if ( * object + size > bplist -> offset_table ) { <S2SV_EndBug> PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_STRING<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" , __func__ ) ; return NULL ; } return parse_string_node ( object , size ) ; case BPLIST_UNICODE : if ( size * 2 < size ) { PLIST_BIN_ERR ( ""%s:<S2SV_blank>Integer<S2SV_blank>overflow<S2SV_blank>when<S2SV_blank>calculating<S2SV_blank>BPLIST_UNICODE<S2SV_blank>data<S2SV_blank>size.\\n"" , __func__ ) ; return NULL ; } <S2SV_StartBug> if ( * object + size * 2 > bplist -> offset_table ) { <S2SV_EndBug> PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_UNICODE<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" , __func__ ) ; return NULL ; } return parse_unicode_node ( object , size ) ; case BPLIST_SET : case BPLIST_ARRAY : <S2SV_StartBug> if ( * object + size > bplist -> offset_table ) { <S2SV_EndBug> PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_ARRAY<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" , __func__ ) ; return NULL ; } return parse_array_node ( bplist , object , size ) ; case BPLIST_UID : if ( * object + size + 1 > bplist -> offset_table ) { PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_UID<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" , __func__ ) ; return NULL ; } return parse_uid_node ( object , size ) ; case BPLIST_DICT : <S2SV_StartBug> if ( * object + size > bplist -> offset_table ) { <S2SV_EndBug> PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_REAL<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" , __func__ ) ; return NULL ; } return parse_dict_node ( bplist , object , size ) ; default : PLIST_BIN_ERR ( ""%s:<S2SV_blank>unexpected<S2SV_blank>node<S2SV_blank>type<S2SV_blank>0x%02x\\n"" , __func__ , type ) ; return NULL ; } return NULL ; }","<S2SV_ModStart> object + size < * object || * object + size <S2SV_ModStart> : if ( * object + size < * object || <S2SV_ModStart> size * 2 < * object || * object + size * 2 <S2SV_ModStart> object + size < * object || * object + size <S2SV_ModStart> object + size < * object || * object + size > bplist -> offset_table ) { PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_DICT<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" <S2SV_ModEnd> , __func__ )",libimobiledevice@libplist/32ee5213fe64f1e10ec76c1ee861ee6f233120dd,CVE-2017-6436,https://github.com/libimobiledevice/libplist/commit/32ee5213fe64f1e10ec76c1ee861ee6f233120dd,2017-03-15T14:59Z
CWE-401,"CWE-000 static struct scatterlist * alloc_sgtable ( int size ) { int alloc_size , nents , i ; struct page * new_page ; struct scatterlist * iter ; struct scatterlist * table ; nents = DIV_ROUND_UP ( size , PAGE_SIZE ) ; table = kcalloc ( nents , sizeof ( * table ) , GFP_KERNEL ) ; if ( ! table ) return NULL ; sg_init_table ( table , nents ) ; iter = table ; for_each_sg ( table , iter , sg_nents ( table ) , i ) { new_page = alloc_page ( GFP_KERNEL ) ; if ( ! new_page ) { iter = table ; for_each_sg ( table , iter , sg_nents ( table ) , i ) { new_page = sg_page ( iter ) ; if ( new_page ) __free_page ( new_page ) ; } <S2SV_StartBug> return NULL ; <S2SV_EndBug> } alloc_size = min_t ( int , size , PAGE_SIZE ) ; size -= PAGE_SIZE ; sg_set_page ( iter , new_page , alloc_size , 0 ) ; } return table ; }",<S2SV_ModStart> ) ; } kfree ( table ) ;,torvalds@linux/b4b814fec1a5a849383f7b3886b654a13abbda7d,CVE-2019-19058,https://github.com/torvalds/linux/commit/b4b814fec1a5a849383f7b3886b654a13abbda7d,2019-11-18T06:15Z
CWE-908,"CWE-000 static int kvaser_usb_leaf_flush_queue ( struct kvaser_usb_net_priv * priv ) { struct kvaser_cmd * cmd ; int rc ; <S2SV_StartBug> cmd = kmalloc ( sizeof ( * cmd ) , GFP_KERNEL ) ; <S2SV_EndBug> if ( ! cmd ) return - ENOMEM ; cmd -> id = CMD_FLUSH_QUEUE ; cmd -> len = CMD_HEADER_LEN + sizeof ( struct kvaser_cmd_flush_queue ) ; cmd -> u . flush_queue . channel = priv -> channel ; cmd -> u . flush_queue . flags = 0x00 ; rc = kvaser_usb_send_cmd ( priv -> dev , cmd , cmd -> len ) ; kfree ( cmd ) ; return rc ; }",<S2SV_ModStart> ; cmd = kzalloc <S2SV_ModEnd> ( sizeof (,torvalds@linux/da2311a6385c3b499da2ed5d9be59ce331fa93e9,CVE-2019-19947,https://github.com/torvalds/linux/commit/da2311a6385c3b499da2ed5d9be59ce331fa93e9,2019-12-24T00:15Z
CWE-787,"CWE-787 int input_set_keycode ( struct input_dev * dev , const struct input_keymap_entry * ke ) { unsigned long flags ; unsigned int old_keycode ; int retval ; if ( ke -> keycode > KEY_MAX ) return - EINVAL ; spin_lock_irqsave ( & dev -> event_lock , flags ) ; retval = dev -> setkeycode ( dev , ke , & old_keycode ) ; if ( retval ) goto out ; __clear_bit ( KEY_RESERVED , dev -> keybit ) ; <S2SV_StartBug> if ( test_bit ( EV_KEY , dev -> evbit ) && <S2SV_EndBug> ! is_event_supported ( old_keycode , dev -> keybit , KEY_MAX ) && __test_and_clear_bit ( old_keycode , dev -> key ) ) { struct input_value vals [ ] = { { EV_KEY , old_keycode , 0 } , input_value_sync } ; input_pass_values ( dev , vals , ARRAY_SIZE ( vals ) ) ; } out : spin_unlock_irqrestore ( & dev -> event_lock , flags ) ; return retval ; }","<S2SV_ModStart> keybit ) ; if ( old_keycode > KEY_MAX ) { dev_warn ( dev -> dev . parent ? : & dev -> dev , ""%s:<S2SV_blank>got<S2SV_blank>too<S2SV_blank>big<S2SV_blank>old<S2SV_blank>keycode<S2SV_blank>%#x\\n"" , __func__ , old_keycode ) ; } else",torvalds@linux/cb222aed03d798fc074be55e59d9a112338ee784,CVE-2019-20636,https://github.com/torvalds/linux/commit/cb222aed03d798fc074be55e59d9a112338ee784,2020-04-08T14:15Z
CWE-119,CWE-119 const char * cJSON_GetErrorPtr ( void ) { <S2SV_StartBug> return ep ; <S2SV_EndBug> },<S2SV_ModStart> ) { return global_ep <S2SV_ModEnd> ; } <S2SV_null>,esnet@iperf/91f2fa59e8ed80dfbf400add0164ee0e508e412a,CVE-2016-4303,https://github.com/esnet/iperf/commit/91f2fa59e8ed80dfbf400add0164ee0e508e412a,2016-09-26T14:59Z
CWE-190,"CWE-190 static PyMemoEntry * _PyMemoTable_Lookup ( PyMemoTable * self , PyObject * key ) { size_t i ; size_t perturb ; <S2SV_StartBug> size_t mask = ( size_t ) self -> mt_mask ; <S2SV_EndBug> PyMemoEntry * table = self -> mt_table ; PyMemoEntry * entry ; Py_hash_t hash = ( Py_hash_t ) key >> 3 ; i = hash & mask ; entry = & table [ i ] ; if ( entry -> me_key == NULL || entry -> me_key == key ) return entry ; for ( perturb = hash ; ; perturb >>= PERTURB_SHIFT ) { i = ( i << 2 ) + i + perturb + 1 ; entry = & table [ i & mask ] ; if ( entry -> me_key == NULL || entry -> me_key == key ) return entry ; } Py_UNREACHABLE ( ) ; }",<S2SV_ModStart> size_t mask = <S2SV_ModEnd> self -> mt_mask,python@cpython/a4ae828ee416a66d8c7bf5ee71d653c2cc6a26dd,CVE-2018-20406,https://github.com/python/cpython/commit/a4ae828ee416a66d8c7bf5ee71d653c2cc6a26dd,2018-12-23T23:29Z
CWE-269,"CWE-000 static void copy_asoundrc ( void ) { char * src = RUN_ASOUNDRC_FILE ; char * dest ; if ( asprintf ( & dest , ""%s/.asoundrc"" , cfg . homedir ) == - 1 ) errExit ( ""asprintf"" ) ; if ( is_link ( dest ) ) { fprintf ( stderr , ""Error:<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>a<S2SV_blank>symbolic<S2SV_blank>link\\n"" , dest ) ; exit ( 1 ) ; } <S2SV_StartBug> pid_t child = fork ( ) ; <S2SV_EndBug> if ( child < 0 ) errExit ( ""fork"" ) ; if ( child == 0 ) { drop_privs ( 0 ) ; int rv = copy_file ( src , dest , getuid ( ) , getgid ( ) , S_IRUSR | S_IWUSR ) ; <S2SV_StartBug> if ( rv ) <S2SV_EndBug> fprintf ( stderr , ""Warning:<S2SV_blank>cannot<S2SV_blank>transfer<S2SV_blank>.asoundrc<S2SV_blank>in<S2SV_blank>private<S2SV_blank>home<S2SV_blank>directory\\n"" ) ; else { <S2SV_StartBug> fs_logger2 ( ""clone"" , dest ) ; <S2SV_EndBug> } _exit ( 0 ) ; } waitpid ( child , NULL , 0 ) ; unlink ( src ) ; }","<S2SV_ModStart> ) ; } copy_file_as_user <S2SV_ModEnd> ( src , <S2SV_ModStart> S_IWUSR ) ; <S2SV_ModEnd> fs_logger2 ( ""clone"" <S2SV_ModStart> ""clone"" , dest <S2SV_ModEnd> ) ; unlink",netblue30@firejail/b8a4ff9775318ca5e679183884a6a63f3da8f863,CVE-2017-5940,https://github.com/netblue30/firejail/commit/b8a4ff9775318ca5e679183884a6a63f3da8f863,2017-02-09T18:59Z
CWE-200,"CWE-200 __be32 ipv6_select_ident ( struct net * net , const struct in6_addr * daddr , const struct in6_addr * saddr ) { <S2SV_StartBug> static u32 ip6_idents_hashrnd __read_mostly ; <S2SV_EndBug> u32 id ; net_get_random_once ( & ip6_idents_hashrnd , sizeof ( ip6_idents_hashrnd ) ) ; <S2SV_StartBug> id = __ipv6_select_ident ( net , ip6_idents_hashrnd , daddr , saddr ) ; <S2SV_EndBug> return htonl ( id ) ; }","<S2SV_ModStart> saddr ) { u32 id <S2SV_ModEnd> ; id = <S2SV_ModStart> __ipv6_select_ident ( net <S2SV_ModEnd> , daddr ,",torvalds@linux/df453700e8d81b1bdafdf684365ee2b9431fb702,CVE-2019-10638,https://github.com/torvalds/linux/commit/df453700e8d81b1bdafdf684365ee2b9431fb702,2019-07-05T23:15Z
CWE-787,"CWE-787 void pdf_summarize ( FILE * fp , const pdf_t * pdf , const char * name , pdf_flag_t flags ) { int i , j , page , n_versions , n_entries ; FILE * dst , * out ; char * dst_name , * c ; dst = NULL ; dst_name = NULL ; if ( name ) { <S2SV_StartBug> dst_name = malloc ( strlen ( name ) * 2 + 16 ) ; <S2SV_EndBug> sprintf ( dst_name , ""%s/%s"" , name , name ) ; if ( ( c = strrchr ( dst_name , '.' ) ) && ( strncmp ( c , "".pdf"" , 4 ) == 0 ) ) * c = '\\0' ; strcat ( dst_name , "".summary"" ) ; if ( ! ( dst = fopen ( dst_name , ""w"" ) ) ) { ERR ( ""Could<S2SV_blank>not<S2SV_blank>open<S2SV_blank>file<S2SV_blank>\'%s\'<S2SV_blank>for<S2SV_blank>writing\\n"" , dst_name ) ; return ; } } out = ( dst ) ? dst : stdout ; n_versions = pdf -> n_xrefs ; if ( n_versions && pdf -> xrefs [ 0 ] . is_linear ) -- n_versions ; for ( i = 1 ; i < pdf -> n_xrefs ; ++ i ) if ( pdf -> xrefs [ i ] . end == 0 ) -- n_versions ; if ( ! pdf -> n_xrefs || ( ! n_versions && pdf -> xrefs [ 0 ] . is_linear ) ) n_versions = 1 ; n_entries = 0 ; for ( i = 0 ; ! ( const int ) pdf -> has_xref_streams && i < pdf -> n_xrefs ; i ++ ) { if ( flags & PDF_FLAG_QUIET ) continue ; for ( j = 0 ; j < pdf -> xrefs [ i ] . n_entries ; j ++ ) { ++ n_entries ; fprintf ( out , ""%s:<S2SV_blank>--%c--<S2SV_blank>Version<S2SV_blank>%d<S2SV_blank>--<S2SV_blank>Object<S2SV_blank>%d<S2SV_blank>(%s)"" , pdf -> name , pdf_get_object_status ( pdf , i , j ) , pdf -> xrefs [ i ] . version , pdf -> xrefs [ i ] . entries [ j ] . obj_id , get_type ( fp , pdf -> xrefs [ i ] . entries [ j ] . obj_id , & pdf -> xrefs [ i ] ) ) ; if ( 0 ) fprintf ( out , ""<S2SV_blank>Page(%d)\\n"" , page ) ; else fprintf ( out , ""\\n"" ) ; } } if ( ! ( flags & PDF_FLAG_QUIET ) ) { if ( pdf -> has_xref_streams || ! n_entries ) fprintf ( out , ""%s:<S2SV_blank>This<S2SV_blank>PDF<S2SV_blank>contains<S2SV_blank>potential<S2SV_blank>cross<S2SV_blank>reference<S2SV_blank>streams.\\n"" ""%s:<S2SV_blank>An<S2SV_blank>object<S2SV_blank>summary<S2SV_blank>is<S2SV_blank>not<S2SV_blank>available.\\n"" , pdf -> name , pdf -> name ) ; fprintf ( out , ""----------<S2SV_blank>%s<S2SV_blank>----------\\n"" ""Versions:<S2SV_blank>%d\\n"" , pdf -> name , n_versions ) ; if ( ! pdf -> has_xref_streams ) for ( i = 0 ; i < pdf -> n_xrefs ; i ++ ) { if ( pdf -> xrefs [ i ] . is_linear ) continue ; n_entries = pdf -> xrefs [ i ] . n_entries ; if ( pdf -> xrefs [ 0 ] . is_linear ) n_entries += pdf -> xrefs [ 0 ] . n_entries ; if ( pdf -> xrefs [ i ] . version && n_entries ) fprintf ( out , ""Version<S2SV_blank>%d<S2SV_blank>--<S2SV_blank>%d<S2SV_blank>objects\\n"" , pdf -> xrefs [ i ] . version , n_entries ) ; } } else fprintf ( out , ""%s:<S2SV_blank>%d\\n"" , pdf -> name , n_versions ) ; if ( dst ) { fclose ( dst ) ; free ( dst_name ) ; } }",<S2SV_ModStart> { dst_name = safe_calloc <S2SV_ModEnd> ( strlen (,enferex@pdfresurrect/0c4120fffa3dffe97b95c486a120eded82afe8a6,CVE-2019-14934,https://github.com/enferex/pdfresurrect/commit/0c4120fffa3dffe97b95c486a120eded82afe8a6,2019-08-11T22:15Z
CWE-125,"CWE-125 static int lha_read_file_header_1 ( struct archive_read * a , struct lha * lha ) { const unsigned char * p ; size_t extdsize ; int i , err , err2 ; int namelen , padding ; unsigned char headersum , sum_calculated ; err = ARCHIVE_OK ; if ( ( p = __archive_read_ahead ( a , H1_FIXED_SIZE , NULL ) ) == NULL ) return ( truncated_error ( a ) ) ; lha -> header_size = p [ H1_HEADER_SIZE_OFFSET ] + 2 ; headersum = p [ H1_HEADER_SUM_OFFSET ] ; lha -> compsize = archive_le32dec ( p + H1_COMP_SIZE_OFFSET ) ; lha -> origsize = archive_le32dec ( p + H1_ORIG_SIZE_OFFSET ) ; lha -> mtime = lha_dos_time ( p + H1_DOS_TIME_OFFSET ) ; namelen = p [ H1_NAME_LEN_OFFSET ] ; padding = ( ( int ) lha -> header_size ) - H1_FIXED_SIZE - namelen ; if ( namelen > 230 || padding < 0 ) goto invalid ; if ( ( p = __archive_read_ahead ( a , lha -> header_size , NULL ) ) == NULL ) return ( truncated_error ( a ) ) ; for ( i = 0 ; i < namelen ; i ++ ) { if ( p [ i + H1_FILE_NAME_OFFSET ] == 0xff ) goto invalid ; } archive_strncpy ( & lha -> filename , p + H1_FILE_NAME_OFFSET , namelen ) ; lha -> crc = archive_le16dec ( p + H1_FILE_NAME_OFFSET + namelen ) ; lha -> setflag |= CRC_IS_SET ; sum_calculated = lha_calcsum ( 0 , p , 2 , lha -> header_size - 2 ) ; __archive_read_consume ( a , lha -> header_size - 2 ) ; err2 = lha_read_file_extended_header ( a , lha , NULL , 2 , ( size_t ) ( lha -> compsize + 2 ) , & extdsize ) ; if ( err2 < ARCHIVE_WARN ) return ( err2 ) ; if ( err2 < err ) err = err2 ; lha -> compsize -= extdsize - 2 ; <S2SV_StartBug> if ( sum_calculated != headersum ) { <S2SV_EndBug> archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , ""LHa<S2SV_blank>header<S2SV_blank>sum<S2SV_blank>error"" ) ; return ( ARCHIVE_FATAL ) ; } return ( err ) ; invalid : archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Invalid<S2SV_blank>LHa<S2SV_blank>header"" ) ; return ( ARCHIVE_FATAL ) ; }",<S2SV_ModStart> ; if ( lha -> compsize < 0 ) goto invalid ; if (,libarchive@libarchive/98dcbbf0bf4854bf987557e55e55fff7abbf3ea9,CVE-2017-5601,https://github.com/libarchive/libarchive/commit/98dcbbf0bf4854bf987557e55e55fff7abbf3ea9,2017-01-27T22:59Z
CWE-200,"CWE-200 static int isofs_export_encode_fh ( struct inode * inode , __u32 * fh32 , int * max_len , struct inode * parent ) { struct iso_inode_info * ei = ISOFS_I ( inode ) ; int len = * max_len ; int type = 1 ; __u16 * fh16 = ( __u16 * ) fh32 ; if ( parent && ( len < 5 ) ) { * max_len = 5 ; return 255 ; } else if ( len < 3 ) { * max_len = 3 ; return 255 ; } len = 3 ; fh32 [ 0 ] = ei -> i_iget5_block ; fh16 [ 2 ] = ( __u16 ) ei -> i_iget5_offset ; <S2SV_StartBug> fh32 [ 2 ] = inode -> i_generation ; <S2SV_EndBug> if ( parent ) { struct iso_inode_info * eparent ; eparent = ISOFS_I ( parent ) ; fh32 [ 3 ] = eparent -> i_iget5_block ; fh16 [ 3 ] = ( __u16 ) eparent -> i_iget5_offset ; fh32 [ 4 ] = parent -> i_generation ; len = 5 ; type = 2 ; } * max_len = len ; return type ; }",<S2SV_ModStart> -> i_iget5_offset ; fh16 [ 3 ] = 0 ;,torvalds@linux/fe685aabf7c8c9f138e5ea900954d295bf229175,CVE-2012-6549,https://github.com/torvalds/linux/commit/fe685aabf7c8c9f138e5ea900954d295bf229175,2013-03-15T20:55Z
CWE-400,"CWE-000 int __usb_get_extra_descriptor ( char * buffer , unsigned size , <S2SV_StartBug> unsigned char type , void * * ptr ) <S2SV_EndBug> { struct usb_descriptor_header * header ; while ( size >= sizeof ( struct usb_descriptor_header ) ) { header = ( struct usb_descriptor_header * ) buffer ; <S2SV_StartBug> if ( header -> bLength < 2 ) { <S2SV_EndBug> printk ( KERN_ERR ""%s:<S2SV_blank>bogus<S2SV_blank>descriptor,<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>length<S2SV_blank>%d\\n"" , usbcore_name , header -> bDescriptorType , header -> bLength ) ; return - 1 ; } <S2SV_StartBug> if ( header -> bDescriptorType == type ) { <S2SV_EndBug> * ptr = header ; return 0 ; } buffer += header -> bLength ; size -= header -> bLength ; } return - 1 ; }","<S2SV_ModStart> * * ptr , size_t minsize <S2SV_ModStart> bLength < 2 || header -> bLength > size <S2SV_ModStart> bDescriptorType == type && header -> bLength >= minsize",torvalds@linux/704620afc70cf47abb9d6a1a57f3825d2bca49cf,CVE-2018-20169,https://github.com/torvalds/linux/commit/704620afc70cf47abb9d6a1a57f3825d2bca49cf,2018-12-17T07:29Z
CWE-20,"CWE-20 error_t mqttSnClientSendUnsubscribe ( MqttSnClientContext * context , const char_t * topicName ) { error_t error ; systime_t time ; uint16_t topicId ; MqttSnFlags flags ; error = NO_ERROR ; flags . all = 0 ; topicId = mqttSnClientFindPredefTopicName ( context , topicName ) ; if ( topicId != MQTT_SN_INVALID_TOPIC_ID ) { flags . topicIdType = MQTT_SN_PREDEFINED_TOPIC_ID ; } else { <S2SV_StartBug> if ( osStrlen ( topicName ) == 2 && strchr ( topicName , '#' ) == NULL && <S2SV_EndBug> <S2SV_StartBug> strchr ( topicName , '+' ) == NULL ) <S2SV_EndBug> { flags . topicIdType = MQTT_SN_SHORT_TOPIC_NAME ; } else { flags . topicIdType = MQTT_SN_NORMAL_TOPIC_NAME ; } error = mqttSnFormatUnsubscribe ( & context -> message , flags , context -> msgId , topicId , topicName ) ; } if ( ! error ) { TRACE_INFO ( ""Sending<S2SV_blank>UNSUBSCRIBE<S2SV_blank>message<S2SV_blank>(%"" PRIuSIZE ""<S2SV_blank>bytes)...\\r\\n"" , context -> message . length ) ; mqttSnDumpMessage ( context -> message . buffer , context -> message . length ) ; error = mqttSnClientSendDatagram ( context , context -> message . buffer , context -> message . length ) ; time = osGetSystemTime ( ) ; context -> retransmitStartTime = time ; context -> keepAliveTimestamp = time ; context -> state = MQTT_SN_CLIENT_STATE_SENDING_REQ ; context -> msgType = MQTT_SN_MSG_TYPE_UNSUBSCRIBE ; } return error ; }","<S2SV_ModStart> == 2 && osStrchr <S2SV_ModEnd> ( topicName , <S2SV_ModStart> == NULL && osStrchr <S2SV_ModEnd> ( topicName ,",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z
CWE-125,"CWE-125 static UINT serial_process_irp_create ( SERIAL_DEVICE * serial , IRP * irp ) { DWORD DesiredAccess ; DWORD SharedAccess ; DWORD CreateDisposition ; UINT32 PathLength ; if ( Stream_GetRemainingLength ( irp -> input ) < 32 ) return ERROR_INVALID_DATA ; Stream_Read_UINT32 ( irp -> input , DesiredAccess ) ; Stream_Seek_UINT64 ( irp -> input ) ; Stream_Seek_UINT32 ( irp -> input ) ; Stream_Read_UINT32 ( irp -> input , SharedAccess ) ; Stream_Read_UINT32 ( irp -> input , CreateDisposition ) ; Stream_Seek_UINT32 ( irp -> input ) ; Stream_Read_UINT32 ( irp -> input , PathLength ) ; <S2SV_StartBug> if ( Stream_GetRemainingLength ( irp -> input ) < PathLength ) <S2SV_EndBug> <S2SV_StartBug> return ERROR_INVALID_DATA ; <S2SV_EndBug> Stream_Seek ( irp -> input , PathLength ) ; assert ( PathLength == 0 ) ; # ifndef _WIN32 WLog_Print ( serial -> log , WLOG_DEBUG , ""DesiredAccess:<S2SV_blank>0x%"" PRIX32 "",<S2SV_blank>SharedAccess:<S2SV_blank>0x%"" PRIX32 "",<S2SV_blank>CreateDisposition:<S2SV_blank>0x%"" PRIX32 """" , DesiredAccess , SharedAccess , CreateDisposition ) ; DesiredAccess = GENERIC_READ | GENERIC_WRITE ; SharedAccess = 0 ; CreateDisposition = OPEN_EXISTING ; # endif serial -> hComm = CreateFile ( serial -> device . name , DesiredAccess , SharedAccess , NULL , CreateDisposition , 0 , NULL ) ; if ( ! serial -> hComm || ( serial -> hComm == INVALID_HANDLE_VALUE ) ) { WLog_Print ( serial -> log , WLOG_WARN , ""CreateFile<S2SV_blank>failure:<S2SV_blank>%s<S2SV_blank>last-error:<S2SV_blank>0x%08"" PRIX32 """" , serial -> device . name , GetLastError ( ) ) ; irp -> IoStatus = STATUS_UNSUCCESSFUL ; goto error_handle ; } _comm_setServerSerialDriver ( serial -> hComm , serial -> ServerSerialDriverId ) ; _comm_set_permissive ( serial -> hComm , serial -> permissive ) ; assert ( irp -> FileId == 0 ) ; irp -> FileId = irp -> devman -> id_sequence ++ ; irp -> IoStatus = STATUS_SUCCESS ; WLog_Print ( serial -> log , WLOG_DEBUG , ""%s<S2SV_blank>(DeviceId:<S2SV_blank>%"" PRIu32 "",<S2SV_blank>FileId:<S2SV_blank>%"" PRIu32 "")<S2SV_blank>created."" , serial -> device . name , irp -> device -> id , irp -> FileId ) ; error_handle : Stream_Write_UINT32 ( irp -> output , irp -> FileId ) ; Stream_Write_UINT8 ( irp -> output , 0 ) ; return CHANNEL_RC_OK ; }","<S2SV_ModStart> ; if ( ! Stream_SafeSeek ( irp -> input , PathLength ) <S2SV_ModEnd> ) return ERROR_INVALID_DATA <S2SV_ModStart> ) return ERROR_INVALID_DATA <S2SV_ModEnd> ; assert (",FreeRDP@FreeRDP/6b485b146a1b9d6ce72dfd7b5f36456c166e7a16,CVE-2020-11089,https://github.com/FreeRDP/FreeRDP/commit/6b485b146a1b9d6ce72dfd7b5f36456c166e7a16,2020-05-29T20:15Z
CWE-119,"CWE-119 static void fill_variance ( int64_t s2 , int64_t s , int c , var * v ) { v -> sum_square_error = s2 ; v -> sum_error = s ; <S2SV_StartBug> v -> count = c ; <S2SV_EndBug> <S2SV_StartBug> if ( c > 0 ) <S2SV_EndBug> v -> variance = ( int ) ( 256 * ( v -> sum_square_error - v -> sum_error * v -> sum_error / v -> count ) / v -> count ) ; else v -> variance = 0 ; }",<S2SV_ModStart> ; v -> log2_count <S2SV_ModEnd> = c ; <S2SV_ModStart> = c ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-20,"CWE-20 error_t webSocketParseRequestLine ( WebSocket * webSocket , char_t * line ) { error_t error ; char_t * token ; char_t * p ; char_t * s ; TRACE_DEBUG ( ""%s"" , line ) ; token = osStrtok_r ( line , ""<S2SV_blank>\\r\\n"" , & p ) ; if ( token == NULL ) return ERROR_INVALID_REQUEST ; if ( osStrcasecmp ( token , ""GET"" ) ) return ERROR_INVALID_REQUEST ; token = osStrtok_r ( NULL , ""<S2SV_blank>\\r\\n"" , & p ) ; if ( token == NULL ) return ERROR_INVALID_REQUEST ; <S2SV_StartBug> s = strchr ( token , '?' ) ; <S2SV_EndBug> if ( s != NULL ) { * s = '\\0' ; error = webSocketDecodePercentEncodedString ( token , webSocket -> uri , WEB_SOCKET_URI_MAX_LEN ) ; if ( error ) return ERROR_INVALID_REQUEST ; if ( osStrlen ( s + 1 ) > WEB_SOCKET_QUERY_STRING_MAX_LEN ) return ERROR_INVALID_REQUEST ; osStrcpy ( webSocket -> queryString , s + 1 ) ; } else { error = webSocketDecodePercentEncodedString ( token , webSocket -> uri , WEB_SOCKET_URI_MAX_LEN ) ; if ( error ) return ERROR_INVALID_REQUEST ; webSocket -> queryString [ 0 ] = '\\0' ; } token = osStrtok_r ( NULL , ""<S2SV_blank>\\r\\n"" , & p ) ; if ( token == NULL ) { webSocket -> handshakeContext . version = WS_HTTP_VERSION_0_9 ; webSocket -> handshakeContext . connectionClose = TRUE ; } else if ( ! osStrcasecmp ( token , ""HTTP/1.0"" ) ) { webSocket -> handshakeContext . version = WS_HTTP_VERSION_1_0 ; webSocket -> handshakeContext . connectionClose = TRUE ; } else if ( ! osStrcasecmp ( token , ""HTTP/1.1"" ) ) { webSocket -> handshakeContext . version = WS_HTTP_VERSION_1_1 ; webSocket -> handshakeContext . connectionClose = FALSE ; } else { return ERROR_INVALID_REQUEST ; } return NO_ERROR ; }","<S2SV_ModStart> ; s = osStrchr <S2SV_ModEnd> ( token ,",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z
CWE-119,"CWE-119 static void update_layer_buffer_level ( SVC * svc , int encoded_frame_size ) { <S2SV_StartBug> int temporal_layer = 0 ; <S2SV_EndBug> int current_temporal_layer = svc -> temporal_layer_id ; <S2SV_StartBug> for ( temporal_layer = current_temporal_layer + 1 ; <S2SV_EndBug> <S2SV_StartBug> temporal_layer < svc -> number_temporal_layers ; ++ temporal_layer ) { <S2SV_EndBug> <S2SV_StartBug> LAYER_CONTEXT * lc = & svc -> layer_context [ temporal_layer ] ; <S2SV_EndBug> RATE_CONTROL * lrc = & lc -> rc ; int bits_off_for_this_layer = ( int ) ( lc -> target_bandwidth / lc -> framerate - encoded_frame_size ) ; lrc -> bits_off_target += bits_off_for_this_layer ; <S2SV_StartBug> lrc -> bits_off_target = MIN ( lrc -> bits_off_target , lc -> maximum_buffer_size ) ; <S2SV_EndBug> lrc -> buffer_level = lrc -> bits_off_target ; } }","<S2SV_ModStart> ) { int i <S2SV_ModEnd> = 0 ; <S2SV_ModStart> ; for ( i <S2SV_ModEnd> = current_temporal_layer + <S2SV_ModStart> + 1 ; i <S2SV_ModEnd> < svc -> <S2SV_ModStart> number_temporal_layers ; ++ i ) { const int layer = LAYER_IDS_TO_IDX ( svc -> spatial_layer_id , i , svc -> number_temporal_layers ) ; <S2SV_ModEnd> LAYER_CONTEXT * lc <S2SV_ModStart> -> layer_context [ layer <S2SV_ModEnd> ] ; RATE_CONTROL <S2SV_ModStart> -> bits_off_target , lrc <S2SV_ModEnd> -> maximum_buffer_size )",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-264,"CWE-264 static struct cifsSesInfo * cifs_get_smb_ses ( struct TCP_Server_Info * server , struct smb_vol * volume_info ) { int rc = - ENOMEM , xid ; struct cifsSesInfo * ses ; xid = GetXid ( ) ; <S2SV_StartBug> ses = cifs_find_smb_ses ( server , volume_info -> username ) ; <S2SV_EndBug> if ( ses ) { cFYI ( 1 , ""Existing<S2SV_blank>smb<S2SV_blank>sess<S2SV_blank>found<S2SV_blank>(status=%d)"" , ses -> status ) ; cifs_put_tcp_session ( server ) ; mutex_lock ( & ses -> session_mutex ) ; rc = cifs_negotiate_protocol ( xid , ses ) ; if ( rc ) { mutex_unlock ( & ses -> session_mutex ) ; cifs_put_smb_ses ( ses ) ; FreeXid ( xid ) ; return ERR_PTR ( rc ) ; } if ( ses -> need_reconnect ) { cFYI ( 1 , ""Session<S2SV_blank>needs<S2SV_blank>reconnect"" ) ; rc = cifs_setup_session ( xid , ses , volume_info -> local_nls ) ; if ( rc ) { mutex_unlock ( & ses -> session_mutex ) ; cifs_put_smb_ses ( ses ) ; FreeXid ( xid ) ; return ERR_PTR ( rc ) ; } } mutex_unlock ( & ses -> session_mutex ) ; FreeXid ( xid ) ; return ses ; } cFYI ( 1 , ""Existing<S2SV_blank>smb<S2SV_blank>sess<S2SV_blank>not<S2SV_blank>found"" ) ; ses = sesInfoAlloc ( ) ; if ( ses == NULL ) goto get_ses_fail ; ses -> server = server ; if ( server -> addr . sockAddr6 . sin6_family == AF_INET6 ) sprintf ( ses -> serverName , ""%pI6"" , & server -> addr . sockAddr6 . sin6_addr ) ; else sprintf ( ses -> serverName , ""%pI4"" , & server -> addr . sockAddr . sin_addr . s_addr ) ; if ( volume_info -> username ) strncpy ( ses -> userName , volume_info -> username , MAX_USERNAME_SIZE ) ; if ( volume_info -> password ) { ses -> password = kstrdup ( volume_info -> password , GFP_KERNEL ) ; if ( ! ses -> password ) goto get_ses_fail ; } if ( volume_info -> domainname ) { int len = strlen ( volume_info -> domainname ) ; ses -> domainName = kmalloc ( len + 1 , GFP_KERNEL ) ; if ( ses -> domainName ) strcpy ( ses -> domainName , volume_info -> domainname ) ; } ses -> linux_uid = volume_info -> linux_uid ; ses -> overrideSecFlg = volume_info -> secFlg ; mutex_lock ( & ses -> session_mutex ) ; rc = cifs_negotiate_protocol ( xid , ses ) ; if ( ! rc ) rc = cifs_setup_session ( xid , ses , volume_info -> local_nls ) ; mutex_unlock ( & ses -> session_mutex ) ; if ( rc ) goto get_ses_fail ; write_lock ( & cifs_tcp_ses_lock ) ; list_add ( & ses -> smb_ses_list , & server -> smb_ses_list ) ; write_unlock ( & cifs_tcp_ses_lock ) ; FreeXid ( xid ) ; return ses ; get_ses_fail : sesInfoFree ( ses ) ; FreeXid ( xid ) ; return ERR_PTR ( rc ) ; }","<S2SV_ModStart> server , volume_info <S2SV_ModEnd> ) ; if",torvalds@linux/4ff67b720c02c36e54d55b88c2931879b7db1cd2,CVE-2011-1585,https://github.com/torvalds/linux/commit/4ff67b720c02c36e54d55b88c2931879b7db1cd2,2013-06-08T13:05Z
NVD-CWE-Other,"CWE-000 char * guestfs___first_line_of_file ( guestfs_h * g , const char * filename ) { <S2SV_StartBug> CLEANUP_FREE char * * lines = NULL ; <S2SV_EndBug> int64_t size ; char * ret ; size = guestfs_filesize ( g , filename ) ; if ( size == - 1 ) return NULL ; if ( size > MAX_SMALL_FILE_SIZE ) { error ( g , _ ( ""size<S2SV_blank>of<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>unreasonably<S2SV_blank>large<S2SV_blank>(%"" PRIi64 ""<S2SV_blank>bytes)"" ) , filename , size ) ; return NULL ; } lines = guestfs_head_n ( g , 1 , filename ) ; if ( lines == NULL ) return NULL ; if ( lines [ 0 ] == NULL ) { guestfs___free_string_list ( lines ) ; return safe_strdup ( g , """" ) ; } ret = lines [ 0 ] ; <S2SV_StartBug> return ret ; <S2SV_EndBug> }",<S2SV_ModStart> filename ) { <S2SV_ModEnd> char * * <S2SV_ModStart> 0 ] ; free ( lines ) ;,libguestfs@libguestfs/fa6a76050d82894365dfe32916903ef7fee3ffcd,CVE-2013-2124,https://github.com/libguestfs/libguestfs/commit/fa6a76050d82894365dfe32916903ef7fee3ffcd,2014-05-27T14:55Z
CWE-125,"CWE-125 static int ospf6_decode_v3 ( netdissect_options * ndo , register const struct ospf6hdr * op , register const u_char * dataend ) { register const rtrid_t * ap ; register const struct lsr6 * lsrp ; register const struct lsa6_hdr * lshp ; register const struct lsa6 * lsap ; register int i ; switch ( op -> ospf6_type ) { case OSPF_TYPE_HELLO : { <S2SV_StartBug> register const struct hello6 * hellop = ( const struct hello6 * ) ( ( const uint8_t * ) op + OSPF6HDR_LEN ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""\\n\\tOptions<S2SV_blank>[%s]"" , bittok2str ( ospf6_option_values , ""none"" , EXTRACT_32BITS ( & hellop -> hello_options ) ) ) ) ; ND_TCHECK ( hellop -> hello_deadint ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Hello<S2SV_blank>Timer<S2SV_blank>%us,<S2SV_blank>Dead<S2SV_blank>Timer<S2SV_blank>%us,<S2SV_blank>Interface-ID<S2SV_blank>%s,<S2SV_blank>Priority<S2SV_blank>%u"" , EXTRACT_16BITS ( & hellop -> hello_helloint ) , EXTRACT_16BITS ( & hellop -> hello_deadint ) , ipaddr_string ( ndo , & hellop -> hello_ifid ) , hellop -> hello_priority ) ) ; ND_TCHECK ( hellop -> hello_dr ) ; if ( EXTRACT_32BITS ( & hellop -> hello_dr ) != 0 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Designated<S2SV_blank>Router<S2SV_blank>%s"" , ipaddr_string ( ndo , & hellop -> hello_dr ) ) ) ; ND_TCHECK ( hellop -> hello_bdr ) ; if ( EXTRACT_32BITS ( & hellop -> hello_bdr ) != 0 ) ND_PRINT ( ( ndo , "",<S2SV_blank>Backup<S2SV_blank>Designated<S2SV_blank>Router<S2SV_blank>%s"" , ipaddr_string ( ndo , & hellop -> hello_bdr ) ) ) ; if ( ndo -> ndo_vflag > 1 ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Neighbor<S2SV_blank>List:"" ) ) ; ap = hellop -> hello_neighbor ; while ( ( const u_char * ) ap < dataend ) { ND_TCHECK ( * ap ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , ipaddr_string ( ndo , ap ) ) ) ; ++ ap ; } } break ; } case OSPF_TYPE_DD : { register const struct dd6 * ddp = ( const struct dd6 * ) ( ( const uint8_t * ) op + OSPF6HDR_LEN ) ; ND_TCHECK ( ddp -> db_options ) ; ND_PRINT ( ( ndo , ""\\n\\tOptions<S2SV_blank>[%s]"" , bittok2str ( ospf6_option_values , ""none"" , EXTRACT_32BITS ( & ddp -> db_options ) ) ) ) ; ND_TCHECK ( ddp -> db_flags ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>DD<S2SV_blank>Flags<S2SV_blank>[%s]"" , bittok2str ( ospf6_dd_flag_values , ""none"" , ddp -> db_flags ) ) ) ; ND_TCHECK ( ddp -> db_seq ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>MTU<S2SV_blank>%u,<S2SV_blank>DD-Sequence<S2SV_blank>0x%08x"" , EXTRACT_16BITS ( & ddp -> db_mtu ) , EXTRACT_32BITS ( & ddp -> db_seq ) ) ) ; if ( ndo -> ndo_vflag > 1 ) { lshp = ddp -> db_lshdr ; while ( ( const u_char * ) lshp < dataend ) { if ( ospf6_print_lshdr ( ndo , lshp ++ , dataend ) ) goto trunc ; } } break ; } case OSPF_TYPE_LS_REQ : if ( ndo -> ndo_vflag > 1 ) { lsrp = ( const struct lsr6 * ) ( ( const uint8_t * ) op + OSPF6HDR_LEN ) ; while ( ( const u_char * ) lsrp < dataend ) { ND_TCHECK ( * lsrp ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Advertising<S2SV_blank>Router<S2SV_blank>%s"" , ipaddr_string ( ndo , & lsrp -> ls_router ) ) ) ; ospf6_print_ls_type ( ndo , EXTRACT_16BITS ( & lsrp -> ls_type ) , & lsrp -> ls_stateid ) ; ++ lsrp ; } } break ; case OSPF_TYPE_LS_UPDATE : if ( ndo -> ndo_vflag > 1 ) { register const struct lsu6 * lsup = ( const struct lsu6 * ) ( ( const uint8_t * ) op + OSPF6HDR_LEN ) ; ND_TCHECK ( lsup -> lsu_count ) ; i = EXTRACT_32BITS ( & lsup -> lsu_count ) ; lsap = lsup -> lsu_lsa ; while ( ( const u_char * ) lsap < dataend && i -- ) { if ( ospf6_print_lsa ( ndo , lsap , dataend ) ) goto trunc ; lsap = ( const struct lsa6 * ) ( ( const u_char * ) lsap + EXTRACT_16BITS ( & lsap -> ls_hdr . ls_length ) ) ; } } break ; case OSPF_TYPE_LS_ACK : if ( ndo -> ndo_vflag > 1 ) { lshp = ( const struct lsa6_hdr * ) ( ( const uint8_t * ) op + OSPF6HDR_LEN ) ; while ( ( const u_char * ) lshp < dataend ) { if ( ospf6_print_lshdr ( ndo , lshp ++ , dataend ) ) goto trunc ; } } break ; default : break ; } return ( 0 ) ; trunc : return ( 1 ) ; }",<S2SV_ModStart> op + OSPF6HDR_LEN ) ; ND_TCHECK_32BITS ( & hellop -> hello_options,the-tcpdump-group@tcpdump/88b2dac837e81cf56dce05e6e7b5989332c0092d,CVE-2017-13036,https://github.com/the-tcpdump-group/tcpdump/commit/88b2dac837e81cf56dce05e6e7b5989332c0092d,2017-09-14T06:29Z
CWE-119,"CWE-119 void show_object_with_name ( FILE * out , struct object * obj , <S2SV_StartBug> struct strbuf * path , const char * component ) <S2SV_EndBug> { char * name = path_name ( path , component ) ; char * p ; fprintf ( out , ""%s<S2SV_blank>"" , oid_to_hex ( & obj -> oid ) ) ; for ( p = name ; * p && * p != '\\n' ; p ++ ) fputc ( * p , out ) ; fputc ( '\\n' , out ) ; <S2SV_StartBug> free ( name ) ; <S2SV_EndBug> }","<S2SV_ModStart> * obj , <S2SV_ModEnd> const char * <S2SV_ModStart> const char * name ) { const <S2SV_ModEnd> char * p <S2SV_ModStart> out ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>",git@git/de1e67d0703894cb6ea782e36abb63976ab07e60,CVE-2016-2315,https://github.com/git/git/commit/de1e67d0703894cb6ea782e36abb63976ab07e60,2016-04-08T14:59Z
CWE-476,"CWE-476 <S2SV_StartBug> static int mpeg4_decode_profile_level ( MpegEncContext * s , GetBitContext * gb ) <S2SV_EndBug> { s -> avctx -> profile = get_bits ( gb , 4 ) ; <S2SV_StartBug> s -> avctx -> level = get_bits ( gb , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( s -> avctx -> profile == 0 && s -> avctx -> level == 8 ) { <S2SV_EndBug> <S2SV_StartBug> s -> avctx -> level = 0 ; <S2SV_EndBug> } return 0 ; }","<S2SV_ModStart> GetBitContext * gb , int * profile , int * level ) { * <S2SV_ModEnd> profile = get_bits <S2SV_ModStart> 4 ) ; * <S2SV_ModEnd> level = get_bits <S2SV_ModStart> ; if ( * <S2SV_ModEnd> profile == 0 <S2SV_ModStart> == 0 && * <S2SV_ModEnd> level == 8 <S2SV_ModStart> 8 ) { * <S2SV_ModEnd> level = 0",FFmpeg@FFmpeg/2aa9047486dbff12d9e040f917e5f799ed2fd78b,CVE-2018-13301,https://github.com/FFmpeg/FFmpeg/commit/2aa9047486dbff12d9e040f917e5f799ed2fd78b,2018-07-05T17:29Z
CWE-125,"CWE-125 int ip6_find_1stfragopt ( struct sk_buff * skb , u8 * * nexthdr ) { <S2SV_StartBug> u16 offset = sizeof ( struct ipv6hdr ) ; <S2SV_EndBug> struct ipv6_opt_hdr * exthdr = ( struct ipv6_opt_hdr * ) ( ipv6_hdr ( skb ) + 1 ) ; unsigned int packet_len = skb_tail_pointer ( skb ) - skb_network_header ( skb ) ; int found_rhdr = 0 ; * nexthdr = & ipv6_hdr ( skb ) -> nexthdr ; <S2SV_StartBug> while ( offset + 1 <= packet_len ) { <S2SV_EndBug> <S2SV_StartBug> switch ( * * nexthdr ) { <S2SV_EndBug> case NEXTHDR_HOP : break ; case NEXTHDR_ROUTING : found_rhdr = 1 ; break ; case NEXTHDR_DEST : # if IS_ENABLED ( CONFIG_IPV6_MIP6 ) if ( ipv6_find_tlv ( skb , offset , IPV6_TLV_HAO ) >= 0 ) break ; # endif if ( found_rhdr ) return offset ; break ; default : return offset ; } <S2SV_StartBug> offset += ipv6_optlen ( exthdr ) ; <S2SV_EndBug> * nexthdr = & exthdr -> nexthdr ; <S2SV_StartBug> exthdr = ( struct ipv6_opt_hdr * ) ( skb_network_header ( skb ) + <S2SV_EndBug> offset ) ; } return offset ; }",<S2SV_ModStart> ( struct ipv6hdr <S2SV_ModEnd> ) ; unsigned <S2SV_ModStart> while ( offset <S2SV_ModEnd> <= packet_len ) <S2SV_ModStart> packet_len ) { struct ipv6_opt_hdr * exthdr ; <S2SV_ModStart> offset ; } if ( offset + sizeof ( struct ipv6_opt_hdr ) > packet_len ) return - EINVAL ; exthdr = ( struct ipv6_opt_hdr * ) ( skb_network_header ( skb ) + offset ) ; <S2SV_ModStart> -> nexthdr ; } return - EINVAL <S2SV_ModEnd> ; } <S2SV_null>,torvalds@linux/2423496af35d94a87156b063ea5cedffc10a70a1,CVE-2017-9074,https://github.com/torvalds/linux/commit/2423496af35d94a87156b063ea5cedffc10a70a1,2017-05-19T07:29Z
CWE-416,"CWE-416 void comps_rtree_unite ( COMPS_RTree * rt1 , COMPS_RTree * rt2 ) { COMPS_HSList * tmplist , * tmp_subnodes ; COMPS_HSListItem * it ; struct Pair { COMPS_HSList * subnodes ; char * key ; <S2SV_StartBug> char added ; <S2SV_EndBug> } * pair , * parent_pair ; pair = malloc ( sizeof ( struct Pair ) ) ; pair -> subnodes = rt2 -> subnodes ; pair -> key = NULL ; tmplist = comps_hslist_create ( ) ; comps_hslist_init ( tmplist , NULL , NULL , & free ) ; comps_hslist_append ( tmplist , pair , 0 ) ; while ( tmplist -> first != NULL ) { it = tmplist -> first ; comps_hslist_remove ( tmplist , tmplist -> first ) ; tmp_subnodes = ( ( struct Pair * ) it -> data ) -> subnodes ; parent_pair = ( struct Pair * ) it -> data ; free ( it ) ; for ( it = tmp_subnodes -> first ; it != NULL ; it = it -> next ) { pair = malloc ( sizeof ( struct Pair ) ) ; pair -> subnodes = ( ( COMPS_RTreeData * ) it -> data ) -> subnodes ; if ( parent_pair -> key != NULL ) { pair -> key = malloc ( sizeof ( char ) * ( strlen ( ( ( COMPS_RTreeData * ) it -> data ) -> key ) + strlen ( parent_pair -> key ) + 1 ) ) ; memcpy ( pair -> key , parent_pair -> key , sizeof ( char ) * strlen ( parent_pair -> key ) ) ; memcpy ( pair -> key + strlen ( parent_pair -> key ) , ( ( COMPS_RTreeData * ) it -> data ) -> key , sizeof ( char ) * ( strlen ( ( ( COMPS_RTreeData * ) it -> data ) -> key ) + 1 ) ) ; } else { pair -> key = malloc ( sizeof ( char ) * ( strlen ( ( ( COMPS_RTreeData * ) it -> data ) -> key ) + 1 ) ) ; memcpy ( pair -> key , ( ( COMPS_RTreeData * ) it -> data ) -> key , sizeof ( char ) * ( strlen ( ( ( COMPS_RTreeData * ) it -> data ) -> key ) + 1 ) ) ; } if ( ( ( COMPS_RTreeData * ) it -> data ) -> data != NULL ) { comps_rtree_set ( rt1 , pair -> key , rt2 -> data_cloner ( ( ( COMPS_RTreeData * ) it -> data ) -> data ) ) ; } if ( ( ( COMPS_RTreeData * ) it -> data ) -> subnodes -> first ) { comps_hslist_append ( tmplist , pair , 0 ) ; } else { free ( pair -> key ) ; free ( pair ) ; } } free ( parent_pair -> key ) ; free ( parent_pair ) ; } comps_hslist_destroy ( & tmplist ) ; }",<S2SV_ModStart> * key ; <S2SV_ModEnd> } * pair,rpm-software-management@libcomps/e3a5d056633677959ad924a51758876d415e7046,CVE-2019-3817,https://github.com/rpm-software-management/libcomps/commit/e3a5d056633677959ad924a51758876d415e7046,2019-03-27T13:29Z
CWE-264,"CWE-264 static int __ptrace_may_access ( struct task_struct * task , unsigned int mode ) { const struct cred * cred = current_cred ( ) , * tcred ; int dumpable = 0 ; if ( same_thread_group ( task , current ) ) return 0 ; rcu_read_lock ( ) ; tcred = __task_cred ( task ) ; if ( uid_eq ( cred -> uid , tcred -> euid ) && uid_eq ( cred -> uid , tcred -> suid ) && uid_eq ( cred -> uid , tcred -> uid ) && gid_eq ( cred -> gid , tcred -> egid ) && gid_eq ( cred -> gid , tcred -> sgid ) && gid_eq ( cred -> gid , tcred -> gid ) ) goto ok ; if ( ptrace_has_cap ( tcred -> user_ns , mode ) ) goto ok ; rcu_read_unlock ( ) ; return - EPERM ; ok : rcu_read_unlock ( ) ; smp_rmb ( ) ; if ( task -> mm ) dumpable = get_dumpable ( task -> mm ) ; rcu_read_lock ( ) ; <S2SV_StartBug> if ( ! dumpable && ! ptrace_has_cap ( __task_cred ( task ) -> user_ns , mode ) ) { <S2SV_EndBug> rcu_read_unlock ( ) ; return - EPERM ; } rcu_read_unlock ( ) ; return security_ptrace_access_check ( task , mode ) ; }",<S2SV_ModStart> ; if ( dumpable != SUID_DUMP_USER && <S2SV_ModEnd> ! ptrace_has_cap (,torvalds@linux/d049f74f2dbe71354d43d393ac3a188947811348,CVE-2013-2929,https://github.com/torvalds/linux/commit/d049f74f2dbe71354d43d393ac3a188947811348,2013-12-09T18:55Z
CWE-20,"CWE-20 static int pppoe_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * m , size_t total_len , int flags ) { struct sock * sk = sock -> sk ; struct sk_buff * skb ; int error = 0 ; if ( sk -> sk_state & PPPOX_BOUND ) { error = - EIO ; goto end ; } skb = skb_recv_datagram ( sk , flags & ~ MSG_DONTWAIT , flags & MSG_DONTWAIT , & error ) ; if ( error < 0 ) goto end ; <S2SV_StartBug> m -> msg_namelen = 0 ; <S2SV_EndBug> if ( skb ) { total_len = min_t ( size_t , total_len , skb -> len ) ; error = skb_copy_datagram_iovec ( skb , 0 , m -> msg_iov , total_len ) ; if ( error == 0 ) { consume_skb ( skb ) ; return total_len ; } } kfree_skb ( skb ) ; end : return error ; }",<S2SV_ModStart> goto end ; <S2SV_ModEnd> if ( skb,torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7270,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z
CWE-476,"CWE-476 GF_Err latm_dmx_process ( GF_Filter * filter ) { GF_LATMDmxCtx * ctx = gf_filter_get_udta ( filter ) ; GF_FilterPacket * pck , * dst_pck ; u32 pos ; <S2SV_StartBug> u8 * data , * output ; <S2SV_EndBug> <S2SV_StartBug> u32 pck_size , prev_pck_size ; <S2SV_EndBug> u64 cts = GF_FILTER_NO_TS ; if ( ctx -> in_error ) return ctx -> in_error ; if ( ! ctx -> duration . num ) latm_dmx_check_dur ( filter , ctx ) ; if ( ctx -> opid && ! ctx -> is_playing ) return GF_OK ; pck = gf_filter_pid_get_packet ( ctx -> ipid ) ; if ( ! pck ) { if ( gf_filter_pid_is_eos ( ctx -> ipid ) ) { if ( ! ctx -> latm_buffer_size ) { if ( ctx -> opid ) gf_filter_pid_set_eos ( ctx -> opid ) ; if ( ctx -> src_pck ) gf_filter_pck_unref ( ctx -> src_pck ) ; ctx -> src_pck = NULL ; return GF_EOS ; } } else { return GF_OK ; } <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> data = ( char * ) gf_filter_pck_get_data ( pck , & pck_size ) ; <S2SV_EndBug> if ( ctx -> timescale && pck ) { cts = gf_filter_pck_get_cts ( pck ) ; } prev_pck_size = ctx -> latm_buffer_size ; if ( pck && ! ctx -> resume_from ) { if ( ctx -> latm_buffer_size + pck_size > ctx -> latm_buffer_alloc ) { ctx -> latm_buffer_alloc = ctx -> latm_buffer_size + pck_size ; ctx -> latm_buffer = gf_realloc ( ctx -> latm_buffer , ctx -> latm_buffer_alloc ) ; } memcpy ( ctx -> latm_buffer + ctx -> latm_buffer_size , data , pck_size ) ; ctx -> latm_buffer_size += pck_size ; } if ( ! ctx -> bs ) ctx -> bs = gf_bs_new ( ctx -> latm_buffer , ctx -> latm_buffer_size , GF_BITSTREAM_READ ) ; else gf_bs_reassign_buffer ( ctx -> bs , ctx -> latm_buffer , ctx -> latm_buffer_size ) ; if ( ctx -> resume_from ) { gf_bs_seek ( ctx -> bs , ctx -> resume_from - 1 ) ; ctx -> resume_from = 0 ; } if ( cts == GF_FILTER_NO_TS ) prev_pck_size = 0 ; while ( 1 ) { pos = ( u32 ) gf_bs_get_position ( ctx -> bs ) ; u8 latm_buffer [ 4096 ] ; u32 latm_frame_size = 4096 ; if ( ! latm_dmx_sync_frame_bs ( ctx -> bs , & ctx -> acfg , & latm_frame_size , latm_buffer , NULL ) ) break ; if ( ctx -> in_seek ) { u64 nb_samples_at_seek = ( u64 ) ( ctx -> start_range * GF_M4ASampleRates [ ctx -> sr_idx ] ) ; if ( ctx -> cts + ctx -> dts_inc >= nb_samples_at_seek ) { ctx -> in_seek = GF_FALSE ; } } latm_dmx_check_pid ( filter , ctx ) ; if ( ! ctx -> is_playing ) { ctx -> resume_from = pos + 1 ; return GF_OK ; } if ( ! ctx -> in_seek ) { GF_FilterSAPType sap = GF_FILTER_SAP_1 ; dst_pck = gf_filter_pck_new_alloc ( ctx -> opid , latm_frame_size , & output ) ; if ( ctx -> src_pck ) gf_filter_pck_merge_properties ( ctx -> src_pck , dst_pck ) ; memcpy ( output , latm_buffer , latm_frame_size ) ; gf_filter_pck_set_cts ( dst_pck , ctx -> cts ) ; gf_filter_pck_set_duration ( dst_pck , ctx -> dts_inc ) ; gf_filter_pck_set_framing ( dst_pck , GF_TRUE , GF_TRUE ) ; if ( ctx -> acfg . base_object_type == GF_CODECID_USAC ) { if ( latm_frame_size && ( output [ 0 ] & 0x80 ) && ! ctx -> prev_sap ) { sap = GF_FILTER_SAP_1 ; ctx -> prev_sap = GF_TRUE ; } else { sap = GF_FILTER_SAP_NONE ; ctx -> prev_sap = GF_FALSE ; } } gf_filter_pck_set_sap ( dst_pck , sap ) ; gf_filter_pck_send ( dst_pck ) ; } latm_dmx_update_cts ( ctx ) ; if ( prev_pck_size ) { pos = ( u32 ) gf_bs_get_position ( ctx -> bs ) ; if ( prev_pck_size <= pos ) { prev_pck_size = 0 ; if ( ctx -> src_pck ) gf_filter_pck_unref ( ctx -> src_pck ) ; ctx -> src_pck = pck ; if ( pck ) gf_filter_pck_ref_props ( & ctx -> src_pck ) ; } } } if ( pck ) { pos = ( u32 ) gf_bs_get_position ( ctx -> bs ) ; assert ( ctx -> latm_buffer_size >= pos ) ; memmove ( ctx -> latm_buffer , ctx -> latm_buffer + pos , ctx -> latm_buffer_size - pos ) ; ctx -> latm_buffer_size -= pos ; gf_filter_pid_drop_packet ( ctx -> ipid ) ; assert ( ! ctx -> resume_from ) ; } else { ctx -> latm_buffer_size = 0 ; return latm_dmx_process ( filter ) ; } return GF_OK ; }",<S2SV_ModStart> u8 * data = NULL <S2SV_ModStart> ; u32 pck_size = 0 <S2SV_ModStart> ; } } else { <S2SV_ModStart> pck_size ) ; },gpac@gpac/b2db2f99b4c30f96e17b9a14537c776da6cb5dca,CVE-2021-30199,https://github.com/gpac/gpac/commit/b2db2f99b4c30f96e17b9a14537c776da6cb5dca,2021-04-19T20:15Z
CWE-119,"CWE-119 static struct stream_state * new_stream ( struct VpxEncoderConfig * global , struct stream_state * prev ) { struct stream_state * stream ; stream = calloc ( 1 , sizeof ( * stream ) ) ; <S2SV_StartBug> if ( ! stream ) <S2SV_EndBug> <S2SV_StartBug> fatal ( ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>new<S2SV_blank>stream."" ) ; <S2SV_EndBug> if ( prev ) { memcpy ( stream , prev , sizeof ( * stream ) ) ; stream -> index ++ ; prev -> next = stream ; } else { vpx_codec_err_t res ; <S2SV_StartBug> res = vpx_codec_enc_config_default ( global -> codec -> interface ( ) , <S2SV_EndBug> & stream -> config . cfg , global -> usage ) ; if ( res ) fatal ( ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>config:<S2SV_blank>%s\\n"" , vpx_codec_err_to_string ( res ) ) ; stream -> config . cfg . g_timebase . den = 1000 ; stream -> config . cfg . g_w = 0 ; stream -> config . cfg . g_h = 0 ; <S2SV_StartBug> stream -> config . stereo_fmt = STEREO_FORMAT_MONO ; <S2SV_EndBug> <S2SV_StartBug> stream -> config . write_webm = 1 ; <S2SV_EndBug> # if CONFIG_WEBM_IO <S2SV_StartBug> stream -> ebml . last_pts_ms = - 1 ; <S2SV_EndBug> # endif stream -> ebml . debug = global -> debug ; if ( global -> deadline == VPX_DL_REALTIME ) stream -> config . cfg . g_lag_in_frames = 0 ; } stream -> config . out_fn = NULL ; stream -> next = NULL ; return stream ; }","<S2SV_ModStart> ; if ( stream == NULL ) { <S2SV_ModEnd> fatal ( ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>new<S2SV_blank>stream."" <S2SV_ModStart> ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>new<S2SV_blank>stream."" ) ; } <S2SV_ModStart> -> codec -> codec_interface <S2SV_ModEnd> ( ) , <S2SV_ModStart> -> config . write_webm = 1 ; # if CONFIG_WEBM_IO stream -> config . <S2SV_ModStart> ; stream -> ebml . last_pts_ns <S2SV_ModEnd> = - 1 <S2SV_ModStart> = - 1 ; stream -> ebml . writer = NULL ; stream -> ebml . segment = NULL",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-399,"CWE-399 static int sctp_process_param ( struct sctp_association * asoc , union sctp_params param , const union sctp_addr * peer_addr , gfp_t gfp ) { struct net * net = sock_net ( asoc -> base . sk ) ; union sctp_addr addr ; int i ; __u16 sat ; int retval = 1 ; sctp_scope_t scope ; time_t stale ; struct sctp_af * af ; union sctp_addr_param * addr_param ; struct sctp_transport * t ; struct sctp_endpoint * ep = asoc -> ep ; switch ( param . p -> type ) { case SCTP_PARAM_IPV6_ADDRESS : if ( PF_INET6 != asoc -> base . sk -> sk_family ) break ; goto do_addr_param ; case SCTP_PARAM_IPV4_ADDRESS : if ( ipv6_only_sock ( asoc -> base . sk ) ) break ; do_addr_param : af = sctp_get_af_specific ( param_type2af ( param . p -> type ) ) ; af -> from_addr_param ( & addr , param . addr , htons ( asoc -> peer . port ) , 0 ) ; scope = sctp_scope ( peer_addr ) ; if ( sctp_in_scope ( net , & addr , scope ) ) if ( ! sctp_assoc_add_peer ( asoc , & addr , gfp , SCTP_UNCONFIRMED ) ) return 0 ; break ; case SCTP_PARAM_COOKIE_PRESERVATIVE : if ( ! net -> sctp . cookie_preserve_enable ) break ; stale = ntohl ( param . life -> lifespan_increment ) ; asoc -> cookie_life = ktime_add_ms ( asoc -> cookie_life , stale ) ; break ; case SCTP_PARAM_HOST_NAME_ADDRESS : pr_debug ( ""%s:<S2SV_blank>unimplemented<S2SV_blank>SCTP_HOST_NAME_ADDRESS\\n"" , __func__ ) ; break ; case SCTP_PARAM_SUPPORTED_ADDRESS_TYPES : asoc -> peer . ipv4_address = 0 ; asoc -> peer . ipv6_address = 0 ; if ( peer_addr -> sa . sa_family == AF_INET6 ) asoc -> peer . ipv6_address = 1 ; else if ( peer_addr -> sa . sa_family == AF_INET ) asoc -> peer . ipv4_address = 1 ; sat = ntohs ( param . p -> length ) - sizeof ( sctp_paramhdr_t ) ; if ( sat ) sat /= sizeof ( __u16 ) ; for ( i = 0 ; i < sat ; ++ i ) { switch ( param . sat -> types [ i ] ) { case SCTP_PARAM_IPV4_ADDRESS : asoc -> peer . ipv4_address = 1 ; break ; case SCTP_PARAM_IPV6_ADDRESS : if ( PF_INET6 == asoc -> base . sk -> sk_family ) asoc -> peer . ipv6_address = 1 ; break ; case SCTP_PARAM_HOST_NAME_ADDRESS : asoc -> peer . hostname_address = 1 ; break ; default : break ; } } break ; case SCTP_PARAM_STATE_COOKIE : asoc -> peer . cookie_len = ntohs ( param . p -> length ) - sizeof ( sctp_paramhdr_t ) ; asoc -> peer . cookie = param . cookie -> body ; break ; case SCTP_PARAM_HEARTBEAT_INFO : break ; case SCTP_PARAM_UNRECOGNIZED_PARAMETERS : break ; case SCTP_PARAM_ECN_CAPABLE : asoc -> peer . ecn_capable = 1 ; break ; case SCTP_PARAM_ADAPTATION_LAYER_IND : asoc -> peer . adaptation_ind = ntohl ( param . aind -> adaptation_ind ) ; break ; case SCTP_PARAM_SET_PRIMARY : if ( ! net -> sctp . addip_enable ) goto fall_through ; addr_param = param . v + sizeof ( sctp_addip_param_t ) ; af = sctp_get_af_specific ( param_type2af ( param . p -> type ) ) ; <S2SV_StartBug> af -> from_addr_param ( & addr , addr_param , <S2SV_EndBug> htons ( asoc -> peer . port ) , 0 ) ; if ( ! af -> addr_valid ( & addr , NULL , NULL ) ) break ; t = sctp_assoc_lookup_paddr ( asoc , & addr ) ; if ( ! t ) break ; sctp_assoc_set_primary ( asoc , t ) ; break ; case SCTP_PARAM_SUPPORTED_EXT : sctp_process_ext_param ( asoc , param ) ; break ; case SCTP_PARAM_FWD_TSN_SUPPORT : if ( net -> sctp . prsctp_enable ) { asoc -> peer . prsctp_capable = 1 ; break ; } goto fall_through ; case SCTP_PARAM_RANDOM : if ( ! ep -> auth_enable ) goto fall_through ; asoc -> peer . peer_random = kmemdup ( param . p , ntohs ( param . p -> length ) , gfp ) ; if ( ! asoc -> peer . peer_random ) { retval = 0 ; break ; } break ; case SCTP_PARAM_HMAC_ALGO : if ( ! ep -> auth_enable ) goto fall_through ; asoc -> peer . peer_hmacs = kmemdup ( param . p , ntohs ( param . p -> length ) , gfp ) ; if ( ! asoc -> peer . peer_hmacs ) { retval = 0 ; break ; } sctp_auth_asoc_set_default_hmac ( asoc , param . hmac_algo ) ; break ; case SCTP_PARAM_CHUNKS : if ( ! ep -> auth_enable ) goto fall_through ; asoc -> peer . peer_chunks = kmemdup ( param . p , ntohs ( param . p -> length ) , gfp ) ; if ( ! asoc -> peer . peer_chunks ) retval = 0 ; break ; fall_through : default : pr_debug ( ""%s:<S2SV_blank>ignoring<S2SV_blank>param:%d<S2SV_blank>for<S2SV_blank>association:%p.\\n"" , __func__ , ntohs ( param . p -> type ) , asoc ) ; break ; } return retval ; }",<S2SV_ModStart> ) ) ; if ( af == NULL ) break ;,torvalds@linux/e40607cbe270a9e8360907cb1e62ddf0736e4864,CVE-2014-7841,https://github.com/torvalds/linux/commit/e40607cbe270a9e8360907cb1e62ddf0736e4864,2014-11-30T01:59Z
CWE-772,"CWE-772 static Image * ReadSCREENSHOTImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = ( Image * ) NULL ; # if defined ( MAGICKCORE_WINGDI32_DELEGATE ) { BITMAPINFO bmi ; DISPLAY_DEVICE device ; HBITMAP bitmap , bitmapOld ; HDC bitmapDC , hDC ; Image * screen ; int i ; MagickBooleanType status ; register Quantum * q ; register ssize_t x ; RGBTRIPLE * p ; ssize_t y ; assert ( image_info != ( const ImageInfo * ) NULL ) ; i = 0 ; device . cb = sizeof ( device ) ; image = ( Image * ) NULL ; while ( EnumDisplayDevices ( NULL , i , & device , 0 ) && ++ i ) { if ( ( device . StateFlags & DISPLAY_DEVICE_ACTIVE ) != DISPLAY_DEVICE_ACTIVE ) continue ; hDC = CreateDC ( device . DeviceName , device . DeviceName , NULL , NULL ) ; if ( hDC == ( HDC ) NULL ) ThrowReaderException ( CoderError , ""UnableToCreateDC"" ) ; screen = AcquireImage ( image_info , exception ) ; screen -> columns = ( size_t ) GetDeviceCaps ( hDC , HORZRES ) ; screen -> rows = ( size_t ) GetDeviceCaps ( hDC , VERTRES ) ; screen -> storage_class = DirectClass ; <S2SV_StartBug> status = SetImageExtent ( screen , screen -> columns , screen -> rows , exception ) ; <S2SV_EndBug> if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; <S2SV_StartBug> if ( image == ( Image * ) NULL ) <S2SV_EndBug> image = screen ; else AppendImageToList ( & image , screen ) ; bitmapDC = CreateCompatibleDC ( hDC ) ; if ( bitmapDC == ( HDC ) NULL ) { DeleteDC ( hDC ) ; ThrowReaderException ( CoderError , ""UnableToCreateDC"" ) ; } ( void ) ResetMagickMemory ( & bmi , 0 , sizeof ( BITMAPINFO ) ) ; bmi . bmiHeader . biSize = sizeof ( BITMAPINFOHEADER ) ; bmi . bmiHeader . biWidth = ( LONG ) screen -> columns ; bmi . bmiHeader . biHeight = ( - 1 ) * ( LONG ) screen -> rows ; bmi . bmiHeader . biPlanes = 1 ; bmi . bmiHeader . biBitCount = 24 ; bmi . bmiHeader . biCompression = BI_RGB ; bitmap = CreateDIBSection ( hDC , & bmi , DIB_RGB_COLORS , ( void * * ) & p , NULL , 0 ) ; if ( bitmap == ( HBITMAP ) NULL ) { DeleteDC ( hDC ) ; DeleteDC ( bitmapDC ) ; ThrowReaderException ( CoderError , ""UnableToCreateBitmap"" ) ; } bitmapOld = ( HBITMAP ) SelectObject ( bitmapDC , bitmap ) ; if ( bitmapOld == ( HBITMAP ) NULL ) { DeleteDC ( hDC ) ; DeleteDC ( bitmapDC ) ; DeleteObject ( bitmap ) ; ThrowReaderException ( CoderError , ""UnableToCreateBitmap"" ) ; } BitBlt ( bitmapDC , 0 , 0 , ( int ) screen -> columns , ( int ) screen -> rows , hDC , 0 , 0 , SRCCOPY ) ; ( void ) SelectObject ( bitmapDC , bitmapOld ) ; for ( y = 0 ; y < ( ssize_t ) screen -> rows ; y ++ ) { q = QueueAuthenticPixels ( screen , 0 , y , screen -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) screen -> columns ; x ++ ) { SetPixelRed ( image , ScaleCharToQuantum ( p -> rgbtRed ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( p -> rgbtGreen ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( p -> rgbtBlue ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; p ++ ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( screen , exception ) == MagickFalse ) break ; } DeleteDC ( hDC ) ; DeleteDC ( bitmapDC ) ; DeleteObject ( bitmap ) ; } } # elif defined ( MAGICKCORE_X11_DELEGATE ) { const char * option ; XImportInfo ximage_info ; XGetImportInfo ( & ximage_info ) ; option = GetImageOption ( image_info , ""x:screen"" ) ; if ( option != ( const char * ) NULL ) ximage_info . screen = IsStringTrue ( option ) ; option = GetImageOption ( image_info , ""x:silent"" ) ; if ( option != ( const char * ) NULL ) ximage_info . silent = IsStringTrue ( option ) ; image = XImportImage ( image_info , & ximage_info , exception ) ; } # endif return ( image ) ; }","<S2SV_ModStart> = DirectClass ; if ( image == ( Image * ) NULL ) image = screen ; else AppendImageToList ( & image , screen ) ; <S2SV_ModStart> ) ) ; <S2SV_ModEnd> bitmapDC = CreateCompatibleDC",ImageMagick@ImageMagick/72a50e400d98d7a2fd610caedfeb9af043dc5582,CVE-2017-11447,https://github.com/ImageMagick/ImageMagick/commit/72a50e400d98d7a2fd610caedfeb9af043dc5582,2017-07-19T07:29Z
CWE-119,"CWE-119 <S2SV_StartBug> int get_vp9_frame_buffer ( void * cb_priv , size_t min_size , <S2SV_EndBug> vpx_codec_frame_buffer_t * fb ) { int i ; struct ExternalFrameBufferList * const ext_fb_list = ( struct ExternalFrameBufferList * ) cb_priv ; if ( ext_fb_list == NULL ) return - 1 ; for ( i = 0 ; i < ext_fb_list -> num_external_frame_buffers ; ++ i ) { if ( ! ext_fb_list -> ext_fb [ i ] . in_use ) break ; } if ( i == ext_fb_list -> num_external_frame_buffers ) return - 1 ; if ( ext_fb_list -> ext_fb [ i ] . size < min_size ) { free ( ext_fb_list -> ext_fb [ i ] . data ) ; <S2SV_StartBug> ext_fb_list -> ext_fb [ i ] . data = ( uint8_t * ) malloc ( min_size ) ; <S2SV_EndBug> if ( ! ext_fb_list -> ext_fb [ i ] . data ) return - 1 ; ext_fb_list -> ext_fb [ i ] . size = min_size ; } fb -> data = ext_fb_list -> ext_fb [ i ] . data ; fb -> size = ext_fb_list -> ext_fb [ i ] . size ; ext_fb_list -> ext_fb [ i ] . in_use = 1 ; fb -> priv = & ext_fb_list -> ext_fb [ i ] ; return 0 ; }","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModStart> uint8_t * ) calloc ( min_size , sizeof ( uint8_t ) <S2SV_ModEnd> ) ; if",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-119,"CWE-119 static int iwl_process_add_sta_resp ( struct iwl_priv * priv , struct iwl_addsta_cmd * addsta , struct iwl_rx_packet * pkt ) { u8 sta_id = addsta -> sta . sta_id ; unsigned long flags ; int ret = - EIO ; if ( pkt -> hdr . flags & IWL_CMD_FAILED_MSK ) { IWL_ERR ( priv , ""Bad<S2SV_blank>return<S2SV_blank>from<S2SV_blank>REPLY_ADD_STA<S2SV_blank>(0x%08X)\\n"" , pkt -> hdr . flags ) ; return ret ; } IWL_DEBUG_INFO ( priv , ""Processing<S2SV_blank>response<S2SV_blank>for<S2SV_blank>adding<S2SV_blank>station<S2SV_blank>%u\\n"" , sta_id ) ; spin_lock_irqsave ( & priv -> shrd -> sta_lock , flags ) ; switch ( pkt -> u . add_sta . status ) { case ADD_STA_SUCCESS_MSK : IWL_DEBUG_INFO ( priv , ""REPLY_ADD_STA<S2SV_blank>PASSED\\n"" ) ; <S2SV_StartBug> iwl_sta_ucode_activate ( priv , sta_id ) ; <S2SV_EndBug> ret = 0 ; break ; case ADD_STA_NO_ROOM_IN_TABLE : IWL_ERR ( priv , ""Adding<S2SV_blank>station<S2SV_blank>%d<S2SV_blank>failed,<S2SV_blank>no<S2SV_blank>room<S2SV_blank>in<S2SV_blank>table.\\n"" , sta_id ) ; break ; case ADD_STA_NO_BLOCK_ACK_RESOURCE : IWL_ERR ( priv , ""Adding<S2SV_blank>station<S2SV_blank>%d<S2SV_blank>failed,<S2SV_blank>no<S2SV_blank>block<S2SV_blank>ack<S2SV_blank>"" ""resource.\\n"" , sta_id ) ; break ; case ADD_STA_MODIFY_NON_EXIST_STA : IWL_ERR ( priv , ""Attempting<S2SV_blank>to<S2SV_blank>modify<S2SV_blank>non-existing<S2SV_blank>station<S2SV_blank>%d\\n"" , sta_id ) ; break ; default : IWL_DEBUG_ASSOC ( priv , ""Received<S2SV_blank>REPLY_ADD_STA:(0x%08X)\\n"" , pkt -> u . add_sta . status ) ; break ; } IWL_DEBUG_INFO ( priv , ""%s<S2SV_blank>station<S2SV_blank>id<S2SV_blank>%u<S2SV_blank>addr<S2SV_blank>%pM\\n"" , priv -> stations [ sta_id ] . sta . mode == STA_CONTROL_MODIFY_MSK ? ""Modified"" : ""Added"" , sta_id , priv -> stations [ sta_id ] . sta . sta . addr ) ; IWL_DEBUG_INFO ( priv , ""%s<S2SV_blank>station<S2SV_blank>according<S2SV_blank>to<S2SV_blank>cmd<S2SV_blank>buffer<S2SV_blank>%pM\\n"" , priv -> stations [ sta_id ] . sta . mode == STA_CONTROL_MODIFY_MSK ? ""Modified"" : ""Added"" , addsta -> sta . addr ) ; spin_unlock_irqrestore ( & priv -> shrd -> sta_lock , flags ) ; return ret ; }","<S2SV_ModStart> ""REPLY_ADD_STA<S2SV_blank>PASSED\\n"" ) ; ret = iwl_sta_ucode_activate ( priv , sta_id ) <S2SV_ModEnd> ; break ;",torvalds@linux/2da424b0773cea3db47e1e81db71eeebde8269d4,CVE-2012-6712,https://github.com/torvalds/linux/commit/2da424b0773cea3db47e1e81db71eeebde8269d4,2019-07-27T22:15Z
CWE-190,"CWE-190 void * xcalloc ( size_t num , size_t size ) { <S2SV_StartBug> void * ptr = malloc ( num * size ) ; <S2SV_EndBug> if ( ptr ) { <S2SV_StartBug> memset ( ptr , '\\0' , ( num * size ) ) ; <S2SV_EndBug> } return ptr ; }","<S2SV_ModStart> size ) { size_t res ; if ( check_mul_overflow ( num , size , & res ) ) abort ( ) ; void * ptr ; <S2SV_ModEnd> ptr = malloc <S2SV_ModStart> = malloc ( res <S2SV_ModEnd> ) ; if <S2SV_ModStart> '\\0' , ( res <S2SV_ModEnd> ) ) ;",verdammelt@tnef/c5044689e50039635e7700fe2472fd632ac77176,CVE-2017-6308,https://github.com/verdammelt/tnef/commit/c5044689e50039635e7700fe2472fd632ac77176,2017-02-24T04:59Z
CWE-59,"CWE-000 static int fsmMkfile ( rpmfi fi , const char * dest , rpmfiles files , rpmpsm psm , int nodigest , int * setmeta , int * firsthardlink ) { int rc = 0 ; int numHardlinks = rpmfiFNlink ( fi ) ; if ( numHardlinks > 1 ) { if ( * firsthardlink < 0 ) { * firsthardlink = rpmfiFX ( fi ) ; <S2SV_StartBug> rc = expandRegular ( fi , dest , psm , nodigest , 1 ) ; <S2SV_EndBug> } else { char * fn = rpmfilesFN ( files , * firsthardlink ) ; rc = link ( fn , dest ) ; if ( rc < 0 ) { rc = RPMERR_LINK_FAILED ; } free ( fn ) ; } } if ( numHardlinks <= 1 ) { if ( ! rc ) <S2SV_StartBug> rc = expandRegular ( fi , dest , psm , nodigest , 0 ) ; <S2SV_EndBug> } else if ( rpmfiArchiveHasContent ( fi ) ) { if ( ! rc ) <S2SV_StartBug> rc = expandRegular ( fi , dest , psm , nodigest , 0 ) ; <S2SV_EndBug> * firsthardlink = - 1 ; } else { * setmeta = 0 ; } return rc ; }","<S2SV_ModStart> , psm , 1 , <S2SV_ModStart> , psm , 1 , <S2SV_ModStart> , psm , 0 ,",rpm-software-management@rpm/404ef011c300207cdb1e531670384564aae04bdc,CVE-2017-7501,https://github.com/rpm-software-management/rpm/commit/404ef011c300207cdb1e531670384564aae04bdc,2017-11-22T22:29Z
CWE-401,"CWE-000 struct resource_pool * dce110_create_resource_pool ( uint8_t num_virtual_links , struct dc * dc , struct hw_asic_id asic_id ) { struct dce110_resource_pool * pool = kzalloc ( sizeof ( struct dce110_resource_pool ) , GFP_KERNEL ) ; if ( ! pool ) return NULL ; if ( construct ( num_virtual_links , dc , pool , asic_id ) ) return & pool -> base ; <S2SV_StartBug> BREAK_TO_DEBUGGER ( ) ; <S2SV_EndBug> return NULL ; }",<S2SV_ModStart> -> base ; kfree ( pool ) ;,torvalds@linux/104c307147ad379617472dd91a5bcb368d72bd6d,CVE-2019-19082,https://github.com/torvalds/linux/commit/104c307147ad379617472dd91a5bcb368d72bd6d,2019-11-18T06:15Z
CWE-119,CWE-119 cJSON * cJSON_CreateString ( const char * string ) { cJSON * item = cJSON_New_Item ( ) ; if ( item ) { item -> type = cJSON_String ; item -> valuestring = cJSON_strdup ( string ) ; <S2SV_StartBug> } <S2SV_EndBug> return item ; },<S2SV_ModStart> string ) ; if ( ! item -> valuestring ) { cJSON_Delete ( item ) ; return 0 ; } } <S2SV_ModEnd> return item ;,esnet@iperf/91f2fa59e8ed80dfbf400add0164ee0e508e412a,CVE-2016-4303,https://github.com/esnet/iperf/commit/91f2fa59e8ed80dfbf400add0164ee0e508e412a,2016-09-26T14:59Z
,"CWE-000 static void * bpf_any_get ( void * raw , enum bpf_type type ) { switch ( type ) { case BPF_TYPE_PROG : <S2SV_StartBug> atomic_inc ( & ( ( struct bpf_prog * ) raw ) -> aux -> refcnt ) ; <S2SV_EndBug> break ; case BPF_TYPE_MAP : <S2SV_StartBug> bpf_map_inc ( raw , true ) ; <S2SV_EndBug> break ; default : WARN_ON_ONCE ( 1 ) ; break ; } return raw ; }",<S2SV_ModStart> case BPF_TYPE_PROG : raw = bpf_prog_inc ( raw <S2SV_ModEnd> ) ; break <S2SV_ModStart> case BPF_TYPE_MAP : raw =,torvalds@linux/92117d8443bc5afacc8d5ba82e541946310f106e,CVE-2016-4558,https://github.com/torvalds/linux/commit/92117d8443bc5afacc8d5ba82e541946310f106e,2016-05-23T10:59Z
CWE-20,"CWE-20 static int hash_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct hash_ctx * ctx = ask -> private ; unsigned ds = crypto_ahash_digestsize ( crypto_ahash_reqtfm ( & ctx -> req ) ) ; int err ; if ( len > ds ) len = ds ; else if ( len < ds ) msg -> msg_flags |= MSG_TRUNC ; <S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> lock_sock ( sk ) ; if ( ctx -> more ) { ctx -> more = 0 ; ahash_request_set_crypt ( & ctx -> req , NULL , ctx -> result , 0 ) ; err = af_alg_wait_for_completion ( crypto_ahash_final ( & ctx -> req ) , & ctx -> completion ) ; if ( err ) goto unlock ; } err = memcpy_toiovec ( msg -> msg_iov , ctx -> result , len ) ; unlock : release_sock ( sk ) ; return err ? : len ; }",<S2SV_ModStart> |= MSG_TRUNC ; <S2SV_ModEnd> lock_sock ( sk,torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7270,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z
CWE-190,"CWE-190 SQLITE_PRIVATE void sqlite3VtabBeginParse ( Parse * pParse , Token * pName1 , Token * pName2 , Token * pModuleName , int ifNotExists ) { Table * pTable ; sqlite3 * db ; sqlite3StartTable ( pParse , pName1 , pName2 , 0 , 0 , 1 , ifNotExists ) ; pTable = pParse -> pNewTable ; if ( pTable == 0 ) return ; assert ( 0 == pTable -> pIndex ) ; db = pParse -> db ; assert ( pTable -> nModuleArg == 0 ) ; <S2SV_StartBug> addModuleArgument ( db , pTable , sqlite3NameFromToken ( db , pModuleName ) ) ; <S2SV_EndBug> <S2SV_StartBug> addModuleArgument ( db , pTable , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> addModuleArgument ( db , pTable , sqlite3DbStrDup ( db , pTable -> zName ) ) ; <S2SV_EndBug> assert ( ( pParse -> sNameToken . z == pName2 -> z && pName2 -> z != 0 ) || ( pParse -> sNameToken . z == pName1 -> z && pName2 -> z == 0 ) ) ; pParse -> sNameToken . n = ( int ) ( & pModuleName -> z [ pModuleName -> n ] - pParse -> sNameToken . z ) ; # ifndef SQLITE_OMIT_AUTHORIZATION if ( pTable -> azModuleArg ) { int iDb = sqlite3SchemaToIndex ( db , pTable -> pSchema ) ; assert ( iDb >= 0 ) ; sqlite3AuthCheck ( pParse , SQLITE_CREATE_VTABLE , pTable -> zName , pTable -> azModuleArg [ 0 ] , pParse -> db -> aDb [ iDb ] . zDbSName ) ; } # endif }","<S2SV_ModStart> ; addModuleArgument ( pParse <S2SV_ModEnd> , pTable , <S2SV_ModStart> ; addModuleArgument ( pParse <S2SV_ModEnd> , pTable , <S2SV_ModStart> ; addModuleArgument ( pParse <S2SV_ModEnd> , pTable ,",chromium@chromium/517ac71c9ee27f856f9becde8abea7d1604af9d4,CVE-2019-5827,https://github.com/chromium/chromium/commit/517ac71c9ee27f856f9becde8abea7d1604af9d4,2019-06-27T17:15Z
CWE-399,"CWE-399 void mono_gc_init ( void ) { InitializeCriticalSection ( & handle_section ) ; InitializeCriticalSection ( & allocator_section ) ; <S2SV_StartBug> InitializeCriticalSection ( & finalizer_mutex ) ; <S2SV_EndBug> MONO_GC_REGISTER_ROOT_FIXED ( gc_handles [ HANDLE_NORMAL ] . entries ) ; MONO_GC_REGISTER_ROOT_FIXED ( gc_handles [ HANDLE_PINNED ] . entries ) ; mono_gc_base_init ( ) ; if ( mono_gc_is_disabled ( ) ) { gc_disabled = TRUE ; return ; } finalizer_event = CreateEvent ( NULL , FALSE , FALSE , NULL ) ; pending_done_event = CreateEvent ( NULL , TRUE , FALSE , NULL ) ; shutdown_event = CreateEvent ( NULL , TRUE , FALSE , NULL ) ; if ( finalizer_event == NULL || pending_done_event == NULL || shutdown_event == NULL ) { g_assert_not_reached ( ) ; } # ifdef MONO_HAS_SEMAPHORES MONO_SEM_INIT ( & finalizer_sem , 0 ) ; # endif gc_thread = mono_thread_create_internal ( mono_domain_get ( ) , finalizer_thread , NULL , FALSE ) ; ves_icall_System_Threading_Thread_SetName_internal ( gc_thread , mono_string_new ( mono_domain_get ( ) , ""Finalizer"" ) ) ; }",<S2SV_ModStart> ( & finalizer_mutex ) ; InitializeCriticalSection ( & reference_queue_mutex,mono@mono/8eb1189099e02372fd45ca1c67230eccf1edddc0,CVE-2011-0991,https://github.com/mono/mono/commit/8eb1189099e02372fd45ca1c67230eccf1edddc0,2011-04-13T21:55Z
CWE-200,"CWE-200 static int read_gab2_sub ( AVFormatContext * s , AVStream * st , AVPacket * pkt ) { if ( pkt -> size >= 7 && pkt -> size < INT_MAX - AVPROBE_PADDING_SIZE && ! strcmp ( pkt -> data , ""GAB2"" ) && AV_RL16 ( pkt -> data + 5 ) == 2 ) { uint8_t desc [ 256 ] ; int score = AVPROBE_SCORE_EXTENSION , ret ; AVIStream * ast = st -> priv_data ; AVInputFormat * sub_demuxer ; AVRational time_base ; int size ; AVIOContext * pb = avio_alloc_context ( pkt -> data + 7 , pkt -> size - 7 , 0 , NULL , NULL , NULL , NULL ) ; AVProbeData pd ; unsigned int desc_len = avio_rl32 ( pb ) ; if ( desc_len > pb -> buf_end - pb -> buf_ptr ) goto error ; ret = avio_get_str16le ( pb , desc_len , desc , sizeof ( desc ) ) ; avio_skip ( pb , desc_len - ret ) ; if ( * desc ) av_dict_set ( & st -> metadata , ""title"" , desc , 0 ) ; avio_rl16 ( pb ) ; avio_rl32 ( pb ) ; size = pb -> buf_end - pb -> buf_ptr ; pd = ( AVProbeData ) { . buf = av_mallocz ( size + AVPROBE_PADDING_SIZE ) , . buf_size = size } ; if ( ! pd . buf ) goto error ; memcpy ( pd . buf , pb -> buf_ptr , size ) ; sub_demuxer = av_probe_input_format2 ( & pd , 1 , & score ) ; av_freep ( & pd . buf ) ; if ( ! sub_demuxer ) goto error ; <S2SV_StartBug> if ( ! ( ast -> sub_ctx = avformat_alloc_context ( ) ) ) <S2SV_EndBug> goto error ; ast -> sub_ctx -> pb = pb ; if ( ff_copy_whiteblacklists ( ast -> sub_ctx , s ) < 0 ) goto error ; if ( ! avformat_open_input ( & ast -> sub_ctx , """" , sub_demuxer , NULL ) ) { if ( ast -> sub_ctx -> nb_streams != 1 ) goto error ; ff_read_packet ( ast -> sub_ctx , & ast -> sub_pkt ) ; avcodec_parameters_copy ( st -> codecpar , ast -> sub_ctx -> streams [ 0 ] -> codecpar ) ; time_base = ast -> sub_ctx -> streams [ 0 ] -> time_base ; avpriv_set_pts_info ( st , 64 , time_base . num , time_base . den ) ; } ast -> sub_buffer = pkt -> data ; memset ( pkt , 0 , sizeof ( * pkt ) ) ; return 1 ; error : av_freep ( & ast -> sub_ctx ) ; av_freep ( & pb ) ; } return 0 ; }","<S2SV_ModStart> ; if ( strcmp ( sub_demuxer -> name , ""srt"" ) && strcmp ( sub_demuxer -> name , ""ass"" ) ) goto error ; if (",FFmpeg@FFmpeg/a5d849b149ca67ced2d271dc84db0bc95a548abb,CVE-2017-9993,https://github.com/FFmpeg/FFmpeg/commit/a5d849b149ca67ced2d271dc84db0bc95a548abb,2017-06-28T06:29Z
CWE-119,"CWE-119 static void calc_av_activity ( VP8_COMP * cpi , int64_t activity_sum ) { # if ACT_MEDIAN { unsigned int median ; unsigned int i , j ; unsigned int * sortlist ; unsigned int tmp ; CHECK_MEM_ERROR ( sortlist , vpx_calloc ( sizeof ( unsigned int ) , cpi -> common . MBs ) ) ; <S2SV_StartBug> vpx_memcpy ( sortlist , cpi -> mb_activity_map , <S2SV_EndBug> sizeof ( unsigned int ) * cpi -> common . MBs ) ; for ( i = 1 ; i < cpi -> common . MBs ; i ++ ) { for ( j = i ; j > 0 ; j -- ) { if ( sortlist [ j ] < sortlist [ j - 1 ] ) { tmp = sortlist [ j - 1 ] ; sortlist [ j - 1 ] = sortlist [ j ] ; sortlist [ j ] = tmp ; } else break ; } } median = ( 1 + sortlist [ cpi -> common . MBs >> 1 ] + sortlist [ ( cpi -> common . MBs >> 1 ) + 1 ] ) >> 1 ; cpi -> activity_avg = median ; vpx_free ( sortlist ) ; } # else cpi -> activity_avg = ( unsigned int ) ( activity_sum / cpi -> common . MBs ) ; # endif if ( cpi -> activity_avg < VP8_ACTIVITY_AVG_MIN ) cpi -> activity_avg = VP8_ACTIVITY_AVG_MIN ; if ( ALT_ACT_MEASURE ) cpi -> activity_avg = 100000 ; }","<S2SV_ModStart> ) ) ; memcpy <S2SV_ModEnd> ( sortlist ,",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-399,"CWE-399 static int yam_ioctl ( struct net_device * dev , struct ifreq * ifr , int cmd ) { struct yam_port * yp = netdev_priv ( dev ) ; struct yamdrv_ioctl_cfg yi ; struct yamdrv_ioctl_mcs * ym ; int ioctl_cmd ; if ( copy_from_user ( & ioctl_cmd , ifr -> ifr_data , sizeof ( int ) ) ) return - EFAULT ; if ( yp -> magic != YAM_MAGIC ) return - EINVAL ; if ( ! capable ( CAP_NET_ADMIN ) ) return - EPERM ; if ( cmd != SIOCDEVPRIVATE ) return - EINVAL ; switch ( ioctl_cmd ) { case SIOCYAMRESERVED : return - EINVAL ; case SIOCYAMSMCS : if ( netif_running ( dev ) ) return - EINVAL ; if ( ( ym = kmalloc ( sizeof ( struct yamdrv_ioctl_mcs ) , GFP_KERNEL ) ) == NULL ) return - ENOBUFS ; if ( copy_from_user ( ym , ifr -> ifr_data , sizeof ( struct yamdrv_ioctl_mcs ) ) ) { kfree ( ym ) ; return - EFAULT ; } if ( ym -> bitrate > YAM_MAXBITRATE ) { kfree ( ym ) ; return - EINVAL ; } add_mcs ( ym -> bits , ym -> bitrate , 0 ) ; kfree ( ym ) ; break ; case SIOCYAMSCFG : if ( ! capable ( CAP_SYS_RAWIO ) ) return - EPERM ; if ( copy_from_user ( & yi , ifr -> ifr_data , sizeof ( struct yamdrv_ioctl_cfg ) ) ) return - EFAULT ; if ( ( yi . cfg . mask & YAM_IOBASE ) && netif_running ( dev ) ) return - EINVAL ; if ( ( yi . cfg . mask & YAM_IRQ ) && netif_running ( dev ) ) return - EINVAL ; if ( ( yi . cfg . mask & YAM_BITRATE ) && netif_running ( dev ) ) return - EINVAL ; if ( ( yi . cfg . mask & YAM_BAUDRATE ) && netif_running ( dev ) ) return - EINVAL ; if ( yi . cfg . mask & YAM_IOBASE ) { yp -> iobase = yi . cfg . iobase ; dev -> base_addr = yi . cfg . iobase ; } if ( yi . cfg . mask & YAM_IRQ ) { if ( yi . cfg . irq > 15 ) return - EINVAL ; yp -> irq = yi . cfg . irq ; dev -> irq = yi . cfg . irq ; } if ( yi . cfg . mask & YAM_BITRATE ) { if ( yi . cfg . bitrate > YAM_MAXBITRATE ) return - EINVAL ; yp -> bitrate = yi . cfg . bitrate ; } if ( yi . cfg . mask & YAM_BAUDRATE ) { if ( yi . cfg . baudrate > YAM_MAXBAUDRATE ) return - EINVAL ; yp -> baudrate = yi . cfg . baudrate ; } if ( yi . cfg . mask & YAM_MODE ) { if ( yi . cfg . mode > YAM_MAXMODE ) return - EINVAL ; yp -> dupmode = yi . cfg . mode ; } if ( yi . cfg . mask & YAM_HOLDDLY ) { if ( yi . cfg . holddly > YAM_MAXHOLDDLY ) return - EINVAL ; yp -> holdd = yi . cfg . holddly ; } if ( yi . cfg . mask & YAM_TXDELAY ) { if ( yi . cfg . txdelay > YAM_MAXTXDELAY ) return - EINVAL ; yp -> txd = yi . cfg . txdelay ; } if ( yi . cfg . mask & YAM_TXTAIL ) { if ( yi . cfg . txtail > YAM_MAXTXTAIL ) return - EINVAL ; yp -> txtail = yi . cfg . txtail ; } if ( yi . cfg . mask & YAM_PERSIST ) { if ( yi . cfg . persist > YAM_MAXPERSIST ) return - EINVAL ; yp -> pers = yi . cfg . persist ; } if ( yi . cfg . mask & YAM_SLOTTIME ) { if ( yi . cfg . slottime > YAM_MAXSLOTTIME ) return - EINVAL ; yp -> slot = yi . cfg . slottime ; yp -> slotcnt = yp -> slot / 10 ; } break ; case SIOCYAMGCFG : <S2SV_StartBug> yi . cfg . mask = 0xffffffff ; <S2SV_EndBug> yi . cfg . iobase = yp -> iobase ; yi . cfg . irq = yp -> irq ; yi . cfg . bitrate = yp -> bitrate ; yi . cfg . baudrate = yp -> baudrate ; yi . cfg . mode = yp -> dupmode ; yi . cfg . txdelay = yp -> txd ; yi . cfg . holddly = yp -> holdd ; yi . cfg . txtail = yp -> txtail ; yi . cfg . persist = yp -> pers ; yi . cfg . slottime = yp -> slot ; if ( copy_to_user ( ifr -> ifr_data , & yi , sizeof ( struct yamdrv_ioctl_cfg ) ) ) return - EFAULT ; break ; default : return - EINVAL ; } return 0 ; }","<S2SV_ModStart> case SIOCYAMGCFG : memset ( & yi , 0 , sizeof ( yi ) ) ;",torvalds@linux/8e3fbf870481eb53b2d3a322d1fc395ad8b367ed,CVE-2014-1446,https://github.com/torvalds/linux/commit/8e3fbf870481eb53b2d3a322d1fc395ad8b367ed,2014-01-18T22:55Z
CWE-476,"CWE-476 static int tun_set_iff ( struct net * net , struct file * file , struct ifreq * ifr ) { struct tun_struct * tun ; struct tun_file * tfile = file -> private_data ; struct net_device * dev ; int err ; if ( tfile -> detached ) return - EINVAL ; dev = __dev_get_by_name ( net , ifr -> ifr_name ) ; if ( dev ) { if ( ifr -> ifr_flags & IFF_TUN_EXCL ) return - EBUSY ; if ( ( ifr -> ifr_flags & IFF_TUN ) && dev -> netdev_ops == & tun_netdev_ops ) tun = netdev_priv ( dev ) ; else if ( ( ifr -> ifr_flags & IFF_TAP ) && dev -> netdev_ops == & tap_netdev_ops ) tun = netdev_priv ( dev ) ; else return - EINVAL ; if ( ! ! ( ifr -> ifr_flags & IFF_MULTI_QUEUE ) != ! ! ( tun -> flags & IFF_MULTI_QUEUE ) ) return - EINVAL ; if ( tun_not_capable ( tun ) ) return - EPERM ; err = security_tun_dev_open ( tun -> security ) ; if ( err < 0 ) return err ; err = tun_attach ( tun , file , ifr -> ifr_flags & IFF_NOFILTER ) ; if ( err < 0 ) return err ; if ( tun -> flags & IFF_MULTI_QUEUE && ( tun -> numqueues + tun -> numdisabled > 1 ) ) { return 0 ; } } else { char * name ; unsigned long flags = 0 ; int queues = ifr -> ifr_flags & IFF_MULTI_QUEUE ? MAX_TAP_QUEUES : 1 ; if ( ! ns_capable ( net -> user_ns , CAP_NET_ADMIN ) ) return - EPERM ; err = security_tun_dev_create ( ) ; if ( err < 0 ) return err ; if ( ifr -> ifr_flags & IFF_TUN ) { flags |= IFF_TUN ; name = ""tun%d"" ; } else if ( ifr -> ifr_flags & IFF_TAP ) { flags |= IFF_TAP ; name = ""tap%d"" ; } else return - EINVAL ; if ( * ifr -> ifr_name ) name = ifr -> ifr_name ; dev = alloc_netdev_mqs ( sizeof ( struct tun_struct ) , name , NET_NAME_UNKNOWN , tun_setup , queues , queues ) ; if ( ! dev ) return - ENOMEM ; <S2SV_StartBug> dev_net_set ( dev , net ) ; <S2SV_EndBug> dev -> rtnl_link_ops = & tun_link_ops ; dev -> ifindex = tfile -> ifindex ; dev -> sysfs_groups [ 0 ] = & tun_attr_group ; tun = netdev_priv ( dev ) ; tun -> dev = dev ; tun -> flags = flags ; tun -> txflt . count = 0 ; tun -> vnet_hdr_sz = sizeof ( struct virtio_net_hdr ) ; tun -> align = NET_SKB_PAD ; tun -> filter_attached = false ; tun -> sndbuf = tfile -> socket . sk -> sk_sndbuf ; tun -> rx_batched = 0 ; tun -> pcpu_stats = netdev_alloc_pcpu_stats ( struct tun_pcpu_stats ) ; if ( ! tun -> pcpu_stats ) { err = - ENOMEM ; goto err_free_dev ; } spin_lock_init ( & tun -> lock ) ; err = security_tun_dev_alloc_security ( & tun -> security ) ; if ( err < 0 ) goto err_free_stat ; tun_net_init ( dev ) ; tun_flow_init ( tun ) ; dev -> hw_features = NETIF_F_SG | NETIF_F_FRAGLIST | TUN_USER_FEATURES | NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_STAG_TX ; dev -> features = dev -> hw_features | NETIF_F_LLTX ; dev -> vlan_features = dev -> features & ~ ( NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_STAG_TX ) ; INIT_LIST_HEAD ( & tun -> disabled ) ; err = tun_attach ( tun , file , false ) ; if ( err < 0 ) goto err_free_flow ; err = register_netdevice ( tun -> dev ) ; if ( err < 0 ) goto err_detach ; } netif_carrier_on ( tun -> dev ) ; tun_debug ( KERN_INFO , tun , ""tun_set_iff\\n"" ) ; tun -> flags = ( tun -> flags & ~ TUN_FEATURES ) | ( ifr -> ifr_flags & TUN_FEATURES ) ; if ( netif_running ( tun -> dev ) ) netif_tx_wake_all_queues ( tun -> dev ) ; strcpy ( ifr -> ifr_name , tun -> dev -> name ) ; return 0 ; err_detach : tun_detach_all ( dev ) ; goto err_free_dev ; err_free_flow : tun_flow_uninit ( tun ) ; security_tun_dev_free_security ( tun -> security ) ; err_free_stat : free_percpu ( tun -> pcpu_stats ) ; err_free_dev : free_netdev ( dev ) ; return err ; }","<S2SV_ModStart> - ENOMEM ; err = dev_get_valid_name ( net , dev , name ) ; if ( err ) goto err_free_dev ;",torvalds@linux/0ad646c81b2182f7fa67ec0c8c825e0ee165696d,CVE-2018-7191,https://github.com/torvalds/linux/commit/0ad646c81b2182f7fa67ec0c8c825e0ee165696d,2019-05-17T05:29Z
CWE-264,"CWE-264 SYSCALL_DEFINE6 ( recvfrom , int , fd , void __user * , ubuf , size_t , size , unsigned int , flags , struct sockaddr __user * , addr , int __user * , addr_len ) { struct socket * sock ; struct iovec iov ; struct msghdr msg ; struct sockaddr_storage address ; int err , err2 ; int fput_needed ; if ( size > INT_MAX ) <S2SV_StartBug> size = INT_MAX ; <S2SV_EndBug> sock = sockfd_lookup_light ( fd , & err , & fput_needed ) ; if ( ! sock ) goto out ; msg . msg_control = NULL ; msg . msg_controllen = 0 ; iov . iov_len = size ; iov . iov_base = ubuf ; iov_iter_init ( & msg . msg_iter , READ , & iov , 1 , size ) ; msg . msg_name = addr ? ( struct sockaddr * ) & address : NULL ; msg . msg_namelen = 0 ; if ( sock -> file -> f_flags & O_NONBLOCK ) flags |= MSG_DONTWAIT ; err = sock_recvmsg ( sock , & msg , size , flags ) ; if ( err >= 0 && addr != NULL ) { err2 = move_addr_to_user ( & address , msg . msg_namelen , addr , addr_len ) ; if ( err2 < 0 ) err = err2 ; } fput_light ( sock -> file , fput_needed ) ; out : return err ; }","<S2SV_ModStart> size = INT_MAX ; if ( unlikely ( ! access_ok ( VERIFY_WRITE , ubuf , size ) ) ) return - EFAULT",torvalds@linux/4de930efc23b92ddf88ce91c405ee645fe6e27ea,CVE-2015-2686,https://github.com/torvalds/linux/commit/4de930efc23b92ddf88ce91c405ee645fe6e27ea,2016-05-02T10:59Z
CWE-125,"CWE-125 static void ubik_print ( netdissect_options * ndo , register const u_char * bp ) { int ubik_op ; int32_t temp ; ubik_op = EXTRACT_32BITS ( bp + sizeof ( struct rx_header ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>ubik<S2SV_blank>call<S2SV_blank>%s"" , tok2str ( ubik_req , ""op#%d"" , ubik_op ) ) ) ; bp += sizeof ( struct rx_header ) + 4 ; switch ( ubik_op ) { case 10000 : ND_TCHECK2 ( bp [ 0 ] , 4 ) ; temp = EXTRACT_32BITS ( bp ) ; bp += sizeof ( int32_t ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>syncsite<S2SV_blank>%s"" , temp ? ""yes"" : ""no"" ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>votestart"" ) ) ; DATEOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>dbversion"" ) ) ; UBIK_VERSIONOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>tid"" ) ) ; UBIK_VERSIONOUT ( ) ; break ; case 10003 : ND_PRINT ( ( ndo , ""<S2SV_blank>site"" ) ) ; UINTOUT ( ) ; break ; case 20000 : case 20001 : case 20007 : case 20008 : case 20010 : ND_PRINT ( ( ndo , ""<S2SV_blank>tid"" ) ) ; UBIK_VERSIONOUT ( ) ; break ; case 20002 : ND_PRINT ( ( ndo , ""<S2SV_blank>tid"" ) ) ; UBIK_VERSIONOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>file"" ) ) ; INTOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>pos"" ) ) ; INTOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>length"" ) ) ; INTOUT ( ) ; <S2SV_StartBug> temp = EXTRACT_32BITS ( bp ) ; <S2SV_EndBug> bp += sizeof ( int32_t ) ; tok2str ( ubik_lock_types , ""type<S2SV_blank>%d"" , temp ) ; break ; case 20003 : ND_PRINT ( ( ndo , ""<S2SV_blank>tid"" ) ) ; UBIK_VERSIONOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>file"" ) ) ; INTOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>pos"" ) ) ; INTOUT ( ) ; break ; case 20005 : ND_PRINT ( ( ndo , ""<S2SV_blank>file"" ) ) ; INTOUT ( ) ; break ; case 20006 : ND_PRINT ( ( ndo , ""<S2SV_blank>file"" ) ) ; INTOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>length"" ) ) ; INTOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>dbversion"" ) ) ; UBIK_VERSIONOUT ( ) ; break ; case 20009 : ND_PRINT ( ( ndo , ""<S2SV_blank>tid"" ) ) ; UBIK_VERSIONOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>file"" ) ) ; INTOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>length"" ) ) ; INTOUT ( ) ; break ; case 20012 : ND_PRINT ( ( ndo , ""<S2SV_blank>tid"" ) ) ; UBIK_VERSIONOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>oldversion"" ) ) ; UBIK_VERSIONOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>newversion"" ) ) ; UBIK_VERSIONOUT ( ) ; break ; default : ; } return ; trunc : ND_PRINT ( ( ndo , ""<S2SV_blank>[|ubik]"" ) ) ; }",<S2SV_ModStart> ( ) ; ND_TCHECK_32BITS ( bp ) ;,the-tcpdump-group@tcpdump/aa0858100096a3490edf93034a80e66a4d61aad5,CVE-2017-13049,https://github.com/the-tcpdump-group/tcpdump/commit/aa0858100096a3490edf93034a80e66a4d61aad5,2017-09-14T06:29Z
CWE-119,"CWE-119 static inline void schedule_debug ( struct task_struct * prev ) { # ifdef CONFIG_SCHED_STACK_END_CHECK <S2SV_StartBug> BUG_ON ( task_stack_end_corrupted ( prev ) ) ; <S2SV_EndBug> # endif if ( unlikely ( in_atomic_preempt_off ( ) ) ) { __schedule_bug ( prev ) ; preempt_count_set ( PREEMPT_DISABLED ) ; } rcu_sleep_check ( ) ; profile_hit ( SCHED_PROFILING , __builtin_return_address ( 0 ) ) ; schedstat_inc ( this_rq ( ) , sched_count ) ; }","<S2SV_ModStart> # ifdef CONFIG_SCHED_STACK_END_CHECK if <S2SV_ModEnd> ( task_stack_end_corrupted ( <S2SV_ModStart> ( prev ) ) panic ( ""corrupted<S2SV_blank>stack<S2SV_blank>end<S2SV_blank>detected<S2SV_blank>inside<S2SV_blank>scheduler\\n""",torvalds@linux/f5364c150aa645b3d7daa21b5c0b9feaa1c9cd6d,CVE-2016-1583,https://github.com/torvalds/linux/commit/f5364c150aa645b3d7daa21b5c0b9feaa1c9cd6d,2016-06-27T10:59Z
CWE-120,"CWE-000 boolean proc_wizkit_line ( buf ) char * buf ; { <S2SV_StartBug> struct obj * otmp = readobjnam ( buf , ( struct obj * ) 0 ) ; <S2SV_EndBug> if ( otmp ) { if ( otmp != & zeroobj ) wizkit_addinv ( otmp ) ; } else { config_error_add ( ""Bad<S2SV_blank>wizkit<S2SV_blank>item:<S2SV_blank>\\""%.60s\\"""" , buf ) ; return FALSE ; } return TRUE ; }",<S2SV_ModStart> struct obj * otmp ; if ( strlen ( buf ) >= BUFSZ ) buf [ BUFSZ - 1 ] = '\\0' ;,NetHack@NetHack/f4a840a48f4bcf11757b3d859e9d53cc9d5ef226,CVE-2019-19905,https://github.com/NetHack/NetHack/commit/f4a840a48f4bcf11757b3d859e9d53cc9d5ef226,2019-12-19T18:15Z
CWE-284,"CWE-284 static void uipc_check_interrupt_locked ( void ) { if ( SAFE_FD_ISSET ( uipc_main . signal_fds [ 0 ] , & uipc_main . read_set ) ) { char sig_recv = 0 ; <S2SV_StartBug> recv ( uipc_main . signal_fds [ 0 ] , & sig_recv , sizeof ( sig_recv ) , MSG_WAITALL ) ; <S2SV_EndBug> } }","<S2SV_ModStart> = 0 ; TEMP_FAILURE_RETRY ( <S2SV_ModStart> , MSG_WAITALL ) )",system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z
CWE-20,"CWE-20 error_t enc28j60SendPacket ( NetInterface * interface , const NetBuffer * buffer , size_t offset , NetTxAncillary * ancillary ) { size_t length ; length = netBufferGetLength ( buffer ) - offset ; if ( length > 1536 ) { osSetEvent ( & interface -> nicTxEvent ) ; return ERROR_INVALID_LENGTH ; } if ( ! interface -> linkState ) { osSetEvent ( & interface -> nicTxEvent ) ; return NO_ERROR ; } <S2SV_StartBug> enc28j60SetBit ( interface , ENC28J60_REG_ECON1 , ECON1_TXRST ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60ClearBit ( interface , ENC28J60_REG_ECON1 , ECON1_TXRST ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60ClearBit ( interface , ENC28J60_REG_EIR , EIR_TXIF | EIR_TXERIF ) ; <S2SV_EndBug> enc28j60WriteReg ( interface , ENC28J60_REG_ETXSTL , LSB ( ENC28J60_TX_BUFFER_START ) ) ; <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_ETXSTH , MSB ( ENC28J60_TX_BUFFER_START ) ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_EWRPTL , LSB ( ENC28J60_TX_BUFFER_START ) ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_EWRPTH , MSB ( ENC28J60_TX_BUFFER_START ) ) ; <S2SV_EndBug> enc28j60WriteBuffer ( interface , buffer , offset ) ; <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_ETXNDL , LSB ( ENC28J60_TX_BUFFER_START + length ) ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_ETXNDH , MSB ( ENC28J60_TX_BUFFER_START + length ) ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60SetBit ( interface , ENC28J60_REG_ECON1 , ECON1_TXRTS ) ; <S2SV_EndBug> return NO_ERROR ; }","<S2SV_ModStart> ( interface , ENC28J60_ECON1 , ENC28J60_ECON1_TXRST <S2SV_ModEnd> ) ; enc28j60ClearBit <S2SV_ModStart> ( interface , ENC28J60_ECON1 , ENC28J60_ECON1_TXRST <S2SV_ModEnd> ) ; enc28j60ClearBit <S2SV_ModStart> ( interface , ENC28J60_EIR , ENC28J60_EIR_TXIF | ENC28J60_EIR_TXERIF ) ; enc28j60WriteReg ( interface , ENC28J60_ETXSTL <S2SV_ModEnd> , LSB ( <S2SV_ModStart> ( interface , ENC28J60_ETXSTH <S2SV_ModEnd> , MSB ( <S2SV_ModStart> ( interface , ENC28J60_EWRPTL <S2SV_ModEnd> , LSB ( <S2SV_ModStart> ( interface , ENC28J60_EWRPTH <S2SV_ModEnd> , MSB ( <S2SV_ModStart> ( interface , ENC28J60_ETXNDL <S2SV_ModEnd> , LSB ( <S2SV_ModStart> ( interface , ENC28J60_ETXNDH <S2SV_ModEnd> , MSB ( <S2SV_ModStart> ( interface , ENC28J60_ECON1 , ENC28J60_ECON1_TXRTS <S2SV_ModEnd> ) ; return",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z
CWE-416,"CWE-416 static int xfrm_user_rcv_msg ( struct sk_buff * skb , struct nlmsghdr * nlh , struct netlink_ext_ack * extack ) { struct net * net = sock_net ( skb -> sk ) ; struct nlattr * attrs [ XFRMA_MAX + 1 ] ; const struct xfrm_link * link ; int type , err ; # ifdef CONFIG_COMPAT if ( in_compat_syscall ( ) ) return - EOPNOTSUPP ; # endif type = nlh -> nlmsg_type ; if ( type > XFRM_MSG_MAX ) return - EINVAL ; type -= XFRM_MSG_BASE ; link = & xfrm_dispatch [ type ] ; if ( ! netlink_net_capable ( skb , CAP_NET_ADMIN ) ) return - EPERM ; if ( ( type == ( XFRM_MSG_GETSA - XFRM_MSG_BASE ) || type == ( XFRM_MSG_GETPOLICY - XFRM_MSG_BASE ) ) && ( nlh -> nlmsg_flags & NLM_F_DUMP ) ) { if ( link -> dump == NULL ) return - EINVAL ; { struct netlink_dump_control c = { <S2SV_StartBug> . dump = link -> dump , <S2SV_EndBug> . done = link -> done , } ; return netlink_dump_start ( net -> xfrm . nlsk , skb , nlh , & c ) ; } } err = nlmsg_parse ( nlh , xfrm_msg_min [ type ] , attrs , link -> nla_max ? : XFRMA_MAX , link -> nla_pol ? : xfrma_policy , extack ) ; if ( err < 0 ) return err ; if ( link -> doit == NULL ) return - EINVAL ; return link -> doit ( skb , nlh , attrs ) ; }","<S2SV_ModStart> = { . start = link -> start , .",torvalds@linux/1137b5e2529a8f5ca8ee709288ecba3e68044df2,CVE-2017-16939,https://github.com/torvalds/linux/commit/1137b5e2529a8f5ca8ee709288ecba3e68044df2,2017-11-24T10:29Z
CWE-20,"CWE-20 static int get_cox ( Jpeg2000DecoderContext * s , Jpeg2000CodingStyle * c ) { uint8_t byte ; if ( bytestream2_get_bytes_left ( & s -> g ) < 5 ) return AVERROR_INVALIDDATA ; c -> nreslevels = bytestream2_get_byteu ( & s -> g ) + 1 ; if ( c -> nreslevels >= JPEG2000_MAX_RESLEVELS ) { av_log ( s -> avctx , AV_LOG_ERROR , ""nreslevels<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>invalid\\n"" , c -> nreslevels ) ; return AVERROR_INVALIDDATA ; } <S2SV_StartBug> if ( c -> nreslevels < s -> reduction_factor ) <S2SV_EndBug> <S2SV_StartBug> c -> nreslevels2decode = 1 ; <S2SV_EndBug> else c -> nreslevels2decode = c -> nreslevels - s -> reduction_factor ; c -> log2_cblk_width = ( bytestream2_get_byteu ( & s -> g ) & 15 ) + 2 ; c -> log2_cblk_height = ( bytestream2_get_byteu ( & s -> g ) & 15 ) + 2 ; if ( c -> log2_cblk_width > 10 || c -> log2_cblk_height > 10 || c -> log2_cblk_width + c -> log2_cblk_height > 12 ) { av_log ( s -> avctx , AV_LOG_ERROR , ""cblk<S2SV_blank>size<S2SV_blank>invalid\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( c -> log2_cblk_width > 6 || c -> log2_cblk_height > 6 ) { avpriv_request_sample ( s -> avctx , ""cblk<S2SV_blank>size<S2SV_blank>><S2SV_blank>64"" ) ; return AVERROR_PATCHWELCOME ; } c -> cblk_style = bytestream2_get_byteu ( & s -> g ) ; if ( c -> cblk_style != 0 ) { av_log ( s -> avctx , AV_LOG_WARNING , ""extra<S2SV_blank>cblk<S2SV_blank>styles<S2SV_blank>%X\\n"" , c -> cblk_style ) ; } c -> transform = bytestream2_get_byteu ( & s -> g ) ; if ( ( s -> avctx -> flags & CODEC_FLAG_BITEXACT ) && ( c -> transform == FF_DWT97 ) ) c -> transform = FF_DWT97_INT ; if ( c -> csty & JPEG2000_CSTY_PREC ) { int i ; for ( i = 0 ; i < c -> nreslevels ; i ++ ) { byte = bytestream2_get_byte ( & s -> g ) ; c -> log2_prec_widths [ i ] = byte & 0x0F ; c -> log2_prec_heights [ i ] = ( byte >> 4 ) & 0x0F ; } } else { memset ( c -> log2_prec_widths , 15 , sizeof ( c -> log2_prec_widths ) ) ; memset ( c -> log2_prec_heights , 15 , sizeof ( c -> log2_prec_heights ) ) ; } return 0 ; }","<S2SV_ModStart> c -> nreslevels <= <S2SV_ModEnd> s -> reduction_factor <S2SV_ModStart> -> reduction_factor ) { av_log ( s -> avctx , AV_LOG_ERROR , ""reduction_factor<S2SV_blank>too<S2SV_blank>large<S2SV_blank>for<S2SV_blank>this<S2SV_blank>bitstream,<S2SV_blank>max<S2SV_blank>is<S2SV_blank>%d\\n"" , c -> nreslevels - 1 ) ; s -> reduction_factor = c -> nreslevels - 1 ; return AVERROR ( EINVAL ) ; } <S2SV_ModEnd> c -> nreslevels2decode",FFmpeg@FFmpeg/a1b9004b768bef606ee98d417bceb9392ceb788d,CVE-2013-7019,https://github.com/FFmpeg/FFmpeg/commit/a1b9004b768bef606ee98d417bceb9392ceb788d,2013-12-09T16:36Z
CWE-119,"CWE-119 <S2SV_StartBug> static vpx_codec_err_t vp8e_get_reference ( vpx_codec_alg_priv_t * ctx , <S2SV_EndBug> int ctr_id , va_list args ) { vpx_ref_frame_t * data = va_arg ( args , vpx_ref_frame_t * ) ; if ( data ) { vpx_ref_frame_t * frame = ( vpx_ref_frame_t * ) data ; YV12_BUFFER_CONFIG sd ; image2yuvconfig ( & frame -> img , & sd ) ; vp8_get_reference ( ctx -> cpi , frame -> frame_type , & sd ) ; return VPX_CODEC_OK ; } else return VPX_CODEC_INVALID_PARAM ; }","<S2SV_ModStart> vpx_codec_alg_priv_t * ctx <S2SV_ModEnd> , va_list args",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-20,"CWE-20 error_t ksz8851SendPacket ( NetInterface * interface , const NetBuffer * buffer , size_t offset , NetTxAncillary * ancillary ) { size_t n ; size_t length ; Ksz8851TxHeader header ; Ksz8851Context * context ; context = ( Ksz8851Context * ) interface -> nicContext ; length = netBufferGetLength ( buffer ) - offset ; if ( length > ETH_MAX_FRAME_SIZE ) { osSetEvent ( & interface -> nicTxEvent ) ; return ERROR_INVALID_LENGTH ; } <S2SV_StartBug> n = ksz8851ReadReg ( interface , KSZ8851_REG_TXMIR ) & TXMIR_TXMA_MASK ; <S2SV_EndBug> if ( n < ( length + 8 ) ) { return ERROR_FAILURE ; } netBufferRead ( context -> txBuffer , buffer , offset , length ) ; <S2SV_StartBug> header . controlWord = htole16 ( TX_CTRL_TXIC | ( context -> frameId ++ & TX_CTRL_TXFID ) ) ; <S2SV_EndBug> header . byteCount = htole16 ( length ) ; <S2SV_StartBug> ksz8851SetBit ( interface , KSZ8851_REG_RXQCR , RXQCR_SDA ) ; <S2SV_EndBug> ksz8851WriteFifo ( interface , ( uint8_t * ) & header , sizeof ( Ksz8851TxHeader ) ) ; ksz8851WriteFifo ( interface , context -> txBuffer , length ) ; <S2SV_StartBug> ksz8851ClearBit ( interface , KSZ8851_REG_RXQCR , RXQCR_SDA ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851SetBit ( interface , KSZ8851_REG_TXQCR , TXQCR_METFE ) ; <S2SV_EndBug> <S2SV_StartBug> n = ksz8851ReadReg ( interface , KSZ8851_REG_TXMIR ) & TXMIR_TXMA_MASK ; <S2SV_EndBug> if ( n >= ( ETH_MAX_FRAME_SIZE + 8 ) ) { osSetEvent ( & interface -> nicTxEvent ) ; } return NO_ERROR ; }","<S2SV_ModStart> ( interface , KSZ8851_TXMIR ) & KSZ8851_TXMIR_TXMA <S2SV_ModEnd> ; if ( <S2SV_ModStart> = htole16 ( KSZ8851_TX_CTRL_TXIC <S2SV_ModEnd> | ( context <S2SV_ModStart> frameId ++ & KSZ8851_TX_CTRL_TXFID <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , KSZ8851_RXQCR , KSZ8851_RXQCR_SDA <S2SV_ModEnd> ) ; ksz8851WriteFifo <S2SV_ModStart> ( interface , KSZ8851_RXQCR , KSZ8851_RXQCR_SDA <S2SV_ModEnd> ) ; ksz8851SetBit <S2SV_ModStart> ( interface , KSZ8851_TXQCR , KSZ8851_TXQCR_METFE <S2SV_ModEnd> ) ; n <S2SV_ModStart> ( interface , KSZ8851_TXMIR ) & KSZ8851_TXMIR_TXMA <S2SV_ModEnd> ; if (",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z
CWE-400,"CWE-000 int fpm_stdio_init_child ( struct fpm_worker_pool_s * wp ) { # ifdef HAVE_SYSLOG_H if ( fpm_globals . error_log_fd == ZLOG_SYSLOG ) { closelog ( ) ; } else # endif if ( fpm_globals . error_log_fd > 0 ) { close ( fpm_globals . error_log_fd ) ; } fpm_globals . error_log_fd = - 1 ; zlog_set_fd ( - 1 ) ; <S2SV_StartBug> if ( wp -> listening_socket != STDIN_FILENO ) { <S2SV_EndBug> if ( 0 > dup2 ( wp -> listening_socket , STDIN_FILENO ) ) { zlog ( ZLOG_SYSERROR , ""failed<S2SV_blank>to<S2SV_blank>init<S2SV_blank>child<S2SV_blank>stdio:<S2SV_blank>dup2()"" ) ; return - 1 ; } } return 0 ; }",<S2SV_ModStart> 1 ) ; <S2SV_ModEnd> return 0 ;,php@php-src/69dee5c732fe982c82edb17d0dbc3e79a47748d8,CVE-2015-9253,https://github.com/php/php-src/commit/69dee5c732fe982c82edb17d0dbc3e79a47748d8,2018-02-19T19:29Z
CWE-476,"CWE-476 static bool CopyKeyAliasesToKeymap ( struct xkb_keymap * keymap , KeyNamesInfo * info ) { AliasInfo * alias ; unsigned i , num_key_aliases ; struct xkb_key_alias * key_aliases ; num_key_aliases = 0 ; darray_foreach ( alias , info -> aliases ) { if ( ! XkbKeyByName ( keymap , alias -> real , false ) ) { log_vrb ( info -> ctx , 5 , ""Attempt<S2SV_blank>to<S2SV_blank>alias<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>non-existent<S2SV_blank>key<S2SV_blank>%s;<S2SV_blank>Ignored\\n"" , KeyNameText ( info -> ctx , alias -> alias ) , KeyNameText ( info -> ctx , alias -> real ) ) ; alias -> real = XKB_ATOM_NONE ; continue ; } if ( XkbKeyByName ( keymap , alias -> alias , false ) ) { log_vrb ( info -> ctx , 5 , ""Attempt<S2SV_blank>to<S2SV_blank>create<S2SV_blank>alias<S2SV_blank>with<S2SV_blank>the<S2SV_blank>name<S2SV_blank>of<S2SV_blank>a<S2SV_blank>real<S2SV_blank>key;<S2SV_blank>"" ""Alias<S2SV_blank>\\""%s<S2SV_blank>=<S2SV_blank>%s\\""<S2SV_blank>ignored\\n"" , KeyNameText ( info -> ctx , alias -> alias ) , KeyNameText ( info -> ctx , alias -> real ) ) ; alias -> real = XKB_ATOM_NONE ; continue ; } num_key_aliases ++ ; } key_aliases = NULL ; if ( num_key_aliases > 0 ) { key_aliases = calloc ( num_key_aliases , sizeof ( * key_aliases ) ) ; if ( ! key_aliases ) return false ; <S2SV_StartBug> } <S2SV_EndBug> i = 0 ; darray_foreach ( alias , info -> aliases ) { if ( alias -> real != XKB_ATOM_NONE ) { key_aliases [ i ] . alias = alias -> alias ; key_aliases [ i ] . real = alias -> real ; i ++ ; } } <S2SV_StartBug> keymap -> num_key_aliases = num_key_aliases ; <S2SV_EndBug> keymap -> key_aliases = key_aliases ; return true ; }",<S2SV_ModStart> return false ; <S2SV_ModEnd> i = 0 <S2SV_ModStart> ; } } },xkbcommon@libxkbcommon/badb428e63387140720f22486b3acbd3d738859f,CVE-2018-15858,https://github.com/xkbcommon/libxkbcommon/commit/badb428e63387140720f22486b3acbd3d738859f,2018-08-25T21:29Z
,"CWE-000 static void setup_token_decoder ( VP8D_COMP * pbi , const unsigned char * token_part_sizes ) { vp8_reader * bool_decoder = & pbi -> mbc [ 0 ] ; unsigned int partition_idx ; unsigned int fragment_idx ; unsigned int num_token_partitions ; const unsigned char * first_fragment_end = pbi -> fragments . ptrs [ 0 ] + pbi -> fragments . sizes [ 0 ] ; TOKEN_PARTITION multi_token_partition = ( TOKEN_PARTITION ) vp8_read_literal ( & pbi -> mbc [ 8 ] , 2 ) ; if ( ! vp8dx_bool_error ( & pbi -> mbc [ 8 ] ) ) pbi -> common . multi_token_partition = multi_token_partition ; num_token_partitions = 1 << pbi -> common . multi_token_partition ; for ( fragment_idx = 0 ; fragment_idx < pbi -> fragments . count ; ++ fragment_idx ) { unsigned int fragment_size = pbi -> fragments . sizes [ fragment_idx ] ; const unsigned char * fragment_end = pbi -> fragments . ptrs [ fragment_idx ] + fragment_size ; if ( fragment_idx == 0 ) { ptrdiff_t ext_first_part_size = token_part_sizes - pbi -> fragments . ptrs [ 0 ] + 3 * ( num_token_partitions - 1 ) ; fragment_size -= ( unsigned int ) ext_first_part_size ; if ( fragment_size > 0 ) { pbi -> fragments . sizes [ 0 ] = ( unsigned int ) ext_first_part_size ; fragment_idx ++ ; pbi -> fragments . ptrs [ fragment_idx ] = pbi -> fragments . ptrs [ 0 ] + pbi -> fragments . sizes [ 0 ] ; } } while ( fragment_size > 0 ) { ptrdiff_t partition_size = read_available_partition_size ( pbi , token_part_sizes , pbi -> fragments . ptrs [ fragment_idx ] , first_fragment_end , fragment_end , fragment_idx - 1 , num_token_partitions ) ; pbi -> fragments . sizes [ fragment_idx ] = ( unsigned int ) partition_size ; fragment_size -= ( unsigned int ) partition_size ; assert ( fragment_idx <= num_token_partitions ) ; if ( fragment_size > 0 ) { fragment_idx ++ ; pbi -> fragments . ptrs [ fragment_idx ] = pbi -> fragments . ptrs [ fragment_idx - 1 ] + partition_size ; } } } pbi -> fragments . count = num_token_partitions + 1 ; for ( partition_idx = 1 ; partition_idx < pbi -> fragments . count ; ++ partition_idx ) { if ( vp8dx_start_decode ( bool_decoder , pbi -> fragments . ptrs [ partition_idx ] , pbi -> fragments . sizes [ partition_idx ] , pbi -> decrypt_cb , pbi -> decrypt_state ) ) vpx_internal_error ( & pbi -> common . error , VPX_CODEC_MEM_ERROR , ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>bool<S2SV_blank>decoder<S2SV_blank>%d"" , partition_idx ) ; bool_decoder ++ ; } # if CONFIG_MULTITHREAD <S2SV_StartBug> if ( pbi -> decoding_thread_count > num_token_partitions - 1 ) <S2SV_EndBug> <S2SV_StartBug> pbi -> decoding_thread_count = num_token_partitions - 1 ; <S2SV_EndBug> # endif }",<S2SV_ModStart> - 1 ) { <S2SV_ModStart> - 1 ; } if ( pbi -> decoding_thread_count > pbi -> common . mb_rows - 1 ) { pbi -> decoding_thread_count = pbi -> common . mb_rows - 1 ; },external@libvpx/6886e8e0a9db2dbad723dc37a548233e004b33bc,CVE-2017-0393,https://android.googlesource.com/platform/external/libvpx/+/6886e8e0a9db2dbad723dc37a548233e004b33bc,2017-01-12T20:59Z
,"CWE-000 static void on_read ( h2o_socket_t * sock , int status ) { h2o_http2_conn_t * conn = sock -> data ; if ( status != 0 ) { h2o_socket_read_stop ( conn -> sock ) ; close_connection ( conn ) ; return ; } update_idle_timeout ( conn ) ; <S2SV_StartBug> parse_input ( conn ) ; <S2SV_EndBug> if ( h2o_timeout_is_linked ( & conn -> _write . timeout_entry ) ) { h2o_timeout_unlink ( & conn -> _write . timeout_entry ) ; do_emit_writereq ( conn ) ; } }",<S2SV_ModStart> conn ) ; if ( <S2SV_ModStart> ( conn ) != 0 ) return,h2o@h2o/1c0808d580da09fdec5a9a74ff09e103ea058dd4,CVE-2016-4817,https://github.com/h2o/h2o/commit/1c0808d580da09fdec5a9a74ff09e103ea058dd4,2016-06-19T01:59Z
CWE-295,"CWE-000 int options_cmdline ( char * arg1 , char * arg2 ) { char * name ; CONF_TYPE type ; # ifdef USE_WIN32 ( void ) arg2 ; # endif if ( ! arg1 ) { name = # ifdef CONFDIR CONFDIR # ifdef USE_WIN32 ""\\\\"" # else ""/"" # endif # endif ""stunnel.conf"" ; type = CONF_FILE ; } else if ( ! strcasecmp ( arg1 , ""-help"" ) ) { <S2SV_StartBug> parse_global_option ( CMD_PRINT_HELP , NULL , NULL ) ; <S2SV_EndBug> parse_service_option ( CMD_PRINT_HELP , NULL , NULL , NULL ) ; log_flush ( LOG_MODE_INFO ) ; return 2 ; } else if ( ! strcasecmp ( arg1 , ""-version"" ) ) { <S2SV_StartBug> parse_global_option ( CMD_PRINT_DEFAULTS , NULL , NULL ) ; <S2SV_EndBug> parse_service_option ( CMD_PRINT_DEFAULTS , NULL , NULL , NULL ) ; log_flush ( LOG_MODE_INFO ) ; return 2 ; } else if ( ! strcasecmp ( arg1 , ""-sockets"" ) ) { socket_options_print ( ) ; log_flush ( LOG_MODE_INFO ) ; return 2 ; } else if ( ! strcasecmp ( arg1 , ""-options"" ) ) { print_ssl_options ( ) ; log_flush ( LOG_MODE_INFO ) ; return 2 ; } else # ifndef USE_WIN32 if ( ! strcasecmp ( arg1 , ""-fd"" ) ) { if ( ! arg2 ) { s_log ( LOG_ERR , ""No<S2SV_blank>file<S2SV_blank>descriptor<S2SV_blank>specified"" ) ; print_syntax ( ) ; return 1 ; } name = arg2 ; type = CONF_FD ; } else # endif { name = arg1 ; type = CONF_FILE ; } if ( type == CONF_FILE ) { # ifdef HAVE_REALPATH char * real_path = NULL ; # ifdef MAXPATHLEN real_path = malloc ( MAXPATHLEN ) ; # endif real_path = realpath ( name , real_path ) ; if ( ! real_path ) { s_log ( LOG_ERR , ""Invalid<S2SV_blank>configuration<S2SV_blank>file<S2SV_blank>name<S2SV_blank>\\""%s\\"""" , name ) ; ioerror ( ""realpath"" ) ; return 1 ; } configuration_file = str_dup ( real_path ) ; free ( real_path ) ; # else configuration_file = str_dup ( name ) ; # endif # ifndef USE_WIN32 } else if ( type == CONF_FD ) { configuration_file = str_dup ( name ) ; # endif } return options_parse ( type ) ; }","<S2SV_ModStart> NULL , NULL , NULL <S2SV_ModStart> parse_global_option ( CMD_PRINT_DEFAULTS , NULL",mtrojnar@stunnel/ebad9ddc4efb2635f37174c9d800d06206f1edf9,CVE-2021-20230,https://github.com/mtrojnar/stunnel/commit/ebad9ddc4efb2635f37174c9d800d06206f1edf9,2021-02-23T17:15Z
CWE-125,"CWE-125 SECURITY_STATUS ntlm_read_NegotiateMessage ( NTLM_CONTEXT * context , PSecBuffer buffer ) { wStream * s ; size_t length ; NTLM_NEGOTIATE_MESSAGE * message ; message = & context -> NEGOTIATE_MESSAGE ; ZeroMemory ( message , sizeof ( NTLM_NEGOTIATE_MESSAGE ) ) ; s = Stream_New ( ( BYTE * ) buffer -> pvBuffer , buffer -> cbBuffer ) ; if ( ! s ) return SEC_E_INTERNAL_ERROR ; if ( ntlm_read_message_header ( s , ( NTLM_MESSAGE_HEADER * ) message ) < 0 ) { Stream_Free ( s , FALSE ) ; return SEC_E_INVALID_TOKEN ; } if ( message -> MessageType != MESSAGE_TYPE_NEGOTIATE ) { Stream_Free ( s , FALSE ) ; return SEC_E_INVALID_TOKEN ; } <S2SV_StartBug> Stream_Read_UINT32 ( s , message -> NegotiateFlags ) ; <S2SV_EndBug> if ( ! ( ( message -> NegotiateFlags & NTLMSSP_REQUEST_TARGET ) && ( message -> NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM ) && ( message -> NegotiateFlags & NTLMSSP_NEGOTIATE_UNICODE ) ) ) { Stream_Free ( s , FALSE ) ; return SEC_E_INVALID_TOKEN ; } context -> NegotiateFlags = message -> NegotiateFlags ; if ( ntlm_read_message_fields ( s , & ( message -> DomainName ) ) < 0 ) { Stream_Free ( s , FALSE ) ; return SEC_E_INVALID_TOKEN ; } if ( ntlm_read_message_fields ( s , & ( message -> Workstation ) ) < 0 ) { Stream_Free ( s , FALSE ) ; return SEC_E_INVALID_TOKEN ; } if ( message -> NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION ) { if ( ntlm_read_version_info ( s , & ( message -> Version ) ) < 0 ) { Stream_Free ( s , FALSE ) ; return SEC_E_INVALID_TOKEN ; } } length = Stream_GetPosition ( s ) ; buffer -> cbBuffer = length ; if ( ! sspi_SecBufferAlloc ( & context -> NegotiateMessage , length ) ) { Stream_Free ( s , FALSE ) ; return SEC_E_INTERNAL_ERROR ; } CopyMemory ( context -> NegotiateMessage . pvBuffer , buffer -> pvBuffer , buffer -> cbBuffer ) ; context -> NegotiateMessage . BufferType = buffer -> BufferType ; # ifdef WITH_DEBUG_NTLM WLog_DBG ( TAG , ""NEGOTIATE_MESSAGE<S2SV_blank>(length<S2SV_blank>=<S2SV_blank>%"" PRIu32 "")"" , context -> NegotiateMessage . cbBuffer ) ; winpr_HexDump ( TAG , WLOG_DEBUG , context -> NegotiateMessage . pvBuffer , context -> NegotiateMessage . cbBuffer ) ; ntlm_print_negotiate_flags ( message -> NegotiateFlags ) ; if ( message -> NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION ) ntlm_print_version_info ( & ( message -> Version ) ) ; # endif context -> state = NTLM_STATE_CHALLENGE ; Stream_Free ( s , FALSE ) ; return SEC_I_CONTINUE_NEEDED ; }","<S2SV_ModStart> SEC_E_INVALID_TOKEN ; } if ( Stream_GetRemainingLength ( s ) < 4 ) { Stream_Free ( s , FALSE ) ; return SEC_E_INVALID_TOKEN ; }",FreeRDP@FreeRDP/8fa38359634a9910b91719818ab02f23c320dbae,CVE-2020-11088,https://github.com/FreeRDP/FreeRDP/commit/8fa38359634a9910b91719818ab02f23c320dbae,2020-05-29T20:15Z
CWE-125,"CWE-125 BOOL license_read_new_or_upgrade_license_packet ( rdpLicense * license , wStream * s ) { UINT32 os_major ; UINT32 os_minor ; UINT32 cbScope , cbCompanyName , cbProductId , cbLicenseInfo ; wStream * licenseStream = NULL ; BOOL ret = FALSE ; BYTE computedMac [ 16 ] ; LICENSE_BLOB * calBlob ; DEBUG_LICENSE ( ""Receiving<S2SV_blank>Server<S2SV_blank>New/Upgrade<S2SV_blank>License<S2SV_blank>Packet"" ) ; calBlob = license_new_binary_blob ( BB_DATA_BLOB ) ; if ( ! calBlob ) return FALSE ; if ( ! license_read_encrypted_blob ( license , s , calBlob ) ) goto out_free_blob ; if ( Stream_GetRemainingLength ( s ) < 16 ) goto out_free_blob ; if ( ! security_mac_data ( license -> MacSaltKey , calBlob -> data , calBlob -> length , computedMac ) ) goto out_free_blob ; if ( memcmp ( computedMac , Stream_Pointer ( s ) , sizeof ( computedMac ) ) != 0 ) { WLog_ERR ( TAG , ""new<S2SV_blank>or<S2SV_blank>upgrade<S2SV_blank>license<S2SV_blank>MAC<S2SV_blank>mismatch"" ) ; goto out_free_blob ; } if ( ! Stream_SafeSeek ( s , 16 ) ) goto out_free_blob ; licenseStream = Stream_New ( calBlob -> data , calBlob -> length ) ; if ( ! licenseStream ) goto out_free_blob ; <S2SV_StartBug> Stream_Read_UINT16 ( licenseStream , os_minor ) ; <S2SV_EndBug> Stream_Read_UINT16 ( licenseStream , os_major ) ; Stream_Read_UINT32 ( licenseStream , cbScope ) ; if ( Stream_GetRemainingLength ( licenseStream ) < cbScope ) goto out_free_stream ; # ifdef WITH_DEBUG_LICENSE WLog_DBG ( TAG , ""Scope:"" ) ; winpr_HexDump ( TAG , WLOG_DEBUG , Stream_Pointer ( licenseStream ) , cbScope ) ; # endif Stream_Seek ( licenseStream , cbScope ) ; <S2SV_StartBug> Stream_Read_UINT32 ( licenseStream , cbCompanyName ) ; <S2SV_EndBug> if ( Stream_GetRemainingLength ( licenseStream ) < cbCompanyName ) goto out_free_stream ; # ifdef WITH_DEBUG_LICENSE WLog_DBG ( TAG , ""Company<S2SV_blank>name:"" ) ; winpr_HexDump ( TAG , WLOG_DEBUG , Stream_Pointer ( licenseStream ) , cbCompanyName ) ; # endif Stream_Seek ( licenseStream , cbCompanyName ) ; <S2SV_StartBug> Stream_Read_UINT32 ( licenseStream , cbProductId ) ; <S2SV_EndBug> if ( Stream_GetRemainingLength ( licenseStream ) < cbProductId ) goto out_free_stream ; # ifdef WITH_DEBUG_LICENSE WLog_DBG ( TAG , ""Product<S2SV_blank>id:"" ) ; winpr_HexDump ( TAG , WLOG_DEBUG , Stream_Pointer ( licenseStream ) , cbProductId ) ; # endif Stream_Seek ( licenseStream , cbProductId ) ; <S2SV_StartBug> Stream_Read_UINT32 ( licenseStream , cbLicenseInfo ) ; <S2SV_EndBug> if ( Stream_GetRemainingLength ( licenseStream ) < cbLicenseInfo ) goto out_free_stream ; license -> state = LICENSE_STATE_COMPLETED ; ret = TRUE ; if ( ! license -> rdp -> settings -> OldLicenseBehaviour ) ret = saveCal ( license -> rdp -> settings , Stream_Pointer ( licenseStream ) , cbLicenseInfo , license -> rdp -> settings -> ClientHostname ) ; out_free_stream : Stream_Free ( licenseStream , FALSE ) ; out_free_blob : license_free_binary_blob ( calBlob ) ; return ret ; }",<S2SV_ModStart> goto out_free_blob ; if ( Stream_GetRemainingLength ( licenseStream ) < 8 ) goto out_free_stream ; <S2SV_ModStart> cbScope ) ; if ( Stream_GetRemainingLength ( licenseStream ) < 4 ) goto out_free_stream ; <S2SV_ModStart> cbCompanyName ) ; if ( Stream_GetRemainingLength ( licenseStream ) < 4 ) goto out_free_stream ; <S2SV_ModStart> cbProductId ) ; if ( Stream_GetRemainingLength ( licenseStream ) < 4 ) goto out_free_stream ;,FreeRDP@FreeRDP/6ade7b4cbfd71c54b3d724e8f2d6ac76a58e879a,CVE-2020-11099,https://github.com/FreeRDP/FreeRDP/commit/6ade7b4cbfd71c54b3d724e8f2d6ac76a58e879a,2020-06-22T22:15Z
,"CWE-000 void sctp_assoc_update ( struct sctp_association * asoc , struct sctp_association * new ) { struct sctp_transport * trans ; struct list_head * pos , * temp ; asoc -> c = new -> c ; asoc -> peer . rwnd = new -> peer . rwnd ; asoc -> peer . sack_needed = new -> peer . sack_needed ; <S2SV_StartBug> asoc -> peer . i = new -> peer . i ; <S2SV_EndBug> sctp_tsnmap_init ( & asoc -> peer . tsn_map , SCTP_TSN_MAP_INITIAL , asoc -> peer . i . initial_tsn , GFP_ATOMIC ) ; list_for_each_safe ( pos , temp , & asoc -> peer . transport_addr_list ) { trans = list_entry ( pos , struct sctp_transport , transports ) ; if ( ! sctp_assoc_lookup_paddr ( new , & trans -> ipaddr ) ) { sctp_assoc_rm_peer ( asoc , trans ) ; continue ; } if ( asoc -> state >= SCTP_STATE_ESTABLISHED ) sctp_transport_reset ( trans ) ; } if ( asoc -> state >= SCTP_STATE_ESTABLISHED ) { asoc -> next_tsn = new -> next_tsn ; asoc -> ctsn_ack_point = new -> ctsn_ack_point ; asoc -> adv_peer_ack_point = new -> adv_peer_ack_point ; sctp_ssnmap_clear ( asoc -> ssnmap ) ; sctp_ulpq_flush ( & asoc -> ulpq ) ; asoc -> overall_error_count = 0 ; } else { list_for_each_entry ( trans , & new -> peer . transport_addr_list , transports ) { if ( ! sctp_assoc_lookup_paddr ( asoc , & trans -> ipaddr ) ) sctp_assoc_add_peer ( asoc , & trans -> ipaddr , GFP_ATOMIC , trans -> state ) ; } asoc -> ctsn_ack_point = asoc -> next_tsn - 1 ; asoc -> adv_peer_ack_point = asoc -> ctsn_ack_point ; if ( ! asoc -> ssnmap ) { asoc -> ssnmap = new -> ssnmap ; new -> ssnmap = NULL ; } if ( ! asoc -> assoc_id ) { sctp_assoc_set_id ( asoc , GFP_ATOMIC ) ; } } kfree ( asoc -> peer . peer_random ) ; asoc -> peer . peer_random = new -> peer . peer_random ; new -> peer . peer_random = NULL ; kfree ( asoc -> peer . peer_chunks ) ; asoc -> peer . peer_chunks = new -> peer . peer_chunks ; new -> peer . peer_chunks = NULL ; kfree ( asoc -> peer . peer_hmacs ) ; asoc -> peer . peer_hmacs = new -> peer . peer_hmacs ; new -> peer . peer_hmacs = NULL ; sctp_auth_key_put ( asoc -> asoc_shared_key ) ; sctp_auth_asoc_init_active_key ( asoc , GFP_ATOMIC ) ; }",<S2SV_ModStart> -> peer . auth_capable = new -> peer . auth_capable ; asoc -> peer .,torvalds@linux/1be9a950c646c9092fb3618197f7b6bfb50e82aa,CVE-2014-5077,https://github.com/torvalds/linux/commit/1be9a950c646c9092fb3618197f7b6bfb50e82aa,2014-08-01T11:13Z
CWE-125,"CWE-125 static int handle_keywordonly_args ( struct compiling * c , const node * n , int start , asdl_seq * kwonlyargs , asdl_seq * kwdefaults ) { PyObject * argname ; node * ch ; expr_ty expression , annotation ; arg_ty arg = NULL ; int i = start ; int j = 0 ; if ( kwonlyargs == NULL ) { ast_error ( c , CHILD ( n , start ) , ""named<S2SV_blank>arguments<S2SV_blank>must<S2SV_blank>follow<S2SV_blank>bare<S2SV_blank>*"" ) ; return - 1 ; } assert ( kwdefaults != NULL ) ; while ( i < NCH ( n ) ) { ch = CHILD ( n , i ) ; switch ( TYPE ( ch ) ) { case vfpdef : case tfpdef : if ( i + 1 < NCH ( n ) && TYPE ( CHILD ( n , i + 1 ) ) == EQUAL ) { expression = ast_for_expr ( c , CHILD ( n , i + 2 ) ) ; if ( ! expression ) goto error ; asdl_seq_SET ( kwdefaults , j , expression ) ; i += 2 ; } else { asdl_seq_SET ( kwdefaults , j , NULL ) ; } if ( NCH ( ch ) == 3 ) { annotation = ast_for_expr ( c , CHILD ( ch , 2 ) ) ; if ( ! annotation ) goto error ; } else { annotation = NULL ; } ch = CHILD ( ch , 0 ) ; argname = NEW_IDENTIFIER ( ch ) ; if ( ! argname ) goto error ; if ( forbidden_name ( c , argname , ch , 0 ) ) goto error ; arg = arg ( argname , annotation , NULL , LINENO ( ch ) , ch -> n_col_offset , ch -> n_end_lineno , ch -> n_end_col_offset , c -> c_arena ) ; if ( ! arg ) goto error ; asdl_seq_SET ( kwonlyargs , j ++ , arg ) ; i += 1 ; <S2SV_StartBug> if ( TYPE ( CHILD ( n , i ) ) == COMMA ) <S2SV_EndBug> i += 1 ; break ; case TYPE_COMMENT : arg -> type_comment = NEW_TYPE_COMMENT ( ch ) ; if ( ! arg -> type_comment ) goto error ; i += 1 ; break ; case DOUBLESTAR : return i ; default : ast_error ( c , ch , ""unexpected<S2SV_blank>node"" ) ; goto error ; } } return i ; error : return - 1 ; }",<S2SV_ModStart> ; if ( i < NCH ( n ) &&,python@typed_ast/a4d78362397fc3bced6ea80fbc7b5f4827aec55e,CVE-2019-19275,https://github.com/python/typed_ast/commit/a4d78362397fc3bced6ea80fbc7b5f4827aec55e,2019-11-26T15:15Z
CWE-404,"CWE-000 static void cp2112_gpio_set ( struct gpio_chip * chip , unsigned offset , int value ) { struct cp2112_device * dev = gpiochip_get_data ( chip ) ; struct hid_device * hdev = dev -> hdev ; u8 * buf = dev -> in_out_buffer ; <S2SV_StartBug> unsigned long flags ; <S2SV_EndBug> int ret ; <S2SV_StartBug> spin_lock_irqsave ( & dev -> lock , flags ) ; <S2SV_EndBug> buf [ 0 ] = CP2112_GPIO_SET ; buf [ 1 ] = value ? 0xff : 0 ; buf [ 2 ] = 1 << offset ; ret = hid_hw_raw_request ( hdev , CP2112_GPIO_SET , buf , CP2112_GPIO_SET_LENGTH , HID_FEATURE_REPORT , HID_REQ_SET_REPORT ) ; if ( ret < 0 ) hid_err ( hdev , ""error<S2SV_blank>setting<S2SV_blank>GPIO<S2SV_blank>values:<S2SV_blank>%d\\n"" , ret ) ; <S2SV_StartBug> spin_unlock_irqrestore ( & dev -> lock , flags ) ; <S2SV_EndBug> }",<S2SV_ModStart> -> in_out_buffer ; <S2SV_ModEnd> int ret ; <S2SV_ModStart> int ret ; mutex_lock <S2SV_ModEnd> ( & dev <S2SV_ModStart> dev -> lock <S2SV_ModEnd> ) ; buf <S2SV_ModStart> ret ) ; mutex_unlock <S2SV_ModEnd> ( & dev <S2SV_ModStart> dev -> lock <S2SV_ModEnd> ) ; },torvalds@linux/7a7b5df84b6b4e5d599c7289526eed96541a0654,CVE-2017-8071,https://github.com/torvalds/linux/commit/7a7b5df84b6b4e5d599c7289526eed96541a0654,2017-04-23T05:59Z
CWE-264,"CWE-264 static int linear_ioctl ( struct dm_target * ti , unsigned int cmd , unsigned long arg ) { struct linear_c * lc = ( struct linear_c * ) ti -> private ; <S2SV_StartBug> return __blkdev_driver_ioctl ( lc -> dev -> bdev , lc -> dev -> mode , cmd , arg ) ; <S2SV_EndBug> }","<S2SV_ModStart> -> private ; struct dm_dev * dev = lc -> dev ; int r = 0 ; if <S2SV_ModEnd> ( lc -> <S2SV_ModStart> ( lc -> start || ti -> len != i_size_read ( dev -> bdev -> bd_inode ) >> SECTOR_SHIFT ) r = scsi_verify_blk_ioctl ( NULL , cmd ) ; return r ? : __blkdev_driver_ioctl ( <S2SV_ModStart> -> bdev , <S2SV_ModEnd> dev -> mode",torvalds@linux/ec8013beddd717d1740cfefb1a9b900deef85462,CVE-2011-4127,https://github.com/torvalds/linux/commit/ec8013beddd717d1740cfefb1a9b900deef85462,2012-07-03T16:40Z
CWE-362,"CWE-362 int my_redel ( const char * org_name , const char * tmp_name , time_t backup_time_stamp , myf MyFlags ) { int error = 1 ; DBUG_ENTER ( ""my_redel"" ) ; DBUG_PRINT ( ""my"" , ( ""org_name:<S2SV_blank>\'%s\'<S2SV_blank>tmp_name:<S2SV_blank>\'%s\'<S2SV_blank><S2SV_blank>MyFlags:<S2SV_blank>%d"" , org_name , tmp_name , MyFlags ) ) ; <S2SV_StartBug> if ( my_copystat ( org_name , tmp_name , MyFlags ) < 0 ) <S2SV_EndBug> goto end ; if ( MyFlags & MY_REDEL_MAKE_BACKUP ) { char name_buff [ FN_REFLEN + MY_BACKUP_NAME_EXTRA_LENGTH ] ; my_create_backup_name ( name_buff , org_name , backup_time_stamp ) ; if ( my_rename ( org_name , name_buff , MyFlags ) ) goto end ; } else if ( my_delete ( org_name , MyFlags ) ) goto end ; if ( my_rename ( tmp_name , org_name , MyFlags ) ) goto end ; error = 0 ; end : DBUG_RETURN ( error ) ; }",<S2SV_ModStart> ; if ( ! my_disable_copystat_in_redel &&,MariaDB@server/347eeefbfc658c8531878218487d729f4e020805,CVE-2016-6663,https://github.com/MariaDB/server/commit/347eeefbfc658c8531878218487d729f4e020805,2016-12-13T21:59Z
CWE-269,"CWE-000 uint32_t virtio_config_readw ( VirtIODevice * vdev , uint32_t addr ) { VirtioDeviceClass * k = VIRTIO_DEVICE_GET_CLASS ( vdev ) ; uint16_t val ; <S2SV_StartBug> k -> get_config ( vdev , vdev -> config ) ; <S2SV_EndBug> if ( addr > ( vdev -> config_len - sizeof ( val ) ) ) return ( uint32_t ) - 1 ; val = lduw_p ( vdev -> config + addr ) ; return val ; }",<S2SV_ModStart> uint16_t val ; if ( addr + sizeof ( val ) > vdev -> config_len ) { return ( uint32_t ) - 1 ; } <S2SV_ModStart> -> config ) <S2SV_ModEnd> ; val =,qemu@qemu/5f5a1318653c08e435cfa52f60b6a712815b659d,CVE-2013-2016,https://github.com/qemu/qemu/commit/5f5a1318653c08e435cfa52f60b6a712815b659d,2019-12-30T22:15Z
CWE-787,"CWE-787 static int process_plane ( uint8 * in , int width , int height , uint8 * out , int size ) { UNUSED ( size ) ; int indexw ; int indexh ; int code ; int collen ; int replen ; int color ; int x ; int revcode ; uint8 * last_line ; uint8 * this_line ; uint8 * org_in ; uint8 * org_out ; org_in = in ; org_out = out ; last_line = 0 ; indexh = 0 ; while ( indexh < height ) { out = ( org_out + width * height * 4 ) - ( ( indexh + 1 ) * width * 4 ) ; color = 0 ; this_line = out ; indexw = 0 ; if ( last_line == 0 ) { while ( indexw < width ) { code = CVAL ( in ) ; replen = code & 0xf ; collen = ( code >> 4 ) & 0xf ; revcode = ( replen << 4 ) | collen ; if ( ( revcode <= 47 ) && ( revcode >= 16 ) ) { replen = revcode ; collen = 0 ; } <S2SV_StartBug> while ( collen > 0 ) <S2SV_EndBug> { color = CVAL ( in ) ; * out = color ; out += 4 ; indexw ++ ; collen -- ; } <S2SV_StartBug> while ( replen > 0 ) <S2SV_EndBug> { * out = color ; out += 4 ; indexw ++ ; replen -- ; } } } else { while ( indexw < width ) { code = CVAL ( in ) ; replen = code & 0xf ; collen = ( code >> 4 ) & 0xf ; revcode = ( replen << 4 ) | collen ; if ( ( revcode <= 47 ) && ( revcode >= 16 ) ) { replen = revcode ; collen = 0 ; } <S2SV_StartBug> while ( collen > 0 ) <S2SV_EndBug> { x = CVAL ( in ) ; if ( x & 1 ) { x = x >> 1 ; x = x + 1 ; color = - x ; } else { x = x >> 1 ; color = x ; } x = last_line [ indexw * 4 ] + color ; * out = x ; out += 4 ; indexw ++ ; collen -- ; } <S2SV_StartBug> while ( replen > 0 ) <S2SV_EndBug> { x = last_line [ indexw * 4 ] + color ; * out = x ; out += 4 ; indexw ++ ; replen -- ; } } } indexh ++ ; last_line = this_line ; } return ( int ) ( in - org_in ) ; }",<S2SV_ModStart> } while ( indexw < width && <S2SV_ModStart> } while ( indexw < width && <S2SV_ModStart> } while ( indexw < width && <S2SV_ModStart> } while ( indexw < width &&,rdesktop@rdesktop/4dca546d04321a610c1835010b5dad85163b65e1,CVE-2018-8800,https://github.com/rdesktop/rdesktop/commit/4dca546d04321a610c1835010b5dad85163b65e1,2019-02-05T20:29Z
CWE-362,"CWE-362 static int raw_sendmsg ( struct sock * sk , struct msghdr * msg , size_t len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct net * net = sock_net ( sk ) ; struct ipcm_cookie ipc ; struct rtable * rt = NULL ; struct flowi4 fl4 ; int free = 0 ; __be32 daddr ; __be32 saddr ; u8 tos ; int err ; struct ip_options_data opt_copy ; struct raw_frag_vec rfv ; <S2SV_StartBug> err = - EMSGSIZE ; <S2SV_EndBug> if ( len > 0xFFFF ) <S2SV_StartBug> goto out ; <S2SV_EndBug> err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out ; if ( msg -> msg_namelen ) { DECLARE_SOCKADDR ( struct sockaddr_in * , usin , msg -> msg_name ) ; err = - EINVAL ; if ( msg -> msg_namelen < sizeof ( * usin ) ) goto out ; if ( usin -> sin_family != AF_INET ) { pr_info_once ( ""%s:<S2SV_blank>%s<S2SV_blank>forgot<S2SV_blank>to<S2SV_blank>set<S2SV_blank>AF_INET.<S2SV_blank>Fix<S2SV_blank>it!\\n"" , __func__ , current -> comm ) ; err = - EAFNOSUPPORT ; if ( usin -> sin_family ) goto out ; } daddr = usin -> sin_addr . s_addr ; } else { err = - EDESTADDRREQ ; if ( sk -> sk_state != TCP_ESTABLISHED ) goto out ; daddr = inet -> inet_daddr ; } ipc . sockc . tsflags = sk -> sk_tsflags ; ipc . addr = inet -> inet_saddr ; ipc . opt = NULL ; ipc . tx_flags = 0 ; ipc . ttl = 0 ; ipc . tos = - 1 ; ipc . oif = sk -> sk_bound_dev_if ; if ( msg -> msg_controllen ) { err = ip_cmsg_send ( sk , msg , & ipc , false ) ; if ( unlikely ( err ) ) { kfree ( ipc . opt ) ; goto out ; } if ( ipc . opt ) free = 1 ; } saddr = ipc . addr ; ipc . addr = daddr ; if ( ! ipc . opt ) { struct ip_options_rcu * inet_opt ; rcu_read_lock ( ) ; inet_opt = rcu_dereference ( inet -> inet_opt ) ; if ( inet_opt ) { memcpy ( & opt_copy , inet_opt , sizeof ( * inet_opt ) + inet_opt -> opt . optlen ) ; ipc . opt = & opt_copy . opt ; } rcu_read_unlock ( ) ; } if ( ipc . opt ) { err = - EINVAL ; <S2SV_StartBug> if ( inet -> hdrincl ) <S2SV_EndBug> goto done ; if ( ipc . opt -> opt . srr ) { if ( ! daddr ) goto done ; daddr = ipc . opt -> opt . faddr ; } } tos = get_rtconn_flags ( & ipc , sk ) ; if ( msg -> msg_flags & MSG_DONTROUTE ) tos |= RTO_ONLINK ; if ( ipv4_is_multicast ( daddr ) ) { if ( ! ipc . oif ) ipc . oif = inet -> mc_index ; if ( ! saddr ) saddr = inet -> mc_addr ; } else if ( ! ipc . oif ) ipc . oif = inet -> uc_index ; flowi4_init_output ( & fl4 , ipc . oif , sk -> sk_mark , tos , RT_SCOPE_UNIVERSE , <S2SV_StartBug> inet -> hdrincl ? IPPROTO_RAW : sk -> sk_protocol , <S2SV_EndBug> inet_sk_flowi_flags ( sk ) | <S2SV_StartBug> ( inet -> hdrincl ? FLOWI_FLAG_KNOWN_NH : 0 ) , <S2SV_EndBug> daddr , saddr , 0 , 0 , sk -> sk_uid ) ; <S2SV_StartBug> if ( ! inet -> hdrincl ) { <S2SV_EndBug> rfv . msg = msg ; rfv . hlen = 0 ; err = raw_probe_proto_opt ( & rfv , & fl4 ) ; if ( err ) goto done ; } security_sk_classify_flow ( sk , flowi4_to_flowi ( & fl4 ) ) ; rt = ip_route_output_flow ( net , & fl4 , sk ) ; if ( IS_ERR ( rt ) ) { err = PTR_ERR ( rt ) ; rt = NULL ; goto done ; } err = - EACCES ; if ( rt -> rt_flags & RTCF_BROADCAST && ! sock_flag ( sk , SOCK_BROADCAST ) ) goto done ; if ( msg -> msg_flags & MSG_CONFIRM ) goto do_confirm ; back_from_confirm : <S2SV_StartBug> if ( inet -> hdrincl ) <S2SV_EndBug> err = raw_send_hdrinc ( sk , & fl4 , msg , len , & rt , msg -> msg_flags , & ipc . sockc ) ; else { sock_tx_timestamp ( sk , ipc . sockc . tsflags , & ipc . tx_flags ) ; if ( ! ipc . addr ) ipc . addr = fl4 . daddr ; lock_sock ( sk ) ; err = ip_append_data ( sk , & fl4 , raw_getfrag , & rfv , len , 0 , & ipc , & rt , msg -> msg_flags ) ; if ( err ) ip_flush_pending_frames ( sk ) ; else if ( ! ( msg -> msg_flags & MSG_MORE ) ) { err = ip_push_pending_frames ( sk , & fl4 ) ; if ( err == - ENOBUFS && ! inet -> recverr ) err = 0 ; } release_sock ( sk ) ; } done : if ( free ) kfree ( ipc . opt ) ; ip_rt_put ( rt ) ; out : if ( err < 0 ) return err ; return len ; do_confirm : if ( msg -> msg_flags & MSG_PROBE ) dst_confirm_neigh ( & rt -> dst , & fl4 . daddr ) ; if ( ! ( msg -> msg_flags & MSG_PROBE ) || len ) goto back_from_confirm ; err = 0 ; goto done ; }","<S2SV_ModStart> raw_frag_vec rfv ; int hdrincl ; <S2SV_ModStart> ) goto out ; hdrincl = inet -> hdrincl <S2SV_ModStart> ; if ( <S2SV_ModEnd> hdrincl ) goto <S2SV_ModStart> , RT_SCOPE_UNIVERSE , <S2SV_ModEnd> hdrincl ? IPPROTO_RAW <S2SV_ModStart> ) | ( <S2SV_ModEnd> hdrincl ? FLOWI_FLAG_KNOWN_NH <S2SV_ModStart> if ( ! <S2SV_ModEnd> hdrincl ) { <S2SV_ModStart> : if ( <S2SV_ModEnd> hdrincl ) err",torvalds@linux/8f659a03a0ba9289b9aeb9b4470e6fb263d6f483,CVE-2017-17712,https://github.com/torvalds/linux/commit/8f659a03a0ba9289b9aeb9b4470e6fb263d6f483,2017-12-16T01:29Z
CWE-264,"CWE-264 int cg_write ( const char * path , const char * buf , size_t size , off_t offset , struct fuse_file_info * fi ) { struct fuse_context * fc = fuse_get_context ( ) ; char * localbuf = NULL ; struct cgfs_files * k = NULL ; struct file_info * f = ( struct file_info * ) fi -> fh ; bool r ; if ( f -> type != LXC_TYPE_CGFILE ) { fprintf ( stderr , ""Internal<S2SV_blank>error:<S2SV_blank>directory<S2SV_blank>cache<S2SV_blank>info<S2SV_blank>used<S2SV_blank>in<S2SV_blank>cg_write\\n"" ) ; return - EIO ; } if ( offset ) return 0 ; if ( ! fc ) return - EIO ; localbuf = alloca ( size + 1 ) ; localbuf [ size ] = '\\0' ; memcpy ( localbuf , buf , size ) ; if ( ( k = cgfs_get_key ( f -> controller , f -> cgroup , f -> file ) ) == NULL ) { size = - EINVAL ; goto out ; } if ( ! fc_may_access ( fc , f -> controller , f -> cgroup , f -> file , O_WRONLY ) ) { size = - EACCES ; goto out ; } if ( strcmp ( f -> file , ""tasks"" ) == 0 || strcmp ( f -> file , ""/tasks"" ) == 0 || strcmp ( f -> file , ""/cgroup.procs"" ) == 0 || strcmp ( f -> file , ""cgroup.procs"" ) == 0 ) <S2SV_StartBug> r = do_write_pids ( fc -> pid , f -> controller , f -> cgroup , f -> file , localbuf ) ; <S2SV_EndBug> else r = cgfs_set_value ( f -> controller , f -> cgroup , f -> file , localbuf ) ; if ( ! r ) size = - EINVAL ; out : free_key ( k ) ; return size ; }","<S2SV_ModStart> -> pid , fc -> uid ,",lxc@lxcfs/8ee2a503e102b1a43ec4d83113dc275ab20a869a,CVE-2015-1344,https://github.com/lxc/lxcfs/commit/8ee2a503e102b1a43ec4d83113dc275ab20a869a,2015-12-07T20:59Z
CWE-119,"CWE-119 TEE_Result syscall_cryp_obj_populate ( unsigned long obj , struct utee_attribute * usr_attrs , unsigned long attr_count ) { TEE_Result res ; struct tee_ta_session * sess ; struct tee_obj * o ; const struct tee_cryp_obj_type_props * type_props ; TEE_Attribute * attrs = NULL ; res = tee_ta_get_current_session ( & sess ) ; if ( res != TEE_SUCCESS ) return res ; res = tee_obj_get ( to_user_ta_ctx ( sess -> ctx ) , tee_svc_uref_to_vaddr ( obj ) , & o ) ; if ( res != TEE_SUCCESS ) return res ; if ( ( o -> info . handleFlags & TEE_HANDLE_FLAG_PERSISTENT ) != 0 ) return TEE_ERROR_BAD_PARAMETERS ; if ( ( o -> info . handleFlags & TEE_HANDLE_FLAG_INITIALIZED ) != 0 ) return TEE_ERROR_BAD_PARAMETERS ; type_props = tee_svc_find_type_props ( o -> info . objectType ) ; if ( ! type_props ) return TEE_ERROR_NOT_IMPLEMENTED ; <S2SV_StartBug> attrs = malloc ( sizeof ( TEE_Attribute ) * attr_count ) ; <S2SV_EndBug> if ( ! attrs ) return TEE_ERROR_OUT_OF_MEMORY ; res = copy_in_attrs ( to_user_ta_ctx ( sess -> ctx ) , usr_attrs , attr_count , attrs ) ; if ( res != TEE_SUCCESS ) goto out ; res = tee_svc_cryp_check_attr ( ATTR_USAGE_POPULATE , type_props , attrs , attr_count ) ; if ( res != TEE_SUCCESS ) goto out ; res = tee_svc_cryp_obj_populate_type ( o , type_props , attrs , attr_count ) ; if ( res == TEE_SUCCESS ) o -> info . handleFlags |= TEE_HANDLE_FLAG_INITIALIZED ; out : free ( attrs ) ; return res ; }","<S2SV_ModStart> return TEE_ERROR_NOT_IMPLEMENTED ; size_t alloc_size = 0 ; if ( MUL_OVERFLOW ( sizeof ( TEE_Attribute ) , attr_count , & alloc_size ) ) return TEE_ERROR_OVERFLOW ; <S2SV_ModStart> = malloc ( alloc_size <S2SV_ModEnd> ) ; if",OP-TEE@optee_os/b60e1cee406a1ff521145ab9534370dfb85dd592,CVE-2019-1010296,https://github.com/OP-TEE/optee_os/commit/b60e1cee406a1ff521145ab9534370dfb85dd592,2019-07-15T18:15Z
CWE-552,"CWE-000 static ssize_t _consolefs_readv ( oe_fd_t * desc , const struct oe_iovec * iov , int iovcnt ) { ssize_t ret = - 1 ; file_t * file = _cast_file ( desc ) ; void * buf = NULL ; <S2SV_StartBug> size_t buf_size = 0 ; <S2SV_EndBug> if ( ! file || ! iov || iovcnt < 0 || iovcnt > OE_IOV_MAX ) OE_RAISE_ERRNO ( OE_EINVAL ) ; <S2SV_StartBug> if ( oe_iov_pack ( iov , iovcnt , & buf , & buf_size ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> OE_RAISE_ERRNO ( OE_ENOMEM ) ; <S2SV_EndBug> if ( oe_syscall_readv_ocall ( & ret , file -> host_fd , buf , iovcnt , buf_size ) != OE_OK ) { OE_RAISE_ERRNO ( OE_EINVAL ) ; } <S2SV_StartBug> if ( oe_iov_sync ( iov , iovcnt , buf , buf_size ) != 0 ) <S2SV_EndBug> OE_RAISE_ERRNO ( OE_EINVAL ) ; done : if ( buf ) oe_free ( buf ) ; return ret ; }","<S2SV_ModStart> ; size_t buf_size = 0 ; size_t data_size <S2SV_ModStart> , & buf_size , & data_size <S2SV_ModStart> OE_RAISE_ERRNO ( OE_ENOMEM ) ; if ( data_size > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL <S2SV_ModStart> } if ( ret > ( ssize_t ) data_size ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; } if (",openenclave@openenclave/bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b,CVE-2020-15224,https://github.com/openenclave/openenclave/commit/bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b,2020-10-14T19:15Z
NVD-CWE-noinfo,"CWE-000 static int fit_image_verify_sig ( const void * fit , int image_noffset , const char * data , size_t size , const void * sig_blob , int sig_offset ) { int noffset ; char * err_msg = """" ; int verified = 0 ; int ret ; fdt_for_each_subnode ( noffset , fit , image_noffset ) { <S2SV_StartBug> const char * name = fit_get_name ( fit , noffset , NULL ) ; <S2SV_EndBug> if ( ! strncmp ( name , FIT_SIG_NODENAME , strlen ( FIT_SIG_NODENAME ) ) ) { ret = fit_image_check_sig ( fit , noffset , data , size , - 1 , & err_msg ) ; if ( ret ) { puts ( ""-<S2SV_blank>"" ) ; } else { puts ( ""+<S2SV_blank>"" ) ; verified = 1 ; break ; } } } if ( noffset == - FDT_ERR_TRUNCATED || noffset == - FDT_ERR_BADSTRUCTURE ) { err_msg = ""Corrupted<S2SV_blank>or<S2SV_blank>truncated<S2SV_blank>tree"" ; goto error ; } return verified ? 0 : - EPERM ; error : printf ( ""<S2SV_blank>error!\\n%s<S2SV_blank>for<S2SV_blank>\'%s\'<S2SV_blank>hash<S2SV_blank>node<S2SV_blank>in<S2SV_blank>\'%s\'<S2SV_blank>image<S2SV_blank>node\\n"" , err_msg , fit_get_name ( fit , noffset , NULL ) , fit_get_name ( fit , image_noffset , NULL ) ) ; return - 1 ; }","<S2SV_ModStart> NULL ) ; if ( strchr ( name , '@' ) ) { err_msg = ""Node<S2SV_blank>name<S2SV_blank>contains<S2SV_blank>@"" ; goto error ; }",u-boot@u-boot/79af75f7776fc20b0d7eb6afe1e27c00fdb4b9b4,CVE-2021-27138,https://github.com/u-boot/u-boot/commit/79af75f7776fc20b0d7eb6afe1e27c00fdb4b9b4,2021-02-17T23:15Z
CWE-119,"CWE-119 php_http_url_t * php_http_url_parse ( const char * str , size_t len , unsigned flags TSRMLS_DC ) { <S2SV_StartBug> size_t maxlen = 3 * len ; <S2SV_EndBug> struct parse_state * state = ecalloc ( 1 , sizeof ( * state ) + maxlen ) ; state -> end = str + len ; state -> ptr = str ; state -> flags = flags ; state -> maxlen = maxlen ; TSRMLS_SET_CTX ( state -> ts ) ; if ( ! parse_scheme ( state ) ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Failed<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>URL<S2SV_blank>scheme:<S2SV_blank>\'%s\'"" , state -> ptr ) ; efree ( state ) ; return NULL ; } if ( ! parse_hier ( state ) ) { efree ( state ) ; return NULL ; } if ( ! parse_query ( state ) ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Failed<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>URL<S2SV_blank>query:<S2SV_blank>\'%s\'"" , state -> ptr ) ; efree ( state ) ; return NULL ; } if ( ! parse_fragment ( state ) ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Failed<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>URL<S2SV_blank>fragment:<S2SV_blank>\'%s\'"" , state -> ptr ) ; efree ( state ) ; return NULL ; } return ( php_http_url_t * ) state ; }",<S2SV_ModStart> 3 * len + 8,m6w6@ext-http/3724cd76a28be1d6049b5537232e97ac567ae1f5,CVE-2016-5873,https://github.com/m6w6/ext-http/commit/3724cd76a28be1d6049b5537232e97ac,2017-01-23T21:59Z
CWE-416,"CWE-416 static int usb_audio_probe ( struct usb_interface * intf , const struct usb_device_id * usb_id ) { struct usb_device * dev = interface_to_usbdev ( intf ) ; const struct snd_usb_audio_quirk * quirk = ( const struct snd_usb_audio_quirk * ) usb_id -> driver_info ; struct snd_usb_audio * chip ; int i , err ; struct usb_host_interface * alts ; int ifnum ; u32 id ; alts = & intf -> altsetting [ 0 ] ; ifnum = get_iface_desc ( alts ) -> bInterfaceNumber ; id = USB_ID ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( get_alias_id ( dev , & id ) ) quirk = get_alias_quirk ( dev , id ) ; if ( quirk && quirk -> ifnum >= 0 && ifnum != quirk -> ifnum ) return - ENXIO ; err = snd_usb_apply_boot_quirk ( dev , intf , quirk , id ) ; if ( err < 0 ) return err ; chip = NULL ; mutex_lock ( & register_mutex ) ; for ( i = 0 ; i < SNDRV_CARDS ; i ++ ) { if ( usb_chip [ i ] && usb_chip [ i ] -> dev == dev ) { if ( atomic_read ( & usb_chip [ i ] -> shutdown ) ) { dev_err ( & dev -> dev , ""USB<S2SV_blank>device<S2SV_blank>is<S2SV_blank>in<S2SV_blank>the<S2SV_blank>shutdown<S2SV_blank>state,<S2SV_blank>cannot<S2SV_blank>create<S2SV_blank>a<S2SV_blank>card<S2SV_blank>instance\\n"" ) ; err = - EIO ; goto __error ; } chip = usb_chip [ i ] ; atomic_inc ( & chip -> active ) ; break ; } } if ( ! chip ) { for ( i = 0 ; i < SNDRV_CARDS ; i ++ ) if ( ! usb_chip [ i ] && ( vid [ i ] == - 1 || vid [ i ] == USB_ID_VENDOR ( id ) ) && ( pid [ i ] == - 1 || pid [ i ] == USB_ID_PRODUCT ( id ) ) ) { if ( enable [ i ] ) { err = snd_usb_audio_create ( intf , dev , i , quirk , id , & chip ) ; if ( err < 0 ) goto __error ; chip -> pm_intf = intf ; break ; } else if ( vid [ i ] != - 1 || pid [ i ] != - 1 ) { dev_info ( & dev -> dev , ""device<S2SV_blank>(%04x:%04x)<S2SV_blank>is<S2SV_blank>disabled\\n"" , USB_ID_VENDOR ( id ) , USB_ID_PRODUCT ( id ) ) ; err = - ENOENT ; goto __error ; } } if ( ! chip ) { dev_err ( & dev -> dev , ""no<S2SV_blank>available<S2SV_blank>usb<S2SV_blank>audio<S2SV_blank>device\\n"" ) ; err = - ENODEV ; goto __error ; } } dev_set_drvdata ( & dev -> dev , chip ) ; if ( ! chip -> ctrl_intf ) chip -> ctrl_intf = alts ; chip -> txfr_quirk = 0 ; err = 1 ; if ( quirk && quirk -> ifnum != QUIRK_NO_INTERFACE ) { err = snd_usb_create_quirk ( chip , intf , & usb_audio_driver , quirk ) ; if ( err < 0 ) goto __error ; } if ( err > 0 ) { err = snd_usb_create_streams ( chip , ifnum ) ; if ( err < 0 ) goto __error ; err = snd_usb_create_mixer ( chip , ifnum , ignore_ctl_error ) ; if ( err < 0 ) goto __error ; } err = snd_card_register ( chip -> card ) ; if ( err < 0 ) goto __error ; usb_chip [ chip -> index ] = chip ; chip -> num_interfaces ++ ; usb_set_intfdata ( intf , chip ) ; atomic_dec ( & chip -> active ) ; mutex_unlock ( & register_mutex ) ; return 0 ; __error : if ( chip ) { <S2SV_StartBug> if ( ! chip -> num_interfaces ) <S2SV_EndBug> snd_card_free ( chip -> card ) ; <S2SV_StartBug> atomic_dec ( & chip -> active ) ; <S2SV_EndBug> } mutex_unlock ( & register_mutex ) ; return err ; }",<S2SV_ModStart> chip ) { atomic_dec ( & chip -> active ) ; <S2SV_ModStart> card ) ; <S2SV_ModEnd> } mutex_unlock (,torvalds@linux/5f8cf712582617d523120df67d392059eaf2fc4b,CVE-2018-19824,https://github.com/torvalds/linux/commit/5f8cf712582617d523120df67d392059eaf2fc4b,2018-12-03T17:29Z
CWE-119,CWE-119 static int _FVMenuClose ( FontView * fv ) { int i ; SplineFont * sf = fv -> b . cidmaster ? fv -> b . cidmaster : fv -> b . sf ; if ( ! SFCloseAllInstrs ( fv -> b . sf ) ) return ( false ) ; <S2SV_StartBug> if ( fv -> b . nextsame != NULL || fv -> b . sf -> fv != & fv -> b ) { <S2SV_EndBug> } else if ( SFAnyChanged ( sf ) ) { i = AskChanged ( fv -> b . sf ) ; if ( i == 2 ) return ( false ) ; if ( i == 0 && ! _FVMenuSave ( fv ) ) return ( false ) ; else SFClearAutoSave ( sf ) ; } _FVCloseWindows ( fv ) ; if ( sf -> filename != NULL ) RecentFilesRemember ( sf -> filename ) ; else if ( sf -> origname != NULL ) RecentFilesRemember ( sf -> origname ) ; GDrawDestroyWindow ( fv -> gw ) ; return ( true ) ; },<S2SV_ModStart> b ) { } else if ( warn_script_unsaved && fv -> script_unsaved && AskScriptChanged ( ) == 2 ) { return false ;,fontforge@fontforge/626f751752875a0ddd74b9e217b6f4828713573c,CVE-2019-15785,https://github.com/fontforge/fontforge/commit/626f751752875a0ddd74b9e217b6f4828713573c,2019-08-29T13:15Z
CWE-119,"CWE-119 IMPEG2D_ERROR_CODES_T impeg2d_dec_seq_hdr ( dec_state_t * ps_dec ) { stream_t * ps_stream ; ps_stream = & ps_dec -> s_bit_stream ; UWORD16 u2_height ; UWORD16 u2_width ; if ( impeg2d_bit_stream_nxt ( ps_stream , START_CODE_LEN ) != SEQUENCE_HEADER_CODE ) { impeg2d_bit_stream_flush ( ps_stream , START_CODE_LEN ) ; return IMPEG2D_FRM_HDR_START_CODE_NOT_FOUND ; } impeg2d_bit_stream_flush ( ps_stream , START_CODE_LEN ) ; u2_width = impeg2d_bit_stream_get ( ps_stream , 12 ) ; u2_height = impeg2d_bit_stream_get ( ps_stream , 12 ) ; if ( ( u2_width != ps_dec -> u2_horizontal_size ) || ( u2_height != ps_dec -> u2_vertical_size ) ) { if ( 0 == ps_dec -> u2_header_done ) { ps_dec -> u2_horizontal_size = u2_width ; ps_dec -> u2_vertical_size = u2_height ; if ( 0 == ps_dec -> u4_frm_buf_stride ) { ps_dec -> u4_frm_buf_stride = ( UWORD32 ) ( u2_width ) ; } } else { if ( ( u2_width > ps_dec -> u2_create_max_width ) || ( u2_height > ps_dec -> u2_create_max_height ) ) { IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_UNSUPPORTED_DIMENSIONS ; ps_dec -> u2_reinit_max_height = u2_height ; ps_dec -> u2_reinit_max_width = u2_width ; return e_error ; } else { return ( IMPEG2D_ERROR_CODES_T ) IVD_RES_CHANGED ; } } } if ( ( ps_dec -> u2_horizontal_size > ps_dec -> u2_create_max_width ) || ( ps_dec -> u2_vertical_size > ps_dec -> u2_create_max_height ) ) { IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_UNSUPPORTED_DIMENSIONS ; <S2SV_StartBug> return SET_IVD_FATAL_ERROR ( e_error ) ; <S2SV_EndBug> } ps_dec -> u2_aspect_ratio_info = impeg2d_bit_stream_get ( ps_stream , 4 ) ; ps_dec -> u2_frame_rate_code = impeg2d_bit_stream_get ( ps_stream , 4 ) ; if ( ps_dec -> u2_frame_rate_code > MPEG2_MAX_FRAME_RATE_CODE ) { return IMPEG2D_FRM_HDR_DECODE_ERR ; } impeg2d_bit_stream_flush ( ps_stream , 18 ) ; GET_MARKER_BIT ( ps_dec , ps_stream ) ; impeg2d_bit_stream_flush ( ps_stream , 11 ) ; if ( impeg2d_bit_stream_get_bit ( ps_stream ) == 1 ) { UWORD16 i ; for ( i = 0 ; i < NUM_PELS_IN_BLOCK ; i ++ ) { ps_dec -> au1_intra_quant_matrix [ gau1_impeg2_inv_scan_zig_zag [ i ] ] = ( UWORD8 ) impeg2d_bit_stream_get ( ps_stream , 8 ) ; } } else { memcpy ( ps_dec -> au1_intra_quant_matrix , gau1_impeg2_intra_quant_matrix_default , NUM_PELS_IN_BLOCK ) ; } if ( impeg2d_bit_stream_get_bit ( ps_stream ) == 1 ) { UWORD16 i ; for ( i = 0 ; i < NUM_PELS_IN_BLOCK ; i ++ ) { ps_dec -> au1_inter_quant_matrix [ gau1_impeg2_inv_scan_zig_zag [ i ] ] = ( UWORD8 ) impeg2d_bit_stream_get ( ps_stream , 8 ) ; } } else { memcpy ( ps_dec -> au1_inter_quant_matrix , gau1_impeg2_inter_quant_matrix_default , NUM_PELS_IN_BLOCK ) ; } impeg2d_next_start_code ( ps_dec ) ; return ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE ; }",<S2SV_ModStart> = IMPEG2D_UNSUPPORTED_DIMENSIONS ; ps_dec -> u2_reinit_max_height = ps_dec -> u2_vertical_size ; ps_dec -> u2_reinit_max_width = ps_dec -> u2_horizontal_size ; return e_error <S2SV_ModEnd> ; } ps_dec,external@libmpeg2/a86eb798d077b9b25c8f8c77e3c02c2f287c1ce7,CVE-2017-0587,https://android.googlesource.com/platform/external/libmpeg2/+/a86eb798d077b9b25c8f8c77e3c02c2f287c1ce7,2017-05-12T15:29Z
CWE-119,"CWE-119 <S2SV_StartBug> static void count_segs ( VP9_COMP * cpi , const TileInfo * const tile , <S2SV_EndBug> <S2SV_StartBug> MODE_INFO * * mi_8x8 , <S2SV_EndBug> int * no_pred_segcounts , int ( * temporal_predictor_count ) [ 2 ] , int * t_unpred_seg_counts , int bw , int bh , int mi_row , int mi_col ) { <S2SV_StartBug> VP9_COMMON * const cm = & cpi -> common ; <S2SV_EndBug> MACROBLOCKD * const xd = & cpi -> mb . e_mbd ; int segment_id ; if ( mi_row >= cm -> mi_rows || mi_col >= cm -> mi_cols ) return ; <S2SV_StartBug> xd -> mi = mi_8x8 ; <S2SV_EndBug> segment_id = xd -> mi [ 0 ] -> mbmi . segment_id ; set_mi_row_col ( xd , tile , mi_row , bh , mi_col , bw , cm -> mi_rows , cm -> mi_cols ) ; no_pred_segcounts [ segment_id ] ++ ; if ( cm -> frame_type != KEY_FRAME ) { <S2SV_StartBug> const BLOCK_SIZE bsize = mi_8x8 [ 0 ] -> mbmi . sb_type ; <S2SV_EndBug> <S2SV_StartBug> const int pred_segment_id = vp9_get_segment_id ( cm , cm -> last_frame_seg_map , <S2SV_EndBug> bsize , mi_row , mi_col ) ; const int pred_flag = pred_segment_id == segment_id ; const int pred_context = vp9_get_pred_context_seg_id ( xd ) ; xd -> mi [ 0 ] -> mbmi . seg_id_predicted = pred_flag ; temporal_predictor_count [ pred_context ] [ pred_flag ] ++ ; if ( ! pred_flag ) t_unpred_seg_counts [ segment_id ] ++ ; } }","<S2SV_ModStart> void count_segs ( const VP9_COMMON * cm , MACROBLOCKD * xd , <S2SV_ModEnd> const TileInfo * <S2SV_ModStart> const TileInfo * <S2SV_ModEnd> tile , MODE_INFO <S2SV_ModStart> MODE_INFO * * mi <S2SV_ModEnd> , int * <S2SV_ModStart> mi_col ) { <S2SV_ModEnd> int segment_id ; <S2SV_ModStart> -> mi = mi <S2SV_ModEnd> ; segment_id = <S2SV_ModStart> BLOCK_SIZE bsize = xd -> mi <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> int pred_segment_id = get_segment_id <S2SV_ModEnd> ( cm ,",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-125,"CWE-125 PIX * pixFewColorsOctcubeQuantMixed ( PIX * pixs , l_int32 level , l_int32 darkthresh , l_int32 lightthresh , l_int32 diffthresh , l_float32 minfract , l_int32 maxspan ) { l_int32 i , j , w , h , wplc , wplm , wpld , ncolors , index ; l_int32 rval , gval , bval , val , minval , maxval ; l_int32 * lut ; l_uint32 * datac , * datam , * datad , * linec , * linem , * lined ; <S2SV_StartBug> PIX * pixc , * pixm , * pixg , * pixd ; <S2SV_EndBug> PIXCMAP * cmap , * cmapd ; PROCNAME ( ""pixFewColorsOctcubeQuantMixed"" ) ; if ( ! pixs || pixGetDepth ( pixs ) != 32 ) return ( PIX * ) ERROR_PTR ( ""pixs<S2SV_blank>undefined<S2SV_blank>or<S2SV_blank>not<S2SV_blank>32<S2SV_blank>bpp"" , procName , NULL ) ; if ( level <= 0 ) level = 3 ; if ( level > 6 ) return ( PIX * ) ERROR_PTR ( ""invalid<S2SV_blank>level"" , procName , NULL ) ; if ( darkthresh <= 0 ) darkthresh = 20 ; if ( lightthresh <= 0 ) lightthresh = 244 ; if ( diffthresh <= 0 ) diffthresh = 20 ; if ( minfract <= 0.0 ) minfract = 0.05 ; if ( maxspan <= 2 ) maxspan = 15 ; <S2SV_StartBug> if ( ( pixc = pixFewColorsOctcubeQuant1 ( pixs , level ) ) == NULL ) <S2SV_EndBug> <S2SV_StartBug> return ( PIX * ) ERROR_PTR ( ""too<S2SV_blank>many<S2SV_blank>colors"" , procName , NULL ) ; <S2SV_EndBug> cmap = pixGetColormap ( pixc ) ; ncolors = pixcmapGetCount ( cmap ) ; cmapd = pixcmapCreate ( 8 ) ; lut = ( l_int32 * ) LEPT_CALLOC ( 256 , sizeof ( l_int32 ) ) ; for ( i = 0 ; i < 256 ; i ++ ) lut [ i ] = - 1 ; for ( i = 0 , index = 0 ; i < ncolors ; i ++ ) { pixcmapGetColor ( cmap , i , & rval , & gval , & bval ) ; minval = L_MIN ( rval , gval ) ; minval = L_MIN ( minval , bval ) ; if ( minval > lightthresh ) continue ; maxval = L_MAX ( rval , gval ) ; maxval = L_MAX ( maxval , bval ) ; if ( maxval < darkthresh ) continue ; if ( maxval - minval >= diffthresh ) { pixcmapAddColor ( cmapd , rval , gval , bval ) ; lut [ i ] = index ; index ++ ; } } pixGetDimensions ( pixs , & w , & h , NULL ) ; pixd = pixCreate ( w , h , 8 ) ; pixSetColormap ( pixd , cmapd ) ; pixm = pixCreate ( w , h , 1 ) ; datac = pixGetData ( pixc ) ; datam = pixGetData ( pixm ) ; datad = pixGetData ( pixd ) ; wplc = pixGetWpl ( pixc ) ; wplm = pixGetWpl ( pixm ) ; wpld = pixGetWpl ( pixd ) ; for ( i = 0 ; i < h ; i ++ ) { linec = datac + i * wplc ; linem = datam + i * wplm ; lined = datad + i * wpld ; for ( j = 0 ; j < w ; j ++ ) { val = GET_DATA_BYTE ( linec , j ) ; if ( lut [ val ] == - 1 ) SET_DATA_BIT ( linem , j ) ; else SET_DATA_BYTE ( lined , j , lut [ val ] ) ; } } pixg = pixConvertTo8 ( pixs , 0 ) ; pixGrayQuantFromHisto ( pixd , pixg , pixm , minfract , maxspan ) ; LEPT_FREE ( lut ) ; pixDestroy ( & pixc ) ; pixDestroy ( & pixm ) ; pixDestroy ( & pixg ) ; return pixd ; }","<S2SV_ModStart> lined ; PIX * pix1 , <S2SV_ModStart> if ( ( pix1 <S2SV_ModEnd> = pixFewColorsOctcubeQuant1 ( <S2SV_ModStart> procName , NULL ) ; pixc = pixConvertTo8 ( pix1 , 1 ) ; pixDestroy ( & pix1",DanBloomberg@leptonica/5ee24b398bb67666f6d173763eaaedd9c36fb1e5,CVE-2020-36281,https://github.com/DanBloomberg/leptonica/commit/5ee24b398bb67666f6d173763eaaedd9c36fb1e5,2021-03-12T01:15Z
CWE-190,"CWE-190 static int growOpArray ( Vdbe * v , int nOp ) { VdbeOp * pNew ; Parse * p = v -> pParse ; # ifdef SQLITE_TEST_REALLOC_STRESS <S2SV_StartBug> int nNew = ( v -> nOpAlloc >= 512 ? v -> nOpAlloc * 2 : v -> nOpAlloc + nOp ) ; <S2SV_EndBug> # else <S2SV_StartBug> int nNew = ( v -> nOpAlloc ? v -> nOpAlloc * 2 : ( int ) ( 1024 / sizeof ( Op ) ) ) ; <S2SV_EndBug> UNUSED_PARAMETER ( nOp ) ; # endif if ( nNew > p -> db -> aLimit [ SQLITE_LIMIT_VDBE_OP ] ) { sqlite3OomFault ( p -> db ) ; return SQLITE_NOMEM ; } assert ( nOp <= ( 1024 / sizeof ( Op ) ) ) ; assert ( nNew >= ( v -> nOpAlloc + nOp ) ) ; pNew = sqlite3DbRealloc ( p -> db , v -> aOp , nNew * sizeof ( Op ) ) ; if ( pNew ) { p -> szOpAlloc = sqlite3DbMallocSize ( p -> db , pNew ) ; v -> nOpAlloc = p -> szOpAlloc / sizeof ( Op ) ; v -> aOp = pNew ; } return ( pNew ? SQLITE_OK : SQLITE_NOMEM_BKPT ) ; }",<S2SV_ModStart> # ifdef SQLITE_TEST_REALLOC_STRESS sqlite3_int64 <S2SV_ModEnd> nNew = ( <S2SV_ModStart> >= 512 ? 2 * ( sqlite3_int64 ) v -> nOpAlloc : ( sqlite3_int64 ) <S2SV_ModEnd> v -> nOpAlloc <S2SV_ModStart> ; # else sqlite3_int64 <S2SV_ModEnd> nNew = ( <S2SV_ModStart> -> nOpAlloc ? 2 * ( sqlite3_int64 ) v -> nOpAlloc : ( sqlite3_int64 ) <S2SV_ModEnd> 1024 / sizeof <S2SV_ModStart> sizeof ( Op <S2SV_ModEnd> ) ) ;,chromium@chromium/517ac71c9ee27f856f9becde8abea7d1604af9d4,CVE-2019-5827,https://github.com/chromium/chromium/commit/517ac71c9ee27f856f9becde8abea7d1604af9d4,2019-06-27T17:15Z
CWE-119,"CWE-119 void WT_VoiceGain ( S_WT_VOICE * pWTVoice , S_WT_INT_FRAME * pWTIntFrame ) { EAS_I32 * pMixBuffer ; EAS_PCM * pInputBuffer ; EAS_I32 gain ; EAS_I32 gainIncrement ; EAS_I32 tmp0 ; EAS_I32 tmp1 ; EAS_I32 tmp2 ; EAS_I32 numSamples ; # if ( NUM_OUTPUT_CHANNELS == 2 ) EAS_I32 gainLeft , gainRight ; # endif numSamples = pWTIntFrame -> numSamples ; if ( numSamples <= 0 ) { <S2SV_StartBug> ALOGE ( ""b/26366256"" ) ; <S2SV_EndBug> return ; } pMixBuffer = pWTIntFrame -> pMixBuffer ; pInputBuffer = pWTIntFrame -> pAudioBuffer ; gainIncrement = ( pWTIntFrame -> frame . gainTarget - pWTIntFrame -> prevGain ) << ( 16 - SYNTH_UPDATE_PERIOD_IN_BITS ) ; if ( gainIncrement < 0 ) gainIncrement ++ ; gain = pWTIntFrame -> prevGain << 16 ; # if ( NUM_OUTPUT_CHANNELS == 2 ) gainLeft = pWTVoice -> gainLeft ; gainRight = pWTVoice -> gainRight ; # endif while ( numSamples -- ) { tmp0 = * pInputBuffer ++ ; gain += gainIncrement ; tmp2 = gain >> 16 ; tmp2 *= tmp0 ; # if ( NUM_OUTPUT_CHANNELS == 2 ) tmp2 = tmp2 >> 14 ; tmp1 = * pMixBuffer ; tmp0 = tmp2 * gainLeft ; tmp0 = tmp0 >> NUM_MIXER_GUARD_BITS ; tmp1 += tmp0 ; * pMixBuffer ++ = tmp1 ; tmp1 = * pMixBuffer ; tmp0 = tmp2 * gainRight ; tmp0 = tmp0 >> NUM_MIXER_GUARD_BITS ; tmp1 += tmp0 ; * pMixBuffer ++ = tmp1 ; # else tmp1 = * pMixBuffer ; tmp2 = tmp2 >> ( NUM_MIXER_GUARD_BITS - 1 ) ; tmp1 += tmp2 ; * pMixBuffer ++ = tmp1 ; # endif } }","<S2SV_ModStart> ALOGE ( ""b/26366256"" ) ; android_errorWriteLog ( 0x534e4554 , ""26366256""",external@sonivox/24d7c408c52143bce7b49de82f3913fd8d1219cf,CVE-2016-0838,https://android.googlesource.com/platform/external/sonivox/+/24d7c408c52143bce7b49de82f3913fd8d1219cf,2016-04-18T00:59Z
CWE-665,"CWE-000 void rfbSendServerCutText ( rfbScreenInfoPtr rfbScreen , char * str , int len ) { rfbClientPtr cl ; rfbServerCutTextMsg sct ; rfbClientIteratorPtr iterator ; <S2SV_StartBug> iterator = rfbGetClientIterator ( rfbScreen ) ; <S2SV_EndBug> while ( ( cl = rfbClientIteratorNext ( iterator ) ) != NULL ) { sct . type = rfbServerCutText ; sct . length = Swap32IfLE ( len ) ; LOCK ( cl -> sendMutex ) ; if ( rfbWriteExact ( cl , ( char * ) & sct , sz_rfbServerCutTextMsg ) < 0 ) { rfbLogPerror ( ""rfbSendServerCutText:<S2SV_blank>write"" ) ; rfbCloseClient ( cl ) ; UNLOCK ( cl -> sendMutex ) ; continue ; } if ( rfbWriteExact ( cl , str , len ) < 0 ) { rfbLogPerror ( ""rfbSendServerCutText:<S2SV_blank>write"" ) ; rfbCloseClient ( cl ) ; } UNLOCK ( cl -> sendMutex ) ; rfbStatRecordMessageSent ( cl , rfbServerCutText , sz_rfbServerCutTextMsg + len , sz_rfbServerCutTextMsg + len ) ; } rfbReleaseClientIterator ( iterator ) ; }","<S2SV_ModStart> rfbClientIteratorPtr iterator ; memset ( ( char * ) & sct , 0 , sizeof ( sct ) ) ;",LibVNC@libvncserver/d01e1bb4246323ba6fcee3b82ef1faa9b1dac82a,CVE-2019-15681,https://github.com/LibVNC/libvncserver/commit/d01e1bb4246323ba6fcee3b82ef1faa9b1dac82a,2019-10-29T19:15Z
CWE-400,"CWE-000 static void xen_irq_init ( unsigned irq ) { struct irq_info * info ; # ifdef CONFIG_SMP cpumask_copy ( irq_get_affinity_mask ( irq ) , cpumask_of ( 0 ) ) ; # endif info = kzalloc ( sizeof ( * info ) , GFP_KERNEL ) ; if ( info == NULL ) panic ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>metadata<S2SV_blank>for<S2SV_blank>IRQ%d\\n"" , irq ) ; info -> type = IRQT_UNBOUND ; info -> refcnt = - 1 ; set_info_for_irq ( irq , info ) ; <S2SV_StartBug> list_add_tail ( & info -> list , & xen_irq_list_head ) ; <S2SV_EndBug> }",<S2SV_ModStart> info ) ; INIT_LIST_HEAD ( & info -> eoi_list ) ;,torvalds@linux/e99502f76271d6bc4e374fe368c50c67a1fd3070,CVE-2020-27673,https://github.com/torvalds/linux/commit/e99502f76271d6bc4e374fe368c50c67a1fd3070,2020-10-22T21:15Z
CWE-476,"CWE-476 long keyctl_read_key ( key_serial_t keyid , char __user * buffer , size_t buflen ) { struct key * key ; key_ref_t key_ref ; long ret ; key_ref = lookup_user_key ( keyid , 0 , 0 ) ; if ( IS_ERR ( key_ref ) ) { ret = - ENOKEY ; goto error ; } key = key_ref_to_ptr ( key_ref ) ; <S2SV_StartBug> ret = key_permission ( key_ref , KEY_NEED_READ ) ; <S2SV_EndBug> if ( ret == 0 ) goto can_read_key ; if ( ret != - EACCES ) goto error2 ; if ( ! is_key_possessed ( key_ref ) ) { ret = - EACCES ; goto error2 ; } can_read_key : ret = - EOPNOTSUPP ; if ( key -> type -> read ) { down_read ( & key -> sem ) ; ret = key_validate ( key ) ; if ( ret == 0 ) ret = key -> type -> read ( key , buffer , buflen ) ; up_read ( & key -> sem ) ; } error2 : key_put ( key ) ; error : return ret ; }","<S2SV_ModStart> key_ref ) ; if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) { ret = - ENOKEY ; goto error2 ; }",torvalds@linux/37863c43b2c6464f252862bf2e9768264e961678,CVE-2017-12192,https://github.com/torvalds/linux/commit/37863c43b2c6464f252862bf2e9768264e961678,2017-10-12T00:29Z
CWE-119,CWE-119 void vp9_restore_layer_context ( VP9_COMP * const cpi ) { <S2SV_StartBug> LAYER_CONTEXT * const lc = get_layer_context ( & cpi -> svc ) ; <S2SV_EndBug> const int old_frame_since_key = cpi -> rc . frames_since_key ; const int old_frame_to_key = cpi -> rc . frames_to_key ; cpi -> rc = lc -> rc ; cpi -> twopass = lc -> twopass ; cpi -> oxcf . target_bandwidth = lc -> target_bandwidth ; <S2SV_StartBug> cpi -> oxcf . starting_buffer_level = lc -> starting_buffer_level ; <S2SV_EndBug> cpi -> oxcf . optimal_buffer_level = lc -> optimal_buffer_level ; cpi -> oxcf . maximum_buffer_size = lc -> maximum_buffer_size ; cpi -> output_framerate = lc -> framerate ; if ( cpi -> svc . number_temporal_layers > 1 ) { cpi -> rc . frames_since_key = old_frame_since_key ; cpi -> rc . frames_to_key = old_frame_to_key ; } },<S2SV_ModStart> = get_layer_context ( cpi <S2SV_ModEnd> ) ; const <S2SV_ModStart> ; cpi -> alt_ref_source <S2SV_ModEnd> = lc -> <S2SV_ModStart> = lc -> alt_ref_source <S2SV_ModEnd> ; if (,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-125,"CWE-125 static void <S2SV_StartBug> l2tp_proxy_auth_type_print ( netdissect_options * ndo , const u_char * dat ) <S2SV_EndBug> { <S2SV_StartBug> const uint16_t * ptr = ( const uint16_t * ) dat ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""%s"" , tok2str ( l2tp_authentype2str , ""AuthType-#%u"" , EXTRACT_16BITS ( ptr ) ) ) ) ; }","<S2SV_ModStart> u_char * dat , u_int length <S2SV_ModStart> ) dat ; if ( length < 2 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; }",the-tcpdump-group@tcpdump/cc4a7391c616be7a64ed65742ef9ed3f106eb165,CVE-2017-13006,https://github.com/the-tcpdump-group/tcpdump/commit/cc4a7391c616be7a64ed65742ef9ed3f106eb165,2017-09-14T06:29Z
CWE-20,"CWE-20 void MoveTo ( double x1 , double y1 ) { <S2SV_StartBug> outpos += <S2SV_EndBug> sprintf ( outpos , ""\\n<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>m"" , x1 , y1 ) ; <S2SV_StartBug> } <S2SV_EndBug>","<S2SV_ModStart> y1 ) { sprintf ( outputbuffer <S2SV_ModEnd> , ""\\n<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>m"" , <S2SV_ModStart> y1 ) ; sendClean ( outputbuffer ) ;",TeX-Live@texlive-source/9216833a3888a4105a18e8c349f65b045ddb1079,CVE-2019-18604,https://github.com/TeX-Live/texlive-source/commit/9216833a3888a4105a18e8c349f65b045ddb1079,2019-10-29T19:15Z
CWE-200,"CWE-200 static void tcp_send_challenge_ack ( struct sock * sk , const struct sk_buff * skb ) { static u32 challenge_timestamp ; static unsigned int challenge_count ; struct tcp_sock * tp = tcp_sk ( sk ) ; <S2SV_StartBug> u32 now ; <S2SV_EndBug> if ( tcp_oow_rate_limited ( sock_net ( sk ) , skb , LINUX_MIB_TCPACKSKIPPEDCHALLENGE , & tp -> last_oow_ack_time ) ) return ; now = jiffies / HZ ; if ( now != challenge_timestamp ) { <S2SV_StartBug> challenge_timestamp = now ; <S2SV_EndBug> <S2SV_StartBug> challenge_count = 0 ; <S2SV_EndBug> } if ( ++ challenge_count <= sysctl_tcp_challenge_ack_limit ) { NET_INC_STATS ( sock_net ( sk ) , LINUX_MIB_TCPCHALLENGEACK ) ; tcp_send_ack ( sk ) ; } }","<S2SV_ModStart> ) ; u32 count , <S2SV_ModStart> challenge_timestamp ) { u32 half = ( sysctl_tcp_challenge_ack_limit + 1 ) >> 1 ; <S2SV_ModStart> = now ; WRITE_ONCE ( challenge_count , half + prandom_u32_max ( sysctl_tcp_challenge_ack_limit ) ) ; } count = READ_ONCE ( challenge_count ) ; if ( count > 0 ) { WRITE_ONCE ( challenge_count , count - 1 ) ; <S2SV_ModEnd> NET_INC_STATS ( sock_net",torvalds@linux/75ff39ccc1bd5d3c455b6822ab09e533c551f758,CVE-2016-5696,https://github.com/torvalds/linux/commit/75ff39ccc1bd5d3c455b6822ab09e533c551f758,2016-08-06T20:59Z
CWE-401,"CWE-000 int v3d_submit_cl_ioctl ( struct drm_device * dev , void * data , struct drm_file * file_priv ) { struct v3d_dev * v3d = to_v3d_dev ( dev ) ; struct v3d_file_priv * v3d_priv = file_priv -> driver_priv ; struct drm_v3d_submit_cl * args = data ; struct v3d_bin_job * bin = NULL ; struct v3d_render_job * render ; struct ww_acquire_ctx acquire_ctx ; int ret = 0 ; trace_v3d_submit_cl_ioctl ( & v3d -> drm , args -> rcl_start , args -> rcl_end ) ; if ( args -> pad != 0 ) { DRM_INFO ( ""pad<S2SV_blank>must<S2SV_blank>be<S2SV_blank>zero:<S2SV_blank>%d\\n"" , args -> pad ) ; return - EINVAL ; } render = kcalloc ( 1 , sizeof ( * render ) , GFP_KERNEL ) ; if ( ! render ) return - ENOMEM ; render -> start = args -> rcl_start ; render -> end = args -> rcl_end ; INIT_LIST_HEAD ( & render -> unref_list ) ; ret = v3d_job_init ( v3d , file_priv , & render -> base , v3d_render_job_free , args -> in_sync_rcl ) ; if ( ret ) { kfree ( render ) ; return ret ; } if ( args -> bcl_start != args -> bcl_end ) { bin = kcalloc ( 1 , sizeof ( * bin ) , GFP_KERNEL ) ; <S2SV_StartBug> if ( ! bin ) <S2SV_EndBug> return - ENOMEM ; <S2SV_StartBug> ret = v3d_job_init ( v3d , file_priv , & bin -> base , <S2SV_EndBug> v3d_job_free , args -> in_sync_bcl ) ; if ( ret ) { <S2SV_StartBug> v3d_job_put ( & render -> base ) ; <S2SV_EndBug> return ret ; } bin -> start = args -> bcl_start ; bin -> end = args -> bcl_end ; bin -> qma = args -> qma ; bin -> qms = args -> qms ; bin -> qts = args -> qts ; bin -> render = render ; } ret = v3d_lookup_bos ( dev , file_priv , & render -> base , args -> bo_handles , args -> bo_handle_count ) ; if ( ret ) goto fail ; ret = v3d_lock_bo_reservations ( & render -> base , & acquire_ctx ) ; if ( ret ) goto fail ; mutex_lock ( & v3d -> sched_lock ) ; if ( bin ) { ret = v3d_push_job ( v3d_priv , & bin -> base , V3D_BIN ) ; if ( ret ) goto fail_unreserve ; ret = drm_gem_fence_array_add ( & render -> base . deps , dma_fence_get ( bin -> base . done_fence ) ) ; if ( ret ) goto fail_unreserve ; } ret = v3d_push_job ( v3d_priv , & render -> base , V3D_RENDER ) ; if ( ret ) goto fail_unreserve ; mutex_unlock ( & v3d -> sched_lock ) ; v3d_attach_fences_and_unlock_reservation ( file_priv , & render -> base , & acquire_ctx , args -> out_sync , render -> base . done_fence ) ; if ( bin ) v3d_job_put ( & bin -> base ) ; v3d_job_put ( & render -> base ) ; return 0 ; fail_unreserve : mutex_unlock ( & v3d -> sched_lock ) ; drm_gem_unlock_reservations ( render -> base . bo , render -> base . bo_count , & acquire_ctx ) ; fail : if ( bin ) v3d_job_put ( & bin -> base ) ; v3d_job_put ( & render -> base ) ; return ret ; }",<S2SV_ModStart> ! bin ) { v3d_job_put ( & render -> base ) ; <S2SV_ModStart> - ENOMEM ; } <S2SV_ModStart> render -> base ) ; kfree ( bin,torvalds@linux/29cd13cfd7624726d9e6becbae9aa419ef35af7f,CVE-2019-19044,https://github.com/torvalds/linux/commit/29cd13cfd7624726d9e6becbae9aa419ef35af7f,2019-11-18T06:15Z
CWE-362,"CWE-362 static struct page * follow_page_pte ( struct vm_area_struct * vma , unsigned long address , pmd_t * pmd , unsigned int flags ) { struct mm_struct * mm = vma -> vm_mm ; struct dev_pagemap * pgmap = NULL ; struct page * page ; spinlock_t * ptl ; pte_t * ptep , pte ; retry : if ( unlikely ( pmd_bad ( * pmd ) ) ) return no_page_table ( vma , flags ) ; ptep = pte_offset_map_lock ( mm , pmd , address , & ptl ) ; pte = * ptep ; if ( ! pte_present ( pte ) ) { swp_entry_t entry ; if ( likely ( ! ( flags & FOLL_MIGRATION ) ) ) goto no_page ; if ( pte_none ( pte ) ) goto no_page ; entry = pte_to_swp_entry ( pte ) ; if ( ! is_migration_entry ( entry ) ) goto no_page ; pte_unmap_unlock ( ptep , ptl ) ; migration_entry_wait ( mm , pmd , address ) ; goto retry ; } if ( ( flags & FOLL_NUMA ) && pte_protnone ( pte ) ) goto no_page ; <S2SV_StartBug> if ( ( flags & FOLL_WRITE ) && ! pte_write ( pte ) ) { <S2SV_EndBug> pte_unmap_unlock ( ptep , ptl ) ; return NULL ; } page = vm_normal_page ( vma , address , pte ) ; if ( ! page && pte_devmap ( pte ) && ( flags & FOLL_GET ) ) { pgmap = get_dev_pagemap ( pte_pfn ( pte ) , NULL ) ; if ( pgmap ) page = pte_page ( pte ) ; else goto no_page ; } else if ( unlikely ( ! page ) ) { if ( flags & FOLL_DUMP ) { page = ERR_PTR ( - EFAULT ) ; goto out ; } if ( is_zero_pfn ( pte_pfn ( pte ) ) ) { page = pte_page ( pte ) ; } else { int ret ; ret = follow_pfn_pte ( vma , address , ptep , flags ) ; page = ERR_PTR ( ret ) ; goto out ; } } if ( flags & FOLL_SPLIT && PageTransCompound ( page ) ) { int ret ; get_page ( page ) ; pte_unmap_unlock ( ptep , ptl ) ; lock_page ( page ) ; ret = split_huge_page ( page ) ; unlock_page ( page ) ; put_page ( page ) ; if ( ret ) return ERR_PTR ( ret ) ; goto retry ; } if ( flags & FOLL_GET ) { get_page ( page ) ; if ( pgmap ) { put_dev_pagemap ( pgmap ) ; pgmap = NULL ; } } if ( flags & FOLL_TOUCH ) { if ( ( flags & FOLL_WRITE ) && ! pte_dirty ( pte ) && ! PageDirty ( page ) ) set_page_dirty ( page ) ; mark_page_accessed ( page ) ; } if ( ( flags & FOLL_MLOCK ) && ( vma -> vm_flags & VM_LOCKED ) ) { if ( PageTransCompound ( page ) ) goto out ; if ( page -> mapping && trylock_page ( page ) ) { lru_add_drain ( ) ; mlock_vma_page ( page ) ; unlock_page ( page ) ; } } out : pte_unmap_unlock ( ptep , ptl ) ; return page ; no_page : pte_unmap_unlock ( ptep , ptl ) ; if ( ! pte_none ( pte ) ) return NULL ; return no_page_table ( vma , flags ) ; }","<S2SV_ModStart> ) && ! can_follow_write_pte ( pte , flags <S2SV_ModEnd> ) ) {",torvalds@linux/19be0eaffa3ac7d8eb6784ad9bdbc7d67ed8e619,CVE-2016-5195,https://github.com/torvalds/linux/commit/19be0eaffa3ac7d8eb6784ad9bdbc7d67ed8e619,2016-11-10T21:59Z
CWE-125,"CWE-125 <S2SV_StartBug> int ntlm_read_message_fields_buffer ( wStream * s , NTLM_MESSAGE_FIELDS * fields ) <S2SV_EndBug> { if ( fields -> Len > 0 ) { <S2SV_StartBug> if ( ( fields -> BufferOffset + fields -> Len ) > Stream_Length ( s ) ) <S2SV_EndBug> return - 1 ; fields -> Buffer = ( PBYTE ) malloc ( fields -> Len ) ; if ( ! fields -> Buffer ) return - 1 ; Stream_SetPosition ( s , fields -> BufferOffset ) ; Stream_Read ( s , fields -> Buffer , fields -> Len ) ; } return 1 ; }",<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModStart> 0 ) { const UINT64 offset = ( UINT64 ) <S2SV_ModEnd> fields -> BufferOffset <S2SV_ModStart> -> BufferOffset + ( UINT64 ) <S2SV_ModStart> fields -> Len ; if ( offset <S2SV_ModEnd> > Stream_Length (,FreeRDP@FreeRDP/2ee663f39dc8dac3d9988e847db19b2d7e3ac8c6,CVE-2018-8789,https://github.com/FreeRDP/FreeRDP/commit/2ee663f39dc8dac3d9988e847db19b2d7e3ac8c6,2018-11-29T18:29Z
CWE-120,"CWE-000 void M_LoadDefaults ( void ) { int i ; int len ; FILE * f ; char def [ 80 ] ; char strparm [ 100 ] ; char * newstring ; int parm ; boolean isstring ; numdefaults = sizeof ( defaults ) / sizeof ( defaults [ 0 ] ) ; for ( i = 0 ; i < numdefaults ; i ++ ) * defaults [ i ] . location = defaults [ i ] . defaultvalue ; i = M_CheckParm ( ""-config"" ) ; if ( i && i < myargc - 1 ) { defaultfile = myargv [ i + 1 ] ; printf ( ""\tdefault<S2SV_blank>file:<S2SV_blank>%s\\n"" , defaultfile ) ; } else defaultfile = basedefault ; f = fopen ( defaultfile , ""r"" ) ; if ( f ) { while ( ! feof ( f ) ) { isstring = false ; <S2SV_StartBug> if ( fscanf ( f , ""%79s<S2SV_blank>%[^\\n]\\n"" , def , strparm ) == 2 ) <S2SV_EndBug> { if ( strparm [ 0 ] == \'""\' ) { isstring = true ; len = strlen ( strparm ) ; newstring = ( char * ) malloc ( len ) ; strparm [ len - 1 ] = 0 ; strcpy ( newstring , strparm + 1 ) ; } else if ( strparm [ 0 ] == '0' && strparm [ 1 ] == 'x' ) sscanf ( strparm + 2 , ""%x"" , & parm ) ; else sscanf ( strparm , ""%i"" , & parm ) ; for ( i = 0 ; i < numdefaults ; i ++ ) if ( ! strcmp ( def , defaults [ i ] . name ) ) { if ( ! isstring ) * defaults [ i ] . location = parm ; else * defaults [ i ] . location = ( int ) newstring ; break ; } } } fclose ( f ) ; } for ( i = 0 ; i < numdefaults ; i ++ ) { if ( defaults [ i ] . scantranslate ) { parm = * defaults [ i ] . location ; defaults [ i ] . untranslated = parm ; * defaults [ i ] . location = scantokey [ parm ] ; } } }","<S2SV_ModStart> ( f , ""%79s<S2SV_blank>%99[^\\n]\\n"" <S2SV_ModEnd> , def ,",AXDOOMER@doom-vanille/8a6d9a02fa991a91ff90ccdc73b5ceabaa6cb9ec,CVE-2020-15007,https://github.com/AXDOOMER/doom-vanille/commit/8a6d9a02fa991a91ff90ccdc73b5ceabaa6cb9ec,2020-06-24T11:15Z
CWE-399,"CWE-399 int kvm_arch_vcpu_init ( struct kvm_vcpu * vcpu ) { struct page * page ; struct kvm * kvm ; int r ; BUG_ON ( vcpu -> kvm == NULL ) ; kvm = vcpu -> kvm ; vcpu -> arch . emulate_ctxt . ops = & emulate_ops ; if ( ! irqchip_in_kernel ( kvm ) || kvm_vcpu_is_bsp ( vcpu ) ) vcpu -> arch . mp_state = KVM_MP_STATE_RUNNABLE ; else vcpu -> arch . mp_state = KVM_MP_STATE_UNINITIALIZED ; page = alloc_page ( GFP_KERNEL | __GFP_ZERO ) ; if ( ! page ) { r = - ENOMEM ; goto fail ; } vcpu -> arch . pio_data = page_address ( page ) ; kvm_set_tsc_khz ( vcpu , max_tsc_khz ) ; r = kvm_mmu_create ( vcpu ) ; if ( r < 0 ) goto fail_free_pio_data ; if ( irqchip_in_kernel ( kvm ) ) { r = kvm_create_lapic ( vcpu ) ; if ( r < 0 ) goto fail_mmu_destroy ; } else static_key_slow_inc ( & kvm_no_apic_vcpu ) ; vcpu -> arch . mce_banks = kzalloc ( KVM_MAX_MCE_BANKS * sizeof ( u64 ) * 4 , GFP_KERNEL ) ; if ( ! vcpu -> arch . mce_banks ) { r = - ENOMEM ; goto fail_free_lapic ; } vcpu -> arch . mcg_cap = KVM_MAX_MCE_BANKS ; if ( ! zalloc_cpumask_var ( & vcpu -> arch . wbinvd_dirty_mask , GFP_KERNEL ) ) goto fail_free_mce_banks ; r = fx_init ( vcpu ) ; if ( r ) goto fail_free_wbinvd_dirty_mask ; vcpu -> arch . ia32_tsc_adjust_msr = 0x0 ; <S2SV_StartBug> kvm_async_pf_hash_reset ( vcpu ) ; <S2SV_EndBug> kvm_pmu_init ( vcpu ) ; return 0 ; fail_free_wbinvd_dirty_mask : free_cpumask_var ( vcpu -> arch . wbinvd_dirty_mask ) ; fail_free_mce_banks : kfree ( vcpu -> arch . mce_banks ) ; fail_free_lapic : kvm_free_lapic ( vcpu ) ; fail_mmu_destroy : kvm_mmu_destroy ( vcpu ) ; fail_free_pio_data : free_page ( ( unsigned long ) vcpu -> arch . pio_data ) ; fail : return r ; }",<S2SV_ModStart> = 0x0 ; vcpu -> arch . pv_time_enabled = false ;,torvalds@linux/0b79459b482e85cb7426aa7da683a9f2c97aeae1,CVE-2013-1797,https://github.com/torvalds/linux/commit/0b79459b482e85cb7426aa7da683a9f2c97aeae1,2013-03-22T11:59Z
CWE-119,"CWE-119 static int mark_source_chains ( const struct xt_table_info * newinfo , unsigned int valid_hooks , void * entry0 ) { unsigned int hook ; for ( hook = 0 ; hook < NF_INET_NUMHOOKS ; hook ++ ) { unsigned int pos = newinfo -> hook_entry [ hook ] ; struct ip6t_entry * e = ( struct ip6t_entry * ) ( entry0 + pos ) ; if ( ! ( valid_hooks & ( 1 << hook ) ) ) continue ; e -> counters . pcnt = pos ; for ( ; ; ) { const struct xt_standard_target * t = ( void * ) ip6t_get_target_c ( e ) ; int visited = e -> comefrom & ( 1 << hook ) ; if ( e -> comefrom & ( 1 << NF_INET_NUMHOOKS ) ) { pr_err ( ""iptables:<S2SV_blank>loop<S2SV_blank>hook<S2SV_blank>%u<S2SV_blank>pos<S2SV_blank>%u<S2SV_blank>%08X.\\n"" , hook , pos , e -> comefrom ) ; return 0 ; } e -> comefrom |= ( ( 1 << hook ) | ( 1 << NF_INET_NUMHOOKS ) ) ; <S2SV_StartBug> if ( ( e -> target_offset == sizeof ( struct ip6t_entry ) && <S2SV_EndBug> ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) && <S2SV_StartBug> t -> verdict < 0 && <S2SV_EndBug> unconditional ( & e -> ipv6 ) ) || visited ) { unsigned int oldpos , size ; if ( ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) && t -> verdict < - NF_MAX_VERDICT - 1 ) { duprintf ( ""mark_source_chains:<S2SV_blank>bad<S2SV_blank>"" ""negative<S2SV_blank>verdict<S2SV_blank>(%i)\\n"" , t -> verdict ) ; return 0 ; } do { e -> comefrom ^= ( 1 << NF_INET_NUMHOOKS ) ; # ifdef DEBUG_IP_FIREWALL_USER if ( e -> comefrom & ( 1 << NF_INET_NUMHOOKS ) ) { duprintf ( ""Back<S2SV_blank>unset<S2SV_blank>"" ""on<S2SV_blank>hook<S2SV_blank>%u<S2SV_blank>"" ""rule<S2SV_blank>%u\\n"" , hook , pos ) ; } # endif oldpos = pos ; pos = e -> counters . pcnt ; e -> counters . pcnt = 0 ; if ( pos == oldpos ) goto next ; e = ( struct ip6t_entry * ) ( entry0 + pos ) ; } while ( oldpos == pos + e -> next_offset ) ; size = e -> next_offset ; e = ( struct ip6t_entry * ) ( entry0 + pos + size ) ; e -> counters . pcnt = pos ; pos += size ; } else { int newpos = t -> verdict ; if ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 && newpos >= 0 ) { if ( newpos > newinfo -> size - sizeof ( struct ip6t_entry ) ) { duprintf ( ""mark_source_chains:<S2SV_blank>"" ""bad<S2SV_blank>verdict<S2SV_blank>(%i)\\n"" , newpos ) ; return 0 ; } duprintf ( ""Jump<S2SV_blank>rule<S2SV_blank>%u<S2SV_blank>-><S2SV_blank>%u\\n"" , pos , newpos ) ; } else { newpos = pos + e -> next_offset ; } e = ( struct ip6t_entry * ) ( entry0 + newpos ) ; e -> counters . pcnt = pos ; pos = newpos ; } } next : duprintf ( ""Finished<S2SV_blank>chain<S2SV_blank>%u\\n"" , hook ) ; } return 1 ; }",<S2SV_ModStart> if ( ( unconditional ( e <S2SV_ModEnd> ) && ( <S2SV_ModStart> verdict < 0 <S2SV_ModEnd> ) || visited,torvalds@linux/54d83fc74aa9ec72794373cb47432c5f7fb1a309,CVE-2016-3134,https://github.com/torvalds/linux/commit/54d83fc74aa9ec72794373cb47432c5f7fb1a309,2016-04-27T17:59Z
CWE-125,"CWE-125 PyObject * ast2obj_alias ( void * _o ) { alias_ty o = ( alias_ty ) _o ; PyObject * result = NULL , * value = NULL ; if ( ! o ) { <S2SV_StartBug> Py_INCREF ( Py_None ) ; <S2SV_EndBug> return Py_None ; } result = PyType_GenericNew ( alias_type , NULL , NULL ) ; if ( ! result ) return NULL ; value = ast2obj_identifier ( o -> name ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_name , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_identifier ( o -> asname ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_asname , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; return result ; failed : Py_XDECREF ( value ) ; Py_XDECREF ( result ) ; return NULL ; }",<S2SV_ModStart> o ) { Py_RETURN_NONE <S2SV_ModEnd> ; } result,python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z
CWE-119,"CWE-119 <S2SV_StartBug> void fdct4_sse2 ( __m128i * in ) { <S2SV_EndBug> <S2SV_StartBug> const __m128i k__cospi_p16_p16 = _mm_set1_epi16 ( cospi_16_64 ) ; <S2SV_EndBug> const __m128i k__cospi_p16_m16 = pair_set_epi16 ( cospi_16_64 , - cospi_16_64 ) ; const __m128i k__cospi_p08_p24 = pair_set_epi16 ( cospi_8_64 , cospi_24_64 ) ; const __m128i k__cospi_p24_m08 = pair_set_epi16 ( cospi_24_64 , - cospi_8_64 ) ; const __m128i k__DCT_CONST_ROUNDING = _mm_set1_epi32 ( DCT_CONST_ROUNDING ) ; __m128i u [ 4 ] , v [ 4 ] ; u [ 0 ] = _mm_unpacklo_epi16 ( in [ 0 ] , in [ 1 ] ) ; u [ 1 ] = _mm_unpacklo_epi16 ( in [ 3 ] , in [ 2 ] ) ; v [ 0 ] = _mm_add_epi16 ( u [ 0 ] , u [ 1 ] ) ; v [ 1 ] = _mm_sub_epi16 ( u [ 0 ] , u [ 1 ] ) ; u [ 0 ] = _mm_madd_epi16 ( v [ 0 ] , k__cospi_p16_p16 ) ; u [ 1 ] = _mm_madd_epi16 ( v [ 0 ] , k__cospi_p16_m16 ) ; u [ 2 ] = _mm_madd_epi16 ( v [ 1 ] , k__cospi_p08_p24 ) ; u [ 3 ] = _mm_madd_epi16 ( v [ 1 ] , k__cospi_p24_m08 ) ; v [ 0 ] = _mm_add_epi32 ( u [ 0 ] , k__DCT_CONST_ROUNDING ) ; v [ 1 ] = _mm_add_epi32 ( u [ 1 ] , k__DCT_CONST_ROUNDING ) ; v [ 2 ] = _mm_add_epi32 ( u [ 2 ] , k__DCT_CONST_ROUNDING ) ; v [ 3 ] = _mm_add_epi32 ( u [ 3 ] , k__DCT_CONST_ROUNDING ) ; u [ 0 ] = _mm_srai_epi32 ( v [ 0 ] , DCT_CONST_BITS ) ; u [ 1 ] = _mm_srai_epi32 ( v [ 1 ] , DCT_CONST_BITS ) ; u [ 2 ] = _mm_srai_epi32 ( v [ 2 ] , DCT_CONST_BITS ) ; u [ 3 ] = _mm_srai_epi32 ( v [ 3 ] , DCT_CONST_BITS ) ; in [ 0 ] = _mm_packs_epi32 ( u [ 0 ] , u [ 1 ] ) ; in [ 1 ] = _mm_packs_epi32 ( u [ 2 ] , u [ 3 ] ) ; transpose_4x4 ( in ) ; }",<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModStart> = _mm_set1_epi16 ( ( int16_t ),external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-20,"CWE-20 static int set_core_reg ( struct kvm_vcpu * vcpu , const struct kvm_one_reg * reg ) { __u32 __user * uaddr = ( __u32 __user * ) ( unsigned long ) reg -> addr ; struct kvm_regs * regs = vcpu_gp_regs ( vcpu ) ; int nr_regs = sizeof ( * regs ) / sizeof ( __u32 ) ; __uint128_t tmp ; void * valp = & tmp ; u64 off ; int err = 0 ; off = core_reg_offset_from_id ( reg -> id ) ; if ( off >= nr_regs || ( off + ( KVM_REG_SIZE ( reg -> id ) / sizeof ( __u32 ) ) ) >= nr_regs ) return - ENOENT ; if ( validate_core_offset ( reg ) ) return - EINVAL ; if ( KVM_REG_SIZE ( reg -> id ) > sizeof ( tmp ) ) return - EINVAL ; if ( copy_from_user ( valp , uaddr , KVM_REG_SIZE ( reg -> id ) ) ) { err = - EFAULT ; goto out ; } if ( off == KVM_REG_ARM_CORE_REG ( regs . pstate ) ) { <S2SV_StartBug> u32 mode = ( * ( u32 * ) valp ) & PSR_AA32_MODE_MASK ; <S2SV_EndBug> switch ( mode ) { case PSR_AA32_MODE_USR : <S2SV_StartBug> case PSR_AA32_MODE_FIQ : <S2SV_EndBug> case PSR_AA32_MODE_IRQ : case PSR_AA32_MODE_SVC : case PSR_AA32_MODE_ABT : case PSR_AA32_MODE_UND : <S2SV_StartBug> case PSR_MODE_EL0t : <S2SV_EndBug> case PSR_MODE_EL1t : <S2SV_StartBug> case PSR_MODE_EL1h : <S2SV_EndBug> break ; default : err = - EINVAL ; goto out ; } } memcpy ( ( u32 * ) regs + off , valp , KVM_REG_SIZE ( reg -> id ) ) ; out : return err ; }",<S2SV_ModStart> ) ) { u64 <S2SV_ModEnd> mode = ( <S2SV_ModStart> ( * ( u64 <S2SV_ModEnd> * ) valp <S2SV_ModStart> case PSR_AA32_MODE_USR : if ( ! system_supports_32bit_el0 ( ) ) return - EINVAL ; break ; <S2SV_ModStart> case PSR_AA32_MODE_UND : if ( ! vcpu_el1_is_32bit ( vcpu ) ) return - EINVAL ; break ; <S2SV_ModStart> case PSR_MODE_EL1h : if ( vcpu_el1_is_32bit ( vcpu ) ) return - EINVAL ;,torvalds@linux/2a3f93459d689d990b3ecfbe782fec89b97d3279,CVE-2018-18021,https://github.com/torvalds/linux/commit/2a3f93459d689d990b3ecfbe782fec89b97d3279,2018-10-07T06:29Z
CWE-399,"CWE-399 static void free_huge_page ( struct page * page ) { struct hstate * h = page_hstate ( page ) ; int nid = page_to_nid ( page ) ; <S2SV_StartBug> struct address_space * mapping ; <S2SV_EndBug> mapping = ( struct address_space * ) page_private ( page ) ; set_page_private ( page , 0 ) ; page -> mapping = NULL ; BUG_ON ( page_count ( page ) ) ; BUG_ON ( page_mapcount ( page ) ) ; INIT_LIST_HEAD ( & page -> lru ) ; spin_lock ( & hugetlb_lock ) ; if ( h -> surplus_huge_pages_node [ nid ] && huge_page_order ( h ) < MAX_ORDER ) { update_and_free_page ( h , page ) ; h -> surplus_huge_pages -- ; h -> surplus_huge_pages_node [ nid ] -- ; } else { enqueue_huge_page ( h , page ) ; } spin_unlock ( & hugetlb_lock ) ; <S2SV_StartBug> if ( mapping ) <S2SV_EndBug> hugetlb_put_quota ( mapping , 1 ) ; }","<S2SV_ModStart> ) ; struct hugepage_subpool * spool = ( struct hugepage_subpool <S2SV_ModEnd> * ) page_private <S2SV_ModStart> hugetlb_lock ) ; hugepage_subpool_put_pages ( spool <S2SV_ModEnd> , 1 )",torvalds@linux/90481622d75715bfcb68501280a917dbfe516029,CVE-2012-2133,https://github.com/torvalds/linux/commit/90481622d75715bfcb68501280a917dbfe516029,2012-07-03T16:40Z
CWE-362,"CWE-362 long keyctl_read_key ( key_serial_t keyid , char __user * buffer , size_t buflen ) { struct key * key ; key_ref_t key_ref ; long ret ; key_ref = lookup_user_key ( keyid , 0 , 0 ) ; if ( IS_ERR ( key_ref ) ) { ret = - ENOKEY ; goto error ; } key = key_ref_to_ptr ( key_ref ) ; ret = key_permission ( key_ref , KEY_NEED_READ ) ; if ( ret == 0 ) goto can_read_key ; if ( ret != - EACCES ) goto error ; if ( ! is_key_possessed ( key_ref ) ) { ret = - EACCES ; goto error2 ; } can_read_key : <S2SV_StartBug> ret = key_validate ( key ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ret == 0 ) { <S2SV_EndBug> ret = - EOPNOTSUPP ; <S2SV_StartBug> if ( key -> type -> read ) { <S2SV_EndBug> down_read ( & key -> sem ) ; <S2SV_StartBug> ret = key -> type -> read ( key , buffer , buflen ) ; <S2SV_EndBug> up_read ( & key -> sem ) ; } } error2 : key_put ( key ) ; error : return ret ; }","<S2SV_ModStart> : ret = - EOPNOTSUPP ; if ( key -> type -> read ) { down_read ( & key -> sem ) ; ret = <S2SV_ModStart> == 0 ) ret = <S2SV_ModEnd> key -> type <S2SV_ModStart> type -> read ( key , buffer , buflen ) ; up_read <S2SV_ModEnd> ( & key <S2SV_ModStart> sem ) ; <S2SV_ModEnd> } error2 :",torvalds@linux/b4a1b4f5047e4f54e194681125c74c0aa64d637d,CVE-2015-7550,https://github.com/torvalds/linux/commit/b4a1b4f5047e4f54e194681125c74c0aa64d637d,2016-02-08T03:59Z
CWE-59,"CWE-000 static int mount_entry ( const char * fsname , const char * target , const char * fstype , unsigned long mountflags , <S2SV_StartBug> const char * data , int optional ) <S2SV_EndBug> { # ifdef HAVE_STATVFS struct statvfs sb ; # endif <S2SV_StartBug> if ( mount ( fsname , target , fstype , mountflags & ~ MS_REMOUNT , data ) ) { <S2SV_EndBug> if ( optional ) { INFO ( ""failed<S2SV_blank>to<S2SV_blank>mount<S2SV_blank>\'%s\'<S2SV_blank>on<S2SV_blank>\'%s\'<S2SV_blank>(optional):<S2SV_blank>%s"" , fsname , target , strerror ( errno ) ) ; return 0 ; } else { SYSERROR ( ""failed<S2SV_blank>to<S2SV_blank>mount<S2SV_blank>\'%s\'<S2SV_blank>on<S2SV_blank>\'%s\'"" , fsname , target ) ; return - 1 ; } } if ( ( mountflags & MS_REMOUNT ) || ( mountflags & MS_BIND ) ) { DEBUG ( ""remounting<S2SV_blank>%s<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>respect<S2SV_blank>bind<S2SV_blank>or<S2SV_blank>remount<S2SV_blank>options"" , fsname ? fsname : ""(none)"" , target ? target : ""(none)"" ) ; unsigned long rqd_flags = 0 ; if ( mountflags & MS_RDONLY ) rqd_flags |= MS_RDONLY ; # ifdef HAVE_STATVFS if ( statvfs ( fsname , & sb ) == 0 ) { unsigned long required_flags = rqd_flags ; if ( sb . f_flag & MS_NOSUID ) required_flags |= MS_NOSUID ; if ( sb . f_flag & MS_NODEV ) required_flags |= MS_NODEV ; if ( sb . f_flag & MS_RDONLY ) required_flags |= MS_RDONLY ; if ( sb . f_flag & MS_NOEXEC ) required_flags |= MS_NOEXEC ; DEBUG ( ""(at<S2SV_blank>remount)<S2SV_blank>flags<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>was<S2SV_blank>%lu,<S2SV_blank>required<S2SV_blank>extra<S2SV_blank>flags<S2SV_blank>are<S2SV_blank>%lu"" , fsname , sb . f_flag , required_flags ) ; if ( ! ( mountflags & MS_REMOUNT ) ) { if ( ! ( required_flags & ~ mountflags ) && rqd_flags == 0 ) { DEBUG ( ""mountflags<S2SV_blank>already<S2SV_blank>was<S2SV_blank>%lu,<S2SV_blank>skipping<S2SV_blank>remount"" , mountflags ) ; goto skipremount ; } } mountflags |= required_flags ; } # endif if ( mount ( fsname , target , fstype , <S2SV_StartBug> mountflags | MS_REMOUNT , data ) ) { <S2SV_EndBug> if ( optional ) { INFO ( ""failed<S2SV_blank>to<S2SV_blank>mount<S2SV_blank>\'%s\'<S2SV_blank>on<S2SV_blank>\'%s\'<S2SV_blank>(optional):<S2SV_blank>%s"" , fsname , target , strerror ( errno ) ) ; return 0 ; } else { SYSERROR ( ""failed<S2SV_blank>to<S2SV_blank>mount<S2SV_blank>\'%s\'<S2SV_blank>on<S2SV_blank>\'%s\'"" , fsname , target ) ; return - 1 ; } } } # ifdef HAVE_STATVFS skipremount : # endif DEBUG ( ""mounted<S2SV_blank>\'%s\'<S2SV_blank>on<S2SV_blank>\'%s\',<S2SV_blank>type<S2SV_blank>\'%s\'"" , fsname , target , fstype ) ; return 0 ; }","<S2SV_ModStart> , int optional , const char * rootfs <S2SV_ModStart> endif if ( safe_mount <S2SV_ModEnd> ( fsname , <S2SV_ModStart> MS_REMOUNT , data , rootfs <S2SV_ModStart> , data ) < 0",lxc@lxc/592fd47a6245508b79fe6ac819fe6d3b2c1289be,CVE-2015-1335,https://github.com/lxc/lxc/commit/592fd47a6245508b79fe6ac819fe6d3b2c1289be,2015-10-01T20:59Z
CWE-401,"CWE-000 int crypto_reportstat ( struct sk_buff * in_skb , struct nlmsghdr * in_nlh , struct nlattr * * attrs ) { struct net * net = sock_net ( in_skb -> sk ) ; struct crypto_user_alg * p = nlmsg_data ( in_nlh ) ; struct crypto_alg * alg ; struct sk_buff * skb ; struct crypto_dump_info info ; int err ; if ( ! null_terminated ( p -> cru_name ) || ! null_terminated ( p -> cru_driver_name ) ) return - EINVAL ; alg = crypto_alg_match ( p , 0 ) ; if ( ! alg ) return - ENOENT ; err = - ENOMEM ; skb = nlmsg_new ( NLMSG_DEFAULT_SIZE , GFP_ATOMIC ) ; if ( ! skb ) goto drop_alg ; info . in_skb = in_skb ; info . out_skb = skb ; info . nlmsg_seq = in_nlh -> nlmsg_seq ; info . nlmsg_flags = 0 ; err = crypto_reportstat_alg ( alg , & info ) ; drop_alg : crypto_mod_put ( alg ) ; if ( err ) <S2SV_StartBug> return err ; <S2SV_EndBug> return nlmsg_unicast ( net -> crypto_nlsk , skb , NETLINK_CB ( in_skb ) . portid ) ; }",<S2SV_ModStart> ( err ) { kfree_skb ( skb ) ; return err ; } <S2SV_ModEnd> return nlmsg_unicast (,torvalds@linux/c03b04dcdba1da39903e23cc4d072abf8f68f2dd,CVE-2019-19050,https://github.com/torvalds/linux/commit/c03b04dcdba1da39903e23cc4d072abf8f68f2dd,2019-11-18T06:15Z
CWE-400,"CWE-000 static int nghttp2_session_upgrade_internal ( nghttp2_session * session , const uint8_t * settings_payload , size_t settings_payloadlen , void * stream_user_data ) { nghttp2_stream * stream ; nghttp2_frame frame ; nghttp2_settings_entry * iv ; size_t niv ; int rv ; nghttp2_priority_spec pri_spec ; nghttp2_mem * mem ; mem = & session -> mem ; if ( ( ! session -> server && session -> next_stream_id != 1 ) || ( session -> server && session -> last_recv_stream_id >= 1 ) ) { return NGHTTP2_ERR_PROTO ; } if ( settings_payloadlen % NGHTTP2_FRAME_SETTINGS_ENTRY_LENGTH ) { <S2SV_StartBug> return NGHTTP2_ERR_INVALID_ARGUMENT ; <S2SV_EndBug> } rv = nghttp2_frame_unpack_settings_payload2 ( & iv , & niv , settings_payload , settings_payloadlen , mem ) ; if ( rv != 0 ) { return rv ; } if ( session -> server ) { nghttp2_frame_hd_init ( & frame . hd , settings_payloadlen , NGHTTP2_SETTINGS , NGHTTP2_FLAG_NONE , 0 ) ; frame . settings . iv = iv ; frame . settings . niv = niv ; rv = nghttp2_session_on_settings_received ( session , & frame , 1 ) ; } else { rv = nghttp2_submit_settings ( session , NGHTTP2_FLAG_NONE , iv , niv ) ; } nghttp2_mem_free ( mem , iv ) ; if ( rv != 0 ) { return rv ; } nghttp2_priority_spec_default_init ( & pri_spec ) ; stream = nghttp2_session_open_stream ( session , 1 , NGHTTP2_STREAM_FLAG_NONE , & pri_spec , NGHTTP2_STREAM_OPENING , session -> server ? NULL : stream_user_data ) ; if ( stream == NULL ) { return NGHTTP2_ERR_NOMEM ; } if ( session -> server ) { nghttp2_stream_shutdown ( stream , NGHTTP2_SHUT_RD ) ; session -> last_recv_stream_id = 1 ; session -> last_proc_stream_id = 1 ; } else { nghttp2_stream_shutdown ( stream , NGHTTP2_SHUT_WR ) ; session -> last_sent_stream_id = 1 ; session -> next_stream_id += 2 ; } return 0 ; }",<S2SV_ModStart> { return NGHTTP2_ERR_INVALID_ARGUMENT ; } if ( settings_payloadlen / NGHTTP2_FRAME_SETTINGS_ENTRY_LENGTH > session -> max_settings ) { return NGHTTP2_ERR_TOO_MANY_SETTINGS,nghttp2@nghttp2/336a98feb0d56b9ac54e12736b18785c27f75090,CVE-2020-11080,https://github.com/nghttp2/nghttp2/commit/336a98feb0d56b9ac54e12736b18785c27f75090,2020-06-03T23:15Z
CWE-617,"CWE-000 static void pci_bus_write_dsdt ( int bus ) { struct businfo * bi ; struct slotinfo * si ; struct pci_vdev * dev ; int count , func , slot ; bi = pci_businfo [ bus ] ; if ( bi == NULL ) { if ( bus != 0 ) return ; } dsdt_line ( ""<S2SV_blank><S2SV_blank>Device<S2SV_blank>(PCI%01X)"" , bus ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank>{"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Name<S2SV_blank>(_HID,<S2SV_blank>EisaId<S2SV_blank>(\\""PNP0A03\\""))"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Name<S2SV_blank>(_ADR,<S2SV_blank>Zero)"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Method<S2SV_blank>(_BBN,<S2SV_blank>0,<S2SV_blank>NotSerialized)"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>{"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Return<S2SV_blank>(0x%08X)"" , bus ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Name<S2SV_blank>(_CRS,<S2SV_blank>ResourceTemplate<S2SV_blank>()"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>{"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>WordBusNumber<S2SV_blank>(ResourceProducer,<S2SV_blank>MinFixed,<S2SV_blank>"" ""MaxFixed,<S2SV_blank>PosDecode,"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x0000,<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>//<S2SV_blank>Granularity"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x%04X,<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>//<S2SV_blank>Range<S2SV_blank>Minimum"" , bus ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x%04X,<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>//<S2SV_blank>Range<S2SV_blank>Maximum"" , bus ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x0000,<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>//<S2SV_blank>Translation<S2SV_blank>Offset"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x0001,<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>//<S2SV_blank>Length"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>,,<S2SV_blank>)"" ) ; if ( bus == 0 ) { dsdt_indent ( 3 ) ; dsdt_fixed_ioport ( 0xCF8 , 8 ) ; dsdt_unindent ( 3 ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>WordIO<S2SV_blank>(ResourceProducer,<S2SV_blank>MinFixed,<S2SV_blank>MaxFixed,<S2SV_blank>"" ""PosDecode,<S2SV_blank>EntireRange,"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x0000,<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>//<S2SV_blank>Granularity"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x0000,<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>//<S2SV_blank>Range<S2SV_blank>Minimum"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x0CF7,<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>//<S2SV_blank>Range<S2SV_blank>Maximum"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x0000,<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>//<S2SV_blank>Translation<S2SV_blank>Offset"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x0CF8,<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>//<S2SV_blank>Length"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>,,<S2SV_blank>,<S2SV_blank>TypeStatic)"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>WordIO<S2SV_blank>(ResourceProducer,<S2SV_blank>MinFixed,<S2SV_blank>MaxFixed,<S2SV_blank>"" ""PosDecode,<S2SV_blank>EntireRange,"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x0000,<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>//<S2SV_blank>Granularity"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x0D00,<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>//<S2SV_blank>Range<S2SV_blank>Minimum"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x%04X,<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>//<S2SV_blank>Range<S2SV_blank>Maximum"" , PCI_EMUL_IOBASE - 1 ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x0000,<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>//<S2SV_blank>Translation<S2SV_blank>Offset"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x%04X,<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>//<S2SV_blank>Length"" , PCI_EMUL_IOBASE - 0x0D00 ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>,,<S2SV_blank>,<S2SV_blank>TypeStatic)"" ) ; if ( bi == NULL ) { dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>})"" ) ; goto done ; } } <S2SV_StartBug> assert ( bi != NULL ) ; <S2SV_EndBug> dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>WordIO<S2SV_blank>(ResourceProducer,<S2SV_blank>MinFixed,<S2SV_blank>MaxFixed,<S2SV_blank>"" ""PosDecode,<S2SV_blank>EntireRange,"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x0000,<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>//<S2SV_blank>Granularity"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x%04X,<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>//<S2SV_blank>Range<S2SV_blank>Minimum"" , bi -> iobase ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x%04X,<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>//<S2SV_blank>Range<S2SV_blank>Maximum"" , bi -> iolimit - 1 ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x0000,<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>//<S2SV_blank>Translation<S2SV_blank>Offset"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x%04X,<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>//<S2SV_blank>Length"" , bi -> iolimit - bi -> iobase ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>,,<S2SV_blank>,<S2SV_blank>TypeStatic)"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>DWordMemory<S2SV_blank>(ResourceProducer,<S2SV_blank>PosDecode,<S2SV_blank>"" ""MinFixed,<S2SV_blank>MaxFixed,<S2SV_blank>NonCacheable,<S2SV_blank>ReadWrite,"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x00000000,<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>//<S2SV_blank>Granularity"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x%08X,<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>//<S2SV_blank>Range<S2SV_blank>Minimum\\n"" , bi -> membase32 ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x%08X,<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>//<S2SV_blank>Range<S2SV_blank>Maximum\\n"" , bi -> memlimit32 - 1 ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x00000000,<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>//<S2SV_blank>Translation<S2SV_blank>Offset"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x%08X,<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>//<S2SV_blank>Length\\n"" , bi -> memlimit32 - bi -> membase32 ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>,,<S2SV_blank>,<S2SV_blank>AddressRangeMemory,<S2SV_blank>TypeStatic)"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>QWordMemory<S2SV_blank>(ResourceProducer,<S2SV_blank>PosDecode,<S2SV_blank>"" ""MinFixed,<S2SV_blank>MaxFixed,<S2SV_blank>NonCacheable,<S2SV_blank>ReadWrite,"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x0000000000000000,<S2SV_blank>//<S2SV_blank>Granularity"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x%016lX,<S2SV_blank>//<S2SV_blank>Range<S2SV_blank>Minimum\\n"" , bi -> membase64 ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x%016lX,<S2SV_blank>//<S2SV_blank>Range<S2SV_blank>Maximum\\n"" , bi -> memlimit64 - 1 ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x0000000000000000,<S2SV_blank>//<S2SV_blank>Translation<S2SV_blank>Offset"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x%016lX,<S2SV_blank>//<S2SV_blank>Length\\n"" , bi -> memlimit64 - bi -> membase64 ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>,,<S2SV_blank>,<S2SV_blank>AddressRangeMemory,<S2SV_blank>TypeStatic)"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>})"" ) ; if ( ! is_rtvm ) { count = pci_count_lintr ( bus ) ; if ( count != 0 ) { dsdt_indent ( 2 ) ; dsdt_line ( ""Name<S2SV_blank>(PPRT,<S2SV_blank>Package<S2SV_blank>()"" ) ; dsdt_line ( ""{"" ) ; pci_walk_lintr ( bus , pci_pirq_prt_entry , NULL ) ; dsdt_line ( ""})"" ) ; dsdt_line ( ""Name<S2SV_blank>(APRT,<S2SV_blank>Package<S2SV_blank>()"" ) ; dsdt_line ( ""{"" ) ; pci_walk_lintr ( bus , pci_apic_prt_entry , NULL ) ; dsdt_line ( ""})"" ) ; dsdt_line ( ""Method<S2SV_blank>(_PRT,<S2SV_blank>0,<S2SV_blank>NotSerialized)"" ) ; dsdt_line ( ""{"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank>If<S2SV_blank>(PICM)"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank>{"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Return<S2SV_blank>(APRT)"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank>}"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank>Else"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank>{"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Return<S2SV_blank>(PPRT)"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank>}"" ) ; dsdt_line ( ""}"" ) ; dsdt_unindent ( 2 ) ; } } dsdt_indent ( 2 ) ; for ( slot = 0 ; slot < MAXSLOTS ; slot ++ ) { si = & bi -> slotinfo [ slot ] ; for ( func = 0 ; func < MAXFUNCS ; func ++ ) { dev = si -> si_funcs [ func ] . fi_devi ; if ( dev != NULL && dev -> dev_ops -> vdev_write_dsdt != NULL ) dev -> dev_ops -> vdev_write_dsdt ( dev ) ; } } dsdt_unindent ( 2 ) ; done : dsdt_line ( ""<S2SV_blank><S2SV_blank>}"" ) ; }","<S2SV_ModStart> ; } } <S2SV_ModEnd> dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>WordIO<S2SV_blank>(ResourceProducer,<S2SV_blank>MinFixed,<S2SV_blank>MaxFixed,<S2SV_blank>""",projectacrn@acrn-hypervisor/2b3dedfb9ba13f15887f22b935d373f36c9a59fa,CVE-2019-18844,https://github.com/projectacrn/acrn-hypervisor/commit/2b3dedfb9ba13f15887f22b935d373f36c9a59fa,2019-11-13T20:15Z
CWE-119,"CWE-119 const char * util_acl_to_str ( const sc_acl_entry_t * e ) { static char line [ 80 ] , buf [ 20 ] ; unsigned int acl ; if ( e == NULL ) return ""N/A"" ; line [ 0 ] = 0 ; while ( e != NULL ) { acl = e -> method ; switch ( acl ) { case SC_AC_UNKNOWN : return ""N/A"" ; case SC_AC_NEVER : return ""NEVR"" ; case SC_AC_NONE : return ""NONE"" ; case SC_AC_CHV : strcpy ( buf , ""CHV"" ) ; if ( e -> key_ref != SC_AC_KEY_REF_NONE ) sprintf ( buf + 3 , ""%d"" , e -> key_ref ) ; break ; case SC_AC_TERM : strcpy ( buf , ""TERM"" ) ; break ; case SC_AC_PRO : strcpy ( buf , ""PROT"" ) ; break ; case SC_AC_AUT : strcpy ( buf , ""AUTH"" ) ; if ( e -> key_ref != SC_AC_KEY_REF_NONE ) sprintf ( buf + 4 , ""%d"" , e -> key_ref ) ; break ; case SC_AC_SEN : strcpy ( buf , ""Sec.Env.<S2SV_blank>"" ) ; if ( e -> key_ref != SC_AC_KEY_REF_NONE ) sprintf ( buf + 3 , ""#%d"" , e -> key_ref ) ; break ; case SC_AC_SCB : strcpy ( buf , ""Sec.ControlByte<S2SV_blank>"" ) ; if ( e -> key_ref != SC_AC_KEY_REF_NONE ) sprintf ( buf + 3 , ""Ox%X"" , e -> key_ref ) ; break ; case SC_AC_IDA : strcpy ( buf , ""PKCS#15<S2SV_blank>AuthID<S2SV_blank>"" ) ; if ( e -> key_ref != SC_AC_KEY_REF_NONE ) sprintf ( buf + 3 , ""#%d"" , e -> key_ref ) ; break ; default : strcpy ( buf , ""????"" ) ; break ; } <S2SV_StartBug> strcat ( line , buf ) ; <S2SV_EndBug> <S2SV_StartBug> strcat ( line , ""<S2SV_blank>"" ) ; <S2SV_EndBug> e = e -> next ; } <S2SV_StartBug> line [ strlen ( line ) - 1 ] = 0 ; <S2SV_EndBug> return line ; }","<S2SV_ModStart> break ; } strncat ( line , buf , sizeof line ) ; strncat <S2SV_ModEnd> ( line , <S2SV_ModStart> line , ""<S2SV_blank>"" , sizeof line <S2SV_ModStart> } line [ ( sizeof <S2SV_ModEnd> line ) - <S2SV_ModStart> 1 ] = '\\0' ; line [ strlen ( line ) - 1 ] =",OpenSC@OpenSC/360e95d45ac4123255a4c796db96337f332160ad,CVE-2018-16391,https://github.com/OpenSC/OpenSC/commit/360e95d45ac4123255a4c796db96337f332160ad#diff-477b7a40136bb418b10ce271c8664536,2018-09-03T14:29Z
CWE-20,"CWE-20 static vpx_codec_err_t vp8_peek_si_internal ( const uint8_t * data , unsigned int data_sz , vpx_codec_stream_info_t * si , vpx_decrypt_cb decrypt_cb , void * decrypt_state ) { vpx_codec_err_t res = VPX_CODEC_OK ; if ( data + data_sz <= data ) { res = VPX_CODEC_INVALID_PARAM ; } else { uint8_t clear_buffer [ 10 ] ; const uint8_t * clear = data ; if ( decrypt_cb ) { int n = MIN ( sizeof ( clear_buffer ) , data_sz ) ; decrypt_cb ( decrypt_state , data , clear_buffer , n ) ; clear = clear_buffer ; } si -> is_kf = 0 ; if ( data_sz >= 10 && ! ( clear [ 0 ] & 0x01 ) ) { si -> is_kf = 1 ; if ( clear [ 3 ] != 0x9d || clear [ 4 ] != 0x01 || clear [ 5 ] != 0x2a ) return VPX_CODEC_UNSUP_BITSTREAM ; si -> w = ( clear [ 6 ] | ( clear [ 7 ] << 8 ) ) & 0x3fff ; si -> h = ( clear [ 8 ] | ( clear [ 9 ] << 8 ) ) & 0x3fff ; <S2SV_StartBug> if ( ! ( si -> h | si -> w ) ) <S2SV_EndBug> <S2SV_StartBug> res = VPX_CODEC_UNSUP_BITSTREAM ; <S2SV_EndBug> } <S2SV_StartBug> else <S2SV_EndBug> { res = VPX_CODEC_UNSUP_BITSTREAM ; } } return res ; }",<S2SV_ModStart> si -> h && <S2SV_ModEnd> si -> w <S2SV_ModStart> ) res = VPX_CODEC_CORRUPT_FRAME ; } else { res = <S2SV_ModStart> VPX_CODEC_UNSUP_BITSTREAM ; } <S2SV_ModEnd> } return res,external@libvpx/063be1485e0099bc81ace3a08b0ec9186dcad693,CVE-2016-6711,https://android.googlesource.com/platform/external/libvpx/+/063be1485e0099bc81ace3a08b0ec9186dcad693,2016-12-13T19:59Z
,"CWE-000 WORD32 ih264d_parse_islice_data_cavlc ( dec_struct_t * ps_dec , dec_slice_params_t * ps_slice , UWORD16 u2_first_mb_in_slice ) { UWORD8 uc_more_data_flag ; UWORD8 u1_num_mbs , u1_mb_idx ; dec_mb_info_t * ps_cur_mb_info ; deblk_mb_t * ps_cur_deblk_mb ; dec_bit_stream_t * const ps_bitstrm = ps_dec -> ps_bitstrm ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD16 i2_pic_wdin_mbs = ps_dec -> u2_frm_wd_in_mbs ; WORD16 i2_cur_mb_addr ; UWORD8 u1_mbaff ; UWORD8 u1_num_mbs_next , u1_end_of_row , u1_tfr_n_mb ; WORD32 ret = OK ; ps_dec -> u1_qp = ps_slice -> u1_slice_qp ; ih264d_update_qp ( ps_dec , 0 ) ; u1_mbaff = ps_slice -> u1_mbaff_frame_flag ; u1_mb_idx = ps_dec -> u1_mb_idx ; u1_num_mbs = u1_mb_idx ; uc_more_data_flag = 1 ; i2_cur_mb_addr = u2_first_mb_in_slice << u1_mbaff ; do { UWORD8 u1_mb_type ; ps_dec -> pv_prev_mb_parse_tu_coeff_data = ps_dec -> pv_parse_tu_coeff_data ; if ( i2_cur_mb_addr > ps_dec -> ps_cur_sps -> u2_max_mb_addr ) { ret = ERROR_MB_ADDRESS_T ; break ; } ps_cur_mb_info = ps_dec -> ps_nmb_info + u1_num_mbs ; ps_dec -> u4_num_mbs_cur_nmb = u1_num_mbs ; ps_dec -> u4_num_pmbair = ( u1_num_mbs >> u1_mbaff ) ; ps_cur_mb_info -> u1_end_of_slice = 0 ; ps_dec -> pf_get_mb_info ( ps_dec , i2_cur_mb_addr , ps_cur_mb_info , 0 ) ; ps_cur_deblk_mb = ps_dec -> ps_deblk_mbn + u1_num_mbs ; if ( ps_dec -> u4_app_disable_deblk_frm == 0 ) ih264d_set_deblocking_parameters ( ps_cur_deblk_mb , ps_slice , ps_dec -> u1_mb_ngbr_availablity , ps_dec -> u1_cur_mb_fld_dec_flag ) ; ps_cur_deblk_mb -> u1_mb_type = ps_cur_deblk_mb -> u1_mb_type | D_INTRA_MB ; { UWORD32 u4_bitstream_offset = * pu4_bitstrm_ofst ; UWORD32 u4_word , u4_ldz , u4_temp ; NEXTBITS_32 ( u4_word , u4_bitstream_offset , pu4_bitstrm_buf ) ; u4_ldz = CLZ ( u4_word ) ; u4_bitstream_offset += ( u4_ldz + 1 ) ; u4_word = 0 ; if ( u4_ldz ) GETBITS ( u4_word , u4_bitstream_offset , pu4_bitstrm_buf , u4_ldz ) ; * pu4_bitstrm_ofst = u4_bitstream_offset ; u4_temp = ( ( 1 << u4_ldz ) + u4_word - 1 ) ; if ( u4_temp > 25 ) return ERROR_MB_TYPE ; u1_mb_type = u4_temp ; } ps_cur_mb_info -> u1_mb_type = u1_mb_type ; COPYTHECONTEXT ( ""u1_mb_type"" , u1_mb_type ) ; if ( 25 == u1_mb_type ) { ps_cur_mb_info -> ps_curmb -> u1_mb_type = I_PCM_MB ; ret = ih264d_parse_ipcm_mb ( ps_dec , ps_cur_mb_info , u1_num_mbs ) ; if ( ret != OK ) return ret ; ps_cur_deblk_mb -> u1_mb_qp = 0 ; } else { ret = ih264d_parse_imb_cavlc ( ps_dec , ps_cur_mb_info , u1_num_mbs , u1_mb_type ) ; if ( ret != OK ) return ret ; ps_cur_deblk_mb -> u1_mb_qp = ps_dec -> u1_qp ; } if ( u1_mbaff ) { ih264d_update_mbaff_left_nnz ( ps_dec , ps_cur_mb_info ) ; <S2SV_StartBug> } <S2SV_EndBug> i2_cur_mb_addr ++ ; uc_more_data_flag = MORE_RBSP_DATA ( ps_bitstrm ) ; { mv_pred_t * ps_mv_nmb_start = ps_dec -> ps_mv_cur + ( u1_num_mbs << 4 ) ; mv_pred_t s_mvPred = { { 0 , 0 , 0 , 0 } , { - 1 , - 1 } , 0 , 0 } ; ih264d_rep_mv_colz ( ps_dec , & s_mvPred , ps_mv_nmb_start , 0 , ( UWORD8 ) ( ps_dec -> u1_cur_mb_fld_dec_flag << 1 ) , 4 , 4 ) ; } if ( ps_dec -> u4_num_cores < 3 ) { if ( ps_dec -> u4_app_disable_deblk_frm == 0 ) ps_dec -> pf_compute_bs ( ps_dec , ps_cur_mb_info , ( UWORD16 ) ( u1_num_mbs >> u1_mbaff ) ) ; } u1_num_mbs ++ ; u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec -> u2_mbx - 1 ; u1_end_of_row = ( ! u1_num_mbs_next ) && ( ! ( u1_mbaff && ( u1_num_mbs & 0x01 ) ) ) ; u1_tfr_n_mb = ( u1_num_mbs == ps_dec -> u1_recon_mb_grp ) || u1_end_of_row || ( ! uc_more_data_flag ) ; ps_cur_mb_info -> u1_end_of_slice = ( ! uc_more_data_flag ) ; if ( u1_tfr_n_mb || ( ! uc_more_data_flag ) ) { if ( ps_dec -> u1_separate_parse ) { ih264d_parse_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; ps_dec -> ps_nmb_info += u1_num_mbs ; } else { ih264d_decode_recon_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; } ps_dec -> u2_total_mbs_coded += u1_num_mbs ; if ( u1_tfr_n_mb ) u1_num_mbs = 0 ; u1_mb_idx = u1_num_mbs ; ps_dec -> u1_mb_idx = u1_num_mbs ; } } while ( uc_more_data_flag ) ; ps_dec -> u4_num_mbs_cur_nmb = 0 ; ps_dec -> ps_cur_slice -> u4_mbs_in_slice = i2_cur_mb_addr - ( u2_first_mb_in_slice << u1_mbaff ) ; return ret ; }",<S2SV_ModStart> ps_cur_mb_info ) ; if ( ! uc_more_data_flag && ( 0 == ( i2_cur_mb_addr & 1 ) ) ) { return ERROR_EOB_FLUSHBITS_T ; },external@libavc/7950bf47b6944546a0aff11a7184947de9591b51,CVE-2017-0550,https://android.googlesource.com/platform/external/libavc/+/7950bf47b6944546a0aff11a7184947de9591b51,2017-04-07T22:59Z
,"CWE-000 static int sanity_check_raw_super ( struct f2fs_sb_info * sbi , struct buffer_head * bh ) { struct f2fs_super_block * raw_super = ( struct f2fs_super_block * ) ( bh -> b_data + F2FS_SUPER_OFFSET ) ; struct super_block * sb = sbi -> sb ; unsigned int blocksize ; if ( F2FS_SUPER_MAGIC != le32_to_cpu ( raw_super -> magic ) ) { f2fs_msg ( sb , KERN_INFO , ""Magic<S2SV_blank>Mismatch,<S2SV_blank>valid(0x%x)<S2SV_blank>-<S2SV_blank>read(0x%x)"" , F2FS_SUPER_MAGIC , le32_to_cpu ( raw_super -> magic ) ) ; return 1 ; } if ( F2FS_BLKSIZE != PAGE_SIZE ) { f2fs_msg ( sb , KERN_INFO , ""Invalid<S2SV_blank>page_cache_size<S2SV_blank>(%lu),<S2SV_blank>supports<S2SV_blank>only<S2SV_blank>4KB\\n"" , PAGE_SIZE ) ; return 1 ; } blocksize = 1 << le32_to_cpu ( raw_super -> log_blocksize ) ; if ( blocksize != F2FS_BLKSIZE ) { f2fs_msg ( sb , KERN_INFO , ""Invalid<S2SV_blank>blocksize<S2SV_blank>(%u),<S2SV_blank>supports<S2SV_blank>only<S2SV_blank>4KB\\n"" , blocksize ) ; return 1 ; } if ( le32_to_cpu ( raw_super -> log_blocks_per_seg ) != 9 ) { f2fs_msg ( sb , KERN_INFO , ""Invalid<S2SV_blank>log<S2SV_blank>blocks<S2SV_blank>per<S2SV_blank>segment<S2SV_blank>(%u)\\n"" , le32_to_cpu ( raw_super -> log_blocks_per_seg ) ) ; return 1 ; } if ( le32_to_cpu ( raw_super -> log_sectorsize ) > F2FS_MAX_LOG_SECTOR_SIZE || le32_to_cpu ( raw_super -> log_sectorsize ) < F2FS_MIN_LOG_SECTOR_SIZE ) { f2fs_msg ( sb , KERN_INFO , ""Invalid<S2SV_blank>log<S2SV_blank>sectorsize<S2SV_blank>(%u)"" , le32_to_cpu ( raw_super -> log_sectorsize ) ) ; return 1 ; } if ( le32_to_cpu ( raw_super -> log_sectors_per_block ) + le32_to_cpu ( raw_super -> log_sectorsize ) != F2FS_MAX_LOG_SECTOR_SIZE ) { f2fs_msg ( sb , KERN_INFO , ""Invalid<S2SV_blank>log<S2SV_blank>sectors<S2SV_blank>per<S2SV_blank>block(%u)<S2SV_blank>log<S2SV_blank>sectorsize(%u)"" , le32_to_cpu ( raw_super -> log_sectors_per_block ) , le32_to_cpu ( raw_super -> log_sectorsize ) ) ; return 1 ; } if ( le32_to_cpu ( raw_super -> node_ino ) != 1 || le32_to_cpu ( raw_super -> meta_ino ) != 2 || le32_to_cpu ( raw_super -> root_ino ) != 3 ) { f2fs_msg ( sb , KERN_INFO , ""Invalid<S2SV_blank>Fs<S2SV_blank>Meta<S2SV_blank>Ino:<S2SV_blank>node(%u)<S2SV_blank>meta(%u)<S2SV_blank>root(%u)"" , le32_to_cpu ( raw_super -> node_ino ) , le32_to_cpu ( raw_super -> meta_ino ) , le32_to_cpu ( raw_super -> root_ino ) ) ; return 1 ; } <S2SV_StartBug> if ( sanity_check_area_boundary ( sbi , bh ) ) <S2SV_EndBug> return 1 ; return 0 ; }","<S2SV_ModStart> } if ( le32_to_cpu ( raw_super -> segment_count ) > F2FS_MAX_SEGMENT ) { f2fs_msg ( sb , KERN_INFO , ""Invalid<S2SV_blank>segment<S2SV_blank>count<S2SV_blank>(%u)"" , le32_to_cpu ( raw_super -> segment_count ) ) ; return 1 ; } if (",torvalds@linux/b9dd46188edc2f0d1f37328637860bb65a771124,CVE-2017-10662,https://github.com/torvalds/linux/commit/b9dd46188edc2f0d1f37328637860bb65a771124,2017-08-19T18:29Z
CWE-264,"CWE-264 static bool caller_is_in_ancestor ( pid_t pid , const char * contrl , const char * cg , char * * nextcg ) { <S2SV_StartBug> char fnam [ PROCLEN ] ; <S2SV_EndBug> FILE * f ; bool answer = false ; <S2SV_StartBug> char * line = NULL ; <S2SV_EndBug> size_t len = 0 ; int ret ; ret = snprintf ( fnam , PROCLEN , ""/proc/%d/cgroup"" , pid ) ; if ( ret < 0 || ret >= PROCLEN ) return false ; if ( ! ( f = fopen ( fnam , ""r"" ) ) ) return false ; while ( getline ( & line , & len , f ) != - 1 ) { char * c1 , * c2 , * linecmp ; if ( ! line [ 0 ] ) continue ; c1 = strchr ( line , ':' ) ; if ( ! c1 ) goto out ; c1 ++ ; c2 = strchr ( c1 , ':' ) ; if ( ! c2 ) <S2SV_StartBug> goto out ; <S2SV_EndBug> * c2 = '\\0' ; if ( strcmp ( c1 , contrl ) != 0 ) continue ; c2 ++ ; stripnewline ( c2 ) ; prune_init_slice ( c2 ) ; linecmp = * cg == '/' ? c2 : c2 + 1 ; if ( strncmp ( linecmp , cg , strlen ( linecmp ) ) != 0 ) { <S2SV_StartBug> if ( nextcg ) <S2SV_EndBug> * nextcg = get_next_cgroup_dir ( linecmp , cg ) ; <S2SV_StartBug> goto out ; <S2SV_EndBug> } answer = true ; <S2SV_StartBug> goto out ; <S2SV_EndBug> } out : fclose ( f ) ; free ( line ) ; return answer ; }","<S2SV_ModStart> nextcg ) { <S2SV_ModEnd> bool answer = <S2SV_ModStart> ; char * c2 = get_pid_cgroup ( pid , contrl ) ; char * linecmp <S2SV_ModEnd> ; if ( <S2SV_ModStart> ! c2 ) return false <S2SV_ModEnd> ; prune_init_slice ( <S2SV_ModStart> ( nextcg ) { <S2SV_ModStart> cg ) ; } <S2SV_ModStart> = true ; out : free ( c2 <S2SV_ModEnd> ) ; return",lxc@lxcfs/a8b6c3e0537e90fba3c55910fd1b7229d54a60a7,CVE-2015-1342,https://github.com/lxc/lxcfs/commit/a8b6c3e0537e90fba3c55910fd1b7229d54a60a7,2015-12-07T20:59Z
CWE-189,"CWE-189 int CIFSFindNext ( const int xid , struct cifs_tcon * tcon , __u16 searchHandle , struct cifs_search_info * psrch_inf ) { TRANSACTION2_FNEXT_REQ * pSMB = NULL ; TRANSACTION2_FNEXT_RSP * pSMBr = NULL ; T2_FNEXT_RSP_PARMS * parms ; char * response_data ; int rc = 0 ; <S2SV_StartBug> int bytes_returned , name_len ; <S2SV_EndBug> __u16 params , byte_count ; cFYI ( 1 , ""In<S2SV_blank>FindNext"" ) ; if ( psrch_inf -> endOfSearch ) return - ENOENT ; rc = smb_init ( SMB_COM_TRANSACTION2 , 15 , tcon , ( void * * ) & pSMB , ( void * * ) & pSMBr ) ; if ( rc ) return rc ; params = 14 ; byte_count = 0 ; pSMB -> TotalDataCount = 0 ; pSMB -> MaxParameterCount = cpu_to_le16 ( 8 ) ; pSMB -> MaxDataCount = cpu_to_le16 ( ( tcon -> ses -> server -> maxBuf - MAX_CIFS_HDR_SIZE ) & 0xFFFFFF00 ) ; pSMB -> MaxSetupCount = 0 ; pSMB -> Reserved = 0 ; pSMB -> Flags = 0 ; pSMB -> Timeout = 0 ; pSMB -> Reserved2 = 0 ; pSMB -> ParameterOffset = cpu_to_le16 ( offsetof ( struct smb_com_transaction2_fnext_req , SearchHandle ) - 4 ) ; pSMB -> DataCount = 0 ; pSMB -> DataOffset = 0 ; pSMB -> SetupCount = 1 ; pSMB -> Reserved3 = 0 ; pSMB -> SubCommand = cpu_to_le16 ( TRANS2_FIND_NEXT ) ; pSMB -> SearchHandle = searchHandle ; pSMB -> SearchCount = cpu_to_le16 ( CIFSMaxBufSize / sizeof ( FILE_UNIX_INFO ) ) ; pSMB -> InformationLevel = cpu_to_le16 ( psrch_inf -> info_level ) ; pSMB -> ResumeKey = psrch_inf -> resume_key ; pSMB -> SearchFlags = cpu_to_le16 ( CIFS_SEARCH_CLOSE_AT_END | CIFS_SEARCH_RETURN_RESUME ) ; name_len = psrch_inf -> resume_name_len ; params += name_len ; if ( name_len < PATH_MAX ) { memcpy ( pSMB -> ResumeFileName , psrch_inf -> presume_name , name_len ) ; byte_count += name_len ; pSMB -> ResumeFileName [ name_len ] = 0 ; pSMB -> ResumeFileName [ name_len + 1 ] = 0 ; } else { rc = - EINVAL ; goto FNext2_err_exit ; } byte_count = params + 1 ; pSMB -> TotalParameterCount = cpu_to_le16 ( params ) ; pSMB -> ParameterCount = pSMB -> TotalParameterCount ; inc_rfc1001_len ( pSMB , byte_count ) ; pSMB -> ByteCount = cpu_to_le16 ( byte_count ) ; rc = SendReceive ( xid , tcon -> ses , ( struct smb_hdr * ) pSMB , ( struct smb_hdr * ) pSMBr , & bytes_returned , 0 ) ; cifs_stats_inc ( & tcon -> num_fnext ) ; if ( rc ) { if ( rc == - EBADF ) { psrch_inf -> endOfSearch = true ; cifs_buf_release ( pSMB ) ; rc = 0 ; } else cFYI ( 1 , ""FindNext<S2SV_blank>returned<S2SV_blank>=<S2SV_blank>%d"" , rc ) ; } else { rc = validate_t2 ( ( struct smb_t2_rsp * ) pSMBr ) ; if ( rc == 0 ) { unsigned int lnoff ; if ( pSMBr -> hdr . Flags2 & SMBFLG2_UNICODE ) psrch_inf -> unicode = true ; else psrch_inf -> unicode = false ; response_data = ( char * ) & pSMBr -> hdr . Protocol + le16_to_cpu ( pSMBr -> t2 . ParameterOffset ) ; parms = ( T2_FNEXT_RSP_PARMS * ) response_data ; response_data = ( char * ) & pSMBr -> hdr . Protocol + le16_to_cpu ( pSMBr -> t2 . DataOffset ) ; if ( psrch_inf -> smallBuf ) cifs_small_buf_release ( psrch_inf -> ntwrk_buf_start ) ; else cifs_buf_release ( psrch_inf -> ntwrk_buf_start ) ; psrch_inf -> srch_entries_start = response_data ; psrch_inf -> ntwrk_buf_start = ( char * ) pSMB ; psrch_inf -> smallBuf = 0 ; if ( parms -> EndofSearch ) psrch_inf -> endOfSearch = true ; else psrch_inf -> endOfSearch = false ; psrch_inf -> entries_in_buffer = le16_to_cpu ( parms -> SearchCount ) ; psrch_inf -> index_of_last_entry += psrch_inf -> entries_in_buffer ; lnoff = le16_to_cpu ( parms -> LastNameOffset ) ; if ( tcon -> ses -> server -> maxBuf - MAX_CIFS_HDR_SIZE < lnoff ) { cERROR ( 1 , ""ignoring<S2SV_blank>corrupt<S2SV_blank>resume<S2SV_blank>name"" ) ; psrch_inf -> last_entry = NULL ; return rc ; } else psrch_inf -> last_entry = psrch_inf -> srch_entries_start + lnoff ; } } FNext2_err_exit : if ( rc != 0 ) cifs_buf_release ( pSMB ) ; return rc ; }",<S2SV_ModStart> ; int bytes_returned ; unsigned int <S2SV_ModEnd> name_len ; __u16,torvalds@linux/9438fabb73eb48055b58b89fc51e0bc4db22fabd,CVE-2011-3191,https://github.com/torvalds/linux/commit/9438fabb73eb48055b58b89fc51e0bc4db22fabd,2012-05-24T23:55Z
CWE-772,"CWE-772 gprinc_ret * get_principal_2_svc ( gprinc_arg * arg , struct svc_req * rqstp ) { static gprinc_ret ret ; char * prime_arg , * funcname ; <S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> service_name ; OM_uint32 minor_stat ; kadm5_server_handle_t handle ; const char * errmsg = NULL ; xdr_free ( xdr_gprinc_ret , & ret ) ; if ( ( ret . code = new_server_handle ( arg -> api_version , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; ret . api_version = handle -> api_version ; funcname = ""kadm5_get_principal"" ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = KADM5_FAILURE ; goto exit_func ; } if ( krb5_unparse_name ( handle -> context , arg -> princ , & prime_arg ) ) { ret . code = KADM5_BAD_PRINCIPAL ; goto exit_func ; } if ( ! cmp_gss_krb5_name ( handle , rqst2name ( rqstp ) , arg -> princ ) && ( CHANGEPW_SERVICE ( rqstp ) || ! kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , ACL_INQUIRE , arg -> princ , NULL ) ) ) { ret . code = KADM5_AUTH_GET ; log_unauth ( funcname , prime_arg , & client_name , & service_name , rqstp ) ; } else { ret . code = kadm5_get_principal ( handle , arg -> princ , & ret . rec , arg -> mask ) ; if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ; log_done ( funcname , prime_arg , errmsg , & client_name , & service_name , rqstp ) ; if ( errmsg != NULL ) krb5_free_error_message ( handle -> context , errmsg ) ; } free ( prime_arg ) ; <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_StartBug> exit_func : <S2SV_EndBug> free_server_handle ( handle ) ; return & ret ; }",<S2SV_ModStart> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; OM_uint32 minor_stat <S2SV_ModStart> prime_arg ) ; exit_func : <S2SV_ModStart> service_name ) ; <S2SV_ModEnd> free_server_handle ( handle,krb5@krb5/83ed75feba32e46f736fcce0d96a0445f29b96c2,CVE-2015-8631,https://github.com/krb5/krb5/commit/83ed75feba32e46f736fcce0d96a0445f29b96c2,2016-02-13T02:59Z
CWE-416,"CWE-416 mrb_value mrb_io_initialize_copy ( mrb_state * mrb , mrb_value copy ) { mrb_value orig ; mrb_value buf ; struct mrb_io * fptr_copy ; struct mrb_io * fptr_orig ; mrb_bool failed = TRUE ; mrb_get_args ( mrb , ""o"" , & orig ) ; <S2SV_StartBug> fptr_copy = ( struct mrb_io * ) DATA_PTR ( copy ) ; <S2SV_EndBug> if ( fptr_copy != NULL ) { fptr_finalize ( mrb , fptr_copy , FALSE ) ; mrb_free ( mrb , fptr_copy ) ; } <S2SV_StartBug> fptr_copy = ( struct mrb_io * ) mrb_io_alloc ( mrb ) ; <S2SV_EndBug> fptr_orig = io_get_open_fptr ( mrb , orig ) ; DATA_TYPE ( copy ) = & mrb_io_type ; DATA_PTR ( copy ) = fptr_copy ; buf = mrb_iv_get ( mrb , orig , mrb_intern_cstr ( mrb , ""@buf"" ) ) ; mrb_iv_set ( mrb , copy , mrb_intern_cstr ( mrb , ""@buf"" ) , buf ) ; fptr_copy -> fd = mrb_dup ( mrb , fptr_orig -> fd , & failed ) ; if ( failed ) { mrb_sys_fail ( mrb , 0 ) ; } mrb_fd_cloexec ( mrb , fptr_copy -> fd ) ; if ( fptr_orig -> fd2 != - 1 ) { fptr_copy -> fd2 = mrb_dup ( mrb , fptr_orig -> fd2 , & failed ) ; if ( failed ) { close ( fptr_copy -> fd ) ; mrb_sys_fail ( mrb , 0 ) ; } mrb_fd_cloexec ( mrb , fptr_copy -> fd2 ) ; } fptr_copy -> pid = fptr_orig -> pid ; fptr_copy -> readable = fptr_orig -> readable ; fptr_copy -> writable = fptr_orig -> writable ; fptr_copy -> sync = fptr_orig -> sync ; fptr_copy -> is_socket = fptr_orig -> is_socket ; return copy ; }","<S2SV_ModStart> orig ) ; fptr_orig = io_get_open_fptr ( mrb , orig ) ; <S2SV_ModStart> mrb_io_alloc ( mrb <S2SV_ModEnd> ) ; DATA_TYPE",mruby@mruby/b51b21fc63c9805862322551387d9036f2b63433,CVE-2018-10199,https://github.com/mruby/mruby/commit/b51b21fc63c9805862322551387d9036f2b63433,2018-04-18T15:29Z
CWE-362,"CWE-362 static int set_evtchn_to_irq ( evtchn_port_t evtchn , unsigned int irq ) { unsigned row ; unsigned col ; if ( evtchn >= xen_evtchn_max_channels ( ) ) return - EINVAL ; row = EVTCHN_ROW ( evtchn ) ; col = EVTCHN_COL ( evtchn ) ; if ( evtchn_to_irq [ row ] == NULL ) { if ( irq == - 1 ) return 0 ; evtchn_to_irq [ row ] = ( int * ) get_zeroed_page ( GFP_KERNEL ) ; if ( evtchn_to_irq [ row ] == NULL ) return - ENOMEM ; clear_evtchn_to_irq_row ( row ) ; } <S2SV_StartBug> evtchn_to_irq [ row ] [ col ] = irq ; <S2SV_EndBug> return 0 ; }","<S2SV_ModStart> ) ; } WRITE_ONCE ( <S2SV_ModStart> [ col ] , irq ) <S2SV_ModEnd> ; return 0",torvalds@linux/073d0552ead5bfc7a3a9c01de590e924f11b5dd2,CVE-2020-27675,https://github.com/torvalds/linux/commit/073d0552ead5bfc7a3a9c01de590e924f11b5dd2,2020-10-22T21:15Z
CWE-416,"CWE-416 int __mdiobus_register ( struct mii_bus * bus , struct module * owner ) { struct mdio_device * mdiodev ; int i , err ; struct gpio_desc * gpiod ; if ( NULL == bus || NULL == bus -> name || NULL == bus -> read || NULL == bus -> write ) return - EINVAL ; BUG_ON ( bus -> state != MDIOBUS_ALLOCATED && bus -> state != MDIOBUS_UNREGISTERED ) ; bus -> owner = owner ; bus -> dev . parent = bus -> parent ; bus -> dev . class = & mdio_bus_class ; bus -> dev . groups = NULL ; dev_set_name ( & bus -> dev , ""%s"" , bus -> id ) ; err = device_register ( & bus -> dev ) ; if ( err ) { pr_err ( ""mii_bus<S2SV_blank>%s<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>register\\n"" , bus -> id ) ; <S2SV_StartBug> put_device ( & bus -> dev ) ; <S2SV_EndBug> return - EINVAL ; } mutex_init ( & bus -> mdio_lock ) ; gpiod = devm_gpiod_get_optional ( & bus -> dev , ""reset"" , GPIOD_OUT_LOW ) ; if ( IS_ERR ( gpiod ) ) { dev_err ( & bus -> dev , ""mii_bus<S2SV_blank>%s<S2SV_blank>couldn\'t<S2SV_blank>get<S2SV_blank>reset<S2SV_blank>GPIO\\n"" , bus -> id ) ; device_del ( & bus -> dev ) ; return PTR_ERR ( gpiod ) ; } else if ( gpiod ) { bus -> reset_gpiod = gpiod ; gpiod_set_value_cansleep ( gpiod , 1 ) ; udelay ( bus -> reset_delay_us ) ; gpiod_set_value_cansleep ( gpiod , 0 ) ; } if ( bus -> reset ) bus -> reset ( bus ) ; for ( i = 0 ; i < PHY_MAX_ADDR ; i ++ ) { if ( ( bus -> phy_mask & ( 1 << i ) ) == 0 ) { struct phy_device * phydev ; phydev = mdiobus_scan ( bus , i ) ; if ( IS_ERR ( phydev ) && ( PTR_ERR ( phydev ) != - ENODEV ) ) { err = PTR_ERR ( phydev ) ; goto error ; } } } mdiobus_setup_mdiodev_from_board_info ( bus , mdiobus_create_device ) ; bus -> state = MDIOBUS_REGISTERED ; pr_info ( ""%s:<S2SV_blank>probed\\n"" , bus -> name ) ; return 0 ; error : while ( -- i >= 0 ) { mdiodev = bus -> mdio_map [ i ] ; if ( ! mdiodev ) continue ; mdiodev -> device_remove ( mdiodev ) ; mdiodev -> device_free ( mdiodev ) ; } if ( bus -> reset_gpiod ) gpiod_set_value_cansleep ( bus -> reset_gpiod , 1 ) ; device_del ( & bus -> dev ) ; return err ; }",<S2SV_ModStart> id ) ; <S2SV_ModEnd> return - EINVAL,torvalds@linux/6ff7b060535e87c2ae14dd8548512abfdda528fb,CVE-2019-12819,https://github.com/torvalds/linux/commit/6ff7b060535e87c2ae14dd8548512abfdda528fb,2019-06-14T02:29Z
CWE-772,"CWE-772 generic_ret * chpass_principal_2_svc ( chpass_arg * arg , struct svc_req * rqstp ) { static generic_ret ret ; char * prime_arg ; <S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> service_name ; OM_uint32 minor_stat ; kadm5_server_handle_t handle ; const char * errmsg = NULL ; xdr_free ( xdr_generic_ret , & ret ) ; if ( ( ret . code = new_server_handle ( arg -> api_version , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; ret . api_version = handle -> api_version ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = KADM5_FAILURE ; goto exit_func ; } if ( krb5_unparse_name ( handle -> context , arg -> princ , & prime_arg ) ) { ret . code = KADM5_BAD_PRINCIPAL ; goto exit_func ; } if ( cmp_gss_krb5_name ( handle , rqst2name ( rqstp ) , arg -> princ ) ) { ret . code = chpass_principal_wrapper_3 ( ( void * ) handle , arg -> princ , FALSE , 0 , NULL , arg -> pass ) ; } else if ( ! ( CHANGEPW_SERVICE ( rqstp ) ) && kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , ACL_CHANGEPW , arg -> princ , NULL ) ) { ret . code = kadm5_chpass_principal ( ( void * ) handle , arg -> princ , arg -> pass ) ; } else { log_unauth ( ""kadm5_chpass_principal"" , prime_arg , & client_name , & service_name , rqstp ) ; ret . code = KADM5_AUTH_CHANGEPW ; } if ( ret . code != KADM5_AUTH_CHANGEPW ) { if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ; log_done ( ""kadm5_chpass_principal"" , prime_arg , errmsg , & client_name , & service_name , rqstp ) ; if ( errmsg != NULL ) krb5_free_error_message ( handle -> context , errmsg ) ; } free ( prime_arg ) ; <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> gss_release_buffer ( & minor_stat , & service_name ) ; exit_func : free_server_handle ( handle ) ; return & ret ; }","<S2SV_ModStart> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; OM_uint32 minor_stat <S2SV_ModStart> prime_arg ) ; exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_ModEnd> free_server_handle ( handle",krb5@krb5/83ed75feba32e46f736fcce0d96a0445f29b96c2,CVE-2015-8631,https://github.com/krb5/krb5/commit/83ed75feba32e46f736fcce0d96a0445f29b96c2,2016-02-13T02:59Z
CWE-119,"CWE-119 vpx_codec_err_t vpx_codec_enc_init_ver ( vpx_codec_ctx_t * ctx , vpx_codec_iface_t * iface , <S2SV_StartBug> vpx_codec_enc_cfg_t * cfg , <S2SV_EndBug> vpx_codec_flags_t flags , int ver ) { vpx_codec_err_t res ; if ( ver != VPX_ENCODER_ABI_VERSION ) res = VPX_CODEC_ABI_MISMATCH ; else if ( ! ctx || ! iface || ! cfg ) res = VPX_CODEC_INVALID_PARAM ; else if ( iface -> abi_version != VPX_CODEC_INTERNAL_ABI_VERSION ) res = VPX_CODEC_ABI_MISMATCH ; else if ( ! ( iface -> caps & VPX_CODEC_CAP_ENCODER ) ) res = VPX_CODEC_INCAPABLE ; <S2SV_StartBug> else if ( ( flags & VPX_CODEC_USE_XMA ) && ! ( iface -> caps & VPX_CODEC_CAP_XMA ) ) <S2SV_EndBug> res = VPX_CODEC_INCAPABLE ; else if ( ( flags & VPX_CODEC_USE_PSNR ) && ! ( iface -> caps & VPX_CODEC_CAP_PSNR ) ) res = VPX_CODEC_INCAPABLE ; else if ( ( flags & VPX_CODEC_USE_OUTPUT_PARTITION ) && ! ( iface -> caps & VPX_CODEC_CAP_OUTPUT_PARTITION ) ) res = VPX_CODEC_INCAPABLE ; else { ctx -> iface = iface ; ctx -> name = iface -> name ; ctx -> priv = NULL ; ctx -> init_flags = flags ; ctx -> config . enc = cfg ; res = ctx -> iface -> init ( ctx , NULL ) ; if ( res ) { ctx -> err_detail = ctx -> priv ? ctx -> priv -> err_detail : NULL ; vpx_codec_destroy ( ctx ) ; } <S2SV_StartBug> if ( ctx -> priv ) <S2SV_EndBug> ctx -> priv -> iface = ctx -> iface ; } return SAVE_STATUS ( ctx , res ) ; }","<S2SV_ModStart> * iface , const <S2SV_ModStart> ( flags & <S2SV_ModEnd> VPX_CODEC_USE_PSNR ) && <S2SV_ModStart> ) ; } <S2SV_ModEnd> } return SAVE_STATUS",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-20,"CWE-20 static int rawv6_recvmsg ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct sockaddr_in6 * sin6 = ( struct sockaddr_in6 * ) msg -> msg_name ; struct sk_buff * skb ; size_t copied ; int err ; if ( flags & MSG_OOB ) <S2SV_StartBug> return - EOPNOTSUPP ; <S2SV_EndBug> if ( addr_len ) * addr_len = sizeof ( * sin6 ) ; if ( flags & MSG_ERRQUEUE ) return ipv6_recv_error ( sk , msg , len ) ; if ( np -> rxpmtu && np -> rxopt . bits . rxpmtu ) return ipv6_recv_rxpmtu ( sk , msg , len ) ; skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( ! skb ) goto out ; copied = skb -> len ; if ( copied > len ) { copied = len ; msg -> msg_flags |= MSG_TRUNC ; } if ( skb_csum_unnecessary ( skb ) ) { err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; } else if ( msg -> msg_flags & MSG_TRUNC ) { if ( __skb_checksum_complete ( skb ) ) goto csum_copy_err ; err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; } else { err = skb_copy_and_csum_datagram_iovec ( skb , 0 , msg -> msg_iov ) ; if ( err == - EINVAL ) goto csum_copy_err ; } if ( err ) goto out_free ; if ( sin6 ) { sin6 -> sin6_family = AF_INET6 ; sin6 -> sin6_port = 0 ; sin6 -> sin6_addr = ipv6_hdr ( skb ) -> saddr ; sin6 -> sin6_flowinfo = 0 ; sin6 -> sin6_scope_id = ipv6_iface_scope_id ( & sin6 -> sin6_addr , <S2SV_StartBug> IP6CB ( skb ) -> iif ) ; <S2SV_EndBug> } sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( np -> rxopt . all ) ip6_datagram_recv_ctl ( sk , msg , skb ) ; err = copied ; if ( flags & MSG_TRUNC ) err = skb -> len ; out_free : skb_free_datagram ( sk , skb ) ; out : return err ; csum_copy_err : skb_kill_datagram ( sk , skb , flags ) ; err = ( flags & MSG_DONTWAIT ) ? - EAGAIN : - EHOSTUNREACH ; goto out ; }",<S2SV_ModStart> return - EOPNOTSUPP <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) -> iif ) ; * addr_len = sizeof ( * sin6,torvalds@linux/bceaa90240b6019ed73b49965eac7d167610be69,CVE-2013-7265,https://github.com/torvalds/linux/commit/bceaa90240b6019ed73b49965eac7d167610be69,2014-01-06T16:55Z
CWE-399,"CWE-399 int cdf_unpack_summary_info ( const cdf_stream_t * sst , const cdf_header_t * h , cdf_summary_info_header_t * ssi , cdf_property_info_t * * info , size_t * count ) { <S2SV_StartBug> size_t i , maxcount ; <S2SV_EndBug> const cdf_summary_info_header_t * si = CAST ( const cdf_summary_info_header_t * , sst -> sst_tab ) ; const cdf_section_declaration_t * sd = CAST ( const cdf_section_declaration_t * , ( const void * ) ( ( const char * ) sst -> sst_tab + CDF_SECTION_DECLARATION_OFFSET ) ) ; if ( cdf_check_stream_offset ( sst , h , si , sizeof ( * si ) , __LINE__ ) == - 1 || cdf_check_stream_offset ( sst , h , sd , sizeof ( * sd ) , __LINE__ ) == - 1 ) return - 1 ; ssi -> si_byte_order = CDF_TOLE2 ( si -> si_byte_order ) ; ssi -> si_os_version = CDF_TOLE2 ( si -> si_os_version ) ; ssi -> si_os = CDF_TOLE2 ( si -> si_os ) ; ssi -> si_class = si -> si_class ; cdf_swap_class ( & ssi -> si_class ) ; <S2SV_StartBug> ssi -> si_count = CDF_TOLE2 ( si -> si_count ) ; <S2SV_EndBug> * count = 0 ; maxcount = 0 ; * info = NULL ; <S2SV_StartBug> for ( i = 0 ; i < CDF_TOLE4 ( si -> si_count ) ; i ++ ) { <S2SV_EndBug> if ( i >= CDF_LOOP_LIMIT ) { DPRINTF ( ( ""Unpack<S2SV_blank>summary<S2SV_blank>info<S2SV_blank>loop<S2SV_blank>limit"" ) ) ; errno = EFTYPE ; return - 1 ; } if ( cdf_read_property_info ( sst , h , CDF_TOLE4 ( sd -> sd_offset ) , <S2SV_StartBug> info , count , & maxcount ) == - 1 ) { <S2SV_EndBug> return - 1 ; <S2SV_StartBug> } <S2SV_EndBug> } return 0 ; }","<S2SV_ModStart> ) { size_t <S2SV_ModEnd> maxcount ; const <S2SV_ModStart> -> si_count = CDF_TOLE4 <S2SV_ModEnd> ( si -> <S2SV_ModStart> = NULL ; if ( cdf_read_property_info ( sst , h , CDF_TOLE4 ( <S2SV_ModEnd> sd -> sd_offset <S2SV_ModStart> - 1 ) <S2SV_ModEnd> return - 1 <S2SV_ModStart> - 1 ; <S2SV_ModEnd> return 0 ;",file@file/b8acc83781d5a24cc5101e525d15efe0482c280d,CVE-2014-0237,https://github.com/file/file/commit/b8acc83781d5a24cc5101e525d15efe0482c280d,2014-06-01T04:29Z
CWE-476,"CWE-476 static VTermState * vterm_state_new ( VTerm * vt ) { <S2SV_StartBug> VTermState * state = vterm_allocator_malloc ( vt , sizeof ( VTermState ) ) ; <S2SV_EndBug> state -> vt = vt ; state -> rows = vt -> rows ; state -> cols = vt -> cols ; state -> mouse_col = 0 ; state -> mouse_row = 0 ; state -> mouse_buttons = 0 ; state -> mouse_protocol = MOUSE_X10 ; state -> callbacks = NULL ; state -> cbdata = NULL ; vterm_state_newpen ( state ) ; state -> bold_is_highbright = 0 ; return state ; }",<S2SV_ModStart> VTermState ) ) ; if ( state == NULL ) return NULL,vim@vim/cd929f7ba8cc5b6d6dcf35c8b34124e969fed6b8,CVE-2018-20786,https://github.com/vim/vim/commit/cd929f7ba8cc5b6d6dcf35c8b34124e969fed6b8,2019-02-24T14:29Z
CWE-119,"CWE-119 static INLINE void add_token_no_extra ( TOKENEXTRA * * t , <S2SV_StartBug> const vp9_prob * context_tree , <S2SV_EndBug> uint8_t token , uint8_t skip_eob_node , unsigned int * counts ) { ( * t ) -> token = token ; ( * t ) -> context_tree = context_tree ; ( * t ) -> skip_eob_node = skip_eob_node ; ( * t ) ++ ; ++ counts [ token ] ; }","<S2SV_ModStart> t , const vpx_prob <S2SV_ModEnd> * context_tree ,",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-119,"CWE-119 static int inv_recenter_nonneg ( int v , int m ) { if ( v > 2 * m ) return v ; <S2SV_StartBug> return v % 2 ? m - ( v + 1 ) / 2 : m + v / 2 ; <S2SV_EndBug> }",<S2SV_ModStart> v ; return ( v & 1 ) <S2SV_ModEnd> ? m - <S2SV_ModStart> ? m - ( <S2SV_ModStart> + 1 ) >> 1 ) <S2SV_ModEnd> : m + <S2SV_ModStart> : m + ( v >> 1 ) <S2SV_ModEnd> ; } <S2SV_null>,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-400,"CWE-000 bool ExprResolveBoolean ( struct xkb_context * ctx , const ExprDef * expr , bool * set_rtrn ) { bool ok = false ; const char * ident ; switch ( expr -> expr . op ) { case EXPR_VALUE : if ( expr -> expr . value_type != EXPR_TYPE_BOOLEAN ) { log_err ( ctx , ""Found<S2SV_blank>constant<S2SV_blank>of<S2SV_blank>type<S2SV_blank>%s<S2SV_blank>where<S2SV_blank>boolean<S2SV_blank>was<S2SV_blank>expected\\n"" , expr_value_type_to_string ( expr -> expr . value_type ) ) ; return false ; } * set_rtrn = expr -> boolean . set ; return true ; case EXPR_IDENT : ident = xkb_atom_text ( ctx , expr -> ident . ident ) ; if ( ident ) { if ( istreq ( ident , ""true"" ) || istreq ( ident , ""yes"" ) || istreq ( ident , ""on"" ) ) { * set_rtrn = true ; return true ; } else if ( istreq ( ident , ""false"" ) || istreq ( ident , ""no"" ) || istreq ( ident , ""off"" ) ) { * set_rtrn = false ; return true ; } } log_err ( ctx , ""Identifier<S2SV_blank>\\""%s\\""<S2SV_blank>of<S2SV_blank>type<S2SV_blank>boolean<S2SV_blank>is<S2SV_blank>unknown\\n"" , ident ) ; return false ; case EXPR_FIELD_REF : log_err ( ctx , ""Default<S2SV_blank>\\""%s.%s\\""<S2SV_blank>of<S2SV_blank>type<S2SV_blank>boolean<S2SV_blank>is<S2SV_blank>unknown\\n"" , xkb_atom_text ( ctx , expr -> field_ref . element ) , xkb_atom_text ( ctx , expr -> field_ref . field ) ) ; return false ; case EXPR_INVERT : case EXPR_NOT : <S2SV_StartBug> ok = ExprResolveBoolean ( ctx , expr , set_rtrn ) ; <S2SV_EndBug> if ( ok ) * set_rtrn = ! * set_rtrn ; return ok ; case EXPR_ADD : case EXPR_SUBTRACT : case EXPR_MULTIPLY : case EXPR_DIVIDE : case EXPR_ASSIGN : case EXPR_NEGATE : case EXPR_UNARY_PLUS : log_err ( ctx , ""%s<S2SV_blank>of<S2SV_blank>boolean<S2SV_blank>values<S2SV_blank>not<S2SV_blank>permitted\\n"" , expr_op_type_to_string ( expr -> expr . op ) ) ; break ; default : log_wsgo ( ctx , ""Unknown<S2SV_blank>operator<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>ResolveBoolean\\n"" , expr -> expr . op ) ; break ; } return false ; }","<S2SV_ModStart> ctx , expr -> unary . child",xkbcommon@libxkbcommon/1f9d1248c07cda8aaff762429c0dce146de8632a,CVE-2018-15853,https://github.com/xkbcommon/libxkbcommon/commit/1f9d1248c07cda8aaff762429c0dce146de8632a,2018-08-25T21:29Z
CWE-704,"CWE-000 static void n_tty_set_termios ( struct tty_struct * tty , struct ktermios * old ) { struct n_tty_data * ldata = tty -> disc_data ; <S2SV_StartBug> if ( ! old || ( old -> c_lflag ^ tty -> termios . c_lflag ) & ICANON ) { <S2SV_EndBug> bitmap_zero ( ldata -> read_flags , N_TTY_BUF_SIZE ) ; ldata -> line_start = ldata -> read_tail ; if ( ! L_ICANON ( tty ) || ! read_cnt ( ldata ) ) { ldata -> canon_head = ldata -> read_tail ; ldata -> push = 0 ; } else { set_bit ( ( ldata -> read_head - 1 ) & ( N_TTY_BUF_SIZE - 1 ) , ldata -> read_flags ) ; ldata -> canon_head = ldata -> read_head ; ldata -> push = 1 ; } ldata -> commit_head = ldata -> read_head ; ldata -> erasing = 0 ; ldata -> lnext = 0 ; } ldata -> icanon = ( L_ICANON ( tty ) != 0 ) ; if ( I_ISTRIP ( tty ) || I_IUCLC ( tty ) || I_IGNCR ( tty ) || I_ICRNL ( tty ) || I_INLCR ( tty ) || L_ICANON ( tty ) || I_IXON ( tty ) || L_ISIG ( tty ) || L_ECHO ( tty ) || I_PARMRK ( tty ) ) { bitmap_zero ( ldata -> char_map , 256 ) ; if ( I_IGNCR ( tty ) || I_ICRNL ( tty ) ) set_bit ( '\\r' , ldata -> char_map ) ; if ( I_INLCR ( tty ) ) set_bit ( '\\n' , ldata -> char_map ) ; if ( L_ICANON ( tty ) ) { set_bit ( ERASE_CHAR ( tty ) , ldata -> char_map ) ; set_bit ( KILL_CHAR ( tty ) , ldata -> char_map ) ; set_bit ( EOF_CHAR ( tty ) , ldata -> char_map ) ; set_bit ( '\\n' , ldata -> char_map ) ; set_bit ( EOL_CHAR ( tty ) , ldata -> char_map ) ; if ( L_IEXTEN ( tty ) ) { set_bit ( WERASE_CHAR ( tty ) , ldata -> char_map ) ; set_bit ( LNEXT_CHAR ( tty ) , ldata -> char_map ) ; set_bit ( EOL2_CHAR ( tty ) , ldata -> char_map ) ; if ( L_ECHO ( tty ) ) set_bit ( REPRINT_CHAR ( tty ) , ldata -> char_map ) ; } } if ( I_IXON ( tty ) ) { set_bit ( START_CHAR ( tty ) , ldata -> char_map ) ; set_bit ( STOP_CHAR ( tty ) , ldata -> char_map ) ; } if ( L_ISIG ( tty ) ) { set_bit ( INTR_CHAR ( tty ) , ldata -> char_map ) ; set_bit ( QUIT_CHAR ( tty ) , ldata -> char_map ) ; set_bit ( SUSP_CHAR ( tty ) , ldata -> char_map ) ; } clear_bit ( __DISABLED_CHAR , ldata -> char_map ) ; ldata -> raw = 0 ; ldata -> real_raw = 0 ; } else { ldata -> raw = 1 ; if ( ( I_IGNBRK ( tty ) || ( ! I_BRKINT ( tty ) && ! I_PARMRK ( tty ) ) ) && ( I_IGNPAR ( tty ) || ! I_INPCK ( tty ) ) && ( tty -> driver -> flags & TTY_DRIVER_REAL_RAW ) ) ldata -> real_raw = 1 ; else ldata -> real_raw = 0 ; } if ( ! I_IXON ( tty ) && old && ( old -> c_iflag & IXON ) && ! tty -> flow_stopped ) { start_tty ( tty ) ; process_echoes ( tty ) ; } wake_up_interruptible ( & tty -> write_wait ) ; wake_up_interruptible ( & tty -> read_wait ) ; }",<S2SV_ModStart> c_lflag ) & ( ICANON | EXTPROC ) <S2SV_ModEnd> ) { bitmap_zero,torvalds@linux/966031f340185eddd05affcf72b740549f056348,CVE-2018-18386,https://github.com/torvalds/linux/commit/966031f340185eddd05affcf72b740549f056348,2018-10-17T20:29Z
CWE-264,"CWE-264 static int svc_can_register ( const uint16_t * name , size_t name_len , pid_t spid , uid_t uid ) { const char * perm = ""add"" ; <S2SV_StartBug> if ( uid >= AID_APP ) { <S2SV_EndBug> return 0 ; } return check_mac_perms_from_lookup ( spid , uid , perm , str8 ( name , name_len ) ) ? 1 : 0 ; }",<S2SV_ModStart> ; if ( multiuser_get_app_id ( uid ) <S2SV_ModEnd> >= AID_APP ),frameworks@native/047eec456943dc082e33220d28abb7df4e089f69,CVE-2016-3900,https://android.googlesource.com/platform/frameworks/native/+/047eec456943dc082e33220d28abb7df4e089f69,2016-10-10T10:59Z
CWE-254,CWE-000 <S2SV_StartBug> static void follow_dotdot ( struct nameidata * nd ) <S2SV_EndBug> { if ( ! nd -> root . mnt ) set_root ( nd ) ; while ( 1 ) { struct dentry * old = nd -> path . dentry ; if ( nd -> path . dentry == nd -> root . dentry && nd -> path . mnt == nd -> root . mnt ) { break ; } if ( nd -> path . dentry != nd -> path . mnt -> mnt_root ) { nd -> path . dentry = dget_parent ( nd -> path . dentry ) ; dput ( old ) ; <S2SV_StartBug> break ; <S2SV_EndBug> } if ( ! follow_up ( & nd -> path ) ) break ; } follow_mount ( & nd -> path ) ; nd -> inode = nd -> path . dentry -> d_inode ; <S2SV_StartBug> } <S2SV_EndBug>,<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> follow_dotdot ( struct <S2SV_ModStart> old ) ; if ( unlikely ( ! path_connected ( & nd -> path ) ) ) return - ENOENT ; <S2SV_ModStart> -> d_inode ; return 0 ;,torvalds@linux/397d425dc26da728396e66d392d5dcb8dac30c37,CVE-2015-2925,https://github.com/torvalds/linux/commit/397d425dc26da728396e66d392d5dcb8dac30c37,2015-11-16T11:59Z
CWE-125,"CWE-125 static __forceinline void draw_line ( float * output , int x0 , int y0 , int x1 , int y1 , int n ) { int dy = y1 - y0 ; int adx = x1 - x0 ; int ady = abs ( dy ) ; int base ; int x = x0 , y = y0 ; int err = 0 ; int sy ; # ifdef STB_VORBIS_DIVIDE_TABLE if ( adx < DIVTAB_DENOM && ady < DIVTAB_NUMER ) { if ( dy < 0 ) { base = - integer_divide_table [ ady ] [ adx ] ; sy = base - 1 ; } else { base = integer_divide_table [ ady ] [ adx ] ; sy = base + 1 ; } } else { base = dy / adx ; if ( dy < 0 ) sy = base - 1 ; else sy = base + 1 ; } # else base = dy / adx ; if ( dy < 0 ) sy = base - 1 ; else sy = base + 1 ; # endif ady -= abs ( base ) * adx ; if ( x1 > n ) x1 = n ; if ( x < x1 ) { <S2SV_StartBug> LINE_OP ( output [ x ] , inverse_db_table [ y ] ) ; <S2SV_EndBug> for ( ++ x ; x < x1 ; ++ x ) { err += ady ; if ( err >= adx ) { err -= adx ; y += sy ; } else y += base ; <S2SV_StartBug> LINE_OP ( output [ x ] , inverse_db_table [ y ] ) ; <S2SV_EndBug> } } }",<S2SV_ModStart> inverse_db_table [ y & 255 <S2SV_ModStart> inverse_db_table [ y & 255,nothings@stb/98fdfc6df88b1e34a736d5e126e6c8139c8de1a6,CVE-2019-13222,https://github.com/nothings/stb/commit/98fdfc6df88b1e34a736d5e126e6c8139c8de1a6,2019-08-15T17:15Z
CWE-20,"CWE-20 uint16_t enc28j60ReadPhyReg ( NetInterface * interface , uint16_t address ) { uint16_t data ; <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_MIREGADR , address & REG_ADDR_MASK ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_MICMD , MICMD_MIIRD ) ; <S2SV_EndBug> <S2SV_StartBug> while ( ( enc28j60ReadReg ( interface , ENC28J60_REG_MISTAT ) & MISTAT_BUSY ) != 0 ) <S2SV_EndBug> { } <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_MICMD , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> data = enc28j60ReadReg ( interface , ENC28J60_REG_MIRDL ) ; <S2SV_EndBug> <S2SV_StartBug> data |= enc28j60ReadReg ( interface , ENC28J60_REG_MIRDH ) << 8 ; <S2SV_EndBug> return data ; }","<S2SV_ModStart> ( interface , ENC28J60_MIREGADR <S2SV_ModEnd> , address & <S2SV_ModStart> ( interface , ENC28J60_MICMD , ENC28J60_MICMD_MIIRD <S2SV_ModEnd> ) ; while <S2SV_ModStart> ( interface , ENC28J60_MISTAT ) & ENC28J60_MISTAT_BUSY <S2SV_ModEnd> ) != 0 <S2SV_ModStart> ( interface , ENC28J60_MICMD <S2SV_ModEnd> , 0 ) <S2SV_ModStart> ( interface , ENC28J60_MIRDL <S2SV_ModEnd> ) ; data <S2SV_ModStart> ( interface , ENC28J60_MIRDH <S2SV_ModEnd> ) << 8",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z
CWE-532,"CWE-000 static int klsi_105_get_line_state ( struct usb_serial_port * port , unsigned long * line_state_p ) { int rc ; u8 * status_buf ; __u16 status ; dev_info ( & port -> serial -> dev -> dev , ""sending<S2SV_blank>SIO<S2SV_blank>Poll<S2SV_blank>request\\n"" ) ; status_buf = kmalloc ( KLSI_STATUSBUF_LEN , GFP_KERNEL ) ; if ( ! status_buf ) return - ENOMEM ; status_buf [ 0 ] = 0xff ; status_buf [ 1 ] = 0xff ; rc = usb_control_msg ( port -> serial -> dev , usb_rcvctrlpipe ( port -> serial -> dev , 0 ) , KL5KUSB105A_SIO_POLL , USB_TYPE_VENDOR | USB_DIR_IN , 0 , 0 , status_buf , KLSI_STATUSBUF_LEN , 10000 ) ; <S2SV_StartBug> if ( rc < 0 ) <S2SV_EndBug> <S2SV_StartBug> dev_err ( & port -> dev , ""Reading<S2SV_blank>line<S2SV_blank>status<S2SV_blank>failed<S2SV_blank>(error<S2SV_blank>=<S2SV_blank>%d)\\n"" , <S2SV_EndBug> rc ) ; else { status = get_unaligned_le16 ( status_buf ) ; dev_info ( & port -> serial -> dev -> dev , ""read<S2SV_blank>status<S2SV_blank>%x<S2SV_blank>%x\\n"" , status_buf [ 0 ] , status_buf [ 1 ] ) ; * line_state_p = klsi_105_status2linestate ( status ) ; } kfree ( status_buf ) ; return rc ; }","<S2SV_ModStart> if ( rc != KLSI_STATUSBUF_LEN ) { <S2SV_ModEnd> dev_err ( & <S2SV_ModStart> -> dev , ""reading<S2SV_blank>line<S2SV_blank>status<S2SV_blank>failed:<S2SV_blank>%d\\n"" , rc ) ; if ( rc >= 0 ) rc = - EIO ; } <S2SV_ModEnd> else { status",torvalds@linux/146cc8a17a3b4996f6805ee5c080e7101277c410,CVE-2017-5549,https://github.com/torvalds/linux/commit/146cc8a17a3b4996f6805ee5c080e7101277c410,2017-02-06T06:59Z
CWE-125,"CWE-125 int yr_re_match ( RE * re , const char * target ) { return yr_re_exec ( re -> code , ( uint8_t * ) target , strlen ( target ) , <S2SV_StartBug> re -> flags | RE_FLAGS_SCAN , <S2SV_EndBug> NULL , NULL ) ; }","<S2SV_ModStart> target ) , 0 ,",VirusTotal@yara/83d799804648c2a0895d40a19835d9b757c6fa4e,CVE-2017-8294,https://github.com/VirusTotal/yara/commit/83d799804648c2a0895d40a19835d9b757c6fa4e,2017-04-27T14:59Z
CWE-284,"CWE-284 static BOOLEAN flush_incoming_que_on_wr_signal_l ( l2cap_socket * sock ) { uint8_t * buf ; uint32_t len ; while ( packet_get_head_l ( sock , & buf , & len ) ) { <S2SV_StartBug> int sent = send ( sock -> our_fd , buf , len , MSG_DONTWAIT ) ; <S2SV_EndBug> if ( sent == ( signed ) len ) osi_free ( buf ) ; else if ( sent >= 0 ) { packet_put_head_l ( sock , buf + sent , len - sent ) ; osi_free ( buf ) ; if ( ! sent ) return TRUE ; } else { packet_put_head_l ( sock , buf , len ) ; osi_free ( buf ) ; return errno == EINTR || errno == EWOULDBLOCK || errno == EAGAIN ; } } return FALSE ; }","<S2SV_ModStart> int sent = TEMP_FAILURE_RETRY ( <S2SV_ModStart> len , MSG_DONTWAIT )",system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z
CWE-200,"CWE-200 static int l2cap_sock_getname ( struct socket * sock , struct sockaddr * addr , int * len , int peer ) { struct sockaddr_l2 * la = ( struct sockaddr_l2 * ) addr ; struct sock * sk = sock -> sk ; struct l2cap_chan * chan = l2cap_pi ( sk ) -> chan ; <S2SV_StartBug> BT_DBG ( ""sock<S2SV_blank>%p,<S2SV_blank>sk<S2SV_blank>%p"" , sock , sk ) ; <S2SV_EndBug> addr -> sa_family = AF_BLUETOOTH ; * len = sizeof ( struct sockaddr_l2 ) ; if ( peer ) { la -> l2_psm = chan -> psm ; bacpy ( & la -> l2_bdaddr , & bt_sk ( sk ) -> dst ) ; la -> l2_cid = cpu_to_le16 ( chan -> dcid ) ; } else { la -> l2_psm = chan -> sport ; bacpy ( & la -> l2_bdaddr , & bt_sk ( sk ) -> src ) ; la -> l2_cid = cpu_to_le16 ( chan -> scid ) ; } return 0 ; }","<S2SV_ModStart> sock , sk ) ; memset ( la , 0 , sizeof ( struct sockaddr_l2 )",torvalds@linux/792039c73cf176c8e39a6e8beef2c94ff46522ed,CVE-2012-6544,https://github.com/torvalds/linux/commit/792039c73cf176c8e39a6e8beef2c94ff46522ed,2013-03-15T20:55Z
CWE-269,"CWE-000 void virtio_config_writeb ( VirtIODevice * vdev , uint32_t addr , uint32_t data ) { VirtioDeviceClass * k = VIRTIO_DEVICE_GET_CLASS ( vdev ) ; uint8_t val = data ; <S2SV_StartBug> if ( addr > ( vdev -> config_len - sizeof ( val ) ) ) <S2SV_EndBug> return ; stb_p ( vdev -> config + addr , val ) ; if ( k -> set_config ) { k -> set_config ( vdev , vdev -> config ) ; } }",<S2SV_ModStart> if ( addr + <S2SV_ModEnd> sizeof ( val <S2SV_ModStart> ( val ) > vdev -> config_len ) { return ; } <S2SV_ModEnd> stb_p ( vdev,qemu@qemu/5f5a1318653c08e435cfa52f60b6a712815b659d,CVE-2013-2016,https://github.com/qemu/qemu/commit/5f5a1318653c08e435cfa52f60b6a712815b659d,2019-12-30T22:15Z
CWE-416,"CWE-416 void ion_free ( struct ion_client * client , struct ion_handle * handle ) { <S2SV_StartBug> bool valid_handle ; <S2SV_EndBug> BUG_ON ( client != handle -> client ) ; mutex_lock ( & client -> lock ) ; <S2SV_StartBug> valid_handle = ion_handle_validate ( client , handle ) ; <S2SV_EndBug> if ( ! valid_handle ) { WARN ( 1 , ""%s:<S2SV_blank>invalid<S2SV_blank>handle<S2SV_blank>passed<S2SV_blank>to<S2SV_blank>free.\\n"" , __func__ ) ; mutex_unlock ( & client -> lock ) ; <S2SV_StartBug> return ; <S2SV_EndBug> } mutex_unlock ( & client -> lock ) ; ion_handle_put ( handle ) ; }","<S2SV_ModStart> handle ) { <S2SV_ModEnd> BUG_ON ( client <S2SV_ModStart> lock ) ; ion_free_nolock <S2SV_ModEnd> ( client , <S2SV_ModStart> client , handle <S2SV_ModEnd> ) ; mutex_unlock <S2SV_ModStart> lock ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>",torvalds@linux/9590232bb4f4cc824f3425a6e1349afbe6d6d2b7,CVE-2016-9120,https://github.com/torvalds/linux/commit/9590232bb4f4cc824f3425a6e1349afbe6d6d2b7,2016-12-08T21:59Z
CWE-119,"CWE-119 <S2SV_StartBug> static void write_sync_code ( struct vp9_write_bit_buffer * wb ) { <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_literal ( wb , VP9_SYNC_CODE_0 , 8 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_literal ( wb , VP9_SYNC_CODE_1 , 8 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_literal ( wb , VP9_SYNC_CODE_2 , 8 ) ; <S2SV_EndBug> }","<S2SV_ModStart> write_sync_code ( struct vpx_write_bit_buffer <S2SV_ModEnd> * wb ) <S2SV_ModStart> wb ) { vpx_wb_write_literal <S2SV_ModEnd> ( wb , <S2SV_ModStart> 8 ) ; vpx_wb_write_literal <S2SV_ModEnd> ( wb , <S2SV_ModStart> 8 ) ; vpx_wb_write_literal <S2SV_ModEnd> ( wb ,",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-119,"CWE-119 <S2SV_StartBug> static INLINE void add_token ( TOKENEXTRA * * t , const vp9_prob * context_tree , <S2SV_EndBug> <S2SV_StartBug> int16_t extra , uint8_t token , <S2SV_EndBug> uint8_t skip_eob_node , unsigned int * counts ) { ( * t ) -> token = token ; ( * t ) -> extra = extra ; ( * t ) -> context_tree = context_tree ; ( * t ) -> skip_eob_node = skip_eob_node ; ( * t ) ++ ; ++ counts [ token ] ; }","<S2SV_ModStart> t , const vpx_prob <S2SV_ModEnd> * context_tree , <S2SV_ModStart> * context_tree , int32_t <S2SV_ModEnd> extra , uint8_t",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-416,CWE-416 static void smp_task_done ( struct sas_task * task ) { <S2SV_StartBug> if ( ! del_timer ( & task -> slow_task -> timer ) ) <S2SV_EndBug> return ; complete ( & task -> slow_task -> completion ) ; },<S2SV_ModStart> task ) { <S2SV_ModEnd> del_timer ( & <S2SV_ModStart> -> timer ) <S2SV_ModEnd> ; complete (,torvalds@linux/b90cd6f2b905905fb42671009dc0e27c310a16ae,CVE-2018-20836,https://github.com/torvalds/linux/commit/b90cd6f2b905905fb42671009dc0e27c310a16ae,2019-05-07T14:29Z
CWE-119,"CWE-119 <S2SV_StartBug> int mutt_b64_decode ( char * out , const char * in ) <S2SV_EndBug> { int len = 0 ; unsigned char digit4 ; do { const unsigned char digit1 = in [ 0 ] ; if ( ( digit1 > 127 ) || ( base64val ( digit1 ) == BAD ) ) return - 1 ; const unsigned char digit2 = in [ 1 ] ; if ( ( digit2 > 127 ) || ( base64val ( digit2 ) == BAD ) ) return - 1 ; const unsigned char digit3 = in [ 2 ] ; if ( ( digit3 > 127 ) || ( ( digit3 != '=' ) && ( base64val ( digit3 ) == BAD ) ) ) return - 1 ; digit4 = in [ 3 ] ; if ( ( digit4 > 127 ) || ( ( digit4 != '=' ) && ( base64val ( digit4 ) == BAD ) ) ) return - 1 ; in += 4 ; <S2SV_StartBug> * out ++ = ( base64val ( digit1 ) << 2 ) | ( base64val ( digit2 ) >> 4 ) ; <S2SV_EndBug> len ++ ; if ( digit3 != '=' ) { <S2SV_StartBug> * out ++ = ( ( base64val ( digit2 ) << 4 ) & 0xf0 ) | ( base64val ( digit3 ) >> 2 ) ; <S2SV_EndBug> len ++ ; if ( digit4 != '=' ) { <S2SV_StartBug> * out ++ = ( ( base64val ( digit3 ) << 6 ) & 0xc0 ) | base64val ( digit4 ) ; <S2SV_EndBug> len ++ ; } } } while ( * in && digit4 != '=' ) ; return len ; }","<S2SV_ModStart> char * in , size_t olen <S2SV_ModStart> += 4 ; if ( len == olen ) return len ; <S2SV_ModStart> '=' ) { if ( len == olen ) return len ; <S2SV_ModStart> '=' ) { if ( len == olen ) return len ;",neomutt@neomutt/6f163e07ae68654d7ac5268cbb7565f6df79ad85,CVE-2018-14359,https://github.com/neomutt/neomutt/commit/6f163e07ae68654d7ac5268cbb7565f6df79ad85,2018-07-17T17:29Z
CWE-189,"CWE-189 void * chk_malloc ( size_t bytes ) { <S2SV_StartBug> char * buffer = ( char * ) dlmalloc ( bytes + CHK_OVERHEAD_SIZE ) ; <S2SV_EndBug> if ( buffer ) { memset ( buffer , CHK_SENTINEL_VALUE , bytes + CHK_OVERHEAD_SIZE ) ; size_t offset = dlmalloc_usable_size ( buffer ) - sizeof ( size_t ) ; * ( size_t * ) ( buffer + offset ) = bytes ; buffer += CHK_SENTINEL_HEAD_SIZE ; } return buffer ; }",<S2SV_ModStart> bytes ) { size_t size = bytes + CHK_OVERHEAD_SIZE ; if ( size < bytes ) { return NULL ; } uint8_t <S2SV_ModEnd> * buffer = <S2SV_ModStart> buffer = ( uint8_t <S2SV_ModEnd> * ) dlmalloc <S2SV_ModStart> ) dlmalloc ( size <S2SV_ModEnd> ) ; if,android@platform_bionic/7f5aa4f35e23fd37425b3a5041737cdf58f87385,CVE-2012-2674,https://github.com/android/platform_bionic/commit/7f5aa4f35e23fd37425b3a5041737cdf58f87385,2012-07-25T19:55Z
CWE-119,"CWE-119 static void write_modes ( VP9_COMP * cpi , const TileInfo * const tile , <S2SV_StartBug> vp9_writer * w , TOKENEXTRA * * tok , TOKENEXTRA * tok_end ) { <S2SV_EndBug> <S2SV_StartBug> int mi_row , mi_col ; <S2SV_EndBug> for ( mi_row = tile -> mi_row_start ; mi_row < tile -> mi_row_end ; mi_row += MI_BLOCK_SIZE ) { <S2SV_StartBug> vp9_zero ( cpi -> mb . e_mbd . left_seg_context ) ; <S2SV_EndBug> for ( mi_col = tile -> mi_col_start ; mi_col < tile -> mi_col_end ; mi_col += MI_BLOCK_SIZE ) write_modes_sb ( cpi , tile , w , tok , tok_end , mi_row , mi_col , BLOCK_64X64 ) ; } }","<S2SV_ModStart> const tile , vpx_writer <S2SV_ModEnd> * w , <S2SV_ModStart> * tok , const TOKENEXTRA * const <S2SV_ModEnd> tok_end ) { <S2SV_ModStart> tok_end ) { const VP9_COMMON * const cm = & cpi -> common ; MACROBLOCKD * const xd = & cpi -> td . mb . e_mbd ; <S2SV_ModStart> mi_row , mi_col ; set_partition_probs ( cm , xd ) <S2SV_ModStart> { vp9_zero ( xd -> <S2SV_ModEnd> left_seg_context ) ;",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-119,"CWE-119 int vp9_is_skippable_in_plane ( MACROBLOCK * x , BLOCK_SIZE bsize , int plane ) { int result = 1 ; <S2SV_StartBug> struct is_skippable_args args = { x , & result } ; <S2SV_EndBug> vp9_foreach_transformed_block_in_plane ( & x -> e_mbd , bsize , plane , is_skippable , & args ) ; return result ; }",<S2SV_ModStart> = { x -> plane [ plane ] . eobs,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-20,"CWE-20 int wait_for_key_construction ( struct key * key , bool intr ) { int ret ; ret = wait_on_bit ( & key -> flags , KEY_FLAG_USER_CONSTRUCT , intr ? TASK_INTERRUPTIBLE : TASK_UNINTERRUPTIBLE ) ; if ( ret ) return - ERESTARTSYS ; <S2SV_StartBug> if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) { <S2SV_EndBug> smp_rmb ( ) ; return key -> reject_error ; } return key_validate ( key ) ; }",<S2SV_ModStart> - ERESTARTSYS ; ret = key_read_state ( key ) ; if ( ret < 0 ) return ret ; <S2SV_ModEnd> return key_validate (,torvalds@linux/363b02dab09b3226f3bd1420dad9c72b79a42a76,CVE-2017-15951,https://github.com/torvalds/linux/commit/363b02dab09b3226f3bd1420dad9c72b79a42a76,2017-10-28T02:29Z
CWE-19,"CWE-000 static void ext4_xattr_release_block ( handle_t * handle , struct inode * inode , struct buffer_head * bh ) { <S2SV_StartBug> struct mb_cache_entry * ce = NULL ; <S2SV_EndBug> <S2SV_StartBug> int error = 0 ; <S2SV_EndBug> struct mb_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ; ce = mb_cache_entry_get ( ext4_mb_cache , bh -> b_bdev , bh -> b_blocknr ) ; BUFFER_TRACE ( bh , ""get_write_access"" ) ; error = ext4_journal_get_write_access ( handle , bh ) ; if ( error ) goto out ; lock_buffer ( bh ) ; if ( BHDR ( bh ) -> h_refcount == cpu_to_le32 ( 1 ) ) { <S2SV_StartBug> ea_bdebug ( bh , ""refcount<S2SV_blank>now=0;<S2SV_blank>freeing"" ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ce ) <S2SV_EndBug> mb_cache_entry_free ( ce ) ; get_bh ( bh ) ; unlock_buffer ( bh ) ; ext4_free_blocks ( handle , inode , bh , 0 , 1 , EXT4_FREE_BLOCKS_METADATA | EXT4_FREE_BLOCKS_FORGET ) ; } else { le32_add_cpu ( & BHDR ( bh ) -> h_refcount , - 1 ) ; <S2SV_StartBug> if ( ce ) <S2SV_EndBug> mb_cache_entry_release ( ce ) ; if ( ext4_handle_valid ( handle ) ) error = ext4_handle_dirty_xattr_block ( handle , inode , bh ) ; unlock_buffer ( bh ) ; if ( ! ext4_handle_valid ( handle ) ) error = ext4_handle_dirty_xattr_block ( handle , inode , bh ) ; if ( IS_SYNC ( inode ) ) ext4_handle_sync ( handle ) ; dquot_free_block ( inode , EXT4_C2B ( EXT4_SB ( inode -> i_sb ) , 1 ) ) ; ea_bdebug ( bh , ""refcount<S2SV_blank>now=%d;<S2SV_blank>releasing"" , le32_to_cpu ( BHDR ( bh ) -> h_refcount ) ) ; } out : ext4_std_error ( inode -> i_sb , error ) ; return ; }","<S2SV_ModStart> bh ) { <S2SV_ModEnd> int error = <S2SV_ModStart> error = 0 <S2SV_ModEnd> ; BUFFER_TRACE ( <S2SV_ModStart> ) ) { __u32 hash = le32_to_cpu ( BHDR ( bh ) -> h_hash ) ; <S2SV_ModStart> ""refcount<S2SV_blank>now=0;<S2SV_blank>freeing"" ) ; mb2_cache_entry_delete_block ( EXT4_GET_MB_CACHE ( inode ) , hash , bh -> b_blocknr <S2SV_ModEnd> ) ; get_bh <S2SV_ModStart> ; if ( <S2SV_ModEnd> ext4_handle_valid ( handle",torvalds@linux/82939d7999dfc1f1998c4b1c12e2f19edbdff272,CVE-2015-8952,https://github.com/torvalds/linux/commit/82939d7999dfc1f1998c4b1c12e2f19edbdff272,2016-10-16T21:59Z
CWE-119,"CWE-119 static int read_skip ( VP9_COMMON * cm , const MACROBLOCKD * xd , <S2SV_StartBug> int segment_id , vp9_reader * r ) { <S2SV_EndBug> <S2SV_StartBug> if ( vp9_segfeature_active ( & cm -> seg , segment_id , SEG_LVL_SKIP ) ) { <S2SV_EndBug> return 1 ; } else { const int ctx = vp9_get_skip_context ( xd ) ; <S2SV_StartBug> const int skip = vp9_read ( r , cm -> fc . skip_probs [ ctx ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! cm -> frame_parallel_decoding_mode ) <S2SV_EndBug> ++ cm -> counts . skip [ ctx ] [ skip ] ; return skip ; } }","<S2SV_ModStart> int segment_id , vpx_reader <S2SV_ModEnd> * r ) <S2SV_ModStart> { if ( segfeature_active <S2SV_ModEnd> ( & cm <S2SV_ModStart> int skip = vpx_read <S2SV_ModEnd> ( r , <S2SV_ModStart> cm -> fc -> <S2SV_ModEnd> skip_probs [ ctx <S2SV_ModStart> ] ) ; FRAME_COUNTS * counts = xd -> counts ; if ( counts ) ++ counts -> <S2SV_ModEnd> skip [ ctx",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-119,"CWE-119 PTA * ptaReadStream ( FILE * fp ) { char typestr [ 128 ] ; l_int32 i , n , ix , iy , type , version ; l_float32 x , y ; PTA * pta ; PROCNAME ( ""ptaReadStream"" ) ; if ( ! fp ) return ( PTA * ) ERROR_PTR ( ""stream<S2SV_blank>not<S2SV_blank>defined"" , procName , NULL ) ; if ( fscanf ( fp , ""\\n<S2SV_blank>Pta<S2SV_blank>Version<S2SV_blank>%d\\n"" , & version ) != 1 ) return ( PTA * ) ERROR_PTR ( ""not<S2SV_blank>a<S2SV_blank>pta<S2SV_blank>file"" , procName , NULL ) ; if ( version != PTA_VERSION_NUMBER ) return ( PTA * ) ERROR_PTR ( ""invalid<S2SV_blank>pta<S2SV_blank>version"" , procName , NULL ) ; <S2SV_StartBug> if ( fscanf ( fp , ""<S2SV_blank>Number<S2SV_blank>of<S2SV_blank>pts<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>format<S2SV_blank>=<S2SV_blank>%s\\n"" , & n , typestr ) != 2 ) <S2SV_EndBug> return ( PTA * ) ERROR_PTR ( ""not<S2SV_blank>a<S2SV_blank>pta<S2SV_blank>file"" , procName , NULL ) ; if ( ! strcmp ( typestr , ""float"" ) ) type = 0 ; else type = 1 ; if ( ( pta = ptaCreate ( n ) ) == NULL ) return ( PTA * ) ERROR_PTR ( ""pta<S2SV_blank>not<S2SV_blank>made"" , procName , NULL ) ; for ( i = 0 ; i < n ; i ++ ) { if ( type == 0 ) { if ( fscanf ( fp , ""<S2SV_blank><S2SV_blank><S2SV_blank>(%f,<S2SV_blank>%f)\\n"" , & x , & y ) != 2 ) { ptaDestroy ( & pta ) ; return ( PTA * ) ERROR_PTR ( ""error<S2SV_blank>reading<S2SV_blank>floats"" , procName , NULL ) ; } ptaAddPt ( pta , x , y ) ; } else { if ( fscanf ( fp , ""<S2SV_blank><S2SV_blank><S2SV_blank>(%d,<S2SV_blank>%d)\\n"" , & ix , & iy ) != 2 ) { ptaDestroy ( & pta ) ; return ( PTA * ) ERROR_PTR ( ""error<S2SV_blank>reading<S2SV_blank>ints"" , procName , NULL ) ; } ptaAddPt ( pta , ix , iy ) ; } } return pta ; }","<S2SV_ModStart> ( fp , ""<S2SV_blank>Number<S2SV_blank>of<S2SV_blank>pts<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>format<S2SV_blank>=<S2SV_blank>%127s\\n"" <S2SV_ModEnd> , & n",DanBloomberg@leptonica/ee301cb2029db8a6289c5295daa42bba7715e99a,CVE-2018-7186,https://github.com/DanBloomberg/leptonica/commit/ee301cb2029db8a6289c5295daa42bba7715e99a,2018-02-16T16:29Z
CWE-119,"CWE-119 <S2SV_StartBug> void vp9_fht4x4_c ( const int16_t * input , int16_t * output , <S2SV_EndBug> int stride , int tx_type ) { if ( tx_type == DCT_DCT ) { <S2SV_StartBug> vp9_fdct4x4_c ( input , output , stride ) ; <S2SV_EndBug> } else { <S2SV_StartBug> int16_t out [ 4 * 4 ] ; <S2SV_EndBug> <S2SV_StartBug> int16_t * outptr = & out [ 0 ] ; <S2SV_EndBug> int i , j ; <S2SV_StartBug> int16_t temp_in [ 4 ] , temp_out [ 4 ] ; <S2SV_EndBug> const transform_2d ht = FHT_4 [ tx_type ] ; for ( i = 0 ; i < 4 ; ++ i ) { for ( j = 0 ; j < 4 ; ++ j ) temp_in [ j ] = input [ j * stride + i ] * 16 ; if ( i == 0 && temp_in [ 0 ] ) temp_in [ 0 ] += 1 ; ht . cols ( temp_in , temp_out ) ; for ( j = 0 ; j < 4 ; ++ j ) <S2SV_StartBug> outptr [ j * 4 + i ] = temp_out [ j ] ; <S2SV_EndBug> } for ( i = 0 ; i < 4 ; ++ i ) { for ( j = 0 ; j < 4 ; ++ j ) temp_in [ j ] = out [ j + i * 4 ] ; ht . rows ( temp_in , temp_out ) ; for ( j = 0 ; j < 4 ; ++ j ) output [ j + i * 4 ] = ( temp_out [ j ] + 1 ) >> 2 ; } } }","<S2SV_ModStart> * input , tran_low_t <S2SV_ModEnd> * output , <S2SV_ModStart> DCT_DCT ) { vpx_fdct4x4_c <S2SV_ModEnd> ( input , <S2SV_ModStart> } else { tran_low_t <S2SV_ModEnd> out [ 4 <S2SV_ModStart> 4 ] ; <S2SV_ModEnd> int i , <S2SV_ModStart> , j ; tran_low_t <S2SV_ModEnd> temp_in [ 4 <S2SV_ModStart> ++ j ) out <S2SV_ModEnd> [ j *",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-399,"CWE-399 static void alpha_perf_event_irq_handler ( unsigned long la_ptr , struct pt_regs * regs ) { struct cpu_hw_events * cpuc ; struct perf_sample_data data ; struct perf_event * event ; struct hw_perf_event * hwc ; int idx , j ; __get_cpu_var ( irq_pmi_count ) ++ ; cpuc = & __get_cpu_var ( cpu_hw_events ) ; wrperfmon ( PERFMON_CMD_DISABLE , cpuc -> idx_mask ) ; if ( unlikely ( la_ptr >= alpha_pmu -> num_pmcs ) ) { irq_err_count ++ ; pr_warning ( ""PMI:<S2SV_blank>silly<S2SV_blank>index<S2SV_blank>%ld\\n"" , la_ptr ) ; wrperfmon ( PERFMON_CMD_ENABLE , cpuc -> idx_mask ) ; return ; } idx = la_ptr ; perf_sample_data_init ( & data , 0 ) ; for ( j = 0 ; j < cpuc -> n_events ; j ++ ) { if ( cpuc -> current_idx [ j ] == idx ) break ; } if ( unlikely ( j == cpuc -> n_events ) ) { wrperfmon ( PERFMON_CMD_ENABLE , cpuc -> idx_mask ) ; return ; } event = cpuc -> event [ j ] ; if ( unlikely ( ! event ) ) { irq_err_count ++ ; pr_warning ( ""PMI:<S2SV_blank>No<S2SV_blank>event<S2SV_blank>at<S2SV_blank>index<S2SV_blank>%d!\\n"" , idx ) ; wrperfmon ( PERFMON_CMD_ENABLE , cpuc -> idx_mask ) ; return ; } hwc = & event -> hw ; alpha_perf_event_update ( event , hwc , idx , alpha_pmu -> pmc_max_period [ idx ] + 1 ) ; data . period = event -> hw . last_period ; if ( alpha_perf_event_set_period ( event , hwc , idx ) ) { <S2SV_StartBug> if ( perf_event_overflow ( event , 1 , & data , regs ) ) { <S2SV_EndBug> alpha_pmu_stop ( event , 0 ) ; } } wrperfmon ( PERFMON_CMD_ENABLE , cpuc -> idx_mask ) ; return ; }","<S2SV_ModStart> ( event , <S2SV_ModEnd> & data ,",torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z
CWE-119,"CWE-119 static struct grub_ext4_extent_header * grub_ext4_find_leaf ( struct grub_ext2_data * data , char * buf , struct grub_ext4_extent_header * ext_block , grub_uint32_t fileblock ) { struct grub_ext4_extent_idx * index ; while ( 1 ) { int i ; grub_disk_addr_t block ; index = ( struct grub_ext4_extent_idx * ) ( ext_block + 1 ) ; if ( grub_le_to_cpu16 ( ext_block -> magic ) != EXT4_EXT_MAGIC ) return 0 ; if ( ext_block -> depth == 0 ) return ext_block ; for ( i = 0 ; i < grub_le_to_cpu16 ( ext_block -> entries ) ; i ++ ) { if ( fileblock < grub_le_to_cpu32 ( index [ i ] . block ) ) break ; } if ( -- i < 0 ) return 0 ; block = grub_le_to_cpu16 ( index [ i ] . leaf_hi ) ; block = ( block << 32 ) + grub_le_to_cpu32 ( index [ i ] . leaf ) ; if ( grub_disk_read ( data -> disk , block << LOG2_EXT2_BLOCK_SIZE ( data ) , 0 , EXT2_BLOCK_SIZE ( data ) , buf ) ) <S2SV_StartBug> return 0 ; <S2SV_EndBug> ext_block = ( struct grub_ext4_extent_header * ) buf ; } }",<S2SV_ModStart> buf ) ) { return 0 ; } <S2SV_ModEnd> ext_block = (,radare@radare2/65000a7fd9eea62359e6d6714f17b94a99a82edd,CVE-2017-9763,https://github.com/radare/radare2/commit/65000a7fd9eea62359e6d6714f17b94a99a82edd,2017-06-19T16:29Z
CWE-125,"CWE-125 BOOL glyph_cache_put ( rdpGlyphCache * glyphCache , UINT32 id , UINT32 index , rdpGlyph * glyph ) { rdpGlyph * prevGlyph ; if ( id > 9 ) { WLog_ERR ( TAG , ""invalid<S2SV_blank>glyph<S2SV_blank>cache<S2SV_blank>id:<S2SV_blank>%"" PRIu32 """" , id ) ; return FALSE ; } <S2SV_StartBug> if ( index > glyphCache -> glyphCache [ id ] . number ) <S2SV_EndBug> { WLog_ERR ( TAG , ""invalid<S2SV_blank>glyph<S2SV_blank>cache<S2SV_blank>index:<S2SV_blank>%"" PRIu32 ""<S2SV_blank>in<S2SV_blank>cache<S2SV_blank>id:<S2SV_blank>%"" PRIu32 """" , index , id ) ; return FALSE ; } WLog_Print ( glyphCache -> log , WLOG_DEBUG , ""GlyphCachePut:<S2SV_blank>id:<S2SV_blank>%"" PRIu32 ""<S2SV_blank>index:<S2SV_blank>%"" PRIu32 """" , id , index ) ; prevGlyph = glyphCache -> glyphCache [ id ] . entries [ index ] ; if ( prevGlyph ) prevGlyph -> Free ( glyphCache -> context , prevGlyph ) ; glyphCache -> glyphCache [ id ] . entries [ index ] = glyph ; return TRUE ; }",<S2SV_ModStart> if ( index >= <S2SV_ModEnd> glyphCache -> glyphCache,FreeRDP@FreeRDP/c0fd449ec0870b050d350d6d844b1ea6dad4bc7d,CVE-2020-11098,https://github.com/FreeRDP/FreeRDP/commit/c0fd449ec0870b050d350d6d844b1ea6dad4bc7d,2020-06-22T22:15Z
CWE-416,"CWE-416 void CleanWriters ( GF_List * writers ) { while ( gf_list_count ( writers ) ) { <S2SV_StartBug> TrackWriter * writer = ( TrackWriter * ) gf_list_get ( writers , 0 ) ; <S2SV_EndBug> gf_isom_box_del ( writer -> stco ) ; gf_isom_box_del ( ( GF_Box * ) writer -> stsc ) ; gf_free ( writer ) ; gf_list_rem ( writers , 0 ) ; } }","<S2SV_ModStart> writers , 0 ) ; gf_list_del_item ( writer -> stbl -> child_boxes , writer -> stco ) ; gf_list_del_item ( writer -> stbl -> child_boxes , writer -> stsc",gpac@gpac/5aba27604d957e960d8069d85ccaf868f8a7b07a,CVE-2020-35980,https://github.com/gpac/gpac/commit/5aba27604d957e960d8069d85ccaf868f8a7b07a,2021-04-21T16:15Z
CWE-125,"CWE-125 static void nfs_printfh ( netdissect_options * ndo , register const uint32_t * dp , const u_int len ) { my_fsid fsid ; uint32_t ino ; const char * sfsname = NULL ; char * spacep ; if ( ndo -> ndo_uflag ) { u_int i ; char const * sep = """" ; ND_PRINT ( ( ndo , ""<S2SV_blank>fh["" ) ) ; for ( i = 0 ; i < len ; i ++ ) { ND_PRINT ( ( ndo , ""%s%x"" , sep , dp [ i ] ) ) ; sep = "":"" ; } ND_PRINT ( ( ndo , ""]"" ) ) ; return ; } Parse_fh ( ( const u_char * ) dp , len , & fsid , & ino , NULL , & sfsname , 0 ) ; if ( sfsname ) { <S2SV_StartBug> static char temp [ NFSX_V3FHMAX + 1 ] ; <S2SV_EndBug> <S2SV_StartBug> strncpy ( temp , sfsname , NFSX_V3FHMAX ) ; <S2SV_EndBug> <S2SV_StartBug> temp [ sizeof ( temp ) - 1 ] = '\\0' ; <S2SV_EndBug> spacep = strchr ( temp , '<S2SV_blank>' ) ; if ( spacep ) * spacep = '\\0' ; ND_PRINT ( ( ndo , ""<S2SV_blank>fh<S2SV_blank>%s/"" , temp ) ) ; } else { ND_PRINT ( ( ndo , ""<S2SV_blank>fh<S2SV_blank>%d,%d/"" , fsid . Fsid_dev . Major , fsid . Fsid_dev . Minor ) ) ; } if ( fsid . Fsid_dev . Minor == 257 ) ND_PRINT ( ( ndo , ""%s"" , fsid . Opaque_Handle ) ) ; else ND_PRINT ( ( ndo , ""%ld"" , ( long ) ino ) ) ; }","<S2SV_ModStart> sfsname ) { <S2SV_ModEnd> char temp [ <S2SV_ModStart> 1 ] ; u_int stringlen ; stringlen = len ; if ( stringlen > NFSX_V3FHMAX ) stringlen = NFSX_V3FHMAX ; <S2SV_ModStart> , sfsname , stringlen <S2SV_ModEnd> ) ; temp <S2SV_ModStart> ; temp [ stringlen <S2SV_ModEnd> ] = '\\0'",the-tcpdump-group@tcpdump/7a923447fd49a069a0fd3b6c3547438ab5ee2123,CVE-2017-13001,https://github.com/the-tcpdump-group/tcpdump/commit/7a923447fd49a069a0fd3b6c3547438ab5ee2123,2017-09-14T06:29Z
CWE-264,"CWE-264 static int load_state_from_tss32 ( struct x86_emulate_ctxt * ctxt , struct tss_segment_32 * tss ) { int ret ; u8 cpl ; if ( ctxt -> ops -> set_cr ( ctxt , 3 , tss -> cr3 ) ) return emulate_gp ( ctxt , 0 ) ; ctxt -> _eip = tss -> eip ; ctxt -> eflags = tss -> eflags | 2 ; * reg_write ( ctxt , VCPU_REGS_RAX ) = tss -> eax ; * reg_write ( ctxt , VCPU_REGS_RCX ) = tss -> ecx ; * reg_write ( ctxt , VCPU_REGS_RDX ) = tss -> edx ; * reg_write ( ctxt , VCPU_REGS_RBX ) = tss -> ebx ; * reg_write ( ctxt , VCPU_REGS_RSP ) = tss -> esp ; * reg_write ( ctxt , VCPU_REGS_RBP ) = tss -> ebp ; * reg_write ( ctxt , VCPU_REGS_RSI ) = tss -> esi ; * reg_write ( ctxt , VCPU_REGS_RDI ) = tss -> edi ; set_segment_selector ( ctxt , tss -> ldt_selector , VCPU_SREG_LDTR ) ; set_segment_selector ( ctxt , tss -> es , VCPU_SREG_ES ) ; set_segment_selector ( ctxt , tss -> cs , VCPU_SREG_CS ) ; set_segment_selector ( ctxt , tss -> ss , VCPU_SREG_SS ) ; set_segment_selector ( ctxt , tss -> ds , VCPU_SREG_DS ) ; set_segment_selector ( ctxt , tss -> fs , VCPU_SREG_FS ) ; set_segment_selector ( ctxt , tss -> gs , VCPU_SREG_GS ) ; if ( ctxt -> eflags & X86_EFLAGS_VM ) { ctxt -> mode = X86EMUL_MODE_VM86 ; cpl = 3 ; } else { ctxt -> mode = X86EMUL_MODE_PROT32 ; cpl = tss -> cs & 3 ; } <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> ldt_selector , VCPU_SREG_LDTR , cpl , true ) ; <S2SV_EndBug> if ( ret != X86EMUL_CONTINUE ) return ret ; <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> es , VCPU_SREG_ES , cpl , true ) ; <S2SV_EndBug> if ( ret != X86EMUL_CONTINUE ) return ret ; <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> cs , VCPU_SREG_CS , cpl , true ) ; <S2SV_EndBug> if ( ret != X86EMUL_CONTINUE ) return ret ; <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> ss , VCPU_SREG_SS , cpl , true ) ; <S2SV_EndBug> if ( ret != X86EMUL_CONTINUE ) return ret ; <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> ds , VCPU_SREG_DS , cpl , true ) ; <S2SV_EndBug> if ( ret != X86EMUL_CONTINUE ) return ret ; <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> fs , VCPU_SREG_FS , cpl , true ) ; <S2SV_EndBug> if ( ret != X86EMUL_CONTINUE ) return ret ; <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> gs , VCPU_SREG_GS , cpl , true ) ; <S2SV_EndBug> if ( ret != X86EMUL_CONTINUE ) return ret ; return X86EMUL_CONTINUE ; }","<S2SV_ModStart> , VCPU_SREG_LDTR , cpl , true , NULL <S2SV_ModEnd> ) ; if <S2SV_ModStart> , cpl , true , NULL <S2SV_ModEnd> ) ; if <S2SV_ModStart> , cpl , true , NULL <S2SV_ModEnd> ) ; if <S2SV_ModStart> , cpl , true , NULL <S2SV_ModEnd> ) ; if <S2SV_ModStart> , cpl , true , NULL <S2SV_ModEnd> ) ; if <S2SV_ModStart> , cpl , true , NULL <S2SV_ModEnd> ) ; if <S2SV_ModStart> , cpl , true , NULL <S2SV_ModEnd> ) ; if",torvalds@linux/d1442d85cc30ea75f7d399474ca738e0bc96f715,CVE-2014-3647,https://github.com/torvalds/linux/commit/d1442d85cc30ea75f7d399474ca738e0bc96f715,2014-11-10T11:55Z
CWE-119,"CWE-119 vpx_codec_err_t vpx_svc_set_options ( SvcContext * svc_ctx , const char * options ) { <S2SV_StartBug> SvcInternal * const si = get_svc_internal ( svc_ctx ) ; <S2SV_EndBug> if ( svc_ctx == NULL || options == NULL || si == NULL ) { return VPX_CODEC_INVALID_PARAM ; } strncpy ( si -> options , options , sizeof ( si -> options ) ) ; si -> options [ sizeof ( si -> options ) - 1 ] = '\\0' ; return VPX_CODEC_OK ; }",<S2SV_ModStart> options ) { SvcInternal_t <S2SV_ModEnd> * const si,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-119,"CWE-119 WORD32 ih264d_cavlc_4x4res_block_totalcoeff_11to16 ( UWORD32 u4_isdc , UWORD32 u4_total_coeff_trail_one , dec_bit_stream_t * ps_bitstrm ) { UWORD32 u4_total_zeroes ; WORD32 i ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 u4_bitstream_offset = ps_bitstrm -> u4_ofst ; UWORD32 u4_trailing_ones = u4_total_coeff_trail_one & 0xFFFF ; UWORD32 u4_total_coeff = u4_total_coeff_trail_one >> 16 ; <S2SV_StartBug> WORD16 i2_level_arr [ 16 ] ; <S2SV_EndBug> tu_sblk4x4_coeff_data_t * ps_tu_4x4 ; WORD16 * pi2_coeff_data ; dec_struct_t * ps_dec = ( dec_struct_t * ) ps_bitstrm -> pv_codec_handle ; ps_tu_4x4 = ( tu_sblk4x4_coeff_data_t * ) ps_dec -> pv_parse_tu_coeff_data ; ps_tu_4x4 -> u2_sig_coeff_map = 0 ; pi2_coeff_data = & ps_tu_4x4 -> ai2_level [ 0 ] ; i = u4_total_coeff - 1 ; if ( u4_trailing_ones ) { UWORD32 u4_signs , u4_cnt = u4_trailing_ones ; WORD16 ( * ppi2_trlone_lkup ) [ 3 ] = ( WORD16 ( * ) [ 3 ] ) gai2_ih264d_trailing_one_level ; WORD16 * pi2_trlone_lkup ; GETBITS ( u4_signs , u4_bitstream_offset , pu4_bitstrm_buf , u4_cnt ) ; pi2_trlone_lkup = ppi2_trlone_lkup [ ( 1 << u4_cnt ) - 2 + u4_signs ] ; while ( u4_cnt -- ) i2_level_arr [ i -- ] = * pi2_trlone_lkup ++ ; } if ( i >= 0 ) { UWORD32 u4_lev_suffix , u4_suffix_len , u4_lev_suffix_size ; UWORD16 u2_lev_code , u2_abs_value ; UWORD32 u4_lev_prefix ; if ( u4_trailing_ones < 3 ) { FIND_ONE_IN_STREAM_32 ( u4_lev_prefix , u4_bitstream_offset , pu4_bitstrm_buf ) ; u4_lev_suffix_size = ( 15 <= u4_lev_prefix ) ? ( u4_lev_prefix - 3 ) : 1 ; GETBITS ( u4_lev_suffix , u4_bitstream_offset , pu4_bitstrm_buf , u4_lev_suffix_size ) ; u2_lev_code = 2 + ( MIN ( u4_lev_prefix , 15 ) << 1 ) + u4_lev_suffix ; if ( 16 <= u4_lev_prefix ) { u2_lev_code += ( ( 1 << ( u4_lev_prefix - 3 ) ) - 4096 ) ; } } else { FIND_ONE_IN_STREAM_32 ( u4_lev_prefix , u4_bitstream_offset , pu4_bitstrm_buf ) ; u2_lev_code = MIN ( 15 , u4_lev_prefix ) ; u2_lev_code += ( 3 == u4_trailing_ones ) ? 0 : ( 2 ) ; if ( 14 == u4_lev_prefix ) u4_lev_suffix_size = 4 ; else if ( 15 <= u4_lev_prefix ) { u2_lev_code += 15 ; u4_lev_suffix_size = ( u4_lev_prefix - 3 ) ; } else u4_lev_suffix_size = 0 ; if ( 16 <= u4_lev_prefix ) { u2_lev_code += ( ( 1 << ( u4_lev_prefix - 3 ) ) - 4096 ) ; } if ( u4_lev_suffix_size ) { GETBITS ( u4_lev_suffix , u4_bitstream_offset , pu4_bitstrm_buf , u4_lev_suffix_size ) ; u2_lev_code += u4_lev_suffix ; } } u2_abs_value = ( u2_lev_code + 2 ) >> 1 ; i2_level_arr [ i -- ] = ( u2_lev_code & 1 ) ? - u2_abs_value : u2_abs_value ; u4_suffix_len = ( u2_abs_value > 3 ) ? 2 : 1 ; while ( i >= 0 ) { FIND_ONE_IN_STREAM_32 ( u4_lev_prefix , u4_bitstream_offset , pu4_bitstrm_buf ) ; u4_lev_suffix_size = ( 15 <= u4_lev_prefix ) ? ( u4_lev_prefix - 3 ) : u4_suffix_len ; GETBITS ( u4_lev_suffix , u4_bitstream_offset , pu4_bitstrm_buf , u4_lev_suffix_size ) ; u2_lev_code = ( MIN ( 15 , u4_lev_prefix ) << u4_suffix_len ) + u4_lev_suffix ; if ( 16 <= u4_lev_prefix ) { u2_lev_code += ( ( 1 << ( u4_lev_prefix - 3 ) ) - 4096 ) ; } u2_abs_value = ( u2_lev_code + 2 ) >> 1 ; i2_level_arr [ i -- ] = ( u2_lev_code & 1 ) ? - u2_abs_value : u2_abs_value ; u4_suffix_len += ( u4_suffix_len < 6 ) ? ( u2_abs_value > ( 3 << ( u4_suffix_len - 1 ) ) ) : 0 ; } } if ( u4_total_coeff < ( 16 - u4_isdc ) ) { UWORD32 u4_index ; const UWORD8 ( * ppu1_total_zero_lkup ) [ 16 ] = ( const UWORD8 ( * ) [ 16 ] ) gau1_ih264d_table_total_zero_11to15 ; NEXTBITS ( u4_index , u4_bitstream_offset , pu4_bitstrm_buf , 4 ) ; u4_total_zeroes = ppu1_total_zero_lkup [ u4_total_coeff - 11 ] [ u4_index ] ; FLUSHBITS ( u4_bitstream_offset , ( u4_total_zeroes >> 4 ) ) ; u4_total_zeroes &= 0xf ; } else u4_total_zeroes = 0 ; { const UWORD8 * pu1_table_runbefore ; UWORD32 u4_run ; WORD32 k ; UWORD32 u4_scan_pos = u4_total_coeff + u4_total_zeroes - 1 + u4_isdc ; WORD32 u4_zeroes_left = u4_total_zeroes ; k = u4_total_coeff - 1 ; pu1_table_runbefore = ( UWORD8 * ) gau1_ih264d_table_run_before ; while ( ( u4_zeroes_left > 0 ) && k ) { UWORD32 u4_code ; NEXTBITS ( u4_code , u4_bitstream_offset , pu4_bitstrm_buf , 3 ) ; u4_code = pu1_table_runbefore [ u4_code + ( u4_zeroes_left << 3 ) ] ; u4_run = u4_code >> 2 ; FLUSHBITS ( u4_bitstream_offset , ( u4_code & 0x03 ) ) ; SET_BIT ( ps_tu_4x4 -> u2_sig_coeff_map , u4_scan_pos ) ; * pi2_coeff_data ++ = i2_level_arr [ k -- ] ; u4_zeroes_left -= u4_run ; u4_scan_pos -= ( u4_run + 1 ) ; } if ( u4_zeroes_left < 0 ) return - 1 ; while ( k >= 0 ) { SET_BIT ( ps_tu_4x4 -> u2_sig_coeff_map , u4_scan_pos ) ; * pi2_coeff_data ++ = i2_level_arr [ k -- ] ; u4_scan_pos -- ; } } { WORD32 offset ; offset = ( UWORD8 * ) pi2_coeff_data - ( UWORD8 * ) ps_tu_4x4 ; offset = ALIGN4 ( offset ) ; ps_dec -> pv_parse_tu_coeff_data = ( void * ) ( ( UWORD8 * ) ps_dec -> pv_parse_tu_coeff_data + offset ) ; } ps_bitstrm -> u4_ofst = u4_bitstream_offset ; return 0 ; }",<S2SV_ModStart> 16 ; WORD16 ai2_level_arr [ 19 ] ; WORD16 * i2_level_arr = & ai2_level_arr [ 3 <S2SV_ModEnd> ] ; tu_sblk4x4_coeff_data_t,external@libavc/c57fc3703ae2e0d41b1f6580c50015937f2d23c1,CVE-2016-0840,https://android.googlesource.com/platform/external/libavc/+/c57fc3703ae2e0d41b1f6580c50015937f2d23c1,2016-04-18T00:59Z
CWE-120,"CWE-000 static char * get_next_file ( FILE * VFile , char * ptr ) { <S2SV_StartBug> char * ret ; <S2SV_EndBug> ret = fgets ( ptr , PATH_MAX , VFile ) ; if ( ! ret ) return NULL ; <S2SV_StartBug> if ( ptr [ strlen ( ptr ) - 1 ] == '\\n' ) <S2SV_EndBug> <S2SV_StartBug> ptr [ strlen ( ptr ) - 1 ] = '\\0' ; <S2SV_EndBug> return ret ; }",<S2SV_ModStart> char * ret ; size_t len <S2SV_ModStart> return NULL ; len = <S2SV_ModEnd> strlen ( ptr <S2SV_ModStart> ( ptr ) ; if ( len > 0 && ptr [ len <S2SV_ModStart> ) ptr [ len <S2SV_ModEnd> - 1 ],the-tcpdump-group@tcpdump/9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6,CVE-2018-14879,https://github.com/the-tcpdump-group/tcpdump/commit/9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6,2019-10-03T16:15Z
CWE-119,"CWE-119 int vp9_rc_pick_q_and_bounds ( const VP9_COMP * cpi , int * bottom_index , int * top_index ) { int q ; <S2SV_StartBug> if ( cpi -> pass == 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) <S2SV_EndBug> q = rc_pick_q_and_bounds_one_pass_cbr ( cpi , bottom_index , top_index ) ; else q = rc_pick_q_and_bounds_one_pass_vbr ( cpi , bottom_index , top_index ) ; } else { q = rc_pick_q_and_bounds_two_pass ( cpi , bottom_index , top_index ) ; } if ( cpi -> sf . use_nonrd_pick_mode ) { <S2SV_StartBug> if ( q == 0 ) <S2SV_EndBug> q ++ ; if ( cpi -> sf . force_frame_boost == 1 ) q -= cpi -> sf . max_delta_qindex ; if ( q < * bottom_index ) * bottom_index = q ; else if ( q > * top_index ) * top_index = q ; } return q ; }",<S2SV_ModStart> ( cpi -> oxcf . <S2SV_ModStart> -> oxcf . rc_mode == VPX_CBR <S2SV_ModEnd> ) q = <S2SV_ModStart> { if ( <S2SV_ModEnd> cpi -> sf,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-59,"CWE-000 void vrrp_print_data ( void ) { <S2SV_StartBug> FILE * file = fopen ( dump_file , ""w"" ) ; <S2SV_EndBug> if ( ! file ) { log_message ( LOG_INFO , ""Can\'t<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>(%d:<S2SV_blank>%s)"" , dump_file , errno , strerror ( errno ) ) ; return ; } dump_data_vrrp ( file ) ; fclose ( file ) ; }","<S2SV_ModStart> * file = fopen_safe <S2SV_ModEnd> ( dump_file ,",acassen@keepalived/04f2d32871bb3b11d7dc024039952f2fe2750306,CVE-2018-19044,https://github.com/acassen/keepalived/commit/04f2d32871bb3b11d7dc024039952f2fe2750306,2018-11-08T20:29Z
CWE-20,"CWE-20 int bpf_check ( struct bpf_prog * * prog , union bpf_attr * attr ) { struct bpf_verifier_env * env ; struct bpf_verifer_log * log ; int ret = - EINVAL ; if ( ARRAY_SIZE ( bpf_verifier_ops ) == 0 ) return - EINVAL ; env = kzalloc ( sizeof ( struct bpf_verifier_env ) , GFP_KERNEL ) ; if ( ! env ) return - ENOMEM ; log = & env -> log ; env -> insn_aux_data = vzalloc ( sizeof ( struct bpf_insn_aux_data ) * ( * prog ) -> len ) ; ret = - ENOMEM ; if ( ! env -> insn_aux_data ) goto err_free_env ; env -> prog = * prog ; env -> ops = bpf_verifier_ops [ env -> prog -> type ] ; mutex_lock ( & bpf_verifier_lock ) ; if ( attr -> log_level || attr -> log_buf || attr -> log_size ) { log -> level = attr -> log_level ; log -> ubuf = ( char __user * ) ( unsigned long ) attr -> log_buf ; log -> len_total = attr -> log_size ; ret = - EINVAL ; if ( log -> len_total < 128 || log -> len_total > UINT_MAX >> 8 || ! log -> level || ! log -> ubuf ) goto err_unlock ; } env -> strict_alignment = ! ! ( attr -> prog_flags & BPF_F_STRICT_ALIGNMENT ) ; if ( ! IS_ENABLED ( CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS ) ) env -> strict_alignment = true ; if ( env -> prog -> aux -> offload ) { ret = bpf_prog_offload_verifier_prep ( env ) ; if ( ret ) goto err_unlock ; } ret = replace_map_fd_with_map_ptr ( env ) ; if ( ret < 0 ) goto skip_full_check ; env -> explored_states = kcalloc ( env -> prog -> len , sizeof ( struct bpf_verifier_state_list * ) , GFP_USER ) ; ret = - ENOMEM ; if ( ! env -> explored_states ) goto skip_full_check ; ret = check_cfg ( env ) ; if ( ret < 0 ) goto skip_full_check ; env -> allow_ptr_leaks = capable ( CAP_SYS_ADMIN ) ; ret = do_check ( env ) ; if ( env -> cur_state ) { free_verifier_state ( env -> cur_state , true ) ; env -> cur_state = NULL ; } skip_full_check : while ( ! pop_stack ( env , NULL , NULL ) ) ; free_states ( env ) ; if ( ret == 0 ) <S2SV_StartBug> ret = convert_ctx_accesses ( env ) ; <S2SV_EndBug> if ( ret == 0 ) ret = fixup_bpf_calls ( env ) ; if ( log -> level && bpf_verifier_log_full ( log ) ) ret = - ENOSPC ; if ( log -> level && ! log -> ubuf ) { ret = - EFAULT ; goto err_release_maps ; } if ( ret == 0 && env -> used_map_cnt ) { env -> prog -> aux -> used_maps = kmalloc_array ( env -> used_map_cnt , sizeof ( env -> used_maps [ 0 ] ) , GFP_KERNEL ) ; if ( ! env -> prog -> aux -> used_maps ) { ret = - ENOMEM ; goto err_release_maps ; } memcpy ( env -> prog -> aux -> used_maps , env -> used_maps , sizeof ( env -> used_maps [ 0 ] ) * env -> used_map_cnt ) ; env -> prog -> aux -> used_map_cnt = env -> used_map_cnt ; convert_pseudo_ld_imm64 ( env ) ; } err_release_maps : if ( ! env -> prog -> aux -> used_maps ) release_maps ( env ) ; * prog = env -> prog ; err_unlock : mutex_unlock ( & bpf_verifier_lock ) ; vfree ( env -> insn_aux_data ) ; err_free_env : kfree ( env ) ; return ret ; }",<S2SV_ModStart> == 0 ) sanitize_dead_code ( env ) ; if ( ret == 0 ),torvalds@linux/c131187db2d3fa2f8bf32fdf4e9a4ef805168467,CVE-2017-17862,https://github.com/torvalds/linux/commit/c131187db2d3fa2f8bf32fdf4e9a4ef805168467,2017-12-27T17:08Z
CWE-19,"CWE-000 static int ext4_xattr_block_get ( struct inode * inode , int name_index , const char * name , void * buffer , size_t buffer_size ) { struct buffer_head * bh = NULL ; struct ext4_xattr_entry * entry ; size_t size ; int error ; <S2SV_StartBug> struct mb_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ; <S2SV_EndBug> ea_idebug ( inode , ""name=%d.%s,<S2SV_blank>buffer=%p,<S2SV_blank>buffer_size=%ld"" , name_index , name , buffer , ( long ) buffer_size ) ; error = - ENODATA ; if ( ! EXT4_I ( inode ) -> i_file_acl ) goto cleanup ; ea_idebug ( inode , ""reading<S2SV_blank>block<S2SV_blank>%llu"" , ( unsigned long long ) EXT4_I ( inode ) -> i_file_acl ) ; bh = sb_bread ( inode -> i_sb , EXT4_I ( inode ) -> i_file_acl ) ; if ( ! bh ) goto cleanup ; ea_bdebug ( bh , ""b_count=%d,<S2SV_blank>refcount=%d"" , atomic_read ( & ( bh -> b_count ) ) , le32_to_cpu ( BHDR ( bh ) -> h_refcount ) ) ; if ( ext4_xattr_check_block ( inode , bh ) ) { bad_block : EXT4_ERROR_INODE ( inode , ""bad<S2SV_blank>block<S2SV_blank>%llu"" , EXT4_I ( inode ) -> i_file_acl ) ; error = - EFSCORRUPTED ; goto cleanup ; } ext4_xattr_cache_insert ( ext4_mb_cache , bh ) ; entry = BFIRST ( bh ) ; error = ext4_xattr_find_entry ( & entry , name_index , name , bh -> b_size , 1 ) ; if ( error == - EFSCORRUPTED ) goto bad_block ; if ( error ) goto cleanup ; size = le32_to_cpu ( entry -> e_value_size ) ; if ( buffer ) { error = - ERANGE ; if ( size > buffer_size ) goto cleanup ; memcpy ( buffer , bh -> b_data + le16_to_cpu ( entry -> e_value_offs ) , size ) ; } error = size ; cleanup : brelse ( bh ) ; return error ; }",<S2SV_ModStart> error ; struct mb2_cache <S2SV_ModEnd> * ext4_mb_cache =,torvalds@linux/82939d7999dfc1f1998c4b1c12e2f19edbdff272,CVE-2015-8952,https://github.com/torvalds/linux/commit/82939d7999dfc1f1998c4b1c12e2f19edbdff272,2016-10-16T21:59Z
CWE-362,"CWE-362 <S2SV_StartBug> static int mptctl_do_reset ( unsigned long arg ) <S2SV_EndBug> { struct mpt_ioctl_diag_reset __user * urinfo = ( void __user * ) arg ; <S2SV_StartBug> struct mpt_ioctl_diag_reset krinfo ; <S2SV_EndBug> MPT_ADAPTER * iocp ; if ( copy_from_user ( & krinfo , urinfo , sizeof ( struct mpt_ioctl_diag_reset ) ) ) { printk ( KERN_ERR MYNAM ""%s@%d::mptctl_do_reset<S2SV_blank>-<S2SV_blank>"" ""Unable<S2SV_blank>to<S2SV_blank>copy<S2SV_blank>mpt_ioctl_diag_reset<S2SV_blank>struct<S2SV_blank>@<S2SV_blank>%p\\n"" , __FILE__ , __LINE__ , urinfo ) ; <S2SV_StartBug> return - EFAULT ; <S2SV_EndBug> } if ( mpt_verify_adapter ( krinfo . hdr . iocnum , & iocp ) < 0 ) { printk ( KERN_DEBUG MYNAM ""%s@%d::mptctl_do_reset<S2SV_blank>-<S2SV_blank>ioc%d<S2SV_blank>not<S2SV_blank>found!\\n"" , __FILE__ , __LINE__ , krinfo . hdr . iocnum ) ; return - ENODEV ; } dctlprintk ( iocp , printk ( MYIOC_s_DEBUG_FMT ""mptctl_do_reset<S2SV_blank>called.\\n"" , iocp -> name ) ) ; if ( mpt_HardResetHandler ( iocp , CAN_SLEEP ) != 0 ) { printk ( MYIOC_s_ERR_FMT ""%s@%d::mptctl_do_reset<S2SV_blank>-<S2SV_blank>reset<S2SV_blank>failed.\\n"" , iocp -> name , __FILE__ , __LINE__ ) ; return - 1 ; } return 0 ; }","<S2SV_ModStart> int mptctl_do_reset ( MPT_ADAPTER * iocp , <S2SV_ModStart> struct mpt_ioctl_diag_reset krinfo <S2SV_ModEnd> ; if ( <S2SV_ModStart> return - EFAULT <S2SV_ModEnd> ; } dctlprintk",torvalds@linux/28d76df18f0ad5bcf5fa48510b225f0ed262a99b,CVE-2020-12652,https://github.com/torvalds/linux/commit/28d76df18f0ad5bcf5fa48510b225f0ed262a99b,2020-05-05T05:15Z
CWE-362,"CWE-362 static int snd_timer_start_slave ( struct snd_timer_instance * timeri ) { unsigned long flags ; spin_lock_irqsave ( & slave_active_lock , flags ) ; timeri -> flags |= SNDRV_TIMER_IFLG_RUNNING ; <S2SV_StartBug> if ( timeri -> master ) <S2SV_EndBug> list_add_tail ( & timeri -> active_list , & timeri -> master -> slave_active_head ) ; <S2SV_StartBug> spin_unlock_irqrestore ( & slave_active_lock , flags ) ; <S2SV_EndBug> return 1 ; }",<S2SV_ModStart> timeri -> master && timeri -> timer ) { spin_lock ( & timeri -> timer -> lock ) ; <S2SV_ModEnd> list_add_tail ( & <S2SV_ModStart> slave_active_head ) ; spin_unlock ( & timeri -> timer -> lock ) ; },torvalds@linux/b5a663aa426f4884c71cd8580adae73f33570f0d,CVE-2016-2547,https://github.com/torvalds/linux/commit/b5a663aa426f4884c71cd8580adae73f33570f0d,2016-04-27T17:59Z
CWE-400,"CWE-000 <S2SV_StartBug> static void consume_one_event ( unsigned cpu , <S2SV_EndBug> struct evtchn_fifo_control_block * control_block , <S2SV_StartBug> unsigned priority , unsigned long * ready , <S2SV_EndBug> bool drop ) { struct evtchn_fifo_queue * q = & per_cpu ( cpu_queue , cpu ) ; uint32_t head ; evtchn_port_t port ; event_word_t * word ; head = q -> head [ priority ] ; if ( head == 0 ) { virt_rmb ( ) ; head = control_block -> head [ priority ] ; } port = head ; word = event_word_from_port ( port ) ; head = clear_linked ( word ) ; if ( head == 0 ) clear_bit ( priority , ready ) ; if ( evtchn_fifo_is_pending ( port ) && ! evtchn_fifo_is_masked ( port ) ) { <S2SV_StartBug> if ( unlikely ( drop ) ) <S2SV_EndBug> pr_warn ( ""Dropping<S2SV_blank>pending<S2SV_blank>event<S2SV_blank>for<S2SV_blank>port<S2SV_blank>%u\\n"" , port ) ; else <S2SV_StartBug> handle_irq_for_port ( port ) ; <S2SV_EndBug> } q -> head [ priority ] = head ; }","<S2SV_ModStart> ( unsigned cpu , struct evtchn_loop_ctrl * ctrl <S2SV_ModStart> long * ready <S2SV_ModEnd> ) { struct <S2SV_ModStart> ( unlikely ( ! ctrl <S2SV_ModEnd> ) ) pr_warn <S2SV_ModStart> handle_irq_for_port ( port , ctrl",torvalds@linux/e99502f76271d6bc4e374fe368c50c67a1fd3070,CVE-2020-27673,https://github.com/torvalds/linux/commit/e99502f76271d6bc4e374fe368c50c67a1fd3070,2020-10-22T21:15Z
CWE-416,"CWE-416 static int my_login ( pTHX_ SV * dbh , imp_dbh_t * imp_dbh ) { SV * sv ; HV * hv ; char * dbname ; char * host ; char * port ; char * user ; char * password ; char * mysql_socket ; <S2SV_StartBug> int result ; <S2SV_EndBug> D_imp_xxh ( dbh ) ; # define TAKE_IMP_DATA_VERSION 1 # if TAKE_IMP_DATA_VERSION if ( DBIc_has ( imp_dbh , DBIcf_IMPSET ) ) { if ( DBIc_has ( imp_dbh , DBIcf_ACTIVE ) ) { if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""my_login<S2SV_blank>skip<S2SV_blank>connect\\n"" ) ; ++ DBIc_ACTIVE_KIDS ( DBIc_PARENT_COM ( imp_dbh ) ) ; return TRUE ; } if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""my_login<S2SV_blank>IMPSET<S2SV_blank>but<S2SV_blank>not<S2SV_blank>ACTIVE<S2SV_blank>so<S2SV_blank>connect<S2SV_blank>not<S2SV_blank>skipped\\n"" ) ; } # endif sv = DBIc_IMP_DATA ( imp_dbh ) ; if ( ! sv || ! SvROK ( sv ) ) return FALSE ; hv = ( HV * ) SvRV ( sv ) ; if ( SvTYPE ( hv ) != SVt_PVHV ) return FALSE ; host = safe_hv_fetch ( aTHX_ hv , ""host"" , 4 ) ; port = safe_hv_fetch ( aTHX_ hv , ""port"" , 4 ) ; user = safe_hv_fetch ( aTHX_ hv , ""user"" , 4 ) ; password = safe_hv_fetch ( aTHX_ hv , ""password"" , 8 ) ; dbname = safe_hv_fetch ( aTHX_ hv , ""database"" , 8 ) ; mysql_socket = safe_hv_fetch ( aTHX_ hv , ""mysql_socket"" , 12 ) ; if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""imp_dbh->my_login<S2SV_blank>:<S2SV_blank>dbname<S2SV_blank>=<S2SV_blank>%s,<S2SV_blank>uid<S2SV_blank>=<S2SV_blank>%s,<S2SV_blank>pwd<S2SV_blank>=<S2SV_blank>%s,"" ""host<S2SV_blank>=<S2SV_blank>%s,<S2SV_blank>port<S2SV_blank>=<S2SV_blank>%s\\n"" , dbname ? dbname : ""NULL"" , user ? user : ""NULL"" , password ? password : ""NULL"" , host ? host : ""NULL"" , port ? port : ""NULL"" ) ; if ( ! imp_dbh -> pmysql ) { <S2SV_StartBug> Newz ( 908 , imp_dbh -> pmysql , 1 , MYSQL ) ; <S2SV_EndBug> } result = mysql_dr_connect ( dbh , imp_dbh -> pmysql , mysql_socket , host , port , user , password , dbname , imp_dbh ) ? TRUE : FALSE ; <S2SV_StartBug> if ( ! result ) <S2SV_EndBug> <S2SV_StartBug> Safefree ( imp_dbh -> pmysql ) ; <S2SV_EndBug> return result ; }","<S2SV_ModStart> ; int result ; int fresh = 0 <S2SV_ModStart> pmysql ) { fresh = 1 ; <S2SV_ModStart> ; if ( fresh && <S2SV_ModStart> ! result ) { do_error ( dbh , mysql_errno ( imp_dbh -> pmysql ) , mysql_error ( imp_dbh -> pmysql ) , mysql_sqlstate ( imp_dbh -> pmysql ) ) ; <S2SV_ModStart> pmysql ) ; imp_dbh -> pmysql = NULL ; }",perl5-dbi@DBD-mysql/a56ae87a4c1c1fead7d09c3653905841ccccf1cc,CVE-2014-9906,https://github.com/perl5-dbi/DBD-mysql/commit/a56ae87a4c1c1fead7d09c3653905841ccccf1cc,2016-08-19T21:59Z
CWE-119,"CWE-119 char * uwsgi_expand_path ( char * dir , int dir_len , char * ptr ) { <S2SV_StartBug> char src [ PATH_MAX + 1 ] ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( src , dir , dir_len ) ; <S2SV_EndBug> src [ dir_len ] = 0 ; char * dst = ptr ; if ( ! dst ) dst = uwsgi_malloc ( PATH_MAX + 1 ) ; if ( ! realpath ( src , dst ) ) { uwsgi_error_realpath ( src ) ; if ( ! ptr ) free ( dst ) ; <S2SV_StartBug> return NULL ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> return dst ; }","<S2SV_ModStart> ptr ) { if ( dir_len > PATH_MAX ) { uwsgi_log ( ""invalid<S2SV_blank>path<S2SV_blank>size:<S2SV_blank>%d<S2SV_blank>(max<S2SV_blank>%d)\\n"" , dir_len , PATH_MAX ) ; return NULL ; } char * src = uwsgi_concat2n ( <S2SV_ModEnd> dir , dir_len <S2SV_ModStart> dir , dir_len , """" , 0 ) <S2SV_ModEnd> ; char * <S2SV_ModStart> dst ) ; free ( src ) ; <S2SV_ModStart> NULL ; } free ( src ) ;",unbit@uwsgi/cb4636f7c0af2e97a4eef7a3cdcbd85a71247bfe,CVE-2018-6758,https://github.com/unbit/uwsgi/commit/cb4636f7c0af2e97a4eef7a3cdcbd85a71247bfe,2018-02-06T18:29Z
CWE-119,"CWE-119 <S2SV_StartBug> static int write_skip ( const VP9_COMP * cpi , int segment_id , const MODE_INFO * mi , <S2SV_EndBug> <S2SV_StartBug> vp9_writer * w ) { <S2SV_EndBug> <S2SV_StartBug> const MACROBLOCKD * const xd = & cpi -> mb . e_mbd ; <S2SV_EndBug> if ( vp9_segfeature_active ( & cpi -> common . seg , segment_id , SEG_LVL_SKIP ) ) { return 1 ; } else { const int skip = mi -> mbmi . skip ; <S2SV_StartBug> vp9_write ( w , skip , vp9_get_skip_prob ( & cpi -> common , xd ) ) ; <S2SV_EndBug> return skip ; } }","<S2SV_ModStart> write_skip ( const VP9_COMMON * cm , const MACROBLOCKD * xd , <S2SV_ModEnd> int segment_id , <S2SV_ModStart> * mi , vpx_writer <S2SV_ModEnd> * w ) <S2SV_ModStart> w ) { if ( segfeature_active ( & cm -> <S2SV_ModEnd> seg , segment_id <S2SV_ModStart> . skip ; vpx_write <S2SV_ModEnd> ( w , <S2SV_ModStart> , vp9_get_skip_prob ( cm <S2SV_ModEnd> , xd )",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-119,"CWE-119 void vp9_adapt_mv_probs ( VP9_COMMON * cm , int allow_hp ) { int i , j ; <S2SV_StartBug> nmv_context * fc = & cm -> fc . nmvc ; <S2SV_EndBug> const nmv_context * pre_fc = & cm -> frame_contexts [ cm -> frame_context_idx ] . nmvc ; const nmv_context_counts * counts = & cm -> counts . mv ; <S2SV_StartBug> adapt_probs ( vp9_mv_joint_tree , pre_fc -> joints , counts -> joints , fc -> joints ) ; <S2SV_EndBug> for ( i = 0 ; i < 2 ; ++ i ) { nmv_component * comp = & fc -> comps [ i ] ; const nmv_component * pre_comp = & pre_fc -> comps [ i ] ; const nmv_component_counts * c = & counts -> comps [ i ] ; <S2SV_StartBug> comp -> sign = adapt_prob ( pre_comp -> sign , c -> sign ) ; <S2SV_EndBug> <S2SV_StartBug> adapt_probs ( vp9_mv_class_tree , pre_comp -> classes , c -> classes , <S2SV_EndBug> comp -> classes ) ; <S2SV_StartBug> adapt_probs ( vp9_mv_class0_tree , pre_comp -> class0 , c -> class0 , comp -> class0 ) ; <S2SV_EndBug> for ( j = 0 ; j < MV_OFFSET_BITS ; ++ j ) <S2SV_StartBug> comp -> bits [ j ] = adapt_prob ( pre_comp -> bits [ j ] , c -> bits [ j ] ) ; <S2SV_EndBug> for ( j = 0 ; j < CLASS0_SIZE ; ++ j ) <S2SV_StartBug> adapt_probs ( vp9_mv_fp_tree , pre_comp -> class0_fp [ j ] , c -> class0_fp [ j ] , <S2SV_EndBug> comp -> class0_fp [ j ] ) ; <S2SV_StartBug> adapt_probs ( vp9_mv_fp_tree , pre_comp -> fp , c -> fp , comp -> fp ) ; <S2SV_EndBug> if ( allow_hp ) { <S2SV_StartBug> comp -> class0_hp = adapt_prob ( pre_comp -> class0_hp , c -> class0_hp ) ; <S2SV_EndBug> <S2SV_StartBug> comp -> hp = adapt_prob ( pre_comp -> hp , c -> hp ) ; <S2SV_EndBug> } } }","<S2SV_ModStart> cm -> fc -> <S2SV_ModEnd> nmvc ; const <S2SV_ModStart> . mv ; vpx_tree_merge_probs <S2SV_ModEnd> ( vp9_mv_joint_tree , <S2SV_ModStart> -> sign = mode_mv_merge_probs <S2SV_ModEnd> ( pre_comp -> <S2SV_ModStart> sign ) ; vpx_tree_merge_probs <S2SV_ModEnd> ( vp9_mv_class_tree , <S2SV_ModStart> classes ) ; vpx_tree_merge_probs <S2SV_ModEnd> ( vp9_mv_class0_tree , <S2SV_ModStart> j ] = mode_mv_merge_probs <S2SV_ModEnd> ( pre_comp -> <S2SV_ModStart> ++ j ) vpx_tree_merge_probs <S2SV_ModEnd> ( vp9_mv_fp_tree , <S2SV_ModStart> ] ) ; vpx_tree_merge_probs <S2SV_ModEnd> ( vp9_mv_fp_tree , <S2SV_ModStart> -> class0_hp = mode_mv_merge_probs <S2SV_ModEnd> ( pre_comp -> <S2SV_ModStart> -> hp = mode_mv_merge_probs <S2SV_ModEnd> ( pre_comp ->",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-119,"CWE-119 static void yv12_extend_frame_bottom_c ( YV12_BUFFER_CONFIG * ybf ) { int i ; unsigned char * src_ptr1 , * src_ptr2 ; unsigned char * dest_ptr2 ; unsigned int Border ; int plane_stride ; int plane_height ; Border = ybf -> border ; plane_stride = ybf -> y_stride ; plane_height = ybf -> y_height ; src_ptr1 = ybf -> y_buffer - Border ; src_ptr2 = src_ptr1 + ( plane_height * plane_stride ) - plane_stride ; dest_ptr2 = src_ptr2 + plane_stride ; for ( i = 0 ; i < ( int ) Border ; i ++ ) { <S2SV_StartBug> vpx_memcpy ( dest_ptr2 , src_ptr2 , plane_stride ) ; <S2SV_EndBug> dest_ptr2 += plane_stride ; } plane_stride = ybf -> uv_stride ; plane_height = ybf -> uv_height ; Border /= 2 ; src_ptr1 = ybf -> u_buffer - Border ; src_ptr2 = src_ptr1 + ( plane_height * plane_stride ) - plane_stride ; dest_ptr2 = src_ptr2 + plane_stride ; for ( i = 0 ; i < ( int ) ( Border ) ; i ++ ) { <S2SV_StartBug> vpx_memcpy ( dest_ptr2 , src_ptr2 , plane_stride ) ; <S2SV_EndBug> dest_ptr2 += plane_stride ; } src_ptr1 = ybf -> v_buffer - Border ; src_ptr2 = src_ptr1 + ( plane_height * plane_stride ) - plane_stride ; dest_ptr2 = src_ptr2 + plane_stride ; for ( i = 0 ; i < ( int ) ( Border ) ; i ++ ) { <S2SV_StartBug> vpx_memcpy ( dest_ptr2 , src_ptr2 , plane_stride ) ; <S2SV_EndBug> dest_ptr2 += plane_stride ; } }","<S2SV_ModStart> ++ ) { memcpy <S2SV_ModEnd> ( dest_ptr2 , <S2SV_ModStart> ++ ) { memcpy <S2SV_ModEnd> ( dest_ptr2 , <S2SV_ModStart> ++ ) { memcpy <S2SV_ModEnd> ( dest_ptr2 ,",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-284,"CWE-284 int uinput_create ( char * name ) { struct uinput_dev dev ; int fd , x = 0 ; for ( x = 0 ; x < MAX_UINPUT_PATHS ; x ++ ) { <S2SV_StartBug> fd = open ( uinput_dev_path [ x ] , O_RDWR ) ; <S2SV_EndBug> if ( fd < 0 ) continue ; break ; } if ( x == MAX_UINPUT_PATHS ) { BTIF_TRACE_ERROR ( ""%s<S2SV_blank>ERROR:<S2SV_blank>uinput<S2SV_blank>device<S2SV_blank>open<S2SV_blank>failed"" , __FUNCTION__ ) ; return - 1 ; } memset ( & dev , 0 , sizeof ( dev ) ) ; if ( name ) strncpy ( dev . name , name , UINPUT_MAX_NAME_SIZE - 1 ) ; dev . id . bustype = BUS_BLUETOOTH ; dev . id . vendor = 0x0000 ; dev . id . product = 0x0000 ; dev . id . version = 0x0000 ; <S2SV_StartBug> if ( write ( fd , & dev , sizeof ( dev ) ) < 0 ) { <S2SV_EndBug> BTIF_TRACE_ERROR ( ""%s<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>write<S2SV_blank>device<S2SV_blank>information"" , __FUNCTION__ ) ; close ( fd ) ; return - 1 ; } <S2SV_StartBug> ioctl ( fd , UI_SET_EVBIT , EV_KEY ) ; <S2SV_EndBug> <S2SV_StartBug> ioctl ( fd , UI_SET_EVBIT , EV_REL ) ; <S2SV_EndBug> <S2SV_StartBug> ioctl ( fd , UI_SET_EVBIT , EV_SYN ) ; <S2SV_EndBug> for ( x = 0 ; key_map [ x ] . name != NULL ; x ++ ) <S2SV_StartBug> ioctl ( fd , UI_SET_KEYBIT , key_map [ x ] . mapped_id ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ioctl ( fd , UI_DEV_CREATE , NULL ) < 0 ) { <S2SV_EndBug> BTIF_TRACE_ERROR ( ""%s<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>create<S2SV_blank>uinput<S2SV_blank>device"" , __FUNCTION__ ) ; close ( fd ) ; return - 1 ; } return fd ; }","<S2SV_ModStart> { fd = TEMP_FAILURE_RETRY ( <S2SV_ModStart> ] , O_RDWR ) <S2SV_ModStart> ; if ( TEMP_FAILURE_RETRY ( <S2SV_ModStart> sizeof ( dev ) <S2SV_ModStart> 1 ; } TEMP_FAILURE_RETRY ( <S2SV_ModStart> , EV_KEY ) ) ; TEMP_FAILURE_RETRY ( <S2SV_ModEnd> ioctl ( fd <S2SV_ModStart> , EV_REL ) ) ; TEMP_FAILURE_RETRY ( <S2SV_ModEnd> ioctl ( fd <S2SV_ModStart> UI_SET_EVBIT , EV_SYN ) <S2SV_ModStart> x ++ ) TEMP_FAILURE_RETRY ( <S2SV_ModStart> . mapped_id ) ) ; if ( TEMP_FAILURE_RETRY <S2SV_ModEnd> ( ioctl ( <S2SV_ModStart> UI_DEV_CREATE , NULL )",system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z
CWE-20,"CWE-20 static void request_key_auth_describe ( const struct key * key , struct seq_file * m ) { struct request_key_auth * rka = key -> payload . data [ 0 ] ; seq_puts ( m , ""key:"" ) ; seq_puts ( m , key -> description ) ; <S2SV_StartBug> if ( key_is_instantiated ( key ) ) <S2SV_EndBug> seq_printf ( m , ""<S2SV_blank>pid:%d<S2SV_blank>ci:%zu"" , rka -> pid , rka -> callout_len ) ; }",<S2SV_ModStart> ; if ( key_is_positive <S2SV_ModEnd> ( key ),torvalds@linux/363b02dab09b3226f3bd1420dad9c72b79a42a76,CVE-2017-15951,https://github.com/torvalds/linux/commit/363b02dab09b3226f3bd1420dad9c72b79a42a76,2017-10-28T02:29Z
CWE-476,"CWE-476 static void pcd_init_units ( void ) { struct pcd_unit * cd ; int unit ; pcd_drive_count = 0 ; for ( unit = 0 , cd = pcd ; unit < PCD_UNITS ; unit ++ , cd ++ ) { struct gendisk * disk = alloc_disk ( 1 ) ; if ( ! disk ) continue ; disk -> queue = blk_mq_init_sq_queue ( & cd -> tag_set , & pcd_mq_ops , 1 , BLK_MQ_F_SHOULD_MERGE ) ; if ( IS_ERR ( disk -> queue ) ) { <S2SV_StartBug> disk -> queue = NULL ; <S2SV_EndBug> continue ; } INIT_LIST_HEAD ( & cd -> rq_list ) ; disk -> queue -> queuedata = cd ; blk_queue_bounce_limit ( disk -> queue , BLK_BOUNCE_HIGH ) ; cd -> disk = disk ; cd -> pi = & cd -> pia ; cd -> present = 0 ; cd -> last_sense = 0 ; cd -> changed = 1 ; cd -> drive = ( * drives [ unit ] ) [ D_SLV ] ; if ( ( * drives [ unit ] ) [ D_PRT ] ) pcd_drive_count ++ ; cd -> name = & cd -> info . name [ 0 ] ; snprintf ( cd -> name , sizeof ( cd -> info . name ) , ""%s%d"" , name , unit ) ; cd -> info . ops = & pcd_dops ; cd -> info . handle = cd ; cd -> info . speed = 0 ; cd -> info . capacity = 1 ; cd -> info . mask = 0 ; disk -> major = major ; disk -> first_minor = unit ; strcpy ( disk -> disk_name , cd -> name ) ; disk -> fops = & pcd_bdops ; disk -> flags = GENHD_FL_BLOCK_EVENTS_ON_EXCL_WRITE ; } }",<S2SV_ModStart> ) ) { put_disk ( disk ) ;,torvalds@linux/f0d1762554014ce0ae347b9f0d088f2c157c8c72,CVE-2019-15923,https://github.com/torvalds/linux/commit/f0d1762554014ce0ae347b9f0d088f2c157c8c72,2019-09-04T19:15Z
CWE-552,"CWE-000 static ssize_t _epoll_readv ( oe_fd_t * desc , const struct oe_iovec * iov , int iovcnt ) { ssize_t ret = - 1 ; epoll_t * file = _cast_epoll ( desc ) ; void * buf = NULL ; size_t buf_size = 0 ; <S2SV_StartBug> if ( ! file || ( iovcnt && ! iov ) || iovcnt < 0 || iovcnt > OE_IOV_MAX ) <S2SV_EndBug> OE_RAISE_ERRNO ( OE_EINVAL ) ; <S2SV_StartBug> if ( oe_iov_pack ( iov , iovcnt , & buf , & buf_size ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> OE_RAISE_ERRNO ( OE_ENOMEM ) ; <S2SV_EndBug> if ( oe_syscall_readv_ocall ( & ret , file -> host_fd , buf , iovcnt , buf_size ) != OE_OK ) { OE_RAISE_ERRNO ( OE_EINVAL ) ; } <S2SV_StartBug> if ( oe_iov_sync ( iov , iovcnt , buf , buf_size ) != 0 ) <S2SV_EndBug> OE_RAISE_ERRNO ( OE_EINVAL ) ; done : if ( buf ) oe_free ( buf ) ; return ret ; }","<S2SV_ModStart> = 0 ; size_t data_size = 0 ; <S2SV_ModStart> , & buf_size , & data_size <S2SV_ModStart> OE_RAISE_ERRNO ( OE_ENOMEM ) ; if ( data_size > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL <S2SV_ModStart> } if ( ret > ( ssize_t ) data_size ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; } if (",openenclave@openenclave/bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b,CVE-2020-15224,https://github.com/openenclave/openenclave/commit/bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b,2020-10-14T19:15Z
CWE-400,"CWE-000 static zend_bool add_post_var ( zval * arr , post_var_data_t * var , zend_bool eof TSRMLS_DC ) { <S2SV_StartBug> char * ksep , * vsep , * val ; <S2SV_EndBug> size_t klen , vlen ; unsigned int new_vlen ; if ( var -> ptr >= var -> end ) { return 0 ; } <S2SV_StartBug> vsep = memchr ( var -> ptr , '&' , var -> end - var -> ptr ) ; <S2SV_EndBug> if ( ! vsep ) { <S2SV_StartBug> if ( ! eof ) { <S2SV_EndBug> return 0 ; } else { vsep = var -> end ; } } ksep = memchr ( var -> ptr , '=' , vsep - var -> ptr ) ; if ( ksep ) { * ksep = '\\0' ; klen = ksep - var -> ptr ; vlen = vsep - ++ ksep ; } else { ksep = """" ; klen = vsep - var -> ptr ; vlen = 0 ; } php_url_decode ( var -> ptr , klen ) ; val = estrndup ( ksep , vlen ) ; if ( vlen ) { vlen = php_url_decode ( val , vlen ) ; } if ( sapi_module . input_filter ( PARSE_POST , var -> ptr , & val , vlen , & new_vlen TSRMLS_CC ) ) { php_register_variable_safe ( var -> ptr , val , new_vlen , arr TSRMLS_CC ) ; } efree ( val ) ; var -> ptr = vsep + ( vsep != var -> end ) ; <S2SV_StartBug> return 1 ; <S2SV_EndBug> }","<S2SV_ModStart> { char * start , * <S2SV_ModStart> 0 ; } start = var -> ptr + var -> already_scanned ; <S2SV_ModStart> = memchr ( start <S2SV_ModEnd> , '&' , <S2SV_ModStart> -> end - start <S2SV_ModEnd> ) ; if <S2SV_ModStart> eof ) { var -> already_scanned = var -> end - var -> ptr ; <S2SV_ModStart> end ) ; var -> already_scanned = 0 ;",php@php-src/0f8cf3b8497dc45c010c44ed9e96518e11e19fc3,CVE-2017-11142,https://github.com/php/php-src/commit/0f8cf3b8497dc45c010c44ed9e96518e11e19fc3,2017-07-10T14:29Z
CWE-362,"CWE-362 static int userfaultfd_register ( struct userfaultfd_ctx * ctx , unsigned long arg ) { struct mm_struct * mm = ctx -> mm ; struct vm_area_struct * vma , * prev , * cur ; int ret ; struct uffdio_register uffdio_register ; struct uffdio_register __user * user_uffdio_register ; unsigned long vm_flags , new_flags ; bool found ; bool basic_ioctls ; unsigned long start , end , vma_end ; user_uffdio_register = ( struct uffdio_register __user * ) arg ; ret = - EFAULT ; if ( copy_from_user ( & uffdio_register , user_uffdio_register , sizeof ( uffdio_register ) - sizeof ( __u64 ) ) ) goto out ; ret = - EINVAL ; if ( ! uffdio_register . mode ) goto out ; if ( uffdio_register . mode & ~ ( UFFDIO_REGISTER_MODE_MISSING | UFFDIO_REGISTER_MODE_WP ) ) goto out ; vm_flags = 0 ; if ( uffdio_register . mode & UFFDIO_REGISTER_MODE_MISSING ) vm_flags |= VM_UFFD_MISSING ; if ( uffdio_register . mode & UFFDIO_REGISTER_MODE_WP ) { vm_flags |= VM_UFFD_WP ; ret = - EINVAL ; goto out ; } ret = validate_range ( mm , uffdio_register . range . start , uffdio_register . range . len ) ; if ( ret ) goto out ; start = uffdio_register . range . start ; end = start + uffdio_register . range . len ; ret = - ENOMEM ; if ( ! mmget_not_zero ( mm ) ) goto out ; <S2SV_StartBug> down_write ( & mm -> mmap_sem ) ; <S2SV_EndBug> vma = find_vma_prev ( mm , start , & prev ) ; if ( ! vma ) goto out_unlock ; ret = - EINVAL ; if ( vma -> vm_start >= end ) goto out_unlock ; if ( is_vm_hugetlb_page ( vma ) ) { unsigned long vma_hpagesize = vma_kernel_pagesize ( vma ) ; if ( start & ( vma_hpagesize - 1 ) ) goto out_unlock ; } found = false ; basic_ioctls = false ; for ( cur = vma ; cur && cur -> vm_start < end ; cur = cur -> vm_next ) { cond_resched ( ) ; BUG_ON ( ! ! cur -> vm_userfaultfd_ctx . ctx ^ ! ! ( cur -> vm_flags & ( VM_UFFD_MISSING | VM_UFFD_WP ) ) ) ; ret = - EINVAL ; if ( ! vma_can_userfault ( cur ) ) goto out_unlock ; ret = - EPERM ; if ( unlikely ( ! ( cur -> vm_flags & VM_MAYWRITE ) ) ) goto out_unlock ; if ( is_vm_hugetlb_page ( cur ) && end <= cur -> vm_end && end > cur -> vm_start ) { unsigned long vma_hpagesize = vma_kernel_pagesize ( cur ) ; ret = - EINVAL ; if ( end & ( vma_hpagesize - 1 ) ) goto out_unlock ; } ret = - EBUSY ; if ( cur -> vm_userfaultfd_ctx . ctx && cur -> vm_userfaultfd_ctx . ctx != ctx ) goto out_unlock ; if ( is_vm_hugetlb_page ( cur ) ) basic_ioctls = true ; found = true ; } BUG_ON ( ! found ) ; if ( vma -> vm_start < start ) prev = vma ; ret = 0 ; do { cond_resched ( ) ; BUG_ON ( ! vma_can_userfault ( vma ) ) ; BUG_ON ( vma -> vm_userfaultfd_ctx . ctx && vma -> vm_userfaultfd_ctx . ctx != ctx ) ; WARN_ON ( ! ( vma -> vm_flags & VM_MAYWRITE ) ) ; if ( vma -> vm_userfaultfd_ctx . ctx == ctx && ( vma -> vm_flags & vm_flags ) == vm_flags ) goto skip ; if ( vma -> vm_start > start ) start = vma -> vm_start ; vma_end = min ( end , vma -> vm_end ) ; new_flags = ( vma -> vm_flags & ~ vm_flags ) | vm_flags ; prev = vma_merge ( mm , prev , start , vma_end , new_flags , vma -> anon_vma , vma -> vm_file , vma -> vm_pgoff , vma_policy ( vma ) , ( ( struct vm_userfaultfd_ctx ) { ctx } ) ) ; if ( prev ) { vma = prev ; goto next ; } if ( vma -> vm_start < start ) { ret = split_vma ( mm , vma , start , 1 ) ; if ( ret ) break ; } if ( vma -> vm_end > end ) { ret = split_vma ( mm , vma , end , 0 ) ; if ( ret ) break ; } next : vma -> vm_flags = new_flags ; vma -> vm_userfaultfd_ctx . ctx = ctx ; skip : prev = vma ; start = vma -> vm_end ; vma = vma -> vm_next ; } while ( vma && vma -> vm_start < end ) ; out_unlock : up_write ( & mm -> mmap_sem ) ; mmput ( mm ) ; if ( ! ret ) { if ( put_user ( basic_ioctls ? UFFD_API_RANGE_IOCTLS_BASIC : UFFD_API_RANGE_IOCTLS , & user_uffdio_register -> ioctls ) ) ret = - EFAULT ; } out : return ret ; }",<S2SV_ModStart> -> mmap_sem ) ; if ( ! mmget_still_valid ( mm ) ) goto out_unlock,torvalds@linux/04f5866e41fb70690e28397487d8bd8eea7d712a,CVE-2019-11599,https://github.com/torvalds/linux/commit/04f5866e41fb70690e28397487d8bd8eea7d712a,2019-04-29T18:29Z
CWE-74,"CWE-000 static int smtp_open ( struct Connection * conn , bool esmtp ) { int rc ; if ( mutt_socket_open ( conn ) ) return - 1 ; rc = smtp_get_resp ( conn ) ; if ( rc != 0 ) return rc ; rc = smtp_helo ( conn , esmtp ) ; if ( rc != 0 ) return rc ; # ifdef USE_SSL enum QuadOption ans = MUTT_NO ; if ( conn -> ssf ) ans = MUTT_NO ; else if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( Capabilities & SMTP_CAP_STARTTLS ) && ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure<S2SV_blank>connection<S2SV_blank>with<S2SV_blank>TLS?"" ) ) ) == MUTT_ABORT ) ) { return - 1 ; } if ( ans == MUTT_YES ) { if ( mutt_socket_send ( conn , ""STARTTLS\\r\\n"" ) < 0 ) return SMTP_ERR_WRITE ; <S2SV_StartBug> rc = smtp_get_resp ( conn ) ; <S2SV_EndBug> if ( rc != 0 ) return rc ; if ( mutt_ssl_starttls ( conn ) ) { mutt_error ( _ ( ""Could<S2SV_blank>not<S2SV_blank>negotiate<S2SV_blank>TLS<S2SV_blank>connection"" ) ) ; return - 1 ; } rc = smtp_helo ( conn , esmtp ) ; if ( rc != 0 ) return rc ; } # endif if ( conn -> account . flags & MUTT_ACCT_USER ) { if ( ! ( Capabilities & SMTP_CAP_AUTH ) ) { mutt_error ( _ ( ""SMTP<S2SV_blank>server<S2SV_blank>does<S2SV_blank>not<S2SV_blank>support<S2SV_blank>authentication"" ) ) ; return - 1 ; } return smtp_auth ( conn ) ; } return 0 ; }",<S2SV_ModStart> rc = smtp_get_resp ( conn ) ; mutt_socket_empty,neomutt@neomutt/fb013ec666759cb8a9e294347c7b4c1f597639cc,CVE-2020-14954,https://github.com/neomutt/neomutt/commit/fb013ec666759cb8a9e294347c7b4c1f597639cc,2020-06-21T17:15Z
CWE-200,"CWE-200 void init_global_keywords ( bool global_active ) { install_keyword_root ( ""linkbeat_use_polling"" , use_polling_handler , global_active ) ; # if HAVE_DECL_CLONE_NEWNET install_keyword_root ( ""net_namespace"" , & net_namespace_handler , global_active ) ; install_keyword_root ( ""namespace_with_ipsets"" , & namespace_ipsets_handler , global_active ) ; # endif install_keyword_root ( ""use_pid_dir"" , & use_pid_dir_handler , global_active ) ; install_keyword_root ( ""instance"" , & instance_handler , global_active ) ; install_keyword_root ( ""child_wait_time"" , & child_wait_handler , global_active ) ; install_keyword_root ( ""global_defs"" , NULL , global_active ) ; install_keyword ( ""router_id"" , & routerid_handler ) ; install_keyword ( ""notification_email_from"" , & emailfrom_handler ) ; install_keyword ( ""smtp_server"" , & smtpserver_handler ) ; install_keyword ( ""smtp_helo_name"" , & smtphelo_handler ) ; install_keyword ( ""smtp_connect_timeout"" , & smtpto_handler ) ; install_keyword ( ""notification_email"" , & email_handler ) ; install_keyword ( ""smtp_alert"" , & smtp_alert_handler ) ; # ifdef _WITH_VRRP_ install_keyword ( ""smtp_alert_vrrp"" , & smtp_alert_vrrp_handler ) ; # endif # ifdef _WITH_LVS_ install_keyword ( ""smtp_alert_checker"" , & smtp_alert_checker_handler ) ; # endif # ifdef _WITH_VRRP_ install_keyword ( ""dynamic_interfaces"" , & dynamic_interfaces_handler ) ; install_keyword ( ""no_email_faults"" , & no_email_faults_handler ) ; install_keyword ( ""default_interface"" , & default_interface_handler ) ; # endif # ifdef _WITH_LVS_ install_keyword ( ""lvs_timeouts"" , & lvs_timeouts ) ; install_keyword ( ""lvs_flush"" , & lvs_flush_handler ) ; # ifdef _WITH_VRRP_ install_keyword ( ""lvs_sync_daemon"" , & lvs_syncd_handler ) ; # endif # endif # ifdef _WITH_VRRP_ install_keyword ( ""vrrp_mcast_group4"" , & vrrp_mcast_group4_handler ) ; install_keyword ( ""vrrp_mcast_group6"" , & vrrp_mcast_group6_handler ) ; install_keyword ( ""vrrp_garp_master_delay"" , & vrrp_garp_delay_handler ) ; install_keyword ( ""vrrp_garp_master_repeat"" , & vrrp_garp_rep_handler ) ; install_keyword ( ""vrrp_garp_master_refresh"" , & vrrp_garp_refresh_handler ) ; install_keyword ( ""vrrp_garp_master_refresh_repeat"" , & vrrp_garp_refresh_rep_handler ) ; install_keyword ( ""vrrp_garp_lower_prio_delay"" , & vrrp_garp_lower_prio_delay_handler ) ; install_keyword ( ""vrrp_garp_lower_prio_repeat"" , & vrrp_garp_lower_prio_rep_handler ) ; install_keyword ( ""vrrp_garp_interval"" , & vrrp_garp_interval_handler ) ; install_keyword ( ""vrrp_gna_interval"" , & vrrp_gna_interval_handler ) ; install_keyword ( ""vrrp_lower_prio_no_advert"" , & vrrp_lower_prio_no_advert_handler ) ; install_keyword ( ""vrrp_higher_prio_send_advert"" , & vrrp_higher_prio_send_advert_handler ) ; install_keyword ( ""vrrp_version"" , & vrrp_version_handler ) ; install_keyword ( ""vrrp_iptables"" , & vrrp_iptables_handler ) ; # ifdef _HAVE_LIBIPSET_ install_keyword ( ""vrrp_ipsets"" , & vrrp_ipsets_handler ) ; # endif install_keyword ( ""vrrp_check_unicast_src"" , & vrrp_check_unicast_src_handler ) ; install_keyword ( ""vrrp_skip_check_adv_addr"" , & vrrp_check_adv_addr_handler ) ; install_keyword ( ""vrrp_strict"" , & vrrp_strict_handler ) ; install_keyword ( ""vrrp_priority"" , & vrrp_prio_handler ) ; install_keyword ( ""vrrp_no_swap"" , & vrrp_no_swap_handler ) ; # ifdef _HAVE_SCHED_RT_ install_keyword ( ""vrrp_rt_priority"" , & vrrp_rt_priority_handler ) ; # if HAVE_DECL_RLIMIT_RTTIME == 1 install_keyword ( ""vrrp_rlimit_rtime"" , & vrrp_rt_rlimit_handler ) ; # endif # endif # endif install_keyword ( ""notify_fifo"" , & global_notify_fifo ) ; install_keyword ( ""notify_fifo_script"" , & global_notify_fifo_script ) ; # ifdef _WITH_VRRP_ install_keyword ( ""vrrp_notify_fifo"" , & vrrp_notify_fifo ) ; install_keyword ( ""vrrp_notify_fifo_script"" , & vrrp_notify_fifo_script ) ; # endif # ifdef _WITH_LVS_ install_keyword ( ""lvs_notify_fifo"" , & lvs_notify_fifo ) ; install_keyword ( ""lvs_notify_fifo_script"" , & lvs_notify_fifo_script ) ; install_keyword ( ""checker_priority"" , & checker_prio_handler ) ; install_keyword ( ""checker_no_swap"" , & checker_no_swap_handler ) ; # ifdef _HAVE_SCHED_RT_ install_keyword ( ""checker_rt_priority"" , & checker_rt_priority_handler ) ; # if HAVE_DECL_RLIMIT_RTTIME == 1 install_keyword ( ""checker_rlimit_rtime"" , & checker_rt_rlimit_handler ) ; # endif # endif # endif # ifdef _WITH_BFD_ install_keyword ( ""bfd_priority"" , & bfd_prio_handler ) ; install_keyword ( ""bfd_no_swap"" , & bfd_no_swap_handler ) ; # ifdef _HAVE_SCHED_RT_ install_keyword ( ""bfd_rt_priority"" , & bfd_rt_priority_handler ) ; # if HAVE_DECL_RLIMIT_RTTIME == 1 install_keyword ( ""bfd_rlimit_rtime"" , & bfd_rt_rlimit_handler ) ; # endif # endif # endif # ifdef _WITH_SNMP_ install_keyword ( ""snmp_socket"" , & snmp_socket_handler ) ; install_keyword ( ""enable_traps"" , & trap_handler ) ; # ifdef _WITH_SNMP_VRRP_ install_keyword ( ""enable_snmp_vrrp"" , & snmp_vrrp_handler ) ; install_keyword ( ""enable_snmp_keepalived"" , & snmp_vrrp_handler ) ; # endif # ifdef _WITH_SNMP_RFC_ install_keyword ( ""enable_snmp_rfc"" , & snmp_rfc_handler ) ; # endif # ifdef _WITH_SNMP_RFCV2_ install_keyword ( ""enable_snmp_rfcv2"" , & snmp_rfcv2_handler ) ; # endif # ifdef _WITH_SNMP_RFCV3_ install_keyword ( ""enable_snmp_rfcv3"" , & snmp_rfcv3_handler ) ; # endif # ifdef _WITH_SNMP_CHECKER_ install_keyword ( ""enable_snmp_checker"" , & snmp_checker_handler ) ; # endif # endif # ifdef _WITH_DBUS_ install_keyword ( ""enable_dbus"" , & enable_dbus_handler ) ; install_keyword ( ""dbus_service_name"" , & dbus_service_name_handler ) ; # endif install_keyword ( ""script_user"" , & script_user_handler ) ; install_keyword ( ""enable_script_security"" , & script_security_handler ) ; # ifdef _WITH_VRRP_ install_keyword ( ""vrrp_netlink_cmd_rcv_bufs"" , & vrrp_netlink_cmd_rcv_bufs_handler ) ; install_keyword ( ""vrrp_netlink_cmd_rcv_bufs_force"" , & vrrp_netlink_cmd_rcv_bufs_force_handler ) ; install_keyword ( ""vrrp_netlink_monitor_rcv_bufs"" , & vrrp_netlink_monitor_rcv_bufs_handler ) ; install_keyword ( ""vrrp_netlink_monitor_rcv_bufs_force"" , & vrrp_netlink_monitor_rcv_bufs_force_handler ) ; # endif # ifdef _WITH_LVS_ install_keyword ( ""lvs_netlink_cmd_rcv_bufs"" , & lvs_netlink_cmd_rcv_bufs_handler ) ; install_keyword ( ""lvs_netlink_cmd_rcv_bufs_force"" , & lvs_netlink_cmd_rcv_bufs_force_handler ) ; install_keyword ( ""lvs_netlink_monitor_rcv_bufs"" , & lvs_netlink_monitor_rcv_bufs_handler ) ; install_keyword ( ""lvs_netlink_monitor_rcv_bufs_force"" , & lvs_netlink_monitor_rcv_bufs_force_handler ) ; # endif # ifdef _WITH_LVS_ install_keyword ( ""rs_init_notifies"" , & rs_init_notifies_handler ) ; install_keyword ( ""no_checker_emails"" , & no_checker_emails_handler ) ; # endif # ifdef _WITH_VRRP_ install_keyword ( ""vrrp_rx_bufs_policy"" , & vrrp_rx_bufs_policy_handler ) ; install_keyword ( ""vrrp_rx_bufs_multiplier"" , & vrrp_rx_bufs_multiplier_handler ) ; # endif <S2SV_StartBug> } <S2SV_EndBug>","<S2SV_ModStart> ; # endif install_keyword ( ""umask"" , & umask_handler ) ;",acassen@keepalived/c6247a9ef2c7b33244ab1d3aa5d629ec49f0a067,CVE-2018-19045,https://github.com/acassen/keepalived/commit/c6247a9ef2c7b33244ab1d3aa5d629ec49f0a067,2018-11-08T20:29Z
CWE-20,"CWE-20 static int dccp_error ( struct net * net , struct nf_conn * tmpl , struct sk_buff * skb , unsigned int dataoff , enum ip_conntrack_info * ctinfo , u_int8_t pf , unsigned int hooknum ) { struct dccp_hdr _dh , * dh ; unsigned int dccp_len = skb -> len - dataoff ; unsigned int cscov ; const char * msg ; <S2SV_StartBug> dh = skb_header_pointer ( skb , dataoff , sizeof ( _dh ) , & dh ) ; <S2SV_EndBug> if ( dh == NULL ) { msg = ""nf_ct_dccp:<S2SV_blank>short<S2SV_blank>packet<S2SV_blank>"" ; goto out_invalid ; } if ( dh -> dccph_doff * 4 < sizeof ( struct dccp_hdr ) || dh -> dccph_doff * 4 > dccp_len ) { msg = ""nf_ct_dccp:<S2SV_blank>truncated/malformed<S2SV_blank>packet<S2SV_blank>"" ; goto out_invalid ; } cscov = dccp_len ; if ( dh -> dccph_cscov ) { cscov = ( dh -> dccph_cscov - 1 ) * 4 ; if ( cscov > dccp_len ) { msg = ""nf_ct_dccp:<S2SV_blank>bad<S2SV_blank>checksum<S2SV_blank>coverage<S2SV_blank>"" ; goto out_invalid ; } } if ( net -> ct . sysctl_checksum && hooknum == NF_INET_PRE_ROUTING && nf_checksum_partial ( skb , hooknum , dataoff , cscov , IPPROTO_DCCP , pf ) ) { msg = ""nf_ct_dccp:<S2SV_blank>bad<S2SV_blank>checksum<S2SV_blank>"" ; goto out_invalid ; } if ( dh -> dccph_type >= DCCP_PKT_INVALID ) { msg = ""nf_ct_dccp:<S2SV_blank>reserved<S2SV_blank>packet<S2SV_blank>type<S2SV_blank>"" ; goto out_invalid ; } return NF_ACCEPT ; out_invalid : if ( LOG_INVALID ( net , IPPROTO_DCCP ) ) nf_log_packet ( net , pf , 0 , skb , NULL , NULL , NULL , ""%s"" , msg ) ; return - NF_ACCEPT ; }","<S2SV_ModStart> ) , & _dh <S2SV_ModEnd> ) ; if",torvalds@linux/b22f5126a24b3b2f15448c3f2a254fc10cbc2b92,CVE-2014-2523,https://github.com/torvalds/linux/commit/b22f5126a24b3b2f15448c3f2a254fc10cbc2b92,2014-03-24T16:40Z
CWE-20,"CWE-20 void dhcpClientProcessMessage ( NetInterface * interface , const IpPseudoHeader * pseudoHeader , const UdpHeader * udpHeader , const NetBuffer * buffer , size_t offset , const NetRxAncillary * ancillary , void * param ) { size_t length ; DhcpClientContext * context ; DhcpMessage * message ; DhcpOption * option ; context = ( DhcpClientContext * ) param ; length = netBufferGetLength ( buffer ) - offset ; <S2SV_StartBug> if ( length < sizeof ( DhcpMessage ) ) <S2SV_EndBug> return ; if ( length > DHCP_MAX_MSG_SIZE ) return ; message = netBufferAt ( buffer , offset ) ; if ( message == NULL ) return ; TRACE_DEBUG ( ""\\r\\n%s:<S2SV_blank>DHCP<S2SV_blank>message<S2SV_blank>received<S2SV_blank>(%"" PRIuSIZE ""<S2SV_blank>bytes)...\\r\\n"" , formatSystemTime ( osGetSystemTime ( ) , NULL ) , length ) ; dhcpDumpMessage ( message , length ) ; if ( message -> op != DHCP_OPCODE_BOOTREPLY ) return ; if ( message -> htype != DHCP_HARDWARE_TYPE_ETH ) return ; if ( message -> hlen != sizeof ( MacAddr ) ) return ; if ( message -> magicCookie != HTONL ( DHCP_MAGIC_COOKIE ) ) return ; option = dhcpGetOption ( message , length , DHCP_OPT_DHCP_MESSAGE_TYPE ) ; if ( option == NULL || option -> length != 1 ) return ; switch ( option -> value [ 0 ] ) { case DHCP_MESSAGE_TYPE_OFFER : dhcpClientParseOffer ( context , message , length ) ; break ; case DHCP_MESSAGE_TYPE_ACK : dhcpClientParseAck ( context , message , length ) ; break ; case DHCP_MESSAGE_TYPE_NAK : dhcpClientParseNak ( context , message , length ) ; break ; default : break ; } }",<S2SV_ModStart> ( DhcpMessage ) || <S2SV_ModEnd> length > DHCP_MAX_MSG_SIZE,Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z
CWE-20,"CWE-20 int ext4_orphan_add ( handle_t * handle , struct inode * inode ) { struct super_block * sb = inode -> i_sb ; struct ext4_iloc iloc ; int err = 0 , rc ; <S2SV_StartBug> if ( ! ext4_handle_valid ( handle ) ) <S2SV_EndBug> return 0 ; mutex_lock ( & EXT4_SB ( sb ) -> s_orphan_lock ) ; if ( ! list_empty ( & EXT4_I ( inode ) -> i_orphan ) ) goto out_unlock ; J_ASSERT ( ( S_ISREG ( inode -> i_mode ) || S_ISDIR ( inode -> i_mode ) || S_ISLNK ( inode -> i_mode ) ) || inode -> i_nlink == 0 ) ; BUFFER_TRACE ( EXT4_SB ( sb ) -> s_sbh , ""get_write_access"" ) ; err = ext4_journal_get_write_access ( handle , EXT4_SB ( sb ) -> s_sbh ) ; if ( err ) goto out_unlock ; err = ext4_reserve_inode_write ( handle , inode , & iloc ) ; if ( err ) goto out_unlock ; if ( NEXT_ORPHAN ( inode ) && NEXT_ORPHAN ( inode ) <= ( le32_to_cpu ( EXT4_SB ( sb ) -> s_es -> s_inodes_count ) ) ) goto mem_insert ; NEXT_ORPHAN ( inode ) = le32_to_cpu ( EXT4_SB ( sb ) -> s_es -> s_last_orphan ) ; EXT4_SB ( sb ) -> s_es -> s_last_orphan = cpu_to_le32 ( inode -> i_ino ) ; err = ext4_handle_dirty_super ( handle , sb ) ; rc = ext4_mark_iloc_dirty ( handle , inode , & iloc ) ; if ( ! err ) err = rc ; mem_insert : if ( ! err ) list_add ( & EXT4_I ( inode ) -> i_orphan , & EXT4_SB ( sb ) -> s_orphan ) ; jbd_debug ( 4 , ""superblock<S2SV_blank>will<S2SV_blank>point<S2SV_blank>to<S2SV_blank>%lu\\n"" , inode -> i_ino ) ; jbd_debug ( 4 , ""orphan<S2SV_blank>inode<S2SV_blank>%lu<S2SV_blank>will<S2SV_blank>point<S2SV_blank>to<S2SV_blank>%d\\n"" , inode -> i_ino , NEXT_ORPHAN ( inode ) ) ; out_unlock : mutex_unlock ( & EXT4_SB ( sb ) -> s_orphan_lock ) ; ext4_std_error ( inode -> i_sb , err ) ; return err ; }",<S2SV_ModStart> if ( ! EXT4_SB ( sb ) -> s_journal <S2SV_ModEnd> ) return 0,torvalds@linux/c9b92530a723ac5ef8e352885a1862b18f31b2f5,CVE-2015-7509,https://github.com/torvalds/linux/commit/c9b92530a723ac5ef8e352885a1862b18f31b2f5,2015-12-28T11:59Z
CWE-119,"CWE-119 void unix_inflight ( struct file * fp ) { struct sock * s = unix_get_socket ( fp ) ; <S2SV_StartBug> if ( s ) { <S2SV_EndBug> <S2SV_StartBug> struct unix_sock * u = unix_sk ( s ) ; <S2SV_EndBug> spin_lock ( & unix_gc_lock ) ; if ( atomic_long_inc_return ( & u -> inflight ) == 1 ) { BUG_ON ( ! list_empty ( & u -> link ) ) ; list_add_tail ( & u -> link , & gc_inflight_list ) ; } else { BUG_ON ( list_empty ( & u -> link ) ) ; } unix_tot_inflight ++ ; <S2SV_StartBug> spin_unlock ( & unix_gc_lock ) ; <S2SV_EndBug> } <S2SV_StartBug> } <S2SV_EndBug>",<S2SV_ModStart> fp ) ; spin_lock ( & unix_gc_lock ) ; <S2SV_ModStart> unix_sk ( s <S2SV_ModEnd> ) ; if <S2SV_ModStart> unix_tot_inflight ++ ; } fp -> f_cred -> user -> unix_inflight ++ ; <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>,torvalds@linux/712f4aad406bb1ed67f3f98d04c044191f0ff593,CVE-2013-4312,https://github.com/torvalds/linux/commit/712f4aad406bb1ed67f3f98d04c044191f0ff593,2016-02-08T03:59Z
CWE-444,"CWE-000 static void * listen_loop ( void * x ) { int optval = 1 ; struct pollfd pa [ 100 ] ; struct pollfd * p ; struct _agooErr err = AGOO_ERR_INIT ; struct sockaddr_in client_addr ; int client_sock ; int pcnt = 0 ; socklen_t alen = 0 ; agooCon con ; int i ; uint64_t cnt = 0 ; agooBind b ; for ( b = agoo_server . binds , p = pa ; NULL != b ; b = b -> next , p ++ , pcnt ++ ) { p -> fd = b -> fd ; p -> events = POLLIN ; p -> revents = 0 ; } memset ( & client_addr , 0 , sizeof ( client_addr ) ) ; atomic_fetch_add ( & agoo_server . running , 1 ) ; while ( agoo_server . active ) { if ( 0 > ( i = poll ( pa , pcnt , 200 ) ) ) { if ( EAGAIN == errno ) { continue ; } agoo_log_cat ( & agoo_error_cat , ""Server<S2SV_blank>polling<S2SV_blank>error.<S2SV_blank>%s."" , strerror ( errno ) ) ; break ; } if ( 0 == i ) { continue ; } for ( b = agoo_server . binds , p = pa ; NULL != b ; b = b -> next , p ++ ) { if ( 0 != ( p -> revents & POLLIN ) ) { if ( 0 > ( client_sock = accept ( p -> fd , ( struct sockaddr * ) & client_addr , & alen ) ) ) { agoo_log_cat ( & agoo_error_cat , ""Server<S2SV_blank>with<S2SV_blank>pid<S2SV_blank>%d<S2SV_blank>accept<S2SV_blank>connection<S2SV_blank>failed.<S2SV_blank>%s."" , getpid ( ) , strerror ( errno ) ) ; } else if ( NULL == ( con = agoo_con_create ( & err , client_sock , ++ cnt , b ) ) ) { agoo_log_cat ( & agoo_error_cat , ""Server<S2SV_blank>with<S2SV_blank>pid<S2SV_blank>%d<S2SV_blank>accept<S2SV_blank>connection<S2SV_blank>failed.<S2SV_blank>%s."" , getpid ( ) , err . msg ) ; close ( client_sock ) ; cnt -- ; agoo_err_clear ( & err ) ; } else { int con_cnt ; # ifdef OSX_OS setsockopt ( client_sock , SOL_SOCKET , SO_NOSIGPIPE , & optval , sizeof ( optval ) ) ; # endif # ifdef PLATFORM_LINUX setsockopt ( client_sock , IPPROTO_TCP , TCP_QUICKACK , & optval , sizeof ( optval ) ) ; # endif fcntl ( client_sock , F_SETFL , O_NONBLOCK ) ; setsockopt ( client_sock , SOL_SOCKET , SO_KEEPALIVE , & optval , sizeof ( optval ) ) ; setsockopt ( client_sock , IPPROTO_TCP , TCP_NODELAY , & optval , sizeof ( optval ) ) ; <S2SV_StartBug> agoo_log_cat ( & agoo_con_cat , ""Server<S2SV_blank>with<S2SV_blank>pid<S2SV_blank>%d<S2SV_blank>accepted<S2SV_blank>connection<S2SV_blank>%llu<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>[%d]"" , <S2SV_EndBug> <S2SV_StartBug> getpid ( ) , ( unsigned long long ) cnt , b -> id , con -> sock ) ; <S2SV_EndBug> con_cnt = atomic_fetch_add ( & agoo_server . con_cnt , 1 ) ; if ( agoo_server . loop_max > agoo_server . loop_cnt && agoo_server . loop_cnt * LOOP_UP < con_cnt ) { add_con_loop ( ) ; } agoo_queue_push ( & agoo_server . con_queue , ( void * ) con ) ; } } if ( 0 != ( p -> revents & ( POLLERR | POLLHUP | POLLNVAL ) ) ) { if ( 0 != ( p -> revents & ( POLLHUP | POLLNVAL ) ) ) { agoo_log_cat ( & agoo_error_cat , ""Agoo<S2SV_blank>server<S2SV_blank>with<S2SV_blank>pid<S2SV_blank>%d<S2SV_blank>socket<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>closed."" , getpid ( ) , b -> id ) ; } else { agoo_log_cat ( & agoo_error_cat , ""Agoo<S2SV_blank>server<S2SV_blank>with<S2SV_blank>pid<S2SV_blank>%d<S2SV_blank>socket<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>error."" , getpid ( ) , b -> id ) ; } agoo_server . active = false ; } p -> revents = 0 ; } } for ( b = agoo_server . binds ; NULL != b ; b = b -> next ) { agoo_bind_close ( b ) ; } atomic_fetch_sub ( & agoo_server . running , 1 ) ; return NULL ; }","<S2SV_ModStart> & agoo_con_cat , ""Server<S2SV_blank>with<S2SV_blank>pid<S2SV_blank>%d<S2SV_blank>accepted<S2SV_blank>connection<S2SV_blank>%llu<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>[%d]<S2SV_blank>from<S2SV_blank>%s"" <S2SV_ModEnd> , getpid ( <S2SV_ModStart> con -> sock , con -> remote",ohler55@agoo/23d03535cf7b50d679a60a953a0cae9519a4a130,CVE-2020-7670,https://github.com/ohler55/agoo/commit/23d03535cf7b50d679a60a953a0cae9519a4a130,2020-06-10T16:15Z
CWE-255,"CWE-000 static int unix_getpw ( UNUSED void * instance , REQUEST * request , VALUE_PAIR * * vp_list ) { const char * name ; const char * encrypted_pass ; # ifdef HAVE_GETSPNAM struct spwd * spwd = NULL ; # endif # ifdef OSFC2 struct pr_passwd * pr_pw ; # else struct passwd * pwd ; # endif # ifdef HAVE_GETUSERSHELL char * shell ; # endif VALUE_PAIR * vp ; if ( ! request -> username ) { return RLM_MODULE_NOOP ; } name = ( char * ) request -> username -> vp_strvalue ; encrypted_pass = NULL ; # ifdef OSFC2 if ( ( pr_pw = getprpwnam ( name ) ) == NULL ) return RLM_MODULE_NOTFOUND ; encrypted_pass = pr_pw -> ufld . fd_encrypt ; if ( pr_pw -> uflg . fg_lock != 1 ) { radlog ( L_AUTH , ""rlm_unix:<S2SV_blank>[%s]:<S2SV_blank>account<S2SV_blank>locked"" , name ) ; return RLM_MODULE_USERLOCK ; } # else if ( ( pwd = getpwnam ( name ) ) == NULL ) { return RLM_MODULE_NOTFOUND ; } encrypted_pass = pwd -> pw_passwd ; # endif # ifdef HAVE_GETSPNAM if ( ( encrypted_pass == NULL ) || ( strlen ( encrypted_pass ) < 10 ) ) { if ( ( spwd = getspnam ( name ) ) == NULL ) { return RLM_MODULE_NOTFOUND ; } encrypted_pass = spwd -> sp_pwdp ; } # endif # ifndef OSFC2 # ifdef DENY_SHELL if ( strcmp ( pwd -> pw_shell , DENY_SHELL ) == 0 ) { radlog_request ( L_AUTH , 0 , request , ""rlm_unix:<S2SV_blank>[%s]:<S2SV_blank>invalid<S2SV_blank>shell"" , name ) ; return RLM_MODULE_REJECT ; } # endif # ifdef HAVE_GETUSERSHELL while ( ( shell = getusershell ( ) ) != NULL ) { if ( strcmp ( shell , pwd -> pw_shell ) == 0 || strcmp ( shell , ""/RADIUSD/ANY/SHELL"" ) == 0 ) { break ; } } endusershell ( ) ; if ( shell == NULL ) { radlog_request ( L_AUTH , 0 , request , ""[%s]:<S2SV_blank>invalid<S2SV_blank>shell<S2SV_blank>[%s]"" , name , pwd -> pw_shell ) ; return RLM_MODULE_REJECT ; } # endif # endif # if defined ( HAVE_GETSPNAM ) && ! defined ( M_UNIX ) <S2SV_StartBug> if ( spwd && spwd -> sp_expire > 0 && <S2SV_EndBug> <S2SV_StartBug> ( request -> timestamp / 86400 ) > spwd -> sp_expire ) { <S2SV_EndBug> <S2SV_StartBug> radlog_request ( L_AUTH , 0 , request , ""[%s]:<S2SV_blank>password<S2SV_blank>has<S2SV_blank>expired"" , name ) ; <S2SV_EndBug> return RLM_MODULE_REJECT ; } # endif # if defined ( __FreeBSD__ ) || defined ( bsdi ) || defined ( _PWF_EXPIRE ) if ( ( pwd -> pw_expire > 0 ) && ( request -> timestamp > pwd -> pw_expire ) ) { radlog_request ( L_AUTH , 0 , request , ""[%s]:<S2SV_blank>password<S2SV_blank>has<S2SV_blank>expired"" , name ) ; return RLM_MODULE_REJECT ; } # endif if ( encrypted_pass [ 0 ] == 0 ) return RLM_MODULE_NOOP ; vp = pairmake ( ""Crypt-Password"" , encrypted_pass , T_OP_SET ) ; if ( ! vp ) return RLM_MODULE_FAIL ; pairmove ( vp_list , & vp ) ; pairfree ( & vp ) ; return RLM_MODULE_UPDATED ; }","<S2SV_ModStart> && spwd -> sp_lstchg > 0 && spwd -> sp_max >= <S2SV_ModEnd> 0 && ( <S2SV_ModStart> 86400 ) > ( spwd -> sp_lstchg + spwd -> sp_max ) ) { radlog_request ( L_AUTH , 0 , request , ""[%s]:<S2SV_blank>password<S2SV_blank>has<S2SV_blank>expired"" , name ) ; return RLM_MODULE_REJECT ; } if ( spwd && <S2SV_ModStart> spwd -> sp_expire > 0 && ( request -> timestamp / 86400 ) > spwd -> sp_expire <S2SV_ModStart> , request , ""[%s]:<S2SV_blank>account<S2SV_blank>has<S2SV_blank>expired"" <S2SV_ModEnd> , name )",alandekok@freeradius-server/1b1ec5ce75e224bd1755650c18ccdaa6dc53e605,CVE-2011-4966,https://github.com/alandekok/freeradius-server/commit/1b1ec5ce75e224bd1755650c18ccdaa6dc53e605,2013-03-12T23:55Z
CWE-787,"CWE-787 int pdf_is_pdf ( FILE * fp ) { <S2SV_StartBug> int is_pdf ; <S2SV_EndBug> char * header ; <S2SV_StartBug> header = get_header ( fp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( header && strstr ( header , ""%PDF-"" ) ) <S2SV_EndBug> is_pdf = 1 ; else is_pdf = 0 ; free ( header ) ; return is_pdf ; }","<S2SV_ModStart> fp ) { <S2SV_ModEnd> char * header <S2SV_ModStart> * header ; if ( ! ( <S2SV_ModStart> ( fp ) ) ) return 0 ; const char * c = <S2SV_ModEnd> strstr ( header <S2SV_ModStart> , ""%PDF-"" ) ; const int is_pdf = c && ( ( c - header + strlen ( ""%PDF-M.m"" ) ) < 1024 ) <S2SV_ModEnd> ; free (",enferex@pdfresurrect/1b422459f07353adce2878806d5247d9e91fb397,CVE-2020-20740,https://github.com/enferex/pdfresurrect/commit/1b422459f07353adce2878806d5247d9e91fb397,2020-11-20T19:15Z
CWE-476,"CWE-476 static int dnxhd_find_frame_end ( DNXHDParserContext * dctx , const uint8_t * buf , int buf_size ) { ParseContext * pc = & dctx -> pc ; uint64_t state = pc -> state64 ; int pic_found = pc -> frame_start_found ; int i = 0 ; if ( ! pic_found ) { for ( i = 0 ; i < buf_size ; i ++ ) { state = ( state << 8 ) | buf [ i ] ; if ( ff_dnxhd_check_header_prefix ( state & 0xffffffffff00LL ) != 0 ) { i ++ ; pic_found = 1 ; dctx -> cur_byte = 0 ; dctx -> remaining = 0 ; break ; } } } if ( pic_found && ! dctx -> remaining ) { if ( ! buf_size ) return 0 ; for ( ; i < buf_size ; i ++ ) { dctx -> cur_byte ++ ; state = ( state << 8 ) | buf [ i ] ; if ( dctx -> cur_byte == 24 ) { dctx -> h = ( state >> 32 ) & 0xFFFF ; } else if ( dctx -> cur_byte == 26 ) { dctx -> w = ( state >> 32 ) & 0xFFFF ; } else if ( dctx -> cur_byte == 42 ) { int cid = ( state >> 32 ) & 0xFFFFFFFF ; <S2SV_StartBug> if ( cid <= 0 ) <S2SV_EndBug> continue ; <S2SV_StartBug> dctx -> remaining = avpriv_dnxhd_get_frame_size ( cid ) ; <S2SV_EndBug> <S2SV_StartBug> if ( dctx -> remaining <= 0 ) { <S2SV_EndBug> <S2SV_StartBug> dctx -> remaining = dnxhd_get_hr_frame_size ( cid , dctx -> w , dctx -> h ) ; <S2SV_EndBug> <S2SV_StartBug> if ( dctx -> remaining <= 0 ) <S2SV_EndBug> <S2SV_StartBug> return dctx -> remaining ; <S2SV_EndBug> } if ( buf_size - i + 47 >= dctx -> remaining ) { int remaining = dctx -> remaining ; pc -> frame_start_found = 0 ; pc -> state64 = - 1 ; dctx -> cur_byte = 0 ; dctx -> remaining = 0 ; return remaining ; } else { dctx -> remaining -= buf_size ; } } } } else if ( pic_found ) { if ( dctx -> remaining > buf_size ) { dctx -> remaining -= buf_size ; } else { int remaining = dctx -> remaining ; pc -> frame_start_found = 0 ; pc -> state64 = - 1 ; dctx -> cur_byte = 0 ; dctx -> remaining = 0 ; return remaining ; } } pc -> frame_start_found = pic_found ; pc -> state64 = state ; return END_NOT_FOUND ; }",<S2SV_ModStart> & 0xFFFFFFFF ; int remaining ; <S2SV_ModStart> ) continue ; <S2SV_ModEnd> remaining = avpriv_dnxhd_get_frame_size <S2SV_ModStart> ; if ( <S2SV_ModEnd> remaining <= 0 <S2SV_ModStart> 0 ) { <S2SV_ModEnd> remaining = dnxhd_get_hr_frame_size <S2SV_ModStart> ; if ( <S2SV_ModEnd> remaining <= 0 <S2SV_ModStart> <= 0 ) continue ; } dctx -> remaining = remaining ; <S2SV_ModEnd> if ( buf_size,FFmpeg@FFmpeg/0a709e2a10b8288a0cc383547924ecfe285cef89,CVE-2017-9608,https://github.com/FFmpeg/FFmpeg/commit/0a709e2a10b8288a0cc383547924ecfe285cef89,2017-12-27T19:29Z
CWE-476,"CWE-476 static ssize_t o2nm_node_num_store ( struct config_item * item , const char * page , size_t count ) { struct o2nm_node * node = to_o2nm_node ( item ) ; <S2SV_StartBug> struct o2nm_cluster * cluster = to_o2nm_cluster_from_node ( node ) ; <S2SV_EndBug> unsigned long tmp ; char * p = ( char * ) page ; int ret = 0 ; tmp = simple_strtoul ( p , & p , 0 ) ; if ( ! p || ( * p && ( * p != '\\n' ) ) ) return - EINVAL ; if ( tmp >= O2NM_MAX_NODES ) return - ERANGE ; if ( ! test_bit ( O2NM_NODE_ATTR_ADDRESS , & node -> nd_set_attributes ) || ! test_bit ( O2NM_NODE_ATTR_PORT , & node -> nd_set_attributes ) ) return - EINVAL ; <S2SV_StartBug> write_lock ( & cluster -> cl_nodes_lock ) ; <S2SV_EndBug> if ( cluster -> cl_nodes [ tmp ] ) ret = - EEXIST ; else if ( test_and_set_bit ( O2NM_NODE_ATTR_NUM , & node -> nd_set_attributes ) ) ret = - EBUSY ; else { cluster -> cl_nodes [ tmp ] = node ; node -> nd_num = tmp ; set_bit ( tmp , cluster -> cl_nodes_bitmap ) ; } write_unlock ( & cluster -> cl_nodes_lock ) ; <S2SV_StartBug> if ( ret ) <S2SV_EndBug> return ret ; return count ; }",<S2SV_ModStart> o2nm_cluster * cluster <S2SV_ModEnd> ; unsigned long <S2SV_ModStart> - EINVAL ; o2nm_lock_subsystem ( ) ; cluster = to_o2nm_cluster_from_node ( node ) ; if ( ! cluster ) { o2nm_unlock_subsystem ( ) ; return - EINVAL ; } <S2SV_ModStart> cl_nodes_lock ) ; o2nm_unlock_subsystem ( ) ;,torvalds@linux/853bc26a7ea39e354b9f8889ae7ad1492ffa28d2,CVE-2017-18216,https://github.com/torvalds/linux/commit/853bc26a7ea39e354b9f8889ae7ad1492ffa28d2,2018-03-05T18:29Z
CWE-401,"CWE-000 static int8_t parse_ext_option ( uint16_t * dst , uint8_t * * packet_data_pptr , uint8_t * packet_data_start_ptr , uint16_t packet_len , uint16_t * message_left ) { uint16_t option_number = * dst ; if ( option_number == 13 ) { uint8_t option_ext ; int8_t read_result = sn_coap_parser_read_packet_u8 ( & option_ext , * packet_data_pptr , packet_data_start_ptr , packet_len ) ; if ( read_result != 0 ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>**packet_data_pptr<S2SV_blank>overflow<S2SV_blank>!"" ) ; return - 1 ; } else { <S2SV_StartBug> option_number += option_ext ; <S2SV_EndBug> * message_left = sn_coap_parser_move_packet_ptr ( packet_data_pptr , packet_data_start_ptr , packet_len , 1 ) ; } } else if ( option_number == 14 ) { int8_t read_result = sn_coap_parser_read_packet_u16 ( & option_number , * packet_data_pptr , packet_data_start_ptr , packet_len ) ; if ( read_result != 0 ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>**packet_data_pptr<S2SV_blank>overflow<S2SV_blank>!"" ) ; return - 1 ; } else { <S2SV_StartBug> option_number += 269 ; <S2SV_EndBug> * message_left = sn_coap_parser_move_packet_ptr ( packet_data_pptr , packet_data_start_ptr , packet_len , 2 ) ; } } else if ( option_number == 15 ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>invalid<S2SV_blank>option<S2SV_blank>number(15)!"" ) ; return - 1 ; } * dst = option_number ; return 0 ; }","<S2SV_ModStart> } else { if ( sn_coap_parser_add_u16_limit ( option_number , option_ext , & option_number ) != 0 ) { return - 1 ; } <S2SV_ModEnd> * message_left = <S2SV_ModStart> } else { if ( sn_coap_parser_add_u16_limit ( option_number , 269 , & option_number ) != 0 ) { return - 1 ; } <S2SV_ModEnd> * message_left =",mjurczak@mbed-coap/4647a68e364401e81dbd370728127d844f221d93,CVE-2020-12887,https://github.com/mjurczak/mbed-coap/commit/4647a68e364401e81dbd370728127d844f221d93,2020-06-18T19:15Z
CWE-189,"CWE-189 static void perf_event_interrupt ( struct pt_regs * regs ) { int i ; struct cpu_hw_events * cpuhw = & __get_cpu_var ( cpu_hw_events ) ; struct perf_event * event ; unsigned long val ; int found = 0 ; int nmi ; if ( cpuhw -> n_limited ) freeze_limited_counters ( cpuhw , mfspr ( SPRN_PMC5 ) , mfspr ( SPRN_PMC6 ) ) ; perf_read_regs ( regs ) ; nmi = perf_intr_is_nmi ( regs ) ; if ( nmi ) nmi_enter ( ) ; else irq_enter ( ) ; for ( i = 0 ; i < cpuhw -> n_events ; ++ i ) { event = cpuhw -> event [ i ] ; if ( ! event -> hw . idx || is_limited_pmc ( event -> hw . idx ) ) continue ; val = read_pmc ( event -> hw . idx ) ; if ( ( int ) val < 0 ) { found = 1 ; record_and_restart ( event , val , regs , nmi ) ; } } if ( ! found ) { for ( i = 0 ; i < ppmu -> n_counter ; ++ i ) { if ( is_limited_pmc ( i + 1 ) ) continue ; val = read_pmc ( i + 1 ) ; <S2SV_StartBug> if ( ( int ) val < 0 ) <S2SV_EndBug> write_pmc ( i + 1 , 0 ) ; } } write_mmcr0 ( cpuhw , cpuhw -> mmcr [ 0 ] ) ; if ( nmi ) nmi_exit ( ) ; else irq_exit ( ) ; }",<S2SV_ModStart> ; if ( pmc_overflow ( val ) <S2SV_ModEnd> ) write_pmc (,torvalds@linux/0837e3242c73566fc1c0196b4ec61779c25ffc93,CVE-2011-4611,https://github.com/torvalds/linux/commit/0837e3242c73566fc1c0196b4ec61779c25ffc93,2012-05-17T11:00Z
CWE-119,"CWE-119 static void first_pass_motion_search ( VP8_COMP * cpi , MACROBLOCK * x , int_mv * ref_mv , MV * best_mv , YV12_BUFFER_CONFIG * recon_buffer , int * best_motion_err , int recon_yoffset ) { MACROBLOCKD * const xd = & x -> e_mbd ; BLOCK * b = & x -> block [ 0 ] ; BLOCKD * d = & x -> e_mbd . block [ 0 ] ; int num00 ; int_mv tmp_mv ; int_mv ref_mv_full ; int tmp_err ; int step_param = 3 ; int further_steps = ( MAX_MVSEARCH_STEPS - 1 ) - step_param ; int n ; vp8_variance_fn_ptr_t v_fn_ptr = cpi -> fn_ptr [ BLOCK_16X16 ] ; int new_mv_mode_penalty = 256 ; <S2SV_StartBug> v_fn_ptr . vf = vp8_mse16x16 ; <S2SV_EndBug> xd -> pre . y_buffer = recon_buffer -> y_buffer + recon_yoffset ; tmp_mv . as_int = 0 ; ref_mv_full . as_mv . col = ref_mv -> as_mv . col >> 3 ; ref_mv_full . as_mv . row = ref_mv -> as_mv . row >> 3 ; tmp_err = cpi -> diamond_search_sad ( x , b , d , & ref_mv_full , & tmp_mv , step_param , x -> sadperbit16 , & num00 , & v_fn_ptr , x -> mvcost , ref_mv ) ; if ( tmp_err < INT_MAX - new_mv_mode_penalty ) tmp_err += new_mv_mode_penalty ; if ( tmp_err < * best_motion_err ) { * best_motion_err = tmp_err ; best_mv -> row = tmp_mv . as_mv . row ; best_mv -> col = tmp_mv . as_mv . col ; } n = num00 ; num00 = 0 ; while ( n < further_steps ) { n ++ ; if ( num00 ) num00 -- ; else { tmp_err = cpi -> diamond_search_sad ( x , b , d , & ref_mv_full , & tmp_mv , step_param + n , x -> sadperbit16 , & num00 , & v_fn_ptr , x -> mvcost , ref_mv ) ; if ( tmp_err < INT_MAX - new_mv_mode_penalty ) tmp_err += new_mv_mode_penalty ; if ( tmp_err < * best_motion_err ) { * best_motion_err = tmp_err ; best_mv -> row = tmp_mv . as_mv . row ; best_mv -> col = tmp_mv . as_mv . col ; } } } }",<S2SV_ModStart> . vf = vpx_mse16x16 <S2SV_ModEnd> ; xd ->,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-20,"CWE-20 int verify_compat_iovec ( struct msghdr * kern_msg , struct iovec * kern_iov , struct sockaddr_storage * kern_address , int mode ) { int tot_len ; if ( kern_msg -> msg_namelen ) { if ( mode == VERIFY_READ ) { int err = move_addr_to_kernel ( kern_msg -> msg_name , kern_msg -> msg_namelen , kern_address ) ; if ( err < 0 ) return err ; } <S2SV_StartBug> kern_msg -> msg_name = kern_address ; <S2SV_EndBug> } else kern_msg -> msg_name = NULL ; tot_len = iov_from_user_compat_to_kern ( kern_iov , ( struct compat_iovec __user * ) kern_msg -> msg_iov , kern_msg -> msg_iovlen ) ; if ( tot_len >= 0 ) kern_msg -> msg_iov = kern_iov ; return tot_len ; }",<S2SV_ModStart> err ; } if ( kern_msg -> msg_name ),torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7270,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z
CWE-20,"CWE-20 static void untrusted_launcher_response_callback ( GtkDialog * dialog , int response_id , ActivateParametersDesktop * parameters ) { GdkScreen * screen ; char * uri ; GFile * file ; switch ( response_id ) { <S2SV_StartBug> case RESPONSE_RUN : <S2SV_EndBug> { screen = gtk_widget_get_screen ( GTK_WIDGET ( parameters -> parent_window ) ) ; uri = nautilus_file_get_uri ( parameters -> file ) ; DEBUG ( ""Launching<S2SV_blank>untrusted<S2SV_blank>launcher<S2SV_blank>%s"" , uri ) ; nautilus_launch_desktop_file ( screen , uri , NULL , parameters -> parent_window ) ; g_free ( uri ) ; <S2SV_StartBug> } <S2SV_EndBug> break ; case RESPONSE_MARK_TRUSTED : { file = nautilus_file_get_location ( parameters -> file ) ; nautilus_file_mark_desktop_file_trusted ( file , parameters -> parent_window , TRUE , NULL , NULL ) ; g_object_unref ( file ) ; } break ; default : { } break ; } gtk_widget_destroy ( GTK_WIDGET ( dialog ) ) ; activate_parameters_desktop_free ( parameters ) ; }","<S2SV_ModStart> ) { case GTK_RESPONSE_OK : { file = nautilus_file_get_location ( parameters -> file ) ; nautilus_file_set_metadata ( parameters -> file , NAUTILUS_METADATA_KEY_DESKTOP_FILE_TRUSTED , NULL , ""yes"" ) ; nautilus_file_mark_desktop_file_executable ( file , parameters -> parent_window , TRUE , NULL , NULL ) ; nautilus_file_invalidate_all_attributes ( parameters -> file ) ; <S2SV_ModEnd> screen = gtk_widget_get_screen <S2SV_ModStart> uri ) ; <S2SV_ModEnd> g_object_unref ( file",GNOME@nautilus/1630f53481f445ada0a455e9979236d31a8d3bb0,CVE-2017-14604,https://github.com/GNOME/nautilus/commit/1630f53481f445ada0a455e9979236d31a8d3bb0,2017-09-20T08:29Z
CWE-59,"CWE-000 void init_rc ( void ) { int i ; struct stat st ; FILE * f ; if ( rc_dir != NULL ) goto open_rc ; rc_dir = expandPath ( RC_DIR ) ; i = strlen ( rc_dir ) ; if ( i > 1 && rc_dir [ i - 1 ] == '/' ) rc_dir [ i - 1 ] = '\\0' ; # ifdef USE_M17N display_charset_str = wc_get_ces_list ( ) ; document_charset_str = display_charset_str ; system_charset_str = display_charset_str ; # endif if ( stat ( rc_dir , & st ) < 0 ) { if ( errno == ENOENT ) { if ( do_mkdir ( rc_dir , 0700 ) < 0 ) { goto rc_dir_err ; } else { stat ( rc_dir , & st ) ; } } else { goto rc_dir_err ; } } if ( ! S_ISDIR ( st . st_mode ) ) { goto rc_dir_err ; } if ( ! ( st . st_mode & S_IWUSR ) ) { goto rc_dir_err ; } no_rc_dir = FALSE ; tmp_dir = rc_dir ; if ( config_file == NULL ) config_file = rcFile ( CONFIG_FILE ) ; create_option_search_table ( ) ; open_rc : if ( ( f = fopen ( etcFile ( W3MCONFIG ) , ""rt"" ) ) != NULL ) { interpret_rc ( f ) ; fclose ( f ) ; } if ( ( f = fopen ( confFile ( CONFIG_FILE ) , ""rt"" ) ) != NULL ) { interpret_rc ( f ) ; fclose ( f ) ; } if ( config_file && ( f = fopen ( config_file , ""rt"" ) ) != NULL ) { interpret_rc ( f ) ; fclose ( f ) ; } return ; rc_dir_err : no_rc_dir = TRUE ; if ( ( ( tmp_dir = getenv ( ""TMPDIR"" ) ) == NULL || * tmp_dir == '\\0' ) && ( ( tmp_dir = getenv ( ""TMP"" ) ) == NULL || * tmp_dir == '\\0' ) && ( ( tmp_dir = getenv ( ""TEMP"" ) ) == NULL || * tmp_dir == '\\0' ) ) tmp_dir = ""/tmp"" ; <S2SV_StartBug> create_option_search_table ( ) ; <S2SV_EndBug> goto open_rc ; }","<S2SV_ModStart> = ""/tmp"" ; # ifdef HAVE_MKDTEMP tmp_dir = mkdtemp ( Strnew_m_charp ( tmp_dir , ""/w3m-XXXXXX"" , NULL ) -> ptr ) ; if ( tmp_dir == NULL ) tmp_dir = rc_dir ; # endif",tats@w3m/18dcbadf2771cdb0c18509b14e4e73505b242753,CVE-2018-6198,https://github.com/tats/w3m/commit/18dcbadf2771cdb0c18509b14e4e73505b242753,2018-01-25T03:29Z
CWE-119,"CWE-119 static void accumulate_stats ( FIRSTPASS_STATS * section , const FIRSTPASS_STATS * frame ) { section -> frame += frame -> frame ; <S2SV_StartBug> section -> spatial_layer_id = frame -> spatial_layer_id ; <S2SV_EndBug> section -> intra_error += frame -> intra_error ; section -> coded_error += frame -> coded_error ; section -> sr_coded_error += frame -> sr_coded_error ; <S2SV_StartBug> section -> ssim_weighted_pred_err += frame -> ssim_weighted_pred_err ; <S2SV_EndBug> section -> pcnt_inter += frame -> pcnt_inter ; section -> pcnt_motion += frame -> pcnt_motion ; section -> pcnt_second_ref += frame -> pcnt_second_ref ; <S2SV_StartBug> section -> pcnt_neutral += frame -> pcnt_neutral ; <S2SV_EndBug> section -> MVr += frame -> MVr ; section -> mvr_abs += frame -> mvr_abs ; section -> MVc += frame -> MVc ; section -> mvc_abs += frame -> mvc_abs ; section -> MVrv += frame -> MVrv ; section -> MVcv += frame -> MVcv ; section -> mv_in_out_count += frame -> mv_in_out_count ; section -> new_mv_count += frame -> new_mv_count ; section -> count += frame -> count ; section -> duration += frame -> duration ; }",<S2SV_ModStart> ; section -> weight += frame -> weight ; section -> <S2SV_ModStart> ; section -> <S2SV_ModEnd> pcnt_inter += frame <S2SV_ModStart> frame -> pcnt_neutral ; section -> intra_skip_pct += frame -> intra_skip_pct ; section -> inactive_zone_rows += frame -> inactive_zone_rows ; section -> inactive_zone_cols += frame -> inactive_zone_cols,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-200,"CWE-200 static void __net_random_once_deferred ( struct work_struct * w ) { struct __net_random_once_work * work = container_of ( w , struct __net_random_once_work , work ) ; <S2SV_StartBug> if ( ! static_key_enabled ( work -> key ) ) <S2SV_EndBug> static_key_slow_inc ( work -> key ) ; kfree ( work ) ; }",<S2SV_ModStart> work ) ; BUG_ON <S2SV_ModEnd> ( ! static_key_enabled <S2SV_ModStart> key ) ) ; static_key_slow_dec <S2SV_ModEnd> ( work ->,torvalds@linux/3d4405226d27b3a215e4d03cfa51f536244e5de7,CVE-2014-7284,https://github.com/torvalds/linux/commit/3d4405226d27b3a215e4d03cfa51f536244e5de7,2014-10-13T10:55Z
CWE-20,"CWE-20 static bool dccp_new ( struct nf_conn * ct , const struct sk_buff * skb , unsigned int dataoff , unsigned int * timeouts ) { struct net * net = nf_ct_net ( ct ) ; struct dccp_net * dn ; struct dccp_hdr _dh , * dh ; const char * msg ; u_int8_t state ; <S2SV_StartBug> dh = skb_header_pointer ( skb , dataoff , sizeof ( _dh ) , & dh ) ; <S2SV_EndBug> BUG_ON ( dh == NULL ) ; state = dccp_state_table [ CT_DCCP_ROLE_CLIENT ] [ dh -> dccph_type ] [ CT_DCCP_NONE ] ; switch ( state ) { default : dn = dccp_pernet ( net ) ; if ( dn -> dccp_loose == 0 ) { msg = ""nf_ct_dccp:<S2SV_blank>not<S2SV_blank>picking<S2SV_blank>up<S2SV_blank>existing<S2SV_blank>connection<S2SV_blank>"" ; goto out_invalid ; } case CT_DCCP_REQUEST : break ; case CT_DCCP_INVALID : msg = ""nf_ct_dccp:<S2SV_blank>invalid<S2SV_blank>state<S2SV_blank>transition<S2SV_blank>"" ; goto out_invalid ; } ct -> proto . dccp . role [ IP_CT_DIR_ORIGINAL ] = CT_DCCP_ROLE_CLIENT ; ct -> proto . dccp . role [ IP_CT_DIR_REPLY ] = CT_DCCP_ROLE_SERVER ; ct -> proto . dccp . state = CT_DCCP_NONE ; ct -> proto . dccp . last_pkt = DCCP_PKT_REQUEST ; ct -> proto . dccp . last_dir = IP_CT_DIR_ORIGINAL ; ct -> proto . dccp . handshake_seq = 0 ; return true ; out_invalid : if ( LOG_INVALID ( net , IPPROTO_DCCP ) ) nf_log_packet ( net , nf_ct_l3num ( ct ) , 0 , skb , NULL , NULL , NULL , ""%s"" , msg ) ; return false ; }","<S2SV_ModStart> ) , & _dh <S2SV_ModEnd> ) ; BUG_ON",torvalds@linux/b22f5126a24b3b2f15448c3f2a254fc10cbc2b92,CVE-2014-2523,https://github.com/torvalds/linux/commit/b22f5126a24b3b2f15448c3f2a254fc10cbc2b92,2014-03-24T16:40Z
CWE-119,"CWE-119 static BT_HDR * create_pbuf ( UINT16 len , UINT8 * data ) { <S2SV_StartBug> BT_HDR * p_buf = GKI_getbuf ( ( UINT16 ) ( len + BTA_HH_MIN_OFFSET + sizeof ( BT_HDR ) ) ) ; <S2SV_EndBug> if ( p_buf ) { UINT8 * pbuf_data ; p_buf -> len = len ; p_buf -> offset = BTA_HH_MIN_OFFSET ; pbuf_data = ( UINT8 * ) ( p_buf + 1 ) + p_buf -> offset ; memcpy ( pbuf_data , data , len ) ; } return p_buf ; }","<S2SV_ModStart> data ) { UINT16 buflen = <S2SV_ModEnd> ( UINT16 ) <S2SV_ModStart> BT_HDR ) ) ; if ( buflen < len ) { android_errorWriteWithInfoLog ( 0x534e4554 , ""28672558"" , - 1 , NULL , 0 ) ; return NULL ; } BT_HDR * p_buf = GKI_getbuf ( buflen",system@bt/514139f4b40cbb035bb92f3e24d5a389d75db9e6,CVE-2016-3744,https://android.googlesource.com/platform/system/bt/+/514139f4b40cbb035bb92f3e24d5a389d75db9e6,2016-07-11T01:59Z
CWE-119,"CWE-119 <S2SV_StartBug> void open_input_file ( struct VpxInputContext * input ) { <S2SV_EndBug> input -> file = strcmp ( input -> filename , ""-"" ) ? fopen ( input -> filename , ""rb"" ) : set_binary_mode ( stdin ) ; if ( ! input -> file ) fatal ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>input<S2SV_blank>file"" ) ; if ( ! fseeko ( input -> file , 0 , SEEK_END ) ) { input -> length = ftello ( input -> file ) ; rewind ( input -> file ) ; } <S2SV_StartBug> input -> detect . buf_read = fread ( input -> detect . buf , 1 , 4 , input -> file ) ; <S2SV_EndBug> input -> detect . position = 0 ; if ( input -> detect . buf_read == 4 && file_is_y4m ( input -> detect . buf ) ) { if ( y4m_input_open ( & input -> y4m , input -> file , input -> detect . buf , 4 , input -> only_i420 ) >= 0 ) { input -> file_type = FILE_TYPE_Y4M ; input -> width = input -> y4m . pic_w ; input -> height = input -> y4m . pic_h ; <S2SV_StartBug> input -> framerate . numerator = input -> y4m . fps_n ; <S2SV_EndBug> input -> framerate . denominator = input -> y4m . fps_d ; <S2SV_StartBug> input -> use_i420 = 0 ; <S2SV_EndBug> } else fatal ( ""Unsupported<S2SV_blank>Y4M<S2SV_blank>stream."" ) ; } else if ( input -> detect . buf_read == 4 && fourcc_is_ivf ( input -> detect . buf ) ) { fatal ( ""IVF<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>as<S2SV_blank>input."" ) ; } else { input -> file_type = FILE_TYPE_RAW ; } }",<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModStart> } input -> pixel_aspect_ratio . numerator = 1 ; input -> pixel_aspect_ratio . denominator = 1 ; input -> <S2SV_ModStart> ; input -> pixel_aspect_ratio . numerator = input -> y4m . par_n ; input -> pixel_aspect_ratio . denominator = input -> y4m . par_d ; input -> <S2SV_ModStart> ; input -> fmt = input -> y4m . vpx_fmt ; input -> bit_depth = input -> y4m . bit_depth <S2SV_ModEnd> ; } else,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-668,"CWE-000 int main ( int argc , const char * argv [ ] ) { struct group * grent ; const char * cmd ; const char * path ; int i ; struct passwd * pw ; grent = getgrnam ( ABUILD_GROUP ) ; if ( grent == NULL ) errx ( 1 , ""%s:<S2SV_blank>Group<S2SV_blank>not<S2SV_blank>found"" , ABUILD_GROUP ) ; char * name = NULL ; pw = getpwuid ( getuid ( ) ) ; if ( pw ) name = pw -> pw_name ; if ( ! is_in_group ( grent -> gr_gid ) ) { errx ( 1 , ""User<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>member<S2SV_blank>of<S2SV_blank>group<S2SV_blank>%s\\n"" , name ? name : ""(unknown)"" , ABUILD_GROUP ) ; } if ( name == NULL ) warnx ( ""Could<S2SV_blank>not<S2SV_blank>find<S2SV_blank>username<S2SV_blank>for<S2SV_blank>uid<S2SV_blank>%d\\n"" , getuid ( ) ) ; setenv ( ""USER"" , name ? : """" , 1 ) ; cmd = strrchr ( argv [ 0 ] , '/' ) ; if ( cmd ) cmd ++ ; else cmd = argv [ 0 ] ; cmd = strchr ( cmd , '-' ) ; if ( cmd == NULL ) errx ( 1 , ""Calling<S2SV_blank>command<S2SV_blank>has<S2SV_blank>no<S2SV_blank>\'-\'"" ) ; cmd ++ ; path = get_command_path ( cmd ) ; if ( path == NULL ) errx ( 1 , ""%s:<S2SV_blank>Not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>subcommand"" , cmd ) ; for ( i = 1 ; i < argc ; i ++ ) <S2SV_StartBug> if ( strcmp ( argv [ i ] , ""--allow-untrusted"" ) == 0 ) <S2SV_EndBug> errx ( 1 , ""%s:<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>option"" , ""--allow-untrusted"" ) ; argv [ 0 ] = path ; setuid ( 0 ) ; setgid ( 0 ) ; execv ( path , ( char * const * ) argv ) ; perror ( path ) ; return 1 ; }",<S2SV_ModStart> i ++ ) check_option ( argv [ i ] <S2SV_ModEnd> ) ; argv,sroracle@abuild/4f90ce92778d0ee302e288def75591b96a397c8b,CVE-2019-12875,https://github.com/sroracle/abuild/commit/4f90ce92778d0ee302e288def75591b96a397c8b,2019-06-18T19:15Z
CWE-264,"CWE-264 void vlan_setup ( struct net_device * dev ) { ether_setup ( dev ) ; dev -> priv_flags |= IFF_802_1Q_VLAN ; <S2SV_StartBug> dev -> priv_flags &= ~ IFF_XMIT_DST_RELEASE ; <S2SV_EndBug> dev -> tx_queue_len = 0 ; dev -> netdev_ops = & vlan_netdev_ops ; dev -> destructor = free_netdev ; dev -> ethtool_ops = & vlan_ethtool_ops ; memset ( dev -> broadcast , 0 , ETH_ALEN ) ; }",<S2SV_ModStart> priv_flags &= ~ ( IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING ) <S2SV_ModEnd> ; dev ->,torvalds@linux/550fd08c2cebad61c548def135f67aba284c6162,CVE-2011-4112,https://github.com/torvalds/linux/commit/550fd08c2cebad61c548def135f67aba284c6162,2012-05-17T11:00Z
CWE-125,"CWE-125 static void atmarp_print ( netdissect_options * ndo , const u_char * bp , u_int length , u_int caplen ) { const struct atmarp_pkthdr * ap ; u_short pro , hrd , op ; ap = ( const struct atmarp_pkthdr * ) bp ; ND_TCHECK ( * ap ) ; hrd = ATMHRD ( ap ) ; pro = ATMPRO ( ap ) ; op = ATMOP ( ap ) ; if ( ! ND_TTEST2 ( * aar_tpa ( ap ) , ATMTPROTO_LEN ( ap ) ) ) { ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; ND_DEFAULTPRINT ( ( const u_char * ) ap , length ) ; return ; } if ( ! ndo -> ndo_eflag ) { ND_PRINT ( ( ndo , ""ARP,<S2SV_blank>"" ) ) ; } if ( ( pro != ETHERTYPE_IP && pro != ETHERTYPE_TRAIL ) || ATMSPROTO_LEN ( ap ) != 4 || ATMTPROTO_LEN ( ap ) != 4 || ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , ""%s,<S2SV_blank>%s<S2SV_blank>(len<S2SV_blank>%u/%u)"" , tok2str ( arphrd_values , ""Unknown<S2SV_blank>Hardware<S2SV_blank>(%u)"" , hrd ) , tok2str ( ethertype_values , ""Unknown<S2SV_blank>Protocol<S2SV_blank>(0x%04x)"" , pro ) , ATMSPROTO_LEN ( ap ) , ATMTPROTO_LEN ( ap ) ) ) ; if ( ! ndo -> ndo_vflag ) { goto out ; } } ND_PRINT ( ( ndo , ""%s%s<S2SV_blank>"" , ndo -> ndo_vflag ? "",<S2SV_blank>"" : """" , tok2str ( arpop_values , ""Unknown<S2SV_blank>(%u)"" , op ) ) ) ; switch ( op ) { case ARPOP_REQUEST : <S2SV_StartBug> ND_PRINT ( ( ndo , ""who-has<S2SV_blank>%s"" , ipaddr_string ( ndo , ATMTPA ( ap ) ) ) ) ; <S2SV_EndBug> if ( ATMTHRD_LEN ( ap ) != 0 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>("" ) ) ; atmarp_addr_print ( ndo , ATMTHA ( ap ) , ATMTHRD_LEN ( ap ) , ATMTSA ( ap ) , ATMTSLN ( ap ) ) ; ND_PRINT ( ( ndo , "")"" ) ) ; } <S2SV_StartBug> ND_PRINT ( ( ndo , ""tell<S2SV_blank>%s"" , ipaddr_string ( ndo , ATMSPA ( ap ) ) ) ) ; <S2SV_EndBug> break ; case ARPOP_REPLY : <S2SV_StartBug> ND_PRINT ( ( ndo , ""%s<S2SV_blank>is-at<S2SV_blank>"" , ipaddr_string ( ndo , ATMSPA ( ap ) ) ) ) ; <S2SV_EndBug> atmarp_addr_print ( ndo , ATMSHA ( ap ) , ATMSHRD_LEN ( ap ) , ATMSSA ( ap ) , ATMSSLN ( ap ) ) ; break ; case ARPOP_INVREQUEST : ND_PRINT ( ( ndo , ""who-is<S2SV_blank>"" ) ) ; atmarp_addr_print ( ndo , ATMTHA ( ap ) , ATMTHRD_LEN ( ap ) , ATMTSA ( ap ) , ATMTSLN ( ap ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>tell<S2SV_blank>"" ) ) ; atmarp_addr_print ( ndo , ATMSHA ( ap ) , ATMSHRD_LEN ( ap ) , ATMSSA ( ap ) , ATMSSLN ( ap ) ) ; break ; case ARPOP_INVREPLY : atmarp_addr_print ( ndo , ATMSHA ( ap ) , ATMSHRD_LEN ( ap ) , ATMSSA ( ap ) , ATMSSLN ( ap ) ) ; <S2SV_StartBug> ND_PRINT ( ( ndo , ""at<S2SV_blank>%s"" , ipaddr_string ( ndo , ATMSPA ( ap ) ) ) ) ; <S2SV_EndBug> break ; case ARPOP_NAK : <S2SV_StartBug> ND_PRINT ( ( ndo , ""for<S2SV_blank>%s"" , ipaddr_string ( ndo , ATMSPA ( ap ) ) ) ) ; <S2SV_EndBug> break ; default : ND_DEFAULTPRINT ( ( const u_char * ) ap , caplen ) ; return ; } out : ND_PRINT ( ( ndo , "",<S2SV_blank>length<S2SV_blank>%u"" , length ) ) ; return ; trunc : ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; }","<S2SV_ModStart> ( ndo , ""who-has<S2SV_blank>"" ) ) ; atmarp_tpaddr_print ( ndo , ap , pro <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( ndo , ""<S2SV_blank>tell<S2SV_blank>"" ) ) ; atmarp_spaddr_print ( ndo , ap , pro <S2SV_ModEnd> ) ; break <S2SV_ModStart> case ARPOP_REPLY : atmarp_spaddr_print ( ndo , ap , pro ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>is-at<S2SV_blank>"" <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( ndo , ""at<S2SV_blank>"" ) ) ; atmarp_spaddr_print ( ndo , ap , pro <S2SV_ModEnd> ) ; break <S2SV_ModStart> ( ndo , ""for<S2SV_blank>"" ) ) ; atmarp_spaddr_print ( ndo , ap , pro <S2SV_ModEnd> ) ; break",the-tcpdump-group@tcpdump/13ab8d18617d616c7d343530f8a842e7143fb5cc,CVE-2017-13013,https://github.com/the-tcpdump-group/tcpdump/commit/13ab8d18617d616c7d343530f8a842e7143fb5cc,2017-09-14T06:29Z
CWE-399,"CWE-399 static void xsltCompileLocationPathPattern ( xsltParserContextPtr ctxt , int novar ) { SKIP_BLANKS ; if ( ( CUR == '/' ) && ( NXT ( 1 ) == '/' ) ) { NEXT ; NEXT ; ctxt -> comp -> priority = 0.5 ; xsltCompileRelativePathPattern ( ctxt , NULL , novar ) ; } else if ( CUR == '/' ) { NEXT ; SKIP_BLANKS ; PUSH ( XSLT_OP_ROOT , NULL , NULL , novar ) ; if ( ( CUR != 0 ) && ( CUR != '|' ) ) { PUSH ( XSLT_OP_PARENT , NULL , NULL , novar ) ; xsltCompileRelativePathPattern ( ctxt , NULL , novar ) ; } } else if ( CUR == '*' ) { xsltCompileRelativePathPattern ( ctxt , NULL , novar ) ; } else if ( CUR == '@' ) { xsltCompileRelativePathPattern ( ctxt , NULL , novar ) ; } else { xmlChar * name ; name = xsltScanNCName ( ctxt ) ; if ( name == NULL ) { xsltTransformError ( NULL , NULL , NULL , ""xsltCompileLocationPathPattern<S2SV_blank>:<S2SV_blank>Name<S2SV_blank>expected\\n"" ) ; ctxt -> error = 1 ; return ; } SKIP_BLANKS ; if ( ( CUR == '(' ) && ! xmlXPathIsNodeType ( name ) ) { xsltCompileIdKeyPattern ( ctxt , name , 1 , novar , 0 ) ; <S2SV_StartBug> if ( ( CUR == '/' ) && ( NXT ( 1 ) == '/' ) ) { <S2SV_EndBug> PUSH ( XSLT_OP_ANCESTOR , NULL , NULL , novar ) ; NEXT ; NEXT ; SKIP_BLANKS ; xsltCompileRelativePathPattern ( ctxt , NULL , novar ) ; } else if ( CUR == '/' ) { PUSH ( XSLT_OP_PARENT , NULL , NULL , novar ) ; NEXT ; SKIP_BLANKS ; xsltCompileRelativePathPattern ( ctxt , NULL , novar ) ; } return ; } xsltCompileRelativePathPattern ( ctxt , name , novar ) ; } error : return ; }",<S2SV_ModStart> ; if ( ctxt -> error ) return ; if (,chromium@chromium/9939d35f9827ed0929646607cbdb071af627ac38,CVE-2012-2870,https://github.com/chromium/chromium/commit/9939d35f9827ed0929646607cbdb071af627ac38,2012-08-31T19:55Z
CWE-362,"CWE-362 int ext4_setattr ( struct dentry * dentry , struct iattr * attr ) { struct inode * inode = d_inode ( dentry ) ; int error , rc = 0 ; int orphan = 0 ; const unsigned int ia_valid = attr -> ia_valid ; error = inode_change_ok ( inode , attr ) ; if ( error ) return error ; if ( is_quota_modification ( inode , attr ) ) { error = dquot_initialize ( inode ) ; if ( error ) return error ; } if ( ( ia_valid & ATTR_UID && ! uid_eq ( attr -> ia_uid , inode -> i_uid ) ) || ( ia_valid & ATTR_GID && ! gid_eq ( attr -> ia_gid , inode -> i_gid ) ) ) { handle_t * handle ; handle = ext4_journal_start ( inode , EXT4_HT_QUOTA , ( EXT4_MAXQUOTAS_INIT_BLOCKS ( inode -> i_sb ) + EXT4_MAXQUOTAS_DEL_BLOCKS ( inode -> i_sb ) ) + 3 ) ; if ( IS_ERR ( handle ) ) { error = PTR_ERR ( handle ) ; goto err_out ; } error = dquot_transfer ( inode , attr ) ; if ( error ) { ext4_journal_stop ( handle ) ; return error ; } if ( attr -> ia_valid & ATTR_UID ) inode -> i_uid = attr -> ia_uid ; if ( attr -> ia_valid & ATTR_GID ) inode -> i_gid = attr -> ia_gid ; error = ext4_mark_inode_dirty ( handle , inode ) ; ext4_journal_stop ( handle ) ; } if ( attr -> ia_valid & ATTR_SIZE ) { handle_t * handle ; loff_t oldsize = inode -> i_size ; int shrink = ( attr -> ia_size <= inode -> i_size ) ; if ( ! ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) ) { struct ext4_sb_info * sbi = EXT4_SB ( inode -> i_sb ) ; if ( attr -> ia_size > sbi -> s_bitmap_maxbytes ) return - EFBIG ; } if ( ! S_ISREG ( inode -> i_mode ) ) return - EINVAL ; if ( IS_I_VERSION ( inode ) && attr -> ia_size != inode -> i_size ) inode_inc_iversion ( inode ) ; if ( ext4_should_order_data ( inode ) && ( attr -> ia_size < inode -> i_size ) ) { error = ext4_begin_ordered_truncate ( inode , attr -> ia_size ) ; if ( error ) goto err_out ; } if ( attr -> ia_size != inode -> i_size ) { handle = ext4_journal_start ( inode , EXT4_HT_INODE , 3 ) ; if ( IS_ERR ( handle ) ) { error = PTR_ERR ( handle ) ; goto err_out ; } if ( ext4_handle_valid ( handle ) && shrink ) { error = ext4_orphan_add ( handle , inode ) ; orphan = 1 ; } if ( ! shrink ) { inode -> i_mtime = ext4_current_time ( inode ) ; inode -> i_ctime = inode -> i_mtime ; } down_write ( & EXT4_I ( inode ) -> i_data_sem ) ; EXT4_I ( inode ) -> i_disksize = attr -> ia_size ; rc = ext4_mark_inode_dirty ( handle , inode ) ; if ( ! error ) error = rc ; if ( ! error ) i_size_write ( inode , attr -> ia_size ) ; up_write ( & EXT4_I ( inode ) -> i_data_sem ) ; ext4_journal_stop ( handle ) ; if ( error ) { if ( orphan ) ext4_orphan_del ( NULL , inode ) ; goto err_out ; } } if ( ! shrink ) pagecache_isize_extended ( inode , oldsize , inode -> i_size ) ; if ( orphan ) { if ( ! ext4_should_journal_data ( inode ) ) { ext4_inode_block_unlocked_dio ( inode ) ; inode_dio_wait ( inode ) ; ext4_inode_resume_unlocked_dio ( inode ) ; } else ext4_wait_for_tail_page_commit ( inode ) ; } <S2SV_StartBug> truncate_pagecache ( inode , inode -> i_size ) ; <S2SV_EndBug> if ( shrink ) <S2SV_StartBug> ext4_truncate ( inode ) ; <S2SV_EndBug> } if ( ! rc ) { setattr_copy ( inode , attr ) ; mark_inode_dirty ( inode ) ; } if ( orphan && inode -> i_nlink ) ext4_orphan_del ( NULL , inode ) ; if ( ! rc && ( ia_valid & ATTR_MODE ) ) rc = posix_acl_chmod ( inode , inode -> i_mode ) ; err_out : ext4_std_error ( inode -> i_sb , error ) ; if ( ! error ) error = rc ; return error ; }",<S2SV_ModStart> ) ; } down_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ; <S2SV_ModStart> ext4_truncate ( inode ) ; up_write ( & EXT4_I ( inode ) -> i_mmap_sem,torvalds@linux/ea3d7209ca01da209cda6f0dea8be9cc4b7a933b,CVE-2015-8839,https://github.com/torvalds/linux/commit/ea3d7209ca01da209cda6f0dea8be9cc4b7a933b,2016-05-02T10:59Z
CWE-20,"CWE-20 static int zip_read_mac_metadata ( struct archive_read * a , struct archive_entry * entry , struct zip_entry * rsrc ) { struct zip * zip = ( struct zip * ) a -> format -> data ; unsigned char * metadata , * mp ; int64_t offset = archive_filter_bytes ( & a -> archive , 0 ) ; size_t remaining_bytes , metadata_bytes ; ssize_t hsize ; int ret = ARCHIVE_OK , eof ; switch ( rsrc -> compression ) { <S2SV_StartBug> case 0 : <S2SV_EndBug> # ifdef HAVE_ZLIB_H case 8 : # endif break ; default : archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Unsupported<S2SV_blank>ZIP<S2SV_blank>compression<S2SV_blank>method<S2SV_blank>(%s)"" , compression_name ( rsrc -> compression ) ) ; return ( ARCHIVE_WARN ) ; } if ( rsrc -> uncompressed_size > ( 4 * 1024 * 1024 ) ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Mac<S2SV_blank>metadata<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large:<S2SV_blank>%jd<S2SV_blank>><S2SV_blank>4M<S2SV_blank>bytes"" , <S2SV_StartBug> ( intmax_t ) rsrc -> uncompressed_size ) ; <S2SV_EndBug> return ( ARCHIVE_WARN ) ; } metadata = malloc ( ( size_t ) rsrc -> uncompressed_size ) ; if ( metadata == NULL ) { archive_set_error ( & a -> archive , ENOMEM , ""Can\'t<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>Mac<S2SV_blank>metadata"" ) ; return ( ARCHIVE_FATAL ) ; } if ( offset < rsrc -> local_header_offset ) __archive_read_consume ( a , rsrc -> local_header_offset - offset ) ; else if ( offset != rsrc -> local_header_offset ) { __archive_read_seek ( a , rsrc -> local_header_offset , SEEK_SET ) ; } hsize = zip_get_local_file_header_size ( a , 0 ) ; __archive_read_consume ( a , hsize ) ; remaining_bytes = ( size_t ) rsrc -> compressed_size ; metadata_bytes = ( size_t ) rsrc -> uncompressed_size ; mp = metadata ; eof = 0 ; while ( ! eof && remaining_bytes ) { const unsigned char * p ; ssize_t bytes_avail ; size_t bytes_used ; p = __archive_read_ahead ( a , 1 , & bytes_avail ) ; if ( p == NULL ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Truncated<S2SV_blank>ZIP<S2SV_blank>file<S2SV_blank>header"" ) ; ret = ARCHIVE_WARN ; goto exit_mac_metadata ; } if ( ( size_t ) bytes_avail > remaining_bytes ) bytes_avail = remaining_bytes ; switch ( rsrc -> compression ) { case 0 : <S2SV_StartBug> memcpy ( mp , p , bytes_avail ) ; <S2SV_EndBug> bytes_used = ( size_t ) bytes_avail ; metadata_bytes -= bytes_used ; mp += bytes_used ; if ( metadata_bytes == 0 ) eof = 1 ; break ; # ifdef HAVE_ZLIB_H case 8 : { int r ; ret = zip_deflate_init ( a , zip ) ; if ( ret != ARCHIVE_OK ) goto exit_mac_metadata ; zip -> stream . next_in = ( Bytef * ) ( uintptr_t ) ( const void * ) p ; zip -> stream . avail_in = ( uInt ) bytes_avail ; zip -> stream . total_in = 0 ; zip -> stream . next_out = mp ; zip -> stream . avail_out = ( uInt ) metadata_bytes ; zip -> stream . total_out = 0 ; r = inflate ( & zip -> stream , 0 ) ; switch ( r ) { case Z_OK : break ; case Z_STREAM_END : eof = 1 ; break ; case Z_MEM_ERROR : archive_set_error ( & a -> archive , ENOMEM , ""Out<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>ZIP<S2SV_blank>decompression"" ) ; ret = ARCHIVE_FATAL ; goto exit_mac_metadata ; default : archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , ""ZIP<S2SV_blank>decompression<S2SV_blank>failed<S2SV_blank>(%d)"" , r ) ; ret = ARCHIVE_FATAL ; goto exit_mac_metadata ; } bytes_used = zip -> stream . total_in ; metadata_bytes -= zip -> stream . total_out ; mp += zip -> stream . total_out ; break ; } # endif default : bytes_used = 0 ; break ; } __archive_read_consume ( a , bytes_used ) ; remaining_bytes -= bytes_used ; } archive_entry_copy_mac_metadata ( entry , metadata , ( size_t ) rsrc -> uncompressed_size - metadata_bytes ) ; exit_mac_metadata : __archive_read_seek ( a , offset , SEEK_SET ) ; zip -> decompress_init = 0 ; free ( metadata ) ; return ( ret ) ; }","<S2SV_ModStart> case 0 : if ( rsrc -> uncompressed_size != rsrc -> compressed_size ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Malformed<S2SV_blank>OS<S2SV_blank>X<S2SV_blank>metadata<S2SV_blank>entry:<S2SV_blank>inconsistent<S2SV_blank>size"" ) ; return ( ARCHIVE_FATAL ) ; } <S2SV_ModStart> rsrc -> uncompressed_size ) ; return ( ARCHIVE_WARN ) ; } if ( rsrc -> compressed_size > ( 4 * 1024 * 1024 ) ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Mac<S2SV_blank>metadata<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large:<S2SV_blank>%jd<S2SV_blank>><S2SV_blank>4M<S2SV_blank>bytes"" , ( intmax_t ) rsrc -> compressed_size <S2SV_ModStart> case 0 : if ( ( size_t ) bytes_avail > metadata_bytes ) bytes_avail = metadata_bytes ;",libarchive@libarchive/d0331e8e5b05b475f20b1f3101fe1ad772d7e7e7,CVE-2016-1541,https://github.com/libarchive/libarchive/commit/d0331e8e5b05b475f20b1f3101fe1ad772d7e7e7,2016-05-07T10:59Z
CWE-674,"CWE-000 krb5_error_code k5_asn1_full_decode ( const krb5_data * code , const struct atype_info * a , void * * retrep ) { krb5_error_code ret ; const uint8_t * contents , * remainder ; size_t clen , rlen ; taginfo t ; * retrep = NULL ; ret = get_tag ( ( uint8_t * ) code -> data , code -> length , & t , & contents , <S2SV_StartBug> & clen , & remainder , & rlen ) ; <S2SV_EndBug> if ( ret ) return ret ; if ( ! check_atype_tag ( a , & t ) ) return ASN1_BAD_ID ; return decode_atype_to_ptr ( & t , contents , clen , a , retrep ) ; }","<S2SV_ModStart> , & rlen , 0",krb5@krb5/57415dda6cf04e73ffc3723be518eddfae599bfd,CVE-2020-28196,https://github.com/krb5/krb5/commit/57415dda6cf04e73ffc3723be518eddfae599bfd,2020-11-06T08:15Z
CWE-190,"CWE-190 static void controloptions ( lua_State * L , int opt , const char * * fmt , Header * h ) { switch ( opt ) { case '<S2SV_blank>' : return ; case '>' : h -> endian = BIG ; return ; case '<' : h -> endian = LITTLE ; return ; case '!' : { <S2SV_StartBug> int a = getnum ( L , fmt , MAXALIGN ) ; <S2SV_EndBug> if ( ! isp2 ( a ) ) luaL_error ( L , ""alignment<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>power<S2SV_blank>of<S2SV_blank>2"" , a ) ; h -> align = a ; return ; } default : { const char * msg = lua_pushfstring ( L , ""invalid<S2SV_blank>format<S2SV_blank>option<S2SV_blank>\'%c\'"" , opt ) ; luaL_argerror ( L , 1 , msg ) ; } } }","<S2SV_ModStart> = getnum ( <S2SV_ModEnd> fmt , MAXALIGN",antirez@redis/1eb08bcd4634ae42ec45e8284923ac048beaa4c3,CVE-2018-11219,https://github.com/antirez/redis/commit/1eb08bcd4634ae42ec45e8284923ac048beaa4c3,2018-06-17T17:29Z
CWE-416,"CWE-416 int __ext4_journal_stop ( const char * where , unsigned int line , handle_t * handle ) { struct super_block * sb ; int err ; int rc ; if ( ! ext4_handle_valid ( handle ) ) { ext4_put_nojournal ( handle ) ; return 0 ; } <S2SV_StartBug> if ( ! handle -> h_transaction ) { <S2SV_EndBug> <S2SV_StartBug> err = jbd2_journal_stop ( handle ) ; <S2SV_EndBug> <S2SV_StartBug> return handle -> h_err ? handle -> h_err : err ; <S2SV_EndBug> } <S2SV_StartBug> sb = handle -> h_transaction -> t_journal -> j_private ; <S2SV_EndBug> err = handle -> h_err ; rc = jbd2_journal_stop ( handle ) ; if ( ! err ) err = rc ; if ( err ) __ext4_std_error ( sb , where , line , err ) ; return err ; }",<S2SV_ModStart> 0 ; } err = handle -> h_err ; <S2SV_ModStart> h_transaction ) { rc <S2SV_ModEnd> = jbd2_journal_stop ( <S2SV_ModStart> ) ; return err ? err : rc <S2SV_ModEnd> ; } sb <S2SV_ModStart> t_journal -> j_private <S2SV_ModEnd> ; rc =,torvalds@linux/6934da9238da947628be83635e365df41064b09b,CVE-2015-8961,https://github.com/torvalds/linux/commit/6934da9238da947628be83635e365df41064b09b,2016-11-16T05:59Z
CWE-119,"CWE-119 int vp8_refining_search_sadx4 ( MACROBLOCK * x , BLOCK * b , BLOCKD * d , int_mv * ref_mv , int error_per_bit , int search_range , vp8_variance_fn_ptr_t * fn_ptr , int * mvcost [ 2 ] , int_mv * center_mv ) { MV neighbors [ 4 ] = { { - 1 , 0 } , { 0 , - 1 } , { 0 , 1 } , { 1 , 0 } } ; int i , j ; short this_row_offset , this_col_offset ; int what_stride = b -> src_stride ; int pre_stride = x -> e_mbd . pre . y_stride ; unsigned char * base_pre = x -> e_mbd . pre . y_buffer ; int in_what_stride = pre_stride ; unsigned char * what = ( * ( b -> base_src ) + b -> src ) ; unsigned char * best_address = ( unsigned char * ) ( base_pre + d -> offset + ( ref_mv -> as_mv . row * pre_stride ) + ref_mv -> as_mv . col ) ; unsigned char * check_here ; int_mv this_mv ; unsigned int bestsad ; unsigned int thissad ; int * mvsadcost [ 2 ] ; int_mv fcenter_mv ; mvsadcost [ 0 ] = x -> mvsadcost [ 0 ] ; mvsadcost [ 1 ] = x -> mvsadcost [ 1 ] ; fcenter_mv . as_mv . row = center_mv -> as_mv . row >> 3 ; fcenter_mv . as_mv . col = center_mv -> as_mv . col >> 3 ; bestsad = fn_ptr -> sdf ( what , what_stride , best_address , <S2SV_StartBug> in_what_stride , UINT_MAX ) <S2SV_EndBug> + mvsad_err_cost ( ref_mv , & fcenter_mv , mvsadcost , error_per_bit ) ; for ( i = 0 ; i < search_range ; i ++ ) { int best_site = - 1 ; int all_in = 1 ; all_in &= ( ( ref_mv -> as_mv . row - 1 ) > x -> mv_row_min ) ; all_in &= ( ( ref_mv -> as_mv . row + 1 ) < x -> mv_row_max ) ; all_in &= ( ( ref_mv -> as_mv . col - 1 ) > x -> mv_col_min ) ; all_in &= ( ( ref_mv -> as_mv . col + 1 ) < x -> mv_col_max ) ; if ( all_in ) { unsigned int sad_array [ 4 ] ; const unsigned char * block_offset [ 4 ] ; block_offset [ 0 ] = best_address - in_what_stride ; block_offset [ 1 ] = best_address - 1 ; block_offset [ 2 ] = best_address + 1 ; block_offset [ 3 ] = best_address + in_what_stride ; fn_ptr -> sdx4df ( what , what_stride , block_offset , in_what_stride , sad_array ) ; for ( j = 0 ; j < 4 ; j ++ ) { if ( sad_array [ j ] < bestsad ) { this_mv . as_mv . row = ref_mv -> as_mv . row + neighbors [ j ] . row ; this_mv . as_mv . col = ref_mv -> as_mv . col + neighbors [ j ] . col ; sad_array [ j ] += mvsad_err_cost ( & this_mv , & fcenter_mv , mvsadcost , error_per_bit ) ; if ( sad_array [ j ] < bestsad ) { bestsad = sad_array [ j ] ; best_site = j ; } } } } else { for ( j = 0 ; j < 4 ; j ++ ) { this_row_offset = ref_mv -> as_mv . row + neighbors [ j ] . row ; this_col_offset = ref_mv -> as_mv . col + neighbors [ j ] . col ; if ( ( this_col_offset > x -> mv_col_min ) && ( this_col_offset < x -> mv_col_max ) && ( this_row_offset > x -> mv_row_min ) && ( this_row_offset < x -> mv_row_max ) ) { check_here = ( neighbors [ j ] . row ) * in_what_stride + neighbors [ j ] . col + best_address ; <S2SV_StartBug> thissad = fn_ptr -> sdf ( what , what_stride , check_here , in_what_stride , bestsad ) ; <S2SV_EndBug> if ( thissad < bestsad ) { this_mv . as_mv . row = this_row_offset ; this_mv . as_mv . col = this_col_offset ; thissad += mvsad_err_cost ( & this_mv , & fcenter_mv , mvsadcost , error_per_bit ) ; if ( thissad < bestsad ) { bestsad = thissad ; best_site = j ; } } } } } if ( best_site == - 1 ) break ; else { ref_mv -> as_mv . row += neighbors [ best_site ] . row ; ref_mv -> as_mv . col += neighbors [ best_site ] . col ; best_address += ( neighbors [ best_site ] . row ) * in_what_stride + neighbors [ best_site ] . col ; } } this_mv . as_mv . row = ref_mv -> as_mv . row * 8 ; this_mv . as_mv . col = ref_mv -> as_mv . col * 8 ; return fn_ptr -> vf ( what , what_stride , best_address , in_what_stride , & thissad ) + mv_err_cost ( & this_mv , center_mv , mvcost , x -> errorperbit ) ; }","<S2SV_ModStart> best_address , in_what_stride <S2SV_ModEnd> ) + mvsad_err_cost <S2SV_ModStart> check_here , in_what_stride <S2SV_ModEnd> ) ; if",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-190,"CWE-190 static PyObject * _pickle_UnpicklerMemoProxy_copy_impl ( UnpicklerMemoProxyObject * self ) { <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> PyObject * new_memo = PyDict_New ( ) ; if ( new_memo == NULL ) return NULL ; for ( i = 0 ; i < self -> unpickler -> memo_size ; i ++ ) { int status ; PyObject * key , * value ; value = self -> unpickler -> memo [ i ] ; if ( value == NULL ) continue ; key = PyLong_FromSsize_t ( i ) ; if ( key == NULL ) goto error ; status = PyDict_SetItem ( new_memo , key , value ) ; Py_DECREF ( key ) ; if ( status < 0 ) goto error ; } return new_memo ; error : Py_DECREF ( new_memo ) ; return NULL ; }",<S2SV_ModStart> self ) { size_t <S2SV_ModEnd> i ; PyObject,python@cpython/a4ae828ee416a66d8c7bf5ee71d653c2cc6a26dd,CVE-2018-20406,https://github.com/python/cpython/commit/a4ae828ee416a66d8c7bf5ee71d653c2cc6a26dd,2018-12-23T23:29Z
CWE-787,"CWE-787 static int _server_handle_vCont ( libgdbr_t * g , int ( * cmd_cb ) ( void * , const char * , char * , size_t ) , void * core_ptr ) { char * action = NULL ; if ( send_ack ( g ) < 0 ) { return - 1 ; } g -> data [ g -> data_len ] = '\\0' ; if ( g -> data [ 5 ] == '?' ) { return send_msg ( g , ""vCont;c;s"" ) ; } if ( ! ( action = strtok ( g -> data , "";"" ) ) ) { return send_msg ( g , ""E01"" ) ; } while ( action = strtok ( NULL , "";"" ) ) { eprintf ( ""action:<S2SV_blank>%s\\n"" , action ) ; switch ( action [ 0 ] ) { case 's' : if ( cmd_cb ( core_ptr , ""ds"" , NULL , 0 ) < 0 ) { send_msg ( g , ""E01"" ) ; return - 1 ; } return send_msg ( g , ""OK"" ) ; case 'c' : if ( cmd_cb ( core_ptr , ""dc"" , NULL , 0 ) < 0 ) { send_msg ( g , ""E01"" ) ; return - 1 ; } return send_msg ( g , ""OK"" ) ; default : return send_msg ( g , ""E01"" ) ; } } <S2SV_StartBug> } <S2SV_EndBug>",<S2SV_ModStart> ; } } return - 1 ;,radare@radare2/796dd28aaa6b9fa76d99c42c4d5ff8b257cc2191,CVE-2017-9949,https://github.com/radare/radare2/commit/796dd28aaa6b9fa76d99c42c4d5ff8b257cc2191,2017-06-26T20:29Z
CWE-264,"CWE-264 int hfsplus_rename_cat ( u32 cnid , struct inode * src_dir , struct qstr * src_name , struct inode * dst_dir , struct qstr * dst_name ) { struct super_block * sb = src_dir -> i_sb ; struct hfs_find_data src_fd , dst_fd ; hfsplus_cat_entry entry ; int entry_size , type ; int err ; dprint ( DBG_CAT_MOD , ""rename_cat:<S2SV_blank>%u<S2SV_blank>-<S2SV_blank>%lu,%s<S2SV_blank>-<S2SV_blank>%lu,%s\\n"" , cnid , src_dir -> i_ino , src_name -> name , dst_dir -> i_ino , dst_name -> name ) ; err = hfs_find_init ( HFSPLUS_SB ( sb ) -> cat_tree , & src_fd ) ; if ( err ) return err ; dst_fd = src_fd ; hfsplus_cat_build_key ( sb , src_fd . search_key , src_dir -> i_ino , src_name ) ; err = hfs_brec_find ( & src_fd ) ; if ( err ) goto out ; <S2SV_StartBug> hfs_bnode_read ( src_fd . bnode , & entry , src_fd . entryoffset , <S2SV_EndBug> src_fd . entrylength ) ; hfsplus_cat_build_key ( sb , dst_fd . search_key , dst_dir -> i_ino , dst_name ) ; err = hfs_brec_find ( & dst_fd ) ; if ( err != - ENOENT ) { if ( ! err ) err = - EEXIST ; goto out ; } err = hfs_brec_insert ( & dst_fd , & entry , src_fd . entrylength ) ; if ( err ) goto out ; dst_dir -> i_size ++ ; dst_dir -> i_mtime = dst_dir -> i_ctime = CURRENT_TIME_SEC ; hfsplus_cat_build_key ( sb , src_fd . search_key , src_dir -> i_ino , src_name ) ; err = hfs_brec_find ( & src_fd ) ; if ( err ) goto out ; err = hfs_brec_remove ( & src_fd ) ; if ( err ) goto out ; src_dir -> i_size -- ; src_dir -> i_mtime = src_dir -> i_ctime = CURRENT_TIME_SEC ; hfsplus_cat_build_key ( sb , src_fd . search_key , cnid , NULL ) ; err = hfs_brec_find ( & src_fd ) ; if ( err ) goto out ; type = hfs_bnode_read_u16 ( src_fd . bnode , src_fd . entryoffset ) ; err = hfs_brec_remove ( & src_fd ) ; if ( err ) goto out ; hfsplus_cat_build_key ( sb , dst_fd . search_key , cnid , NULL ) ; entry_size = hfsplus_fill_cat_thread ( sb , & entry , type , dst_dir -> i_ino , dst_name ) ; err = hfs_brec_find ( & dst_fd ) ; if ( err != - ENOENT ) { if ( ! err ) err = - EEXIST ; goto out ; } err = hfs_brec_insert ( & dst_fd , & entry , entry_size ) ; hfsplus_mark_inode_dirty ( dst_dir , HFSPLUS_I_CAT_DIRTY ) ; hfsplus_mark_inode_dirty ( src_dir , HFSPLUS_I_CAT_DIRTY ) ; out : hfs_bnode_put ( dst_fd . bnode ) ; hfs_find_exit ( & src_fd ) ; return err ; }",<S2SV_ModStart> goto out ; if ( src_fd . entrylength > sizeof ( entry ) || src_fd . entrylength < 0 ) { err = - EIO ; goto out ; },torvalds@linux/6f24f892871acc47b40dd594c63606a17c714f77,CVE-2012-2319,https://github.com/torvalds/linux/commit/6f24f892871acc47b40dd594c63606a17c714f77,2012-05-17T11:00Z
,"CWE-000 OM_uint32 kg_seal_iov ( OM_uint32 * minor_status , gss_ctx_id_t context_handle , int conf_req_flag , gss_qop_t qop_req , int * conf_state , gss_iov_buffer_desc * iov , int iov_count , int toktype ) { krb5_gss_ctx_id_rec * ctx ; krb5_error_code code ; krb5_context context ; if ( qop_req != 0 ) { * minor_status = ( OM_uint32 ) G_UNKNOWN_QOP ; return GSS_S_FAILURE ; } ctx = ( krb5_gss_ctx_id_rec * ) context_handle ; <S2SV_StartBug> if ( ! ctx -> established ) { <S2SV_EndBug> * minor_status = KG_CTX_INCOMPLETE ; return GSS_S_NO_CONTEXT ; } if ( conf_req_flag && kg_integ_only_iov ( iov , iov_count ) ) { conf_req_flag = FALSE ; } context = ctx -> k5_context ; switch ( ctx -> proto ) { case 0 : code = make_seal_token_v1_iov ( context , ctx , conf_req_flag , conf_state , iov , iov_count , toktype ) ; break ; case 1 : code = gss_krb5int_make_seal_token_v3_iov ( context , ctx , conf_req_flag , conf_state , iov , iov_count , toktype ) ; break ; default : code = G_UNKNOWN_QOP ; break ; } if ( code != 0 ) { * minor_status = code ; save_error_info ( * minor_status , context ) ; return GSS_S_FAILURE ; } * minor_status = 0 ; return GSS_S_COMPLETE ; }",<S2SV_ModStart> ; if ( ctx -> terminated ||,krb5@krb5/82dc33da50338ac84c7b4102dc6513d897d0506a,CVE-2014-5352,https://github.com/krb5/krb5/commit/82dc33da50338ac84c7b4102dc6513d897d0506a,2015-02-19T11:59Z
CWE-401,"CWE-000 static int fsl_lpspi_probe ( struct platform_device * pdev ) { struct device_node * np = pdev -> dev . of_node ; struct fsl_lpspi_data * fsl_lpspi ; struct spi_controller * controller ; struct spi_imx_master * lpspi_platform_info = dev_get_platdata ( & pdev -> dev ) ; struct resource * res ; int i , ret , irq ; u32 temp ; bool is_slave ; is_slave = of_property_read_bool ( ( & pdev -> dev ) -> of_node , ""spi-slave"" ) ; if ( is_slave ) controller = spi_alloc_slave ( & pdev -> dev , sizeof ( struct fsl_lpspi_data ) ) ; else controller = spi_alloc_master ( & pdev -> dev , sizeof ( struct fsl_lpspi_data ) ) ; if ( ! controller ) return - ENOMEM ; platform_set_drvdata ( pdev , controller ) ; fsl_lpspi = spi_controller_get_devdata ( controller ) ; fsl_lpspi -> dev = & pdev -> dev ; fsl_lpspi -> is_slave = is_slave ; if ( ! fsl_lpspi -> is_slave ) { for ( i = 0 ; i < controller -> num_chipselect ; i ++ ) { int cs_gpio = of_get_named_gpio ( np , ""cs-gpios"" , i ) ; if ( ! gpio_is_valid ( cs_gpio ) && lpspi_platform_info ) cs_gpio = lpspi_platform_info -> chipselect [ i ] ; fsl_lpspi -> chipselect [ i ] = cs_gpio ; if ( ! gpio_is_valid ( cs_gpio ) ) continue ; ret = devm_gpio_request ( & pdev -> dev , fsl_lpspi -> chipselect [ i ] , DRIVER_NAME ) ; if ( ret ) { dev_err ( & pdev -> dev , ""can\'t<S2SV_blank>get<S2SV_blank>cs<S2SV_blank>gpios\\n"" ) ; goto out_controller_put ; } } controller -> cs_gpios = fsl_lpspi -> chipselect ; controller -> prepare_message = fsl_lpspi_prepare_message ; } controller -> bits_per_word_mask = SPI_BPW_RANGE_MASK ( 8 , 32 ) ; controller -> transfer_one = fsl_lpspi_transfer_one ; controller -> prepare_transfer_hardware = lpspi_prepare_xfer_hardware ; controller -> unprepare_transfer_hardware = lpspi_unprepare_xfer_hardware ; controller -> mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH ; controller -> flags = SPI_MASTER_MUST_RX | SPI_MASTER_MUST_TX ; controller -> dev . of_node = pdev -> dev . of_node ; controller -> bus_num = pdev -> id ; controller -> slave_abort = fsl_lpspi_slave_abort ; init_completion ( & fsl_lpspi -> xfer_done ) ; res = platform_get_resource ( pdev , IORESOURCE_MEM , 0 ) ; fsl_lpspi -> base = devm_ioremap_resource ( & pdev -> dev , res ) ; if ( IS_ERR ( fsl_lpspi -> base ) ) { ret = PTR_ERR ( fsl_lpspi -> base ) ; goto out_controller_put ; } fsl_lpspi -> base_phys = res -> start ; irq = platform_get_irq ( pdev , 0 ) ; if ( irq < 0 ) { ret = irq ; goto out_controller_put ; } ret = devm_request_irq ( & pdev -> dev , irq , fsl_lpspi_isr , 0 , dev_name ( & pdev -> dev ) , fsl_lpspi ) ; if ( ret ) { dev_err ( & pdev -> dev , ""can\'t<S2SV_blank>get<S2SV_blank>irq%d:<S2SV_blank>%d\\n"" , irq , ret ) ; goto out_controller_put ; } fsl_lpspi -> clk_per = devm_clk_get ( & pdev -> dev , ""per"" ) ; if ( IS_ERR ( fsl_lpspi -> clk_per ) ) { ret = PTR_ERR ( fsl_lpspi -> clk_per ) ; goto out_controller_put ; } fsl_lpspi -> clk_ipg = devm_clk_get ( & pdev -> dev , ""ipg"" ) ; if ( IS_ERR ( fsl_lpspi -> clk_ipg ) ) { ret = PTR_ERR ( fsl_lpspi -> clk_ipg ) ; goto out_controller_put ; } ret = fsl_lpspi_init_rpm ( fsl_lpspi ) ; if ( ret ) goto out_controller_put ; ret = pm_runtime_get_sync ( fsl_lpspi -> dev ) ; if ( ret < 0 ) { dev_err ( fsl_lpspi -> dev , ""failed<S2SV_blank>to<S2SV_blank>enable<S2SV_blank>clock\\n"" ) ; <S2SV_StartBug> return ret ; <S2SV_EndBug> } temp = readl ( fsl_lpspi -> base + IMX7ULP_PARAM ) ; fsl_lpspi -> txfifosize = 1 << ( temp & 0x0f ) ; fsl_lpspi -> rxfifosize = 1 << ( ( temp >> 8 ) & 0x0f ) ; ret = fsl_lpspi_dma_init ( & pdev -> dev , fsl_lpspi , controller ) ; if ( ret == - EPROBE_DEFER ) goto out_controller_put ; if ( ret < 0 ) dev_err ( & pdev -> dev , ""dma<S2SV_blank>setup<S2SV_blank>error<S2SV_blank>%d,<S2SV_blank>use<S2SV_blank>pio\\n"" , ret ) ; ret = devm_spi_register_controller ( & pdev -> dev , controller ) ; if ( ret < 0 ) { dev_err ( & pdev -> dev , ""spi_register_controller<S2SV_blank>error.\\n"" ) ; goto out_controller_put ; } return 0 ; out_controller_put : spi_controller_put ( controller ) ; return ret ; }","<S2SV_ModStart> ""failed<S2SV_blank>to<S2SV_blank>enable<S2SV_blank>clock\\n"" ) ; goto out_controller_put <S2SV_ModEnd> ; } temp",torvalds@linux/057b8945f78f76d0b04eeb5c27cd9225e5e7ad86,CVE-2019-19064,https://github.com/torvalds/linux/commit/057b8945f78f76d0b04eeb5c27cd9225e5e7ad86,2019-11-18T06:15Z
CWE-200,"CWE-200 static int cdrom_ioctl_drive_status ( struct cdrom_device_info * cdi , unsigned long arg ) { cd_dbg ( CD_DO_IOCTL , ""entering<S2SV_blank>CDROM_DRIVE_STATUS\\n"" ) ; if ( ! ( cdi -> ops -> capability & CDC_DRIVE_STATUS ) ) return - ENOSYS ; if ( ! CDROM_CAN ( CDC_SELECT_DISC ) || ( arg == CDSL_CURRENT || arg == CDSL_NONE ) ) return cdi -> ops -> drive_status ( cdi , CDSL_CURRENT ) ; <S2SV_StartBug> if ( ( ( int ) arg >= cdi -> capacity ) ) <S2SV_EndBug> return - EINVAL ; return cdrom_slot_status ( cdi , arg ) ; }",<S2SV_ModStart> ; if ( <S2SV_ModEnd> arg >= cdi <S2SV_ModStart> cdi -> capacity <S2SV_ModEnd> ) return -,torvalds@linux/8f3fafc9c2f0ece10832c25f7ffcb07c97a32ad4,CVE-2018-16658,https://github.com/torvalds/linux/commit/8f3fafc9c2f0ece10832c25f7ffcb07c97a32ad4,2018-09-07T14:29Z
CWE-264,"CWE-264 <S2SV_StartBug> int setpwnam ( struct passwd * pwd ) <S2SV_EndBug> { FILE * fp = NULL , * pwf = NULL ; int save_errno ; int found ; int namelen ; int buflen = 256 ; int contlen , rc ; char * linebuf = NULL ; char * tmpname = NULL ; <S2SV_StartBug> char * atomic_dir = ""/etc"" ; <S2SV_EndBug> pw_init ( ) ; <S2SV_StartBug> if ( ( fp = xfmkstemp ( & tmpname , atomic_dir ) ) == NULL ) <S2SV_EndBug> return - 1 ; if ( fchown ( fileno ( fp ) , ( uid_t ) 0 , ( gid_t ) 0 ) < 0 ) goto fail ; if ( lckpwdf ( ) < 0 ) goto fail ; pwf = fopen ( PASSWD_FILE , ""r"" ) ; if ( ! pwf ) goto fail ; namelen = strlen ( pwd -> pw_name ) ; linebuf = malloc ( buflen ) ; if ( ! linebuf ) goto fail ; found = false ; while ( fgets ( linebuf , buflen , pwf ) != NULL ) { contlen = strlen ( linebuf ) ; while ( linebuf [ contlen - 1 ] != '\\n' && ! feof ( pwf ) ) { char * tmp ; buflen *= 2 ; tmp = realloc ( linebuf , buflen ) ; if ( tmp == NULL ) goto fail ; linebuf = tmp ; if ( fgets ( & linebuf [ contlen ] , buflen / 2 , pwf ) == NULL ) break ; contlen = strlen ( linebuf ) ; } if ( ! found && linebuf [ namelen ] == ':' && ! strncmp ( linebuf , pwd -> pw_name , namelen ) ) { if ( putpwent ( pwd , fp ) < 0 ) goto fail ; found = true ; continue ; } fputs ( linebuf , fp ) ; } if ( fchmod ( fileno ( fp ) , 0644 ) < 0 ) goto fail ; rc = close_stream ( fp ) ; fp = NULL ; if ( rc != 0 ) goto fail ; fclose ( pwf ) ; pwf = NULL ; if ( ! found ) { errno = ENOENT ; goto fail ; } unlink ( PASSWD_FILE "".OLD"" ) ; ignore_result ( link ( PASSWD_FILE , PASSWD_FILE "".OLD"" ) ) ; if ( rename ( tmpname , PASSWD_FILE ) < 0 ) goto fail ; ulckpwdf ( ) ; return 0 ; fail : save_errno = errno ; ulckpwdf ( ) ; if ( fp != NULL ) fclose ( fp ) ; if ( tmpname != NULL ) unlink ( tmpname ) ; free ( tmpname ) ; if ( pwf != NULL ) fclose ( pwf ) ; free ( linebuf ) ; errno = save_errno ; return - 1 ; }","<S2SV_ModStart> passwd * pwd , const char * prefix <S2SV_ModStart> = NULL ; <S2SV_ModEnd> pw_init ( ) <S2SV_ModStart> & tmpname , ""/etc"" , prefix <S2SV_ModEnd> ) ) ==",karelzak@util-linux/bde91c85bdc77975155058276f99d2e0f5eab5a9,CVE-2015-5224,https://github.com/karelzak/util-linux/commit/bde91c85bdc77975155058276f99d2e0f5eab5a9,2017-08-23T15:29Z
CWE-400,"CWE-000 static int attach_recursive_mnt ( struct mount * source_mnt , struct mount * dest_mnt , struct mountpoint * dest_mp , struct path * parent_path ) { HLIST_HEAD ( tree_list ) ; <S2SV_StartBug> struct mount * child , * p ; <S2SV_EndBug> struct hlist_node * n ; int err ; <S2SV_StartBug> if ( IS_MNT_SHARED ( dest_mnt ) ) { <S2SV_EndBug> err = invent_group_ids ( source_mnt , true ) ; if ( err ) goto out ; <S2SV_StartBug> err = propagate_mnt ( dest_mnt , dest_mp , source_mnt , & tree_list ) ; <S2SV_EndBug> lock_mount_hash ( ) ; if ( err ) goto out_cleanup_ids ; for ( p = source_mnt ; p ; p = next_mnt ( p , source_mnt ) ) set_mnt_shared ( p ) ; } else { lock_mount_hash ( ) ; } if ( parent_path ) { detach_mnt ( source_mnt , parent_path ) ; attach_mnt ( source_mnt , dest_mnt , dest_mp ) ; touch_mnt_namespace ( source_mnt -> mnt_ns ) ; } else { mnt_set_mountpoint ( dest_mnt , dest_mp , source_mnt ) ; commit_tree ( source_mnt , NULL ) ; } hlist_for_each_entry_safe ( child , n , & tree_list , mnt_hash ) { struct mount * q ; hlist_del_init ( & child -> mnt_hash ) ; q = __lookup_mnt_last ( & child -> mnt_parent -> mnt , child -> mnt_mountpoint ) ; commit_tree ( child , q ) ; } unlock_mount_hash ( ) ; return 0 ; out_cleanup_ids : while ( ! hlist_empty ( & tree_list ) ) { child = hlist_entry ( tree_list . first , struct mount , mnt_hash ) ; <S2SV_StartBug> umount_tree ( child , UMOUNT_SYNC ) ; <S2SV_EndBug> } unlock_mount_hash ( ) ; cleanup_group_ids ( source_mnt , NULL ) ; out : <S2SV_StartBug> return err ; <S2SV_EndBug> }","<S2SV_ModStart> ) ; struct mnt_namespace * ns = dest_mnt -> mnt_ns ; struct <S2SV_ModStart> ; if ( ! parent_path ) { err = count_mounts ( ns , source_mnt <S2SV_ModEnd> ) ; if <S2SV_ModStart> goto out ; } if ( IS_MNT_SHARED ( dest_mnt ) ) { err = invent_group_ids ( source_mnt , true ) ; if ( err ) goto out ; <S2SV_ModStart> mnt_hash ) ; child -> mnt_parent -> mnt_ns -> pending_mounts = 0 ; <S2SV_ModStart> ; out : ns -> pending_mounts = 0 ;",torvalds@linux/d29216842a85c7970c536108e093963f02714498,CVE-2016-6213,https://github.com/torvalds/linux/commit/d29216842a85c7970c536108e093963f02714498,2016-12-28T07:59Z
CWE-119,"CWE-119 <S2SV_StartBug> cJSON * cJSON_CreateIntArray ( int64_t * numbers , int count ) <S2SV_EndBug> { int i ; cJSON * n = 0 , * p = 0 , * a = cJSON_CreateArray ( ) ; <S2SV_StartBug> for ( i = 0 ; a && i < count ; ++ i ) { <S2SV_EndBug> <S2SV_StartBug> n = cJSON_CreateInt ( numbers [ i ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! i ) <S2SV_EndBug> a -> child = n ; else suffix_object ( p , n ) ; p = n ; } return a ; }","<S2SV_ModStart> * cJSON_CreateIntArray ( const int <S2SV_ModEnd> * numbers , <S2SV_ModStart> < count ; i ++ <S2SV_ModEnd> ) { n <S2SV_ModStart> { n = cJSON_CreateNumber <S2SV_ModEnd> ( numbers [ <S2SV_ModStart> ] ) ; if ( ! n ) { cJSON_Delete ( a ) ; return 0 ; }",esnet@iperf/91f2fa59e8ed80dfbf400add0164ee0e508e412a,CVE-2016-4303,https://github.com/esnet/iperf/commit/91f2fa59e8ed80dfbf400add0164ee0e508e412a,2016-09-26T14:59Z
CWE-119,"CWE-119 <S2SV_StartBug> void vp9_setup_dst_planes ( MACROBLOCKD * xd , <S2SV_EndBug> const YV12_BUFFER_CONFIG * src , int mi_row , int mi_col ) { <S2SV_StartBug> uint8_t * const buffers [ 4 ] = { src -> y_buffer , src -> u_buffer , src -> v_buffer , <S2SV_EndBug> src -> alpha_buffer } ; <S2SV_StartBug> const int strides [ 4 ] = { src -> y_stride , src -> uv_stride , src -> uv_stride , <S2SV_EndBug> src -> alpha_stride } ; int i ; for ( i = 0 ; i < MAX_MB_PLANE ; ++ i ) { <S2SV_StartBug> struct macroblockd_plane * const pd = & xd -> plane [ i ] ; <S2SV_EndBug> setup_pred_plane ( & pd -> dst , buffers [ i ] , strides [ i ] , mi_row , mi_col , NULL , pd -> subsampling_x , pd -> subsampling_y ) ; } }","<S2SV_ModStart> void vp9_setup_dst_planes ( struct macroblockd_plane planes [ MAX_MB_PLANE ] <S2SV_ModEnd> , const YV12_BUFFER_CONFIG <S2SV_ModStart> const buffers [ MAX_MB_PLANE <S2SV_ModEnd> ] = { <S2SV_ModStart> src -> v_buffer <S2SV_ModEnd> } ; const <S2SV_ModStart> int strides [ MAX_MB_PLANE <S2SV_ModEnd> ] = { <S2SV_ModStart> src -> uv_stride <S2SV_ModEnd> } ; int <S2SV_ModStart> pd = & planes <S2SV_ModEnd> [ i ]",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-399,"CWE-399 SYSCALL_DEFINE1 ( inotify_init1 , int , flags ) { struct fsnotify_group * group ; struct user_struct * user ; int ret ; BUILD_BUG_ON ( IN_CLOEXEC != O_CLOEXEC ) ; BUILD_BUG_ON ( IN_NONBLOCK != O_NONBLOCK ) ; if ( flags & ~ ( IN_CLOEXEC | IN_NONBLOCK ) ) return - EINVAL ; user = get_current_user ( ) ; if ( unlikely ( atomic_read ( & user -> inotify_devs ) >= inotify_max_user_instances ) ) { ret = - EMFILE ; goto out_free_uid ; } group = inotify_new_group ( user , inotify_max_queued_events ) ; if ( IS_ERR ( group ) ) { ret = PTR_ERR ( group ) ; goto out_free_uid ; } atomic_inc ( & user -> inotify_devs ) ; ret = anon_inode_getfd ( ""inotify"" , & inotify_fops , group , O_RDONLY | flags ) ; if ( ret >= 0 ) return ret ; <S2SV_StartBug> atomic_dec ( & user -> inotify_devs ) ; <S2SV_EndBug> out_free_uid : free_uid ( user ) ; return ret ; }",<S2SV_ModStart> return ret ; fsnotify_put_group ( group ) ;,torvalds@linux/a2ae4cc9a16e211c8a128ba10d22a85431f093ab,CVE-2010-4250,https://github.com/torvalds/linux/commit/a2ae4cc9a16e211c8a128ba10d22a85431f093ab,2012-06-21T23:55Z
CWE-362,"CWE-362 void ieee80211_sta_ps_deliver_wakeup ( struct sta_info * sta ) { struct ieee80211_sub_if_data * sdata = sta -> sdata ; struct ieee80211_local * local = sdata -> local ; struct sk_buff_head pending ; int filtered = 0 , buffered = 0 , ac ; unsigned long flags ; clear_sta_flag ( sta , WLAN_STA_SP ) ; BUILD_BUG_ON ( BITS_TO_LONGS ( IEEE80211_NUM_TIDS ) > 1 ) ; sta -> driver_buffered_tids = 0 ; if ( ! ( local -> hw . flags & IEEE80211_HW_AP_LINK_PS ) ) drv_sta_notify ( local , sdata , STA_NOTIFY_AWAKE , & sta -> sta ) ; skb_queue_head_init ( & pending ) ; <S2SV_StartBug> for ( ac = 0 ; ac < IEEE80211_NUM_ACS ; ac ++ ) { <S2SV_EndBug> int count = skb_queue_len ( & pending ) , tmp ; spin_lock_irqsave ( & sta -> tx_filtered [ ac ] . lock , flags ) ; skb_queue_splice_tail_init ( & sta -> tx_filtered [ ac ] , & pending ) ; spin_unlock_irqrestore ( & sta -> tx_filtered [ ac ] . lock , flags ) ; tmp = skb_queue_len ( & pending ) ; filtered += tmp - count ; count = tmp ; spin_lock_irqsave ( & sta -> ps_tx_buf [ ac ] . lock , flags ) ; skb_queue_splice_tail_init ( & sta -> ps_tx_buf [ ac ] , & pending ) ; spin_unlock_irqrestore ( & sta -> ps_tx_buf [ ac ] . lock , flags ) ; tmp = skb_queue_len ( & pending ) ; buffered += tmp - count ; } <S2SV_StartBug> ieee80211_add_pending_skbs_fn ( local , & pending , clear_sta_ps_flags , sta ) ; <S2SV_EndBug> if ( ! ieee80211_smps_is_restrictive ( sta -> known_smps_mode , sdata -> smps_mode ) && sta -> known_smps_mode != sdata -> bss -> req_smps && sta_info_tx_streams ( sta ) != 1 ) { ht_dbg ( sdata , ""%pM<S2SV_blank>just<S2SV_blank>woke<S2SV_blank>up<S2SV_blank>and<S2SV_blank>MIMO<S2SV_blank>capable<S2SV_blank>-<S2SV_blank>update<S2SV_blank>SMPS\\n"" , sta -> sta . addr ) ; ieee80211_send_smps_action ( sdata , sdata -> bss -> req_smps , sta -> sta . addr , sdata -> vif . bss_conf . bssid ) ; } local -> total_ps_buffered -= buffered ; sta_info_recalc_tim ( sta ) ; ps_dbg ( sdata , ""STA<S2SV_blank>%pM<S2SV_blank>aid<S2SV_blank>%d<S2SV_blank>sending<S2SV_blank>%d<S2SV_blank>filtered/%d<S2SV_blank>PS<S2SV_blank>frames<S2SV_blank>since<S2SV_blank>STA<S2SV_blank>not<S2SV_blank>sleeping<S2SV_blank>anymore\\n"" , sta -> sta . addr , sta -> sta . aid , filtered , buffered ) ; }","<S2SV_ModStart> pending ) ; spin_lock ( & sta -> ps_lock ) ; <S2SV_ModStart> clear_sta_ps_flags , sta ) ; spin_unlock ( & sta -> ps_lock",torvalds@linux/1d147bfa64293b2723c4fec50922168658e613ba,CVE-2014-2706,https://github.com/torvalds/linux/commit/1d147bfa64293b2723c4fec50922168658e613ba,2014-04-14T23:55Z
CWE-20,"CWE-20 void test_path_dotgit__dotgit_modules_symlink ( void ) { cl_assert_equal_b ( true , git_path_isvalid ( NULL , "".gitmodules"" , 0 , GIT_PATH_REJECT_DOT_GIT_HFS | GIT_PATH_REJECT_DOT_GIT_NTFS ) ) ; cl_assert_equal_b ( false , git_path_isvalid ( NULL , "".gitmodules"" , S_IFLNK , GIT_PATH_REJECT_DOT_GIT_HFS ) ) ; cl_assert_equal_b ( false , git_path_isvalid ( NULL , "".gitmodules"" , S_IFLNK , GIT_PATH_REJECT_DOT_GIT_NTFS ) ) ; <S2SV_StartBug> } <S2SV_EndBug>","<S2SV_ModStart> ) ) ; cl_assert_equal_b ( false , git_path_isvalid ( NULL , "".gitmodules<S2SV_blank>.<S2SV_blank>.::$DATA"" , S_IFLNK , GIT_PATH_REJECT_DOT_GIT_NTFS ) ) ;",libgit2@libgit2/e1832eb20a7089f6383cfce474f213157f5300cb,CVE-2020-12278,https://github.com/libgit2/libgit2/commit/e1832eb20a7089f6383cfce474f213157f5300cb,2020-04-27T17:15Z
CWE-125,"CWE-125 u_int chdlc_print ( netdissect_options * ndo , register const u_char * p , u_int length ) { u_int proto ; const u_char * bp = p ; if ( length < CHDLC_HDRLEN ) goto trunc ; ND_TCHECK2 ( * p , CHDLC_HDRLEN ) ; proto = EXTRACT_16BITS ( & p [ 2 ] ) ; if ( ndo -> ndo_eflag ) { ND_PRINT ( ( ndo , ""%s,<S2SV_blank>ethertype<S2SV_blank>%s<S2SV_blank>(0x%04x),<S2SV_blank>length<S2SV_blank>%u:<S2SV_blank>"" , tok2str ( chdlc_cast_values , ""0x%02x"" , p [ 0 ] ) , tok2str ( ethertype_values , ""Unknown"" , proto ) , proto , length ) ) ; } length -= CHDLC_HDRLEN ; p += CHDLC_HDRLEN ; switch ( proto ) { case ETHERTYPE_IP : ip_print ( ndo , p , length ) ; break ; case ETHERTYPE_IPV6 : ip6_print ( ndo , p , length ) ; break ; case CHDLC_TYPE_SLARP : chdlc_slarp_print ( ndo , p , length ) ; break ; # if 0 case CHDLC_TYPE_CDP : chdlc_cdp_print ( p , length ) ; break ; # endif case ETHERTYPE_MPLS : case ETHERTYPE_MPLS_MULTI : mpls_print ( ndo , p , length ) ; break ; case ETHERTYPE_ISO : if ( length < 2 ) goto trunc ; ND_TCHECK_16BITS ( p ) ; if ( * ( p + 1 ) == 0x81 || * ( p + 1 ) == 0x82 || * ( p + 1 ) == 0x83 ) <S2SV_StartBug> isoclns_print ( ndo , p + 1 , length - 1 , ndo -> ndo_snapend - p - 1 ) ; <S2SV_EndBug> else <S2SV_StartBug> isoclns_print ( ndo , p , length , ndo -> ndo_snapend - p ) ; <S2SV_EndBug> break ; default : if ( ! ndo -> ndo_eflag ) ND_PRINT ( ( ndo , ""unknown<S2SV_blank>CHDLC<S2SV_blank>protocol<S2SV_blank>(0x%04x)"" , proto ) ) ; break ; } return ( CHDLC_HDRLEN ) ; trunc : ND_PRINT ( ( ndo , ""[|chdlc]"" ) ) ; return ndo -> ndo_snapend - bp ; }","<S2SV_ModStart> length - 1 <S2SV_ModEnd> ) ; else <S2SV_ModStart> p , length <S2SV_ModEnd> ) ; break",the-tcpdump-group@tcpdump/1dcd10aceabbc03bf571ea32b892c522cbe923de,CVE-2017-12897,https://github.com/the-tcpdump-group/tcpdump/commit/1dcd10aceabbc03bf571ea32b892c522cbe923de,2017-09-14T06:29Z
CWE-119,"CWE-119 int vp8_get_preview_raw_frame ( VP8_COMP * cpi , YV12_BUFFER_CONFIG * dest , vp8_ppflags_t * flags ) { if ( cpi -> common . refresh_alt_ref_frame ) return - 1 ; else { int ret ; # if CONFIG_MULTITHREAD if ( cpi -> b_lpf_running ) { sem_wait ( & cpi -> h_event_end_lpf ) ; cpi -> b_lpf_running = 0 ; } # endif # if CONFIG_POSTPROC cpi -> common . show_frame_mi = cpi -> common . mi ; ret = vp8_post_proc_frame ( & cpi -> common , dest , flags ) ; # else <S2SV_StartBug> if ( cpi -> common . frame_to_show ) <S2SV_EndBug> { * dest = * cpi -> common . frame_to_show ; dest -> y_width = cpi -> common . Width ; dest -> y_height = cpi -> common . Height ; dest -> uv_height = cpi -> common . Height / 2 ; ret = 0 ; } else { ret = - 1 ; } # endif vp8_clear_system_state ( ) ; return ret ; } }",<S2SV_ModStart> ; # else ( void ) flags ;,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-200,"CWE-200 int vcc_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; struct atm_vcc * vcc ; struct sk_buff * skb ; <S2SV_StartBug> int copied , error = - EINVAL ; <S2SV_EndBug> if ( sock -> state != SS_CONNECTED ) return - ENOTCONN ; if ( flags & ~ ( MSG_DONTWAIT | MSG_PEEK ) ) return - EOPNOTSUPP ; vcc = ATM_SD ( sock ) ; if ( test_bit ( ATM_VF_RELEASED , & vcc -> flags ) || test_bit ( ATM_VF_CLOSE , & vcc -> flags ) || ! test_bit ( ATM_VF_READY , & vcc -> flags ) ) return 0 ; skb = skb_recv_datagram ( sk , flags , flags & MSG_DONTWAIT , & error ) ; if ( ! skb ) return error ; copied = skb -> len ; if ( copied > size ) { copied = size ; msg -> msg_flags |= MSG_TRUNC ; } error = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( error ) return error ; sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( ! ( flags & MSG_PEEK ) ) { pr_debug ( ""%d<S2SV_blank>-=<S2SV_blank>%d\\n"" , atomic_read ( & sk -> sk_rmem_alloc ) , skb -> truesize ) ; atm_return ( vcc , skb -> truesize ) ; } skb_free_datagram ( sk , skb ) ; return copied ; }",<S2SV_ModStart> = - EINVAL ; msg -> msg_namelen = 0,torvalds@linux/9b3e617f3df53822345a8573b6d358f6b9e5ed87,CVE-2013-3222,https://github.com/torvalds/linux/commit/9b3e617f3df53822345a8573b6d358f6b9e5ed87,2013-04-22T11:41Z
CWE-119,"CWE-119 void vp9_loop_filter_frame_init ( VP9_COMMON * cm , int default_filt_lvl ) { int seg_id ; const int scale = 1 << ( default_filt_lvl >> 5 ) ; loop_filter_info_n * const lfi = & cm -> lf_info ; struct loopfilter * const lf = & cm -> lf ; const struct segmentation * const seg = & cm -> seg ; if ( lf -> last_sharpness_level != lf -> sharpness_level ) { update_sharpness ( lfi , lf -> sharpness_level ) ; lf -> last_sharpness_level = lf -> sharpness_level ; } for ( seg_id = 0 ; seg_id < MAX_SEGMENTS ; seg_id ++ ) { int lvl_seg = default_filt_lvl ; <S2SV_StartBug> if ( vp9_segfeature_active ( seg , seg_id , SEG_LVL_ALT_LF ) ) { <S2SV_EndBug> <S2SV_StartBug> const int data = vp9_get_segdata ( seg , seg_id , SEG_LVL_ALT_LF ) ; <S2SV_EndBug> lvl_seg = clamp ( seg -> abs_delta == SEGMENT_ABSDATA ? data : default_filt_lvl + data , 0 , MAX_LOOP_FILTER ) ; } if ( ! lf -> mode_ref_delta_enabled ) { <S2SV_StartBug> vpx_memset ( lfi -> lvl [ seg_id ] , lvl_seg , sizeof ( lfi -> lvl [ seg_id ] ) ) ; <S2SV_EndBug> } else { int ref , mode ; const int intra_lvl = lvl_seg + lf -> ref_deltas [ INTRA_FRAME ] * scale ; lfi -> lvl [ seg_id ] [ INTRA_FRAME ] [ 0 ] = clamp ( intra_lvl , 0 , MAX_LOOP_FILTER ) ; for ( ref = LAST_FRAME ; ref < MAX_REF_FRAMES ; ++ ref ) { for ( mode = 0 ; mode < MAX_MODE_LF_DELTAS ; ++ mode ) { const int inter_lvl = lvl_seg + lf -> ref_deltas [ ref ] * scale + lf -> mode_deltas [ mode ] * scale ; lfi -> lvl [ seg_id ] [ ref ] [ mode ] = clamp ( inter_lvl , 0 , MAX_LOOP_FILTER ) ; } } } } }","<S2SV_ModStart> ; if ( segfeature_active <S2SV_ModEnd> ( seg , <S2SV_ModStart> int data = get_segdata <S2SV_ModEnd> ( seg , <S2SV_ModStart> mode_ref_delta_enabled ) { memset <S2SV_ModEnd> ( lfi ->",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-125,"CWE-125 static int dhcpv6_print ( netdissect_options * ndo , const u_char * cp , u_int length , int indent ) { u_int i , t ; const u_char * tlv , * value ; uint16_t type , optlen ; i = 0 ; while ( i < length ) { <S2SV_StartBug> tlv = cp + i ; <S2SV_EndBug> type = EXTRACT_16BITS ( tlv ) ; optlen = EXTRACT_16BITS ( tlv + 2 ) ; value = tlv + 4 ; ND_PRINT ( ( ndo , ""\\n"" ) ) ; for ( t = indent ; t > 0 ; t -- ) ND_PRINT ( ( ndo , ""\\t"" ) ) ; ND_PRINT ( ( ndo , ""%s"" , tok2str ( dh6opt_str , ""Unknown"" , type ) ) ) ; <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>(%u)"" , optlen + 4 ) ) ; <S2SV_EndBug> switch ( type ) { case DH6OPT_DNS_SERVERS : case DH6OPT_SNTP_SERVERS : { if ( optlen % 16 != 0 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , istr ) ) ; return - 1 ; } for ( t = 0 ; t < optlen ; t += 16 ) ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , ip6addr_string ( ndo , value + t ) ) ) ; } break ; case DH6OPT_DOMAIN_LIST : { const u_char * tp = value ; while ( tp < value + optlen ) { ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ; if ( ( tp = ns_nprint ( ndo , tp , value + optlen ) ) == NULL ) return - 1 ; } } break ; } i += 4 + optlen ; } return 0 ; }",<S2SV_ModStart> length ) { if ( i + 4 > length ) return - 1 ; <S2SV_ModStart> 4 ) ) ; if ( i + 4 + optlen > length ) return - 1,the-tcpdump-group@tcpdump/39582c04cc5e34054b2936b423072fb9df2ff6ef,CVE-2017-13042,https://github.com/the-tcpdump-group/tcpdump/commit/39582c04cc5e34054b2936b423072fb9df2ff6ef,2017-09-14T06:29Z
CWE-362,"CWE-362 int install_user_keyrings ( void ) { struct user_struct * user ; const struct cred * cred ; struct key * uid_keyring , * session_keyring ; key_perm_t user_keyring_perm ; char buf [ 20 ] ; int ret ; uid_t uid ; user_keyring_perm = ( KEY_POS_ALL & ~ KEY_POS_SETATTR ) | KEY_USR_ALL ; cred = current_cred ( ) ; user = cred -> user ; uid = from_kuid ( cred -> user_ns , user -> uid ) ; kenter ( ""%p{%u}"" , user , uid ) ; <S2SV_StartBug> if ( user -> uid_keyring ) { <S2SV_EndBug> kleave ( ""<S2SV_blank>=<S2SV_blank>0<S2SV_blank>[exist]"" ) ; return 0 ; } mutex_lock ( & key_user_keyring_mutex ) ; ret = 0 ; if ( ! user -> uid_keyring ) { sprintf ( buf , ""_uid.%u"" , uid ) ; uid_keyring = find_keyring_by_name ( buf , true ) ; if ( IS_ERR ( uid_keyring ) ) { uid_keyring = keyring_alloc ( buf , user -> uid , INVALID_GID , cred , user_keyring_perm , KEY_ALLOC_IN_QUOTA , NULL ) ; if ( IS_ERR ( uid_keyring ) ) { ret = PTR_ERR ( uid_keyring ) ; goto error ; } } sprintf ( buf , ""_uid_ses.%u"" , uid ) ; session_keyring = find_keyring_by_name ( buf , true ) ; if ( IS_ERR ( session_keyring ) ) { session_keyring = keyring_alloc ( buf , user -> uid , INVALID_GID , cred , user_keyring_perm , KEY_ALLOC_IN_QUOTA , NULL ) ; if ( IS_ERR ( session_keyring ) ) { ret = PTR_ERR ( session_keyring ) ; goto error_release ; } ret = key_link ( session_keyring , uid_keyring ) ; if ( ret < 0 ) goto error_release_both ; } user -> uid_keyring = uid_keyring ; user -> session_keyring = session_keyring ; } mutex_unlock ( & key_user_keyring_mutex ) ; kleave ( ""<S2SV_blank>=<S2SV_blank>0"" ) ; return 0 ; error_release_both : key_put ( session_keyring ) ; error_release : key_put ( uid_keyring ) ; error : mutex_unlock ( & key_user_keyring_mutex ) ; kleave ( ""<S2SV_blank>=<S2SV_blank>%d"" , ret ) ; return ret ; }",<S2SV_ModStart> user -> uid_keyring && user -> session_keyring,torvalds@linux/0da9dfdd2cd9889201bc6f6f43580c99165cd087,CVE-2013-1792,https://github.com/torvalds/linux/commit/0da9dfdd2cd9889201bc6f6f43580c99165cd087,2013-03-22T11:59Z
CWE-200,"CWE-200 int vmw_gb_surface_define_ioctl ( struct drm_device * dev , void * data , struct drm_file * file_priv ) { struct vmw_private * dev_priv = vmw_priv ( dev ) ; struct vmw_user_surface * user_srf ; struct vmw_surface * srf ; struct vmw_resource * res ; struct vmw_resource * tmp ; union drm_vmw_gb_surface_create_arg * arg = ( union drm_vmw_gb_surface_create_arg * ) data ; struct drm_vmw_gb_surface_create_req * req = & arg -> req ; struct drm_vmw_gb_surface_create_rep * rep = & arg -> rep ; struct ttm_object_file * tfile = vmw_fpriv ( file_priv ) -> tfile ; int ret ; uint32_t size ; <S2SV_StartBug> uint32_t backup_handle ; <S2SV_EndBug> if ( req -> multisample_count != 0 ) return - EINVAL ; if ( req -> mip_levels > DRM_VMW_MAX_MIP_LEVELS ) return - EINVAL ; if ( unlikely ( vmw_user_surface_size == 0 ) ) vmw_user_surface_size = ttm_round_pot ( sizeof ( * user_srf ) ) + 128 ; size = vmw_user_surface_size + 128 ; ret = vmw_surface_gb_priv_define ( dev , size , req -> svga3d_flags , req -> format , req -> drm_surface_flags & drm_vmw_surface_flag_scanout , req -> mip_levels , req -> multisample_count , req -> array_size , req -> base_size , & srf ) ; if ( unlikely ( ret != 0 ) ) return ret ; user_srf = container_of ( srf , struct vmw_user_surface , srf ) ; if ( drm_is_primary_client ( file_priv ) ) user_srf -> master = drm_master_get ( file_priv -> master ) ; ret = ttm_read_lock ( & dev_priv -> reservation_sem , true ) ; if ( unlikely ( ret != 0 ) ) return ret ; res = & user_srf -> srf . res ; if ( req -> buffer_handle != SVGA3D_INVALID_ID ) { ret = vmw_user_dmabuf_lookup ( tfile , req -> buffer_handle , & res -> backup , & user_srf -> backup_base ) ; <S2SV_StartBug> if ( ret == 0 && res -> backup -> base . num_pages * PAGE_SIZE < <S2SV_EndBug> res -> backup_size ) { DRM_ERROR ( ""Surface<S2SV_blank>backup<S2SV_blank>buffer<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small.\\n"" ) ; vmw_dmabuf_unreference ( & res -> backup ) ; ret = - EINVAL ; <S2SV_StartBug> goto out_unlock ; <S2SV_EndBug> } } else if ( req -> drm_surface_flags & drm_vmw_surface_flag_create_buffer ) ret = vmw_user_dmabuf_alloc ( dev_priv , tfile , res -> backup_size , req -> drm_surface_flags & drm_vmw_surface_flag_shareable , & backup_handle , & res -> backup , & user_srf -> backup_base ) ; if ( unlikely ( ret != 0 ) ) { vmw_resource_unreference ( & res ) ; goto out_unlock ; } tmp = vmw_resource_reference ( res ) ; ret = ttm_prime_object_init ( tfile , res -> backup_size , & user_srf -> prime , req -> drm_surface_flags & drm_vmw_surface_flag_shareable , VMW_RES_SURFACE , & vmw_user_surface_base_release , NULL ) ; if ( unlikely ( ret != 0 ) ) { vmw_resource_unreference ( & tmp ) ; vmw_resource_unreference ( & res ) ; goto out_unlock ; } rep -> handle = user_srf -> prime . base . hash . key ; rep -> backup_size = res -> backup_size ; if ( res -> backup ) { rep -> buffer_map_handle = drm_vma_node_offset_addr ( & res -> backup -> base . vma_node ) ; rep -> buffer_size = res -> backup -> base . num_pages * PAGE_SIZE ; rep -> buffer_handle = backup_handle ; } else { rep -> buffer_map_handle = 0 ; rep -> buffer_size = 0 ; rep -> buffer_handle = SVGA3D_INVALID_ID ; } vmw_resource_unreference ( & res ) ; out_unlock : ttm_read_unlock ( & dev_priv -> reservation_sem ) ; return ret ; }",<S2SV_ModStart> ; uint32_t backup_handle = 0 <S2SV_ModStart> ret == 0 ) { if ( <S2SV_ModEnd> res -> backup <S2SV_ModStart> goto out_unlock ; } else { backup_handle = req -> buffer_handle ; },torvalds@linux/07678eca2cf9c9a18584e546c2b2a0d0c9a3150c,CVE-2017-9605,https://github.com/torvalds/linux/commit/07678eca2cf9c9a18584e546c2b2a0d0c9a3150c,2017-06-13T19:29Z
CWE-119,"CWE-119 int read_yuv_frame ( struct VpxInputContext * input_ctx , vpx_image_t * yuv_frame ) { FILE * f = input_ctx -> file ; struct FileTypeDetectionBuffer * detect = & input_ctx -> detect ; int plane = 0 ; int shortread = 0 ; <S2SV_StartBug> for ( plane = 0 ; plane < 3 ; ++ plane ) { <S2SV_EndBug> uint8_t * ptr ; <S2SV_StartBug> const int w = ( plane ? ( 1 + yuv_frame -> d_w ) / 2 : yuv_frame -> d_w ) ; <S2SV_EndBug> <S2SV_StartBug> const int h = ( plane ? ( 1 + yuv_frame -> d_h ) / 2 : yuv_frame -> d_h ) ; <S2SV_EndBug> int r ; switch ( plane ) { case 1 : ptr = yuv_frame -> planes [ yuv_frame -> fmt == VPX_IMG_FMT_YV12 ? VPX_PLANE_V : VPX_PLANE_U ] ; break ; case 2 : ptr = yuv_frame -> planes [ yuv_frame -> fmt == VPX_IMG_FMT_YV12 ? VPX_PLANE_U : VPX_PLANE_V ] ; break ; default : ptr = yuv_frame -> planes [ plane ] ; } for ( r = 0 ; r < h ; ++ r ) { <S2SV_StartBug> size_t needed = w ; <S2SV_EndBug> size_t buf_position = 0 ; const size_t left = detect -> buf_read - detect -> position ; if ( left > 0 ) { const size_t more = ( left < needed ) ? left : needed ; memcpy ( ptr , detect -> buf + detect -> position , more ) ; buf_position = more ; needed -= more ; detect -> position += more ; } if ( needed > 0 ) { shortread |= ( fread ( ptr + buf_position , 1 , needed , f ) < needed ) ; } ptr += yuv_frame -> stride [ plane ] ; } } return shortread ; }","<S2SV_ModStart> = 0 ; const int bytespp = ( yuv_frame -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ? 2 : 1 ; <S2SV_ModStart> int w = vpx_img_plane_width ( yuv_frame , plane <S2SV_ModEnd> ) ; const <S2SV_ModStart> int h = vpx_img_plane_height ( yuv_frame , plane <S2SV_ModEnd> ) ; int <S2SV_ModStart> needed = w * bytespp",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-835,"CWE-000 static long madvise_willneed ( struct vm_area_struct * vma , struct vm_area_struct * * prev , unsigned long start , unsigned long end ) { struct file * file = vma -> vm_file ; <S2SV_StartBug> # ifdef CONFIG_SWAP <S2SV_EndBug> if ( ! file ) { <S2SV_StartBug> * prev = vma ; <S2SV_EndBug> force_swapin_readahead ( vma , start , end ) ; return 0 ; } if ( shmem_mapping ( file -> f_mapping ) ) { <S2SV_StartBug> * prev = vma ; <S2SV_EndBug> force_shm_swapin_readahead ( vma , start , end , file -> f_mapping ) ; return 0 ; } # else if ( ! file ) return - EBADF ; # endif if ( IS_DAX ( file_inode ( file ) ) ) { return 0 ; } <S2SV_StartBug> * prev = vma ; <S2SV_EndBug> start = ( ( start - vma -> vm_start ) >> PAGE_SHIFT ) + vma -> vm_pgoff ; if ( end > vma -> vm_end ) end = vma -> vm_end ; end = ( ( end - vma -> vm_start ) >> PAGE_SHIFT ) + vma -> vm_pgoff ; force_page_cache_readahead ( file -> f_mapping , file , start , end - start ) ; return 0 ; }",<S2SV_ModStart> -> vm_file ; * prev = vma ; <S2SV_ModStart> file ) { <S2SV_ModEnd> force_swapin_readahead ( vma <S2SV_ModStart> ) ) { <S2SV_ModEnd> force_shm_swapin_readahead ( vma <S2SV_ModStart> 0 ; } <S2SV_ModEnd> start = (,torvalds@linux/6ea8d958a2c95a1d514015d4e29ba21a8c0a1a91,CVE-2017-18208,https://github.com/torvalds/linux/commit/6ea8d958a2c95a1d514015d4e29ba21a8c0a1a91,2018-03-01T05:29Z
CWE-19,"CWE-000 STATIC int xfs_attr_calc_size ( struct xfs_inode * ip , int namelen , int valuelen , int * local ) { struct xfs_mount * mp = ip -> i_mount ; int size ; int nblks ; size = xfs_attr_leaf_newentsize ( namelen , valuelen , mp -> m_sb . sb_blocksize , local ) ; nblks = XFS_DAENTER_SPACE_RES ( mp , XFS_ATTR_FORK ) ; if ( * local ) { if ( size > ( mp -> m_sb . sb_blocksize >> 1 ) ) { nblks *= 2 ; } } else { <S2SV_StartBug> uint dblocks = XFS_B_TO_FSB ( mp , valuelen ) ; <S2SV_EndBug> nblks += dblocks ; nblks += XFS_NEXTENTADD_SPACE_RES ( mp , dblocks , XFS_ATTR_FORK ) ; } return nblks ; }","<S2SV_ModStart> uint dblocks = xfs_attr3_rmt_blocks <S2SV_ModEnd> ( mp ,",torvalds@linux/8275cdd0e7ac550dcce2b3ef6d2fb3b808c1ae59,CVE-2015-0274,https://github.com/torvalds/linux/commit/8275cdd0e7ac550dcce2b3ef6d2fb3b808c1ae59,2015-03-16T10:59Z
CWE-200,"CWE-200 static int raptor_rdfxml_parse_start ( raptor_parser * rdf_parser ) { raptor_uri * uri = rdf_parser -> base_uri ; raptor_rdfxml_parser * rdf_xml_parser ; rdf_xml_parser = ( raptor_rdfxml_parser * ) rdf_parser -> context ; if ( ! uri ) return 1 ; raptor_sax2_set_option ( rdf_xml_parser -> sax2 , RAPTOR_OPTION_NORMALIZE_LANGUAGE , NULL , RAPTOR_OPTIONS_GET_NUMERIC ( rdf_parser , RAPTOR_OPTION_NORMALIZE_LANGUAGE ) ) ; raptor_sax2_set_option ( rdf_xml_parser -> sax2 , RAPTOR_OPTION_NO_NET , NULL , RAPTOR_OPTIONS_GET_NUMERIC ( rdf_parser , RAPTOR_OPTION_NO_NET ) ) ; raptor_sax2_set_option ( rdf_xml_parser -> sax2 , RAPTOR_OPTION_NO_FILE , NULL , RAPTOR_OPTIONS_GET_NUMERIC ( rdf_parser , RAPTOR_OPTION_NO_FILE ) ) ; <S2SV_StartBug> if ( rdf_parser -> uri_filter ) <S2SV_EndBug> raptor_sax2_set_uri_filter ( rdf_xml_parser -> sax2 , rdf_parser -> uri_filter , rdf_parser -> uri_filter_user_data ) ; raptor_sax2_parse_start ( rdf_xml_parser -> sax2 , uri ) ; if ( rdf_xml_parser -> id_set ) { raptor_free_id_set ( rdf_xml_parser -> id_set ) ; rdf_xml_parser -> id_set = NULL ; } if ( RAPTOR_OPTIONS_GET_NUMERIC ( rdf_parser , RAPTOR_OPTION_CHECK_RDF_ID ) ) { rdf_xml_parser -> id_set = raptor_new_id_set ( rdf_parser -> world ) ; if ( ! rdf_xml_parser -> id_set ) return 1 ; } return 0 ; }","<S2SV_ModStart> ) ) ; raptor_sax2_set_option ( rdf_xml_parser -> sax2 , RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES , NULL , RAPTOR_OPTIONS_GET_NUMERIC ( rdf_parser , RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES ) ) ;",dajobe@raptor/a676f235309a59d4aa78eeffd2574ae5d341fcb0,CVE-2012-0037,https://github.com/dajobe/raptor/commit/a676f235309a59d4aa78eeffd2574ae5d341fcb0,2012-06-17T03:41Z
CWE-476,"CWE-476 static int parse_report ( transport_smart * transport , git_push * push ) { git_pkt * pkt = NULL ; const char * line_end = NULL ; gitno_buffer * buf = & transport -> buffer ; int error , recvd ; git_buf data_pkt_buf = GIT_BUF_INIT ; for ( ; ; ) { if ( buf -> offset > 0 ) error = git_pkt_parse_line ( & pkt , buf -> data , & line_end , buf -> offset ) ; else error = GIT_EBUFS ; if ( error < 0 && error != GIT_EBUFS ) { error = - 1 ; goto done ; } if ( error == GIT_EBUFS ) { if ( ( recvd = gitno_recv ( buf ) ) < 0 ) { error = recvd ; goto done ; } if ( recvd == 0 ) { giterr_set ( GITERR_NET , ""early<S2SV_blank>EOF"" ) ; error = GIT_EEOF ; goto done ; } continue ; } gitno_consume ( buf , line_end ) ; <S2SV_StartBug> error = 0 ; <S2SV_EndBug> if ( pkt == NULL ) continue ; switch ( pkt -> type ) { case GIT_PKT_DATA : error = add_push_report_sideband_pkt ( push , ( git_pkt_data * ) pkt , & data_pkt_buf ) ; break ; case GIT_PKT_ERR : giterr_set ( GITERR_NET , ""report-status:<S2SV_blank>Error<S2SV_blank>reported:<S2SV_blank>%s"" , ( ( git_pkt_err * ) pkt ) -> error ) ; error = - 1 ; break ; case GIT_PKT_PROGRESS : if ( transport -> progress_cb ) { git_pkt_progress * p = ( git_pkt_progress * ) pkt ; error = transport -> progress_cb ( p -> data , p -> len , transport -> message_cb_payload ) ; } break ; default : error = add_push_report_pkt ( push , pkt ) ; break ; } git_pkt_free ( pkt ) ; if ( error == GIT_ITEROVER ) { error = 0 ; if ( data_pkt_buf . size > 0 ) { giterr_set ( GITERR_NET , ""Incomplete<S2SV_blank>pack<S2SV_blank>data<S2SV_blank>pkt-line"" ) ; error = GIT_ERROR ; } goto done ; } if ( error < 0 ) { goto done ; } } done : git_buf_free ( & data_pkt_buf ) ; return error ; }",<S2SV_ModStart> error = 0 <S2SV_ModEnd> ; switch (,libgit2@libgit2/2fdef641fd0dd2828bd948234ae86de75221a11a,CVE-2016-10129,https://github.com/libgit2/libgit2/commit/2fdef641fd0dd2828bd948234ae86de75221a11a,2017-03-24T15:59Z
,"CWE-000 static void sas_revalidate_domain ( struct work_struct * work ) { int res = 0 ; struct sas_discovery_event * ev = to_sas_discovery_event ( work ) ; struct asd_sas_port * port = ev -> port ; struct sas_ha_struct * ha = port -> ha ; struct domain_device * ddev = port -> port_dev ; mutex_lock ( & ha -> disco_mutex ) ; if ( test_bit ( SAS_HA_ATA_EH_ACTIVE , & ha -> state ) ) { SAS_DPRINTK ( ""REVALIDATION<S2SV_blank>DEFERRED<S2SV_blank>on<S2SV_blank>port<S2SV_blank>%d,<S2SV_blank>pid:%d\\n"" , port -> id , task_pid_nr ( current ) ) ; goto out ; } clear_bit ( DISCE_REVALIDATE_DOMAIN , & port -> disc . pending ) ; SAS_DPRINTK ( ""REVALIDATING<S2SV_blank>DOMAIN<S2SV_blank>on<S2SV_blank>port<S2SV_blank>%d,<S2SV_blank>pid:%d\\n"" , port -> id , task_pid_nr ( current ) ) ; if ( ddev && ( ddev -> dev_type == SAS_FANOUT_EXPANDER_DEVICE || ddev -> dev_type == SAS_EDGE_EXPANDER_DEVICE ) ) res = sas_ex_revalidate_domain ( ddev ) ; SAS_DPRINTK ( ""done<S2SV_blank>REVALIDATING<S2SV_blank>DOMAIN<S2SV_blank>on<S2SV_blank>port<S2SV_blank>%d,<S2SV_blank>pid:%d,<S2SV_blank>res<S2SV_blank>0x%x\\n"" , port -> id , task_pid_nr ( current ) , res ) ; out : mutex_unlock ( & ha -> disco_mutex ) ; <S2SV_StartBug> } <S2SV_EndBug>",<S2SV_ModStart> disco_mutex ) ; sas_destruct_devices ( port ) ; sas_destruct_ports ( port ) ; sas_probe_devices ( port ) ;,torvalds@linux/0558f33c06bb910e2879e355192227a8e8f0219d,CVE-2017-18232,https://github.com/torvalds/linux/commit/0558f33c06bb910e2879e355192227a8e8f0219d,2018-03-15T04:29Z
CWE-476,"CWE-476 bool ExprResolveLhs ( struct xkb_context * ctx , const ExprDef * expr , const char * * elem_rtrn , const char * * field_rtrn , ExprDef * * index_rtrn ) { switch ( expr -> expr . op ) { case EXPR_IDENT : * elem_rtrn = NULL ; * field_rtrn = xkb_atom_text ( ctx , expr -> ident . ident ) ; * index_rtrn = NULL ; return ( * field_rtrn != NULL ) ; case EXPR_FIELD_REF : * elem_rtrn = xkb_atom_text ( ctx , expr -> field_ref . element ) ; * field_rtrn = xkb_atom_text ( ctx , expr -> field_ref . field ) ; * index_rtrn = NULL ; <S2SV_StartBug> return true ; <S2SV_EndBug> case EXPR_ARRAY_REF : * elem_rtrn = xkb_atom_text ( ctx , expr -> array_ref . element ) ; * field_rtrn = xkb_atom_text ( ctx , expr -> array_ref . field ) ; * index_rtrn = expr -> array_ref . entry ; <S2SV_StartBug> return true ; <S2SV_EndBug> default : break ; } log_wsgo ( ctx , ""Unexpected<S2SV_blank>operator<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>ResolveLhs\\n"" , expr -> expr . op ) ; return false ; }",<S2SV_ModStart> NULL ; return ( * elem_rtrn != NULL && * field_rtrn != NULL ) <S2SV_ModEnd> ; case EXPR_ARRAY_REF <S2SV_ModStart> . entry ; if ( expr -> array_ref . element != XKB_ATOM_NONE && * elem_rtrn == NULL ) return false ; if ( * field_rtrn == NULL ) return false ;,xkbcommon@libxkbcommon/bb4909d2d8fa6b08155e449986a478101e2b2634,CVE-2018-15859,https://github.com/xkbcommon/libxkbcommon/commit/bb4909d2d8fa6b08155e449986a478101e2b2634,2018-08-25T21:29Z
CWE-189,"CWE-189 Datum poly_in ( PG_FUNCTION_ARGS ) { char * str = PG_GETARG_CSTRING ( 0 ) ; POLYGON * poly ; int npts ; int size ; <S2SV_StartBug> int isopen ; <S2SV_EndBug> char * s ; if ( ( npts = pair_count ( str , ',' ) ) <= 0 ) ereport ( ERROR , ( errcode ( ERRCODE_INVALID_TEXT_REPRESENTATION ) , errmsg ( ""invalid<S2SV_blank>input<S2SV_blank>syntax<S2SV_blank>for<S2SV_blank>type<S2SV_blank>polygon:<S2SV_blank>\\""%s\\"""" , str ) ) ) ; <S2SV_StartBug> size = offsetof ( POLYGON , p [ 0 ] ) + sizeof ( poly -> p [ 0 ] ) * npts ; <S2SV_EndBug> poly = ( POLYGON * ) palloc0 ( size ) ; SET_VARSIZE ( poly , size ) ; poly -> npts = npts ; if ( ( ! path_decode ( FALSE , npts , str , & isopen , & s , & ( poly -> p [ 0 ] ) ) ) || ( * s != '\\0' ) ) ereport ( ERROR , ( errcode ( ERRCODE_INVALID_TEXT_REPRESENTATION ) , errmsg ( ""invalid<S2SV_blank>input<S2SV_blank>syntax<S2SV_blank>for<S2SV_blank>type<S2SV_blank>polygon:<S2SV_blank>\\""%s\\"""" , str ) ) ) ; make_bound_box ( poly ) ; PG_RETURN_POLYGON_P ( poly ) ; }","<S2SV_ModStart> size ; int base_size ; int <S2SV_ModStart> ) ) ; base_size = sizeof ( poly -> p [ 0 ] ) * npts ; <S2SV_ModStart> ] ) + base_size ; if ( base_size / npts != <S2SV_ModStart> 0 ] ) || size <= base_size ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""too<S2SV_blank>many<S2SV_blank>points<S2SV_blank>requested"" ) ) ) <S2SV_ModEnd> ; poly =",postgres@postgres/31400a673325147e1205326008e32135a78b4d8a,CVE-2014-0064,https://github.com/postgres/postgres/commit/31400a673325147e1205326008e32135a78b4d8a,2014-03-31T14:58Z
CWE-119,"CWE-119 static int get_prediction_error ( BLOCK * be , BLOCKD * b ) { unsigned char * sptr ; unsigned char * dptr ; sptr = ( * ( be -> base_src ) + be -> src ) ; dptr = b -> predictor ; <S2SV_StartBug> return vp8_get4x4sse_cs ( sptr , be -> src_stride , dptr , 16 ) ; <S2SV_EndBug> }","<S2SV_ModStart> predictor ; return vpx_get4x4sse_cs <S2SV_ModEnd> ( sptr ,",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-119,"CWE-119 static Image * ReadFAXImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; MagickBooleanType status ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image -> storage_class = PseudoClass ; if ( image -> columns == 0 ) image -> columns = 2592 ; if ( image -> rows == 0 ) image -> rows = 3508 ; image -> depth = 8 ; if ( AcquireImageColormap ( image , 2 ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; image -> colormap [ 0 ] . red = QuantumRange ; image -> colormap [ 0 ] . green = QuantumRange ; image -> colormap [ 0 ] . blue = QuantumRange ; image -> colormap [ 1 ] . red = ( Quantum ) 0 ; image -> colormap [ 1 ] . green = ( Quantum ) 0 ; image -> colormap [ 1 ] . blue = ( Quantum ) 0 ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } <S2SV_StartBug> status = HuffmanDecodeImage ( image ) ; <S2SV_EndBug> if ( status == MagickFalse ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }","<S2SV_ModStart> } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } status =",ImageMagick@ImageMagick/f6e9d0d9955e85bdd7540b251cd50d598dacc5e6,CVE-2016-10066,https://github.com/ImageMagick/ImageMagick/commit/f6e9d0d9955e85bdd7540b251cd50d598dacc5e6,2017-03-03T17:59Z
CWE-285,"CWE-000 static int v9fs_xattr_set_acl ( const struct xattr_handler * handler , struct dentry * dentry , struct inode * inode , const char * name , const void * value , size_t size , int flags ) { int retval ; struct posix_acl * acl ; struct v9fs_session_info * v9ses ; v9ses = v9fs_dentry2v9ses ( dentry ) ; if ( ( v9ses -> flags & V9FS_ACCESS_MASK ) != V9FS_ACCESS_CLIENT ) return v9fs_xattr_set ( dentry , handler -> name , value , size , flags ) ; if ( S_ISLNK ( inode -> i_mode ) ) return - EOPNOTSUPP ; if ( ! inode_owner_or_capable ( inode ) ) return - EPERM ; if ( value ) { acl = posix_acl_from_xattr ( & init_user_ns , value , size ) ; if ( IS_ERR ( acl ) ) return PTR_ERR ( acl ) ; else if ( acl ) { retval = posix_acl_valid ( inode -> i_sb -> s_user_ns , acl ) ; if ( retval ) goto err_out ; } } else acl = NULL ; switch ( handler -> flags ) { case ACL_TYPE_ACCESS : if ( acl ) { <S2SV_StartBug> umode_t mode = inode -> i_mode ; <S2SV_EndBug> retval = posix_acl_equiv_mode ( acl , & mode ) ; if ( retval < 0 ) goto err_out ; <S2SV_StartBug> else { <S2SV_EndBug> struct iattr iattr ; if ( retval == 0 ) { acl = NULL ; value = NULL ; size = 0 ; } iattr . ia_mode = ( ( mode & S_IALLUGO ) | ( inode -> i_mode & ~ S_IALLUGO ) ) ; iattr . ia_valid = ATTR_MODE ; v9fs_vfs_setattr_dotl ( dentry , & iattr ) ; <S2SV_StartBug> } <S2SV_EndBug> } break ; case ACL_TYPE_DEFAULT : if ( ! S_ISDIR ( inode -> i_mode ) ) { retval = acl ? - EINVAL : 0 ; goto err_out ; } break ; default : BUG ( ) ; } retval = v9fs_xattr_set ( dentry , handler -> name , value , size , flags ) ; if ( ! retval ) set_cached_acl ( inode , handler -> flags , acl ) ; err_out : posix_acl_release ( acl ) ; return retval ; }","<S2SV_ModStart> acl ) { struct iattr iattr ; retval = posix_acl_update_mode ( inode , & iattr . ia_mode , & acl ) ; if ( retval <S2SV_ModEnd> ) goto err_out <S2SV_ModStart> goto err_out ; if ( ! acl ) { value = NULL ; size = 0 ; } <S2SV_ModEnd> iattr . ia_valid <S2SV_ModStart> iattr ) ; <S2SV_ModEnd> } break ;",torvalds@linux/073931017b49d9458aa351605b43a7e34598caef,CVE-2016-7097,https://github.com/torvalds/linux/commit/073931017b49d9458aa351605b43a7e34598caef,2016-10-16T21:59Z
CWE-125,"CWE-125 static int init_normalization ( struct compiling * c ) { PyObject * m = PyImport_ImportModuleNoBlock ( ""unicodedata"" ) ; if ( ! m ) return 0 ; c -> c_normalize = PyObject_GetAttrString ( m , ""normalize"" ) ; Py_DECREF ( m ) ; if ( ! c -> c_normalize ) return 0 ; <S2SV_StartBug> c -> c_normalize_args = Py_BuildValue ( ""(sN)"" , ""NFKC"" , Py_None ) ; <S2SV_EndBug> if ( ! c -> c_normalize_args ) { Py_CLEAR ( c -> c_normalize ) ; return 0 ; } PyTuple_SET_ITEM ( c -> c_normalize_args , 1 , NULL ) ; return 1 ; }",<S2SV_ModStart> return 0 ; <S2SV_ModEnd> return 1 ;,python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z
,"CWE-000 void ff_jpeg2000_cleanup ( Jpeg2000Component * comp , Jpeg2000CodingStyle * codsty ) { int reslevelno , bandno , precno ; for ( reslevelno = 0 ; comp -> reslevel && reslevelno < codsty -> nreslevels ; reslevelno ++ ) { Jpeg2000ResLevel * reslevel = comp -> reslevel + reslevelno ; for ( bandno = 0 ; bandno < reslevel -> nbands ; bandno ++ ) { Jpeg2000Band * band = reslevel -> band + bandno ; for ( precno = 0 ; precno < reslevel -> num_precincts_x * reslevel -> num_precincts_y ; precno ++ ) { <S2SV_StartBug> Jpeg2000Prec * prec = band -> prec + precno ; <S2SV_EndBug> av_freep ( & prec -> zerobits ) ; av_freep ( & prec -> cblkincl ) ; av_freep ( & prec -> cblk ) ; } <S2SV_StartBug> av_freep ( & band -> prec ) ; <S2SV_EndBug> } av_freep ( & reslevel -> band ) ; } ff_dwt_destroy ( & comp -> dwt ) ; av_freep ( & comp -> reslevel ) ; av_freep ( & comp -> i_data ) ; av_freep ( & comp -> f_data ) ; }",<S2SV_ModStart> ++ ) { if ( band -> prec ) { <S2SV_ModStart> ) ; } },FFmpeg@FFmpeg/912ce9dd2080c5837285a471d750fa311e09b555,CVE-2013-7017,https://github.com/FFmpeg/FFmpeg/commit/912ce9dd2080c5837285a471d750fa311e09b555,2013-12-09T16:36Z
CWE-189,"CWE-189 static void findoprnd ( ITEM * ptr , int32 * pos ) <S2SV_StartBug> { <S2SV_EndBug> if ( ptr [ * pos ] . type == VAL || ptr [ * pos ] . type == VALTRUE ) { ptr [ * pos ] . left = 0 ; ( * pos ) ++ ; } else if ( ptr [ * pos ] . val == ( int32 ) '!' ) { ptr [ * pos ] . left = 1 ; ( * pos ) ++ ; findoprnd ( ptr , pos ) ; } else { ITEM * curitem = & ptr [ * pos ] ; int32 tmp = * pos ; ( * pos ) ++ ; findoprnd ( ptr , pos ) ; curitem -> left = * pos - tmp ; findoprnd ( ptr , pos ) ; } }",<S2SV_ModStart> pos ) { check_stack_depth ( ) ;,postgres@postgres/31400a673325147e1205326008e32135a78b4d8a,CVE-2014-0064,https://github.com/postgres/postgres/commit/31400a673325147e1205326008e32135a78b4d8a,2014-03-31T14:58Z
CWE-399,"CWE-399 <S2SV_StartBug> static int isofs_read_inode ( struct inode * inode ) <S2SV_EndBug> { struct super_block * sb = inode -> i_sb ; struct isofs_sb_info * sbi = ISOFS_SB ( sb ) ; unsigned long bufsize = ISOFS_BUFFER_SIZE ( inode ) ; unsigned long block ; int high_sierra = sbi -> s_high_sierra ; struct buffer_head * bh = NULL ; struct iso_directory_record * de ; struct iso_directory_record * tmpde = NULL ; unsigned int de_len ; unsigned long offset ; struct iso_inode_info * ei = ISOFS_I ( inode ) ; int ret = - EIO ; block = ei -> i_iget5_block ; bh = sb_bread ( inode -> i_sb , block ) ; if ( ! bh ) goto out_badread ; offset = ei -> i_iget5_offset ; de = ( struct iso_directory_record * ) ( bh -> b_data + offset ) ; de_len = * ( unsigned char * ) de ; if ( offset + de_len > bufsize ) { int frag1 = bufsize - offset ; tmpde = kmalloc ( de_len , GFP_KERNEL ) ; if ( tmpde == NULL ) { printk ( KERN_INFO ""%s:<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory\\n"" , __func__ ) ; ret = - ENOMEM ; goto fail ; } memcpy ( tmpde , bh -> b_data + offset , frag1 ) ; brelse ( bh ) ; bh = sb_bread ( inode -> i_sb , ++ block ) ; if ( ! bh ) goto out_badread ; memcpy ( ( char * ) tmpde + frag1 , bh -> b_data , de_len - frag1 ) ; de = tmpde ; } inode -> i_ino = isofs_get_ino ( ei -> i_iget5_block , ei -> i_iget5_offset , ISOFS_BUFFER_BITS ( inode ) ) ; ei -> i_file_format = isofs_file_normal ; if ( de -> flags [ - high_sierra ] & 2 ) { if ( sbi -> s_dmode != ISOFS_INVALID_MODE ) inode -> i_mode = S_IFDIR | sbi -> s_dmode ; else inode -> i_mode = S_IFDIR | S_IRUGO | S_IXUGO ; set_nlink ( inode , 1 ) ; } else { if ( sbi -> s_fmode != ISOFS_INVALID_MODE ) { inode -> i_mode = S_IFREG | sbi -> s_fmode ; } else { inode -> i_mode = S_IFREG | S_IRUGO | S_IXUGO ; } set_nlink ( inode , 1 ) ; } inode -> i_uid = sbi -> s_uid ; inode -> i_gid = sbi -> s_gid ; inode -> i_blocks = 0 ; ei -> i_format_parm [ 0 ] = 0 ; ei -> i_format_parm [ 1 ] = 0 ; ei -> i_format_parm [ 2 ] = 0 ; ei -> i_section_size = isonum_733 ( de -> size ) ; if ( de -> flags [ - high_sierra ] & 0x80 ) { ret = isofs_read_level3_size ( inode ) ; if ( ret < 0 ) goto fail ; ret = - EIO ; } else { ei -> i_next_section_block = 0 ; ei -> i_next_section_offset = 0 ; inode -> i_size = isonum_733 ( de -> size ) ; } if ( sbi -> s_cruft ) inode -> i_size &= 0x00ffffff ; if ( de -> interleave [ 0 ] ) { printk ( KERN_DEBUG ""ISOFS:<S2SV_blank>Interleaved<S2SV_blank>files<S2SV_blank>not<S2SV_blank>(yet)<S2SV_blank>supported.\\n"" ) ; inode -> i_size = 0 ; } if ( de -> file_unit_size [ 0 ] != 0 ) { printk ( KERN_DEBUG ""ISOFS:<S2SV_blank>File<S2SV_blank>unit<S2SV_blank>size<S2SV_blank>!=<S2SV_blank>0<S2SV_blank>for<S2SV_blank>ISO<S2SV_blank>file<S2SV_blank>(%ld).\\n"" , inode -> i_ino ) ; } # ifdef DEBUG if ( ( de -> flags [ - high_sierra ] & ~ 2 ) != 0 ) { printk ( KERN_DEBUG ""ISOFS:<S2SV_blank>Unusual<S2SV_blank>flag<S2SV_blank>settings<S2SV_blank>for<S2SV_blank>ISO<S2SV_blank>file<S2SV_blank>"" ""(%ld<S2SV_blank>%x).\\n"" , inode -> i_ino , de -> flags [ - high_sierra ] ) ; } # endif inode -> i_mtime . tv_sec = inode -> i_atime . tv_sec = inode -> i_ctime . tv_sec = iso_date ( de -> date , high_sierra ) ; inode -> i_mtime . tv_nsec = inode -> i_atime . tv_nsec = inode -> i_ctime . tv_nsec = 0 ; ei -> i_first_extent = ( isonum_733 ( de -> extent ) + isonum_711 ( de -> ext_attr_length ) ) ; inode -> i_blocks = ( inode -> i_size + 511 ) >> 9 ; if ( ! high_sierra ) { <S2SV_StartBug> parse_rock_ridge_inode ( de , inode ) ; <S2SV_EndBug> if ( sbi -> s_uid_set ) inode -> i_uid = sbi -> s_uid ; if ( sbi -> s_gid_set ) inode -> i_gid = sbi -> s_gid ; } if ( S_ISDIR ( inode -> i_mode ) && sbi -> s_overriderockperm && sbi -> s_dmode != ISOFS_INVALID_MODE ) inode -> i_mode = S_IFDIR | sbi -> s_dmode ; if ( S_ISREG ( inode -> i_mode ) && sbi -> s_overriderockperm && sbi -> s_fmode != ISOFS_INVALID_MODE ) inode -> i_mode = S_IFREG | sbi -> s_fmode ; if ( S_ISREG ( inode -> i_mode ) ) { inode -> i_fop = & generic_ro_fops ; switch ( ei -> i_file_format ) { # ifdef CONFIG_ZISOFS case isofs_file_compressed : inode -> i_data . a_ops = & zisofs_aops ; break ; # endif default : inode -> i_data . a_ops = & isofs_aops ; break ; } } else if ( S_ISDIR ( inode -> i_mode ) ) { inode -> i_op = & isofs_dir_inode_operations ; inode -> i_fop = & isofs_dir_operations ; } else if ( S_ISLNK ( inode -> i_mode ) ) { inode -> i_op = & page_symlink_inode_operations ; inode -> i_data . a_ops = & isofs_symlink_aops ; } else init_special_inode ( inode , inode -> i_mode , inode -> i_rdev ) ; ret = 0 ; out : kfree ( tmpde ) ; if ( bh ) brelse ( bh ) ; return ret ; out_badread : printk ( KERN_WARNING ""ISOFS:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>i-node<S2SV_blank>block\\n"" ) ; fail : goto out ; }","<S2SV_ModStart> inode * inode , int relocated <S2SV_ModStart> de , inode , relocated",torvalds@linux/410dd3cf4c9b36f27ed4542ee18b1af5e68645a4,CVE-2014-5471,https://github.com/torvalds/linux/commit/410dd3cf4c9b36f27ed4542ee18b1af5e68645a4,2014-09-01T01:55Z
CWE-119,"CWE-119 void vp9_encode_intra_block_plane ( MACROBLOCK * x , BLOCK_SIZE bsize , int plane ) { const MACROBLOCKD * const xd = & x -> e_mbd ; struct encode_b_args arg = { x , NULL , & xd -> mi [ 0 ] -> mbmi . skip } ; <S2SV_StartBug> vp9_foreach_transformed_block_in_plane ( xd , bsize , plane , encode_block_intra , <S2SV_EndBug> & arg ) ; }","<S2SV_ModStart> , plane , vp9_encode_block_intra <S2SV_ModEnd> , & arg",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-617,"CWE-000 static krb5_error_code kdc_process_s4u_x509_user ( krb5_context context , krb5_kdc_req * request , krb5_pa_data * pa_data , krb5_keyblock * tgs_subkey , krb5_keyblock * tgs_session , krb5_pa_s4u_x509_user * * s4u_x509_user , const char * * status ) { krb5_error_code code ; krb5_data req_data ; req_data . length = pa_data -> length ; req_data . data = ( char * ) pa_data -> contents ; code = decode_krb5_pa_s4u_x509_user ( & req_data , s4u_x509_user ) ; if ( code ) <S2SV_StartBug> return code ; <S2SV_EndBug> code = verify_s4u_x509_user_checksum ( context , tgs_subkey ? tgs_subkey : tgs_session , & req_data , request -> nonce , * s4u_x509_user ) ; if ( code ) { * status = ""INVALID_S4U2SELF_CHECKSUM"" ; krb5_free_pa_s4u_x509_user ( context , * s4u_x509_user ) ; * s4u_x509_user = NULL ; return code ; } if ( krb5_princ_size ( context , ( * s4u_x509_user ) -> user_id . user ) == 0 || ( * s4u_x509_user ) -> user_id . subject_cert . length != 0 ) { * status = ""INVALID_S4U2SELF_REQUEST"" ; krb5_free_pa_s4u_x509_user ( context , * s4u_x509_user ) ; * s4u_x509_user = NULL ; return KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN ; } return 0 ; }","<S2SV_ModStart> ( code ) { * status = ""DECODE_PA_S4U_X509_USER"" ; return code ; } <S2SV_ModEnd> code = verify_s4u_x509_user_checksum",krb5@krb5/ffb35baac6981f9e8914f8f3bffd37f284b85970,CVE-2017-11368,https://github.com/krb5/krb5/commit/ffb35baac6981f9e8914f8f3bffd37f284b85970,2017-08-09T18:29Z
CWE-125,"CWE-125 u_int atm_if_print ( netdissect_options * ndo , const struct pcap_pkthdr * h , const u_char * p ) { u_int caplen = h -> caplen ; u_int length = h -> len ; uint32_t llchdr ; u_int hdrlen = 0 ; if ( caplen < 1 || length < 1 ) { ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return ( caplen ) ; } if ( * p == LLC_UI ) { if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , ""CNLPID<S2SV_blank>"" ) ) ; <S2SV_StartBug> isoclns_print ( ndo , p + 1 , length - 1 , caplen - 1 ) ; <S2SV_EndBug> return hdrlen ; } if ( caplen < 3 || length < 3 ) { ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return ( caplen ) ; } llchdr = EXTRACT_24BITS ( p ) ; if ( llchdr != LLC_UI_HDR ( LLCSAP_SNAP ) && llchdr != LLC_UI_HDR ( LLCSAP_ISONS ) && llchdr != LLC_UI_HDR ( LLCSAP_IP ) ) { if ( caplen < 20 || length < 20 ) { ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return ( caplen ) ; } if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , ""%08x%08x<S2SV_blank>%08x%08x<S2SV_blank>"" , EXTRACT_32BITS ( p ) , EXTRACT_32BITS ( p + 4 ) , EXTRACT_32BITS ( p + 8 ) , EXTRACT_32BITS ( p + 12 ) ) ) ; p += 20 ; length -= 20 ; caplen -= 20 ; hdrlen += 20 ; } hdrlen += atm_llc_print ( ndo , p , length , caplen ) ; return ( hdrlen ) ; }",<S2SV_ModStart> length - 1 <S2SV_ModEnd> ) ; return,the-tcpdump-group@tcpdump/1dcd10aceabbc03bf571ea32b892c522cbe923de,CVE-2017-12897,https://github.com/the-tcpdump-group/tcpdump/commit/1dcd10aceabbc03bf571ea32b892c522cbe923de,2017-09-14T06:29Z
CWE-399,"CWE-399 static int rock_continue ( struct rock_state * rs ) { int ret = 1 ; int blocksize = 1 << rs -> inode -> i_blkbits ; const int min_de_size = offsetof ( struct rock_ridge , u ) ; kfree ( rs -> buffer ) ; rs -> buffer = NULL ; if ( ( unsigned ) rs -> cont_offset > blocksize - min_de_size || ( unsigned ) rs -> cont_size > blocksize || ( unsigned ) ( rs -> cont_offset + rs -> cont_size ) > blocksize ) { printk ( KERN_NOTICE ""rock:<S2SV_blank>corrupted<S2SV_blank>directory<S2SV_blank>entry.<S2SV_blank>"" ""extent=%d,<S2SV_blank>offset=%d,<S2SV_blank>size=%d\\n"" , rs -> cont_extent , rs -> cont_offset , rs -> cont_size ) ; ret = - EIO ; goto out ; } if ( rs -> cont_extent ) { struct buffer_head * bh ; rs -> buffer = kmalloc ( rs -> cont_size , GFP_KERNEL ) ; if ( ! rs -> buffer ) { ret = - ENOMEM ; goto out ; } ret = - EIO ; <S2SV_StartBug> bh = sb_bread ( rs -> inode -> i_sb , rs -> cont_extent ) ; <S2SV_EndBug> if ( bh ) { memcpy ( rs -> buffer , bh -> b_data + rs -> cont_offset , rs -> cont_size ) ; put_bh ( bh ) ; rs -> chr = rs -> buffer ; rs -> len = rs -> cont_size ; rs -> cont_extent = 0 ; rs -> cont_size = 0 ; rs -> cont_offset = 0 ; return 0 ; } printk ( ""Unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>rock-ridge<S2SV_blank>attributes\\n"" ) ; } out : kfree ( rs -> buffer ) ; rs -> buffer = NULL ; return ret ; }",<S2SV_ModStart> - EIO ; if ( ++ rs -> cont_loops >= RR_MAX_CE_ENTRIES ) goto out ;,torvalds@linux/f54e18f1b831c92f6512d2eedb224cd63d607d3d,CVE-2014-9420,https://github.com/torvalds/linux/commit/f54e18f1b831c92f6512d2eedb224cd63d607d3d,2014-12-26T00:59Z
CWE-362,"CWE-362 static int userfaultfd_release ( struct inode * inode , struct file * file ) { struct userfaultfd_ctx * ctx = file -> private_data ; struct mm_struct * mm = ctx -> mm ; struct vm_area_struct * vma , * prev ; struct userfaultfd_wake_range range = { . len = 0 , } ; unsigned long new_flags ; WRITE_ONCE ( ctx -> released , true ) ; if ( ! mmget_not_zero ( mm ) ) goto wakeup ; down_write ( & mm -> mmap_sem ) ; <S2SV_StartBug> prev = NULL ; <S2SV_EndBug> for ( vma = mm -> mmap ; vma ; vma = vma -> vm_next ) { cond_resched ( ) ; BUG_ON ( ! ! vma -> vm_userfaultfd_ctx . ctx ^ ! ! ( vma -> vm_flags & ( VM_UFFD_MISSING | VM_UFFD_WP ) ) ) ; if ( vma -> vm_userfaultfd_ctx . ctx != ctx ) { prev = vma ; continue ; } new_flags = vma -> vm_flags & ~ ( VM_UFFD_MISSING | VM_UFFD_WP ) ; prev = vma_merge ( mm , prev , vma -> vm_start , vma -> vm_end , new_flags , vma -> anon_vma , vma -> vm_file , vma -> vm_pgoff , vma_policy ( vma ) , NULL_VM_UFFD_CTX ) ; if ( prev ) vma = prev ; else prev = vma ; vma -> vm_flags = new_flags ; vma -> vm_userfaultfd_ctx = NULL_VM_UFFD_CTX ; } <S2SV_StartBug> up_write ( & mm -> mmap_sem ) ; <S2SV_EndBug> mmput ( mm ) ; wakeup : spin_lock ( & ctx -> fault_pending_wqh . lock ) ; __wake_up_locked_key ( & ctx -> fault_pending_wqh , TASK_NORMAL , & range ) ; __wake_up ( & ctx -> fault_wqh , TASK_NORMAL , 1 , & range ) ; spin_unlock ( & ctx -> fault_pending_wqh . lock ) ; wake_up_all ( & ctx -> event_wqh ) ; wake_up_poll ( & ctx -> fd_wqh , EPOLLHUP ) ; userfaultfd_ctx_put ( ctx ) ; return 0 ; }",<S2SV_ModStart> mmap_sem ) ; if ( ! mmget_still_valid ( mm ) ) goto skip_mm ; <S2SV_ModStart> NULL_VM_UFFD_CTX ; } skip_mm :,torvalds@linux/04f5866e41fb70690e28397487d8bd8eea7d712a,CVE-2019-11599,https://github.com/torvalds/linux/commit/04f5866e41fb70690e28397487d8bd8eea7d712a,2019-04-29T18:29Z
CWE-119,"CWE-119 void impeg2d_dec_pic_data_thread ( dec_state_t * ps_dec ) { WORD32 i4_continue_decode ; WORD32 i4_cur_row , temp ; UWORD32 u4_bits_read ; WORD32 i4_dequeue_job ; IMPEG2D_ERROR_CODES_T e_error ; i4_cur_row = ps_dec -> u2_mb_y + 1 ; i4_continue_decode = 1 ; i4_dequeue_job = 1 ; do { if ( i4_cur_row > ps_dec -> u2_num_vert_mb ) { i4_continue_decode = 0 ; break ; } { if ( ( ps_dec -> i4_num_cores > 1 ) && ( i4_dequeue_job ) ) { job_t s_job ; IV_API_CALL_STATUS_T e_ret ; UWORD8 * pu1_buf ; e_ret = impeg2_jobq_dequeue ( ps_dec -> pv_jobq , & s_job , sizeof ( s_job ) , 1 , 1 ) ; if ( e_ret != IV_SUCCESS ) break ; if ( CMD_PROCESS == s_job . i4_cmd ) { pu1_buf = ps_dec -> pu1_inp_bits_buf + s_job . i4_bistream_ofst ; impeg2d_bit_stream_init ( & ( ps_dec -> s_bit_stream ) , pu1_buf , ( ps_dec -> u4_num_inp_bytes - s_job . i4_bistream_ofst ) + 8 ) ; i4_cur_row = s_job . i2_start_mb_y ; ps_dec -> i4_start_mb_y = s_job . i2_start_mb_y ; ps_dec -> i4_end_mb_y = s_job . i2_end_mb_y ; ps_dec -> u2_mb_x = 0 ; ps_dec -> u2_mb_y = ps_dec -> i4_start_mb_y ; ps_dec -> u2_num_mbs_left = ( ps_dec -> i4_end_mb_y - ps_dec -> i4_start_mb_y ) * ps_dec -> u2_num_horiz_mb ; } else { WORD32 start_row ; WORD32 num_rows ; start_row = s_job . i2_start_mb_y << 4 ; num_rows = MIN ( ( s_job . i2_end_mb_y << 4 ) , ps_dec -> u2_vertical_size ) ; num_rows -= start_row ; impeg2d_format_convert ( ps_dec , ps_dec -> ps_disp_pic , ps_dec -> ps_disp_frm_buf , start_row , num_rows ) ; break ; } } e_error = impeg2d_dec_slice ( ps_dec ) ; if ( ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE != e_error ) { impeg2d_next_start_code ( ps_dec ) ; } } while ( 1 ) { u4_bits_read = impeg2d_bit_stream_nxt ( & ps_dec -> s_bit_stream , START_CODE_LEN ) ; temp = u4_bits_read & 0xFF ; i4_continue_decode = ( ( ( u4_bits_read >> 8 ) == 0x01 ) && ( temp ) && ( temp <= 0xAF ) ) ; <S2SV_StartBug> if ( i4_continue_decode ) <S2SV_EndBug> { if ( ( temp - 1 ) == i4_cur_row ) { i4_dequeue_job = 0 ; break ; } if ( temp < ps_dec -> i4_end_mb_y ) { i4_cur_row = ps_dec -> u2_mb_y ; } else { i4_dequeue_job = 1 ; } break ; } else break ; } } while ( i4_continue_decode ) ; if ( ps_dec -> i4_num_cores > 1 ) { while ( 1 ) { job_t s_job ; IV_API_CALL_STATUS_T e_ret ; e_ret = impeg2_jobq_dequeue ( ps_dec -> pv_jobq , & s_job , sizeof ( s_job ) , 1 , 1 ) ; if ( e_ret != IV_SUCCESS ) break ; if ( CMD_FMTCONV == s_job . i4_cmd ) { WORD32 start_row ; WORD32 num_rows ; start_row = s_job . i2_start_mb_y << 4 ; num_rows = MIN ( ( s_job . i2_end_mb_y << 4 ) , ps_dec -> u2_vertical_size ) ; num_rows -= start_row ; impeg2d_format_convert ( ps_dec , ps_dec -> ps_disp_pic , ps_dec -> ps_disp_frm_buf , start_row , num_rows ) ; } } } else { if ( ( NULL != ps_dec -> ps_disp_pic ) && ( ( 0 == ps_dec -> u4_share_disp_buf ) || ( IV_YUV_420P != ps_dec -> i4_chromaFormat ) ) ) impeg2d_format_convert ( ps_dec , ps_dec -> ps_disp_pic , ps_dec -> ps_disp_frm_buf , 0 , ps_dec -> u2_vertical_size ) ; } }","<S2SV_ModStart> ; if ( 1 == ps_dec -> i4_num_cores && 0 == ps_dec -> u2_num_mbs_left ) { i4_continue_decode = 0 ; android_errorWriteLog ( 0x534e4554 , ""26070014"" ) ; } if (",external@libmpeg2/ba604d336b40fd4bde1622f64d67135bdbd61301,CVE-2016-0835,https://android.googlesource.com/platform/external/libmpeg2/+/ba604d336b40fd4bde1622f64d67135bdbd61301,2016-04-18T00:59Z
CWE-415,"CWE-415 int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; int err = 0 ; if ( ! asoc ) <S2SV_StartBug> return - EINVAL ; <S2SV_EndBug> if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }",<S2SV_ModStart> return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY,torvalds@linux/dfcb9f4f99f1e9a49e43398a7bfbf56927544af1,CVE-2017-6353,https://github.com/torvalds/linux/commit/dfcb9f4f99f1e9a49e43398a7bfbf56927544af1,2017-03-01T20:59Z
CWE-20,"CWE-20 error_t webSocketParseAuthenticateField ( WebSocket * webSocket , char_t * value ) { # if ( WEB_SOCKET_BASIC_AUTH_SUPPORT == ENABLED || WEB_SOCKET_DIGEST_AUTH_SUPPORT == ENABLED ) size_t n ; char_t * p ; char_t * token ; char_t * separator ; char_t * name ; WebSocketAuthContext * authContext ; authContext = & webSocket -> authContext ; token = osStrtok_r ( value , ""<S2SV_blank>\\t"" , & p ) ; if ( token == NULL ) return ERROR_INVALID_SYNTAX ; if ( ! osStrcasecmp ( token , ""Basic"" ) ) { authContext -> requiredAuthMode = WS_AUTH_MODE_BASIC ; } else if ( ! osStrcasecmp ( token , ""Digest"" ) ) { authContext -> requiredAuthMode = WS_AUTH_MODE_DIGEST ; } else { return ERROR_INVALID_SYNTAX ; } token = osStrtok_r ( NULL , "","" , & p ) ; while ( token != NULL ) { <S2SV_StartBug> separator = strchr ( token , '=' ) ; <S2SV_EndBug> if ( separator != NULL ) { * separator = '\\0' ; name = strTrimWhitespace ( token ) ; value = strTrimWhitespace ( separator + 1 ) ; n = osStrlen ( value ) ; if ( n > 0 && value [ n - 1 ] == \'\\""\' ) value [ n - 1 ] = '\\0' ; if ( value [ 0 ] == \'\\""\' ) value ++ ; if ( ! osStrcasecmp ( name , ""realm"" ) ) { strSafeCopy ( authContext -> realm , value , WEB_SOCKET_REALM_MAX_LEN ) ; } # if ( WEB_SOCKET_DIGEST_AUTH_SUPPORT == ENABLED ) else if ( ! osStrcasecmp ( name , ""nonce"" ) ) { strSafeCopy ( authContext -> nonce , value , WEB_SOCKET_NONCE_MAX_LEN + 1 ) ; } else if ( ! osStrcasecmp ( name , ""opaque"" ) ) { strSafeCopy ( authContext -> opaque , value , WEB_SOCKET_OPAQUE_MAX_LEN + 1 ) ; } else if ( ! osStrcasecmp ( name , ""stale"" ) ) { if ( ! osStrcasecmp ( value , ""true"" ) ) authContext -> stale = TRUE ; else authContext -> stale = FALSE ; } # endif token = osStrtok_r ( NULL , "","" , & p ) ; } } # endif return NO_ERROR ; }","<S2SV_ModStart> { separator = osStrchr <S2SV_ModEnd> ( token ,",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z
CWE-416,"CWE-416 INST_HANDLER ( cpse ) { int r = ( buf [ 0 ] & 0xf ) | ( ( buf [ 1 ] & 0x2 ) << 3 ) ; int d = ( ( buf [ 0 ] >> 4 ) & 0xf ) | ( ( buf [ 1 ] & 0x1 ) << 4 ) ; <S2SV_StartBug> RAnalOp next_op ; <S2SV_EndBug> avr_op_analyze ( anal , & next_op , op -> addr + op -> size , buf + op -> size , len - op -> size , cpu ) ; r_strbuf_fini ( & next_op . esil ) ; op -> jump = op -> addr + next_op . size + 2 ; op -> cycles = 1 ; ESIL_A ( ""r%d,r%d,^,!,"" , r , d ) ; ESIL_A ( ""?{,%"" PFMT64d "",pc,=,},"" , op -> jump ) ; }",<S2SV_ModStart> ; RAnalOp next_op = { 0 },radare@radare2/9d348bcc2c4bbd3805e7eec97b594be9febbdf9a,CVE-2018-11383,https://github.com/radare/radare2/commit/9d348bcc2c4bbd3805e7eec97b594be9febbdf9a,2018-05-22T19:29Z
CWE-125,"CWE-125 static int vorbis_finish_frame ( stb_vorbis * f , int len , int left , int right ) { int prev , i , j ; if ( f -> previous_length ) { int i , j , n = f -> previous_length ; <S2SV_StartBug> float * w = get_window ( f , n ) ; <S2SV_EndBug> for ( i = 0 ; i < f -> channels ; ++ i ) { for ( j = 0 ; j < n ; ++ j ) f -> channel_buffers [ i ] [ left + j ] = f -> channel_buffers [ i ] [ left + j ] * w [ j ] + f -> previous_window [ i ] [ j ] * w [ n - 1 - j ] ; } } prev = f -> previous_length ; f -> previous_length = len - right ; for ( i = 0 ; i < f -> channels ; ++ i ) for ( j = 0 ; right + j < len ; ++ j ) f -> previous_window [ i ] [ j ] = f -> channel_buffers [ i ] [ right + j ] ; if ( ! prev ) return 0 ; if ( len < right ) right = len ; f -> samples_output += right - left ; return right - left ; }","<S2SV_ModStart> , n ) ; if ( w == NULL ) return 0",nothings@stb/98fdfc6df88b1e34a736d5e126e6c8139c8de1a6,CVE-2019-13222,https://github.com/nothings/stb/commit/98fdfc6df88b1e34a736d5e126e6c8139c8de1a6,2019-08-15T17:15Z
CWE-362,"CWE-362 static int sctp_init_sock ( struct sock * sk ) { struct net * net = sock_net ( sk ) ; struct sctp_sock * sp ; pr_debug ( ""%s:<S2SV_blank>sk:%p\\n"" , __func__ , sk ) ; sp = sctp_sk ( sk ) ; switch ( sk -> sk_type ) { case SOCK_SEQPACKET : sp -> type = SCTP_SOCKET_UDP ; break ; case SOCK_STREAM : sp -> type = SCTP_SOCKET_TCP ; break ; default : return - ESOCKTNOSUPPORT ; } sp -> default_stream = 0 ; sp -> default_ppid = 0 ; sp -> default_flags = 0 ; sp -> default_context = 0 ; sp -> default_timetolive = 0 ; sp -> default_rcv_context = 0 ; sp -> max_burst = net -> sctp . max_burst ; sp -> sctp_hmac_alg = net -> sctp . sctp_hmac_alg ; sp -> initmsg . sinit_num_ostreams = sctp_max_outstreams ; sp -> initmsg . sinit_max_instreams = sctp_max_instreams ; sp -> initmsg . sinit_max_attempts = net -> sctp . max_retrans_init ; sp -> initmsg . sinit_max_init_timeo = net -> sctp . rto_max ; sp -> rtoinfo . srto_initial = net -> sctp . rto_initial ; sp -> rtoinfo . srto_max = net -> sctp . rto_max ; sp -> rtoinfo . srto_min = net -> sctp . rto_min ; sp -> assocparams . sasoc_asocmaxrxt = net -> sctp . max_retrans_association ; sp -> assocparams . sasoc_number_peer_destinations = 0 ; sp -> assocparams . sasoc_peer_rwnd = 0 ; sp -> assocparams . sasoc_local_rwnd = 0 ; sp -> assocparams . sasoc_cookie_life = net -> sctp . valid_cookie_life ; memset ( & sp -> subscribe , 0 , sizeof ( struct sctp_event_subscribe ) ) ; sp -> hbinterval = net -> sctp . hb_interval ; sp -> pathmaxrxt = net -> sctp . max_retrans_path ; sp -> pathmtu = 0 ; sp -> sackdelay = net -> sctp . sack_timeout ; sp -> sackfreq = 2 ; sp -> param_flags = SPP_HB_ENABLE | SPP_PMTUD_ENABLE | SPP_SACKDELAY_ENABLE ; sp -> disable_fragments = 0 ; sp -> nodelay = 0 ; sp -> recvrcvinfo = 0 ; sp -> recvnxtinfo = 0 ; sp -> v4mapped = 1 ; sp -> autoclose = 0 ; sp -> user_frag = 0 ; sp -> adaptation_ind = 0 ; sp -> pf = sctp_get_pf_specific ( sk -> sk_family ) ; atomic_set ( & sp -> pd_mode , 0 ) ; skb_queue_head_init ( & sp -> pd_lobby ) ; sp -> frag_interleave = 0 ; sp -> ep = sctp_endpoint_new ( sk , GFP_KERNEL ) ; if ( ! sp -> ep ) return - ENOMEM ; sp -> hmac = NULL ; sk -> sk_destruct = sctp_destruct_sock ; SCTP_DBG_OBJCNT_INC ( sock ) ; local_bh_disable ( ) ; percpu_counter_inc ( & sctp_sockets_allocated ) ; sock_prot_inuse_add ( net , sk -> sk_prot , 1 ) ; if ( net -> sctp . default_auto_asconf ) { <S2SV_StartBug> list_add_tail ( & sp -> auto_asconf_list , <S2SV_EndBug> & net -> sctp . auto_asconf_splist ) ; <S2SV_StartBug> sp -> do_auto_asconf = 1 ; <S2SV_EndBug> <S2SV_StartBug> } else <S2SV_EndBug> <S2SV_StartBug> sp -> do_auto_asconf = 0 ; <S2SV_EndBug> local_bh_enable ( ) ; return 0 ; }",<S2SV_ModStart> default_auto_asconf ) { spin_lock ( & sock_net ( sk ) -> sctp . addr_wq_lock ) ; <S2SV_ModStart> do_auto_asconf = 1 ; spin_unlock ( & sock_net ( sk ) -> sctp . addr_wq_lock ) <S2SV_ModStart> ; } else { <S2SV_ModStart> = 0 ; },torvalds@linux/2d45a02d0166caf2627fe91897c6ffc3b19514c4,CVE-2015-3212,https://github.com/torvalds/linux/commit/2d45a02d0166caf2627fe91897c6ffc3b19514c4,2015-08-31T10:59Z
CWE-119,"CWE-119 int stats_open_file ( stats_io_t * stats , const char * fpf , int pass ) { int res ; stats -> pass = pass ; if ( pass == 0 ) { stats -> file = fopen ( fpf , ""wb"" ) ; stats -> buf . sz = 0 ; stats -> buf . buf = NULL ; res = ( stats -> file != NULL ) ; } else { # if USE_POSIX_MMAP struct stat stat_buf ; int fd ; fd = open ( fpf , O_RDONLY ) ; stats -> file = fdopen ( fd , ""rb"" ) ; fstat ( fd , & stat_buf ) ; stats -> buf . sz = stat_buf . st_size ; stats -> buf . buf = mmap ( NULL , stats -> buf . sz , PROT_READ , MAP_PRIVATE , fd , 0 ) ; res = ( stats -> buf . buf != NULL ) ; # else size_t nbytes ; stats -> file = fopen ( fpf , ""rb"" ) ; <S2SV_StartBug> if ( fseek ( stats -> file , 0 , SEEK_END ) ) <S2SV_EndBug> fatal ( ""First-pass<S2SV_blank>stats<S2SV_blank>file<S2SV_blank>must<S2SV_blank>be<S2SV_blank>seekable!"" ) ; stats -> buf . sz = stats -> buf_alloc_sz = ftell ( stats -> file ) ; rewind ( stats -> file ) ; stats -> buf . buf = malloc ( stats -> buf_alloc_sz ) ; if ( ! stats -> buf . buf ) fatal ( ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>first-pass<S2SV_blank>stats<S2SV_blank>buffer<S2SV_blank>(%lu<S2SV_blank>bytes)"" , ( unsigned int ) stats -> buf_alloc_sz ) ; nbytes = fread ( stats -> buf . buf , 1 , stats -> buf . sz , stats -> file ) ; res = ( nbytes == stats -> buf . sz ) ; # endif } return res ; }","<S2SV_ModStart> ; if ( stats -> file == NULL ) fatal ( ""First-pass<S2SV_blank>stats<S2SV_blank>file<S2SV_blank>does<S2SV_blank>not<S2SV_blank>exist!"" ) ; if (",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-416,"CWE-416 int snd_timer_open ( struct snd_timer_instance * * ti , char * owner , struct snd_timer_id * tid , unsigned int slave_id ) { struct snd_timer * timer ; struct snd_timer_instance * timeri = NULL ; struct device * card_dev_to_put = NULL ; int err ; mutex_lock ( & register_mutex ) ; if ( tid -> dev_class == SNDRV_TIMER_CLASS_SLAVE ) { if ( tid -> dev_sclass <= SNDRV_TIMER_SCLASS_NONE || tid -> dev_sclass > SNDRV_TIMER_SCLASS_OSS_SEQUENCER ) { pr_debug ( ""ALSA:<S2SV_blank>timer:<S2SV_blank>invalid<S2SV_blank>slave<S2SV_blank>class<S2SV_blank>%i\\n"" , tid -> dev_sclass ) ; err = - EINVAL ; goto unlock ; } timeri = snd_timer_instance_new ( owner , NULL ) ; if ( ! timeri ) { err = - ENOMEM ; goto unlock ; } timeri -> slave_class = tid -> dev_sclass ; timeri -> slave_id = tid -> device ; timeri -> flags |= SNDRV_TIMER_IFLG_SLAVE ; list_add_tail ( & timeri -> open_list , & snd_timer_slave_list ) ; err = snd_timer_check_slave ( timeri ) ; if ( err < 0 ) { snd_timer_close_locked ( timeri , & card_dev_to_put ) ; timeri = NULL ; } goto unlock ; } timer = snd_timer_find ( tid ) ; # ifdef CONFIG_MODULES if ( ! timer ) { mutex_unlock ( & register_mutex ) ; snd_timer_request ( tid ) ; mutex_lock ( & register_mutex ) ; timer = snd_timer_find ( tid ) ; } # endif if ( ! timer ) { err = - ENODEV ; goto unlock ; } if ( ! list_empty ( & timer -> open_list_head ) ) { <S2SV_StartBug> timeri = list_entry ( timer -> open_list_head . next , <S2SV_EndBug> struct snd_timer_instance , open_list ) ; <S2SV_StartBug> if ( timeri -> flags & SNDRV_TIMER_IFLG_EXCLUSIVE ) { <S2SV_EndBug> <S2SV_StartBug> err = - EBUSY ; <S2SV_EndBug> timeri = NULL ; goto unlock ; } } if ( timer -> num_instances >= timer -> max_instances ) { err = - EBUSY ; goto unlock ; } timeri = snd_timer_instance_new ( owner , timer ) ; if ( ! timeri ) { err = - ENOMEM ; goto unlock ; } if ( timer -> card ) get_device ( & timer -> card -> card_dev ) ; timeri -> slave_class = tid -> dev_sclass ; timeri -> slave_id = slave_id ; if ( list_empty ( & timer -> open_list_head ) && timer -> hw . open ) { err = timer -> hw . open ( timer ) ; if ( err ) { kfree ( timeri -> owner ) ; kfree ( timeri ) ; timeri = NULL ; if ( timer -> card ) card_dev_to_put = & timer -> card -> card_dev ; module_put ( timer -> module ) ; goto unlock ; } } list_add_tail ( & timeri -> open_list , & timer -> open_list_head ) ; timer -> num_instances ++ ; err = snd_timer_check_master ( timeri ) ; if ( err < 0 ) { snd_timer_close_locked ( timeri , & card_dev_to_put ) ; timeri = NULL ; } unlock : mutex_unlock ( & register_mutex ) ; if ( card_dev_to_put ) put_device ( card_dev_to_put ) ; * ti = timeri ; return err ; }",<S2SV_ModStart> ) ) { struct snd_timer_instance * t = <S2SV_ModEnd> list_entry ( timer <S2SV_ModStart> ; if ( t <S2SV_ModEnd> -> flags & <S2SV_ModStart> = - EBUSY <S2SV_ModEnd> ; goto unlock,torvalds@linux/e7af6307a8a54f0b873960b32b6a644f2d0fbd97,CVE-2019-19807,https://github.com/torvalds/linux/commit/e7af6307a8a54f0b873960b32b6a644f2d0fbd97,2019-12-15T23:15Z
,"CWE-000 static int crypto_report_one ( struct crypto_alg * alg , struct crypto_user_alg * ualg , struct sk_buff * skb ) { <S2SV_StartBug> strlcpy ( ualg -> cru_name , alg -> cra_name , sizeof ( ualg -> cru_name ) ) ; <S2SV_EndBug> <S2SV_StartBug> strlcpy ( ualg -> cru_driver_name , alg -> cra_driver_name , <S2SV_EndBug> sizeof ( ualg -> cru_driver_name ) ) ; <S2SV_StartBug> strlcpy ( ualg -> cru_module_name , module_name ( alg -> cra_module ) , <S2SV_EndBug> sizeof ( ualg -> cru_module_name ) ) ; ualg -> cru_type = 0 ; ualg -> cru_mask = 0 ; ualg -> cru_flags = alg -> cra_flags ; ualg -> cru_refcnt = refcount_read ( & alg -> cra_refcnt ) ; if ( nla_put_u32 ( skb , CRYPTOCFGA_PRIORITY_VAL , alg -> cra_priority ) ) goto nla_put_failure ; if ( alg -> cra_flags & CRYPTO_ALG_LARVAL ) { struct crypto_report_larval rl ; <S2SV_StartBug> strlcpy ( rl . type , ""larval"" , sizeof ( rl . type ) ) ; <S2SV_EndBug> if ( nla_put ( skb , CRYPTOCFGA_REPORT_LARVAL , sizeof ( struct crypto_report_larval ) , & rl ) ) goto nla_put_failure ; goto out ; } if ( alg -> cra_type && alg -> cra_type -> report ) { if ( alg -> cra_type -> report ( skb , alg ) ) goto nla_put_failure ; goto out ; } switch ( alg -> cra_flags & ( CRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_LARVAL ) ) { case CRYPTO_ALG_TYPE_CIPHER : if ( crypto_report_cipher ( skb , alg ) ) goto nla_put_failure ; break ; case CRYPTO_ALG_TYPE_COMPRESS : if ( crypto_report_comp ( skb , alg ) ) goto nla_put_failure ; break ; case CRYPTO_ALG_TYPE_ACOMPRESS : if ( crypto_report_acomp ( skb , alg ) ) goto nla_put_failure ; break ; case CRYPTO_ALG_TYPE_AKCIPHER : if ( crypto_report_akcipher ( skb , alg ) ) goto nla_put_failure ; break ; case CRYPTO_ALG_TYPE_KPP : if ( crypto_report_kpp ( skb , alg ) ) goto nla_put_failure ; break ; } out : return 0 ; nla_put_failure : return - EMSGSIZE ; }",<S2SV_ModStart> skb ) { strncpy <S2SV_ModEnd> ( ualg -> <S2SV_ModStart> ) ) ; strncpy <S2SV_ModEnd> ( ualg -> <S2SV_ModStart> ) ) ; strncpy <S2SV_ModEnd> ( ualg -> <S2SV_ModStart> crypto_report_larval rl ; strncpy <S2SV_ModEnd> ( rl .,torvalds@linux/f43f39958beb206b53292801e216d9b8a660f087,CVE-2018-19854,https://github.com/torvalds/linux/commit/f43f39958beb206b53292801e216d9b8a660f087,2018-12-04T16:29Z
CWE-254,"CWE-000 void impeg2d_dec_user_data ( dec_state_t * ps_dec ) { UWORD32 u4_start_code ; stream_t * ps_stream ; ps_stream = & ps_dec -> s_bit_stream ; u4_start_code = impeg2d_bit_stream_nxt ( ps_stream , START_CODE_LEN ) ; while ( u4_start_code == USER_DATA_START_CODE ) { impeg2d_bit_stream_flush ( ps_stream , START_CODE_LEN ) ; <S2SV_StartBug> while ( impeg2d_bit_stream_nxt ( ps_stream , START_CODE_PREFIX_LEN ) != START_CODE_PREFIX ) <S2SV_EndBug> { impeg2d_bit_stream_flush ( ps_stream , 8 ) ; } u4_start_code = impeg2d_bit_stream_nxt ( ps_stream , START_CODE_LEN ) ; } }",<S2SV_ModStart> ; while ( ( <S2SV_ModStart> ) != START_CODE_PREFIX ) && ( ps_stream -> u4_offset < ps_stream -> u4_max_offset ),external@libmpeg2/ffab15eb80630dc799eb410855c93525b75233c3,CVE-2016-0824,https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3,2016-03-12T21:59Z
NVD-CWE-noinfo,"CWE-000 void ngx_gmtime ( time_t t , ngx_tm_t * tp ) { ngx_int_t yday ; ngx_uint_t sec , min , hour , mday , mon , year , wday , days , leap ; if ( t < 0 ) { t = 0 ; } days = t / 86400 ; <S2SV_StartBug> sec = t % 86400 ; <S2SV_EndBug> wday = ( 4 + days ) % 7 ; hour = sec / 3600 ; sec %= 3600 ; min = sec / 60 ; sec %= 60 ; days = days - ( 31 + 28 ) + 719527 ; year = ( days + 2 ) * 400 / ( 365 * 400 + 100 - 4 + 1 ) ; yday = days - ( 365 * year + year / 4 - year / 100 + year / 400 ) ; if ( yday < 0 ) { leap = ( year % 4 == 0 ) && ( year % 100 || ( year % 400 == 0 ) ) ; yday = 365 + leap + yday ; year -- ; } mon = ( yday + 31 ) * 10 / 306 ; mday = yday - ( 367 * mon / 12 - 30 ) + 1 ; if ( yday >= 306 ) { year ++ ; mon -= 10 ; } else { mon += 2 ; } tp -> ngx_tm_sec = ( ngx_tm_sec_t ) sec ; tp -> ngx_tm_min = ( ngx_tm_min_t ) min ; tp -> ngx_tm_hour = ( ngx_tm_hour_t ) hour ; tp -> ngx_tm_mday = ( ngx_tm_mday_t ) mday ; tp -> ngx_tm_mon = ( ngx_tm_mon_t ) mon ; tp -> ngx_tm_year = ( ngx_tm_year_t ) year ; tp -> ngx_tm_wday = ( ngx_tm_wday_t ) wday ; }",<S2SV_ModStart> % 86400 ; if ( days > 2932896 ) { days = 2932896 ; sec = 86399 ; },nginx@nginx/b900cc28fcbb4cf5a32ab62f80b59292e1c85b4b,CVE-2017-20005,https://github.com/nginx/nginx/commit/b900cc28fcbb4cf5a32ab62f80b59292e1c85b4b,2021-06-06T22:15Z
CWE-125,"CWE-125 u_int ieee802_15_4_if_print ( netdissect_options * ndo , const struct pcap_pkthdr * h , const u_char * p ) { u_int caplen = h -> caplen ; u_int hdrlen ; uint16_t fc ; uint8_t seq ; uint16_t panid = 0 ; if ( caplen < 3 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return caplen ; } hdrlen = 3 ; fc = EXTRACT_LE_16BITS ( p ) ; seq = EXTRACT_LE_8BITS ( p + 2 ) ; p += 3 ; caplen -= 3 ; ND_PRINT ( ( ndo , ""IEEE<S2SV_blank>802.15.4<S2SV_blank>%s<S2SV_blank>packet<S2SV_blank>"" , ftypes [ FC_FRAME_TYPE ( fc ) ] ) ) ; if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""seq<S2SV_blank>%02x<S2SV_blank>"" , seq ) ) ; switch ( FC_DEST_ADDRESSING_MODE ( fc ) ) { case FC_ADDRESSING_MODE_NONE : if ( fc & FC_PAN_ID_COMPRESSION ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""none<S2SV_blank>"" ) ) ; break ; case FC_ADDRESSING_MODE_RESERVED : if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""reserved<S2SV_blank>destination<S2SV_blank>addressing<S2SV_blank>mode"" ) ) ; return hdrlen ; case FC_ADDRESSING_MODE_SHORT : if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } panid = EXTRACT_LE_16BITS ( p ) ; p += 2 ; caplen -= 2 ; hdrlen += 2 ; if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""%04x:%04x<S2SV_blank>"" , panid , EXTRACT_LE_16BITS ( p + 2 ) ) ) ; p += 2 ; caplen -= 2 ; hdrlen += 2 ; break ; case FC_ADDRESSING_MODE_LONG : if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } panid = EXTRACT_LE_16BITS ( p ) ; p += 2 ; caplen -= 2 ; hdrlen += 2 ; if ( caplen < 8 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) <S2SV_StartBug> ND_PRINT ( ( ndo , ""%04x:%s<S2SV_blank>"" , panid , le64addr_string ( ndo , p + 2 ) ) ) ; <S2SV_EndBug> p += 8 ; caplen -= 8 ; hdrlen += 8 ; break ; } if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""<<S2SV_blank>"" ) ) ; switch ( FC_SRC_ADDRESSING_MODE ( fc ) ) { case FC_ADDRESSING_MODE_NONE : if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""none<S2SV_blank>"" ) ) ; break ; case FC_ADDRESSING_MODE_RESERVED : if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""reserved<S2SV_blank>source<S2SV_blank>addressing<S2SV_blank>mode"" ) ) ; return 0 ; case FC_ADDRESSING_MODE_SHORT : if ( ! ( fc & FC_PAN_ID_COMPRESSION ) ) { if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } panid = EXTRACT_LE_16BITS ( p ) ; p += 2 ; caplen -= 2 ; hdrlen += 2 ; } if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""%04x:%04x<S2SV_blank>"" , panid , EXTRACT_LE_16BITS ( p ) ) ) ; p += 2 ; caplen -= 2 ; hdrlen += 2 ; break ; case FC_ADDRESSING_MODE_LONG : if ( ! ( fc & FC_PAN_ID_COMPRESSION ) ) { if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } panid = EXTRACT_LE_16BITS ( p ) ; p += 2 ; caplen -= 2 ; hdrlen += 2 ; } if ( caplen < 8 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""%04x:%s<S2SV_blank>"" , panid , le64addr_string ( ndo , p ) ) ) ; p += 8 ; caplen -= 8 ; hdrlen += 8 ; break ; } if ( ! ndo -> ndo_suppress_default_print ) ND_DEFAULTPRINT ( p , caplen ) ; return hdrlen ; }","<S2SV_ModStart> ndo , p <S2SV_ModEnd> ) ) )",the-tcpdump-group@tcpdump/a7e5f58f402e6919ec444a57946bade7dfd6b184,CVE-2017-13000,https://github.com/the-tcpdump-group/tcpdump/commit/a7e5f58f402e6919ec444a57946bade7dfd6b184,2017-09-14T06:29Z
CWE-285,"CWE-000 int ext2_set_acl ( struct inode * inode , struct posix_acl * acl , int type ) { int name_index ; void * value = NULL ; size_t size = 0 ; int error ; switch ( type ) { case ACL_TYPE_ACCESS : name_index = EXT2_XATTR_INDEX_POSIX_ACL_ACCESS ; if ( acl ) { <S2SV_StartBug> error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; <S2SV_EndBug> if ( error < 0 ) return error ; else { inode -> i_ctime = CURRENT_TIME_SEC ; mark_inode_dirty ( inode ) ; <S2SV_StartBug> if ( error == 0 ) <S2SV_EndBug> acl = NULL ; } } break ; case ACL_TYPE_DEFAULT : name_index = EXT2_XATTR_INDEX_POSIX_ACL_DEFAULT ; if ( ! S_ISDIR ( inode -> i_mode ) ) return acl ? - EACCES : 0 ; break ; default : return - EINVAL ; } if ( acl ) { value = ext2_acl_to_disk ( acl , & size ) ; if ( IS_ERR ( value ) ) return ( int ) PTR_ERR ( value ) ; } error = ext2_xattr_set ( inode , name_index , """" , value , size , 0 ) ; kfree ( value ) ; if ( ! error ) set_cached_acl ( inode , type , acl ) ; return error ; }","<S2SV_ModStart> { error = posix_acl_update_mode ( inode <S2SV_ModEnd> , & inode <S2SV_ModStart> inode -> i_mode , & acl ) ; if ( error ) return error ; <S2SV_ModEnd> inode -> i_ctime <S2SV_ModStart> inode ) ; <S2SV_ModEnd> } break ;",torvalds@linux/073931017b49d9458aa351605b43a7e34598caef,CVE-2016-7097,https://github.com/torvalds/linux/commit/073931017b49d9458aa351605b43a7e34598caef,2016-10-16T21:59Z
CWE-416,"CWE-416 static void sunkbd_reinit ( struct work_struct * work ) { struct sunkbd * sunkbd = container_of ( work , struct sunkbd , tq ) ; <S2SV_StartBug> wait_event_interruptible_timeout ( sunkbd -> wait , sunkbd -> reset >= 0 , HZ ) ; <S2SV_EndBug> <S2SV_StartBug> serio_write ( sunkbd -> serio , SUNKBD_CMD_SETLED ) ; <S2SV_EndBug> serio_write ( sunkbd -> serio , ( ! ! test_bit ( LED_CAPSL , sunkbd -> dev -> led ) << 3 ) | ( ! ! test_bit ( LED_SCROLLL , sunkbd -> dev -> led ) << 2 ) | ( ! ! test_bit ( LED_COMPOSE , sunkbd -> dev -> led ) << 1 ) | ! ! test_bit ( LED_NUML , sunkbd -> dev -> led ) ) ; serio_write ( sunkbd -> serio , SUNKBD_CMD_NOCLICK - ! ! test_bit ( SND_CLICK , sunkbd -> dev -> snd ) ) ; serio_write ( sunkbd -> serio , SUNKBD_CMD_BELLOFF - ! ! test_bit ( SND_BELL , sunkbd -> dev -> snd ) ) ; }",<S2SV_ModStart> reset >= 0 || ! sunkbd -> enabled <S2SV_ModStart> HZ ) ; if <S2SV_ModEnd> ( sunkbd -> <S2SV_ModStart> ( sunkbd -> reset >= 0 && sunkbd -> enabled ) sunkbd_set_leds_beeps ( sunkbd <S2SV_ModEnd> ) ; },torvalds@linux/77e70d351db7de07a46ac49b87a6c3c7a60fca7e,CVE-2020-25669,https://github.com/torvalds/linux/commit/77e70d351db7de07a46ac49b87a6c3c7a60fca7e,2021-05-26T12:15Z
CWE-284,"CWE-284 static void * btif_hl_select_thread ( void * arg ) { fd_set org_set , curr_set ; int r , max_curr_s , max_org_s ; UNUSED ( arg ) ; BTIF_TRACE_DEBUG ( ""entered<S2SV_blank>btif_hl_select_thread"" ) ; FD_ZERO ( & org_set ) ; max_org_s = btif_hl_select_wakeup_init ( & org_set ) ; BTIF_TRACE_DEBUG ( ""max_s=%d<S2SV_blank>"" , max_org_s ) ; for ( ; ; ) { r = 0 ; BTIF_TRACE_DEBUG ( ""set<S2SV_blank>curr_set<S2SV_blank>=<S2SV_blank>org_set<S2SV_blank>"" ) ; curr_set = org_set ; max_curr_s = max_org_s ; <S2SV_StartBug> int ret = select ( ( max_curr_s + 1 ) , & curr_set , NULL , NULL , NULL ) ; <S2SV_EndBug> BTIF_TRACE_DEBUG ( ""select<S2SV_blank>unblocked<S2SV_blank>ret=%d"" , ret ) ; if ( ret == - 1 ) { BTIF_TRACE_DEBUG ( ""select()<S2SV_blank>ret<S2SV_blank>-1,<S2SV_blank>exit<S2SV_blank>the<S2SV_blank>thread"" ) ; btif_hl_thread_cleanup ( ) ; select_thread_id = - 1 ; return 0 ; } else if ( ret ) { BTIF_TRACE_DEBUG ( ""btif_hl_select_wake_signaled,<S2SV_blank>signal<S2SV_blank>ret=%d"" , ret ) ; if ( btif_hl_select_wake_signaled ( & curr_set ) ) { r = btif_hl_select_wake_reset ( ) ; BTIF_TRACE_DEBUG ( ""btif_hl_select_wake_signaled,<S2SV_blank>signal:%d"" , r ) ; if ( r == btif_hl_signal_select_wakeup || r == btif_hl_signal_select_close_connected ) { btif_hl_select_wakeup_callback ( & org_set , r ) ; } else if ( r == btif_hl_signal_select_exit ) { btif_hl_thread_cleanup ( ) ; BTIF_TRACE_DEBUG ( ""Exit<S2SV_blank>hl_select_thread<S2SV_blank>for<S2SV_blank>btif_hl_signal_select_exit"" ) ; return 0 ; } } btif_hl_select_monitor_callback ( & curr_set , & org_set ) ; max_org_s = btif_hl_update_maxfd ( max_org_s ) ; } else BTIF_TRACE_DEBUG ( ""no<S2SV_blank>data,<S2SV_blank>select<S2SV_blank>ret:<S2SV_blank>%d\\n"" , ret ) ; } BTIF_TRACE_DEBUG ( ""leaving<S2SV_blank>hl_select_thread"" ) ; return 0 ; }","<S2SV_ModStart> int ret = TEMP_FAILURE_RETRY ( <S2SV_ModStart> , NULL ) )",system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z
CWE-119,"CWE-119 static __u8 * sp_report_fixup ( struct hid_device * hdev , __u8 * rdesc , unsigned int * rsize ) { <S2SV_StartBug> if ( * rsize >= 107 && rdesc [ 104 ] == 0x26 && rdesc [ 105 ] == 0x80 && <S2SV_EndBug> rdesc [ 106 ] == 0x03 ) { hid_info ( hdev , ""fixing<S2SV_blank>up<S2SV_blank>Sunplus<S2SV_blank>Wireless<S2SV_blank>Desktop<S2SV_blank>report<S2SV_blank>descriptor\\n"" ) ; rdesc [ 105 ] = rdesc [ 110 ] = 0x03 ; rdesc [ 106 ] = rdesc [ 111 ] = 0x21 ; } return rdesc ; }",<S2SV_ModStart> * rsize >= 112 <S2SV_ModEnd> && rdesc [,torvalds@linux/4ab25786c87eb20857bbb715c3ae34ec8fd6a214,CVE-2014-3184,https://github.com/torvalds/linux/commit/4ab25786c87eb20857bbb715c3ae34ec8fd6a214,2014-09-28T10:55Z
CWE-119,"CWE-119 <S2SV_StartBug> static void iwl_sta_ucode_activate ( struct iwl_priv * priv , u8 sta_id ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> if ( ! ( priv -> stations [ sta_id ] . used & IWL_STA_DRIVER_ACTIVE ) ) IWL_ERR ( priv , ""ACTIVATE<S2SV_blank>a<S2SV_blank>non<S2SV_blank>DRIVER<S2SV_blank>active<S2SV_blank>station<S2SV_blank>id<S2SV_blank>%u<S2SV_blank>"" ""addr<S2SV_blank>%pM\\n"" , sta_id , priv -> stations [ sta_id ] . sta . sta . addr ) ; if ( priv -> stations [ sta_id ] . used & IWL_STA_UCODE_ACTIVE ) { IWL_DEBUG_ASSOC ( priv , ""STA<S2SV_blank>id<S2SV_blank>%u<S2SV_blank>addr<S2SV_blank>%pM<S2SV_blank>already<S2SV_blank>present<S2SV_blank>in<S2SV_blank>uCode<S2SV_blank>"" ""(according<S2SV_blank>to<S2SV_blank>driver)\\n"" , sta_id , priv -> stations [ sta_id ] . sta . sta . addr ) ; } else { priv -> stations [ sta_id ] . used |= IWL_STA_UCODE_ACTIVE ; IWL_DEBUG_ASSOC ( priv , ""Added<S2SV_blank>STA<S2SV_blank>id<S2SV_blank>%u<S2SV_blank>addr<S2SV_blank>%pM<S2SV_blank>to<S2SV_blank>uCode\\n"" , sta_id , priv -> stations [ sta_id ] . sta . sta . addr ) ; } <S2SV_StartBug> } <S2SV_EndBug>","<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> iwl_sta_ucode_activate ( struct <S2SV_ModStart> sta_id ) { if ( sta_id >= IWLAGN_STATION_COUNT ) { IWL_ERR ( priv , ""invalid<S2SV_blank>sta_id<S2SV_blank>%u"" , sta_id ) ; return - EINVAL ; } <S2SV_ModStart> ) ; } return 0 ;",torvalds@linux/2da424b0773cea3db47e1e81db71eeebde8269d4,CVE-2012-6712,https://github.com/torvalds/linux/commit/2da424b0773cea3db47e1e81db71eeebde8269d4,2019-07-27T22:15Z
CWE-125,"CWE-125 static void hid_input_field ( struct hid_device * hid , struct hid_field * field , __u8 * data , int interrupt ) { unsigned n ; unsigned count = field -> report_count ; unsigned offset = field -> report_offset ; unsigned size = field -> report_size ; __s32 min = field -> logical_minimum ; __s32 max = field -> logical_maximum ; __s32 * value ; value = kmalloc ( sizeof ( __s32 ) * count , GFP_ATOMIC ) ; if ( ! value ) return ; for ( n = 0 ; n < count ; n ++ ) { value [ n ] = min < 0 ? snto32 ( hid_field_extract ( hid , data , offset + n * size , size ) , size ) : hid_field_extract ( hid , data , offset + n * size , size ) ; if ( ! ( field -> flags & HID_MAIN_ITEM_VARIABLE ) && <S2SV_StartBug> value [ n ] >= min && value [ n ] <= max && <S2SV_EndBug> field -> usage [ value [ n ] - min ] . hid == HID_UP_KEYBOARD + 1 ) goto exit ; } for ( n = 0 ; n < count ; n ++ ) { if ( HID_MAIN_ITEM_VARIABLE & field -> flags ) { hid_process_event ( hid , field , & field -> usage [ n ] , value [ n ] , interrupt ) ; continue ; } if ( field -> value [ n ] >= min && field -> value [ n ] <= max <S2SV_StartBug> && field -> usage [ field -> value [ n ] - min ] . hid <S2SV_EndBug> && search ( value , field -> value [ n ] , count ) ) hid_process_event ( hid , field , & field -> usage [ field -> value [ n ] - min ] , 0 , interrupt ) ; if ( value [ n ] >= min && value [ n ] <= max <S2SV_StartBug> && field -> usage [ value [ n ] - min ] . hid <S2SV_EndBug> && search ( field -> value , value [ n ] , count ) ) hid_process_event ( hid , field , & field -> usage [ value [ n ] - min ] , 1 , interrupt ) ; } memcpy ( field -> value , value , count * sizeof ( __s32 ) ) ; exit : kfree ( value ) ; }",<S2SV_ModStart> ] <= max && value [ n ] - min < field -> maxusage <S2SV_ModStart> && field -> value [ n ] - min < field -> maxusage && field -> <S2SV_ModStart> <= max && value [ n ] - min < field -> maxusage &&,torvalds@linux/50220dead1650609206efe91f0cc116132d59b3f,CVE-2016-7915,https://github.com/torvalds/linux/commit/50220dead1650609206efe91f0cc116132d59b3f,2016-11-16T05:59Z
CWE-476,"CWE-476 static void srpt_handle_tsk_mgmt ( struct srpt_rdma_ch * ch , struct srpt_recv_ioctx * recv_ioctx , struct srpt_send_ioctx * send_ioctx ) { struct srp_tsk_mgmt * srp_tsk ; struct se_cmd * cmd ; struct se_session * sess = ch -> sess ; uint64_t unpacked_lun ; <S2SV_StartBug> uint32_t tag = 0 ; <S2SV_EndBug> int tcm_tmr ; int rc ; BUG_ON ( ! send_ioctx ) ; srp_tsk = recv_ioctx -> ioctx . buf ; cmd = & send_ioctx -> cmd ; pr_debug ( ""recv<S2SV_blank>tsk_mgmt<S2SV_blank>fn<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>task_tag<S2SV_blank>%lld<S2SV_blank>and<S2SV_blank>cmd<S2SV_blank>tag<S2SV_blank>%lld"" ""<S2SV_blank>cm_id<S2SV_blank>%p<S2SV_blank>sess<S2SV_blank>%p\\n"" , srp_tsk -> tsk_mgmt_func , srp_tsk -> task_tag , srp_tsk -> tag , ch -> cm_id , ch -> sess ) ; srpt_set_cmd_state ( send_ioctx , SRPT_STATE_MGMT ) ; send_ioctx -> cmd . tag = srp_tsk -> tag ; tcm_tmr = srp_tmr_to_tcm ( srp_tsk -> tsk_mgmt_func ) ; <S2SV_StartBug> if ( tcm_tmr < 0 ) { <S2SV_EndBug> send_ioctx -> cmd . se_tmr_req -> response = TMR_TASK_MGMT_FUNCTION_NOT_SUPPORTED ; goto fail ; } unpacked_lun = srpt_unpack_lun ( ( uint8_t * ) & srp_tsk -> lun , sizeof ( srp_tsk -> lun ) ) ; if ( srp_tsk -> tsk_mgmt_func == SRP_TSK_ABORT_TASK ) { <S2SV_StartBug> rc = srpt_rx_mgmt_fn_tag ( send_ioctx , srp_tsk -> task_tag ) ; <S2SV_EndBug> if ( rc < 0 ) { send_ioctx -> cmd . se_tmr_req -> response = TMR_TASK_DOES_NOT_EXIST ; goto fail ; } tag = srp_tsk -> task_tag ; } rc = target_submit_tmr ( & send_ioctx -> cmd , sess , NULL , unpacked_lun , srp_tsk , tcm_tmr , GFP_KERNEL , tag , TARGET_SCF_ACK_KREF ) ; if ( rc != 0 ) { send_ioctx -> cmd . se_tmr_req -> response = TMR_FUNCTION_REJECTED ; goto fail ; } return ; fail : transport_send_check_condition_and_sense ( cmd , 0 , 0 ) ; }","<S2SV_ModStart> uint64_t unpacked_lun ; <S2SV_ModEnd> int tcm_tmr ; <S2SV_ModStart> tsk_mgmt_func ) ; unpacked_lun = srpt_unpack_lun ( ( uint8_t * ) & srp_tsk -> lun , sizeof ( srp_tsk -> lun ) ) ; rc = target_submit_tmr ( & send_ioctx -> cmd , sess , NULL , unpacked_lun , srp_tsk , tcm_tmr , GFP_KERNEL <S2SV_ModEnd> , srp_tsk -> <S2SV_ModStart> srp_tsk -> task_tag <S2SV_ModEnd> , TARGET_SCF_ACK_KREF )",torvalds@linux/51093254bf879bc9ce96590400a87897c7498463,CVE-2016-6327,https://github.com/torvalds/linux/commit/51093254bf879bc9ce96590400a87897c7498463,2016-10-16T21:59Z
CWE-362,"CWE-362 int insn_get_code_seg_params ( struct pt_regs * regs ) { <S2SV_StartBug> struct desc_struct * desc ; <S2SV_EndBug> short sel ; if ( v8086_mode ( regs ) ) return INSN_CODE_SEG_PARAMS ( 2 , 2 ) ; sel = get_segment_selector ( regs , INAT_SEG_REG_CS ) ; if ( sel < 0 ) return sel ; <S2SV_StartBug> desc = get_desc ( sel ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! desc ) <S2SV_EndBug> return - EINVAL ; <S2SV_StartBug> if ( ! ( desc -> type & BIT ( 3 ) ) ) <S2SV_EndBug> return - EINVAL ; <S2SV_StartBug> switch ( ( desc -> l << 1 ) | desc -> d ) { <S2SV_EndBug> case 0 : return INSN_CODE_SEG_PARAMS ( 2 , 2 ) ; case 1 : return INSN_CODE_SEG_PARAMS ( 4 , 4 ) ; case 2 : return INSN_CODE_SEG_PARAMS ( 4 , 8 ) ; case 3 : default : return - EINVAL ; } }","<S2SV_ModStart> { struct desc_struct <S2SV_ModEnd> desc ; short <S2SV_ModStart> return sel ; <S2SV_ModEnd> if ( ! <S2SV_ModStart> if ( ! get_desc ( & desc , sel ) <S2SV_ModEnd> ) return - <S2SV_ModStart> ! ( desc . <S2SV_ModEnd> type & BIT <S2SV_ModStart> ( ( desc . <S2SV_ModEnd> l << 1 <S2SV_ModStart> ) | desc . <S2SV_ModEnd> d ) {",torvalds@linux/de9f869616dd95e95c00bdd6b0fcd3421e8a4323,CVE-2019-13233,https://github.com/torvalds/linux/commit/de9f869616dd95e95c00bdd6b0fcd3421e8a4323,2019-07-04T13:15Z
CWE-119,"CWE-119 <S2SV_StartBug> static vpx_codec_err_t ctrl_set_svc ( vpx_codec_alg_priv_t * ctx , int ctr_id , <S2SV_EndBug> va_list args ) { int data = va_arg ( args , int ) ; const vpx_codec_enc_cfg_t * cfg = & ctx -> cfg ; vp9_set_svc ( ctx -> cpi , data ) ; if ( data == 1 && <S2SV_StartBug> ( cfg -> rc_end_usage == VPX_CBR || <S2SV_EndBug> cfg -> g_pass == VPX_RC_FIRST_PASS || cfg -> g_pass == VPX_RC_LAST_PASS ) && cfg -> ss_number_layers > 1 && cfg -> ts_number_layers > 1 ) { return VPX_CODEC_INVALID_PARAM ; } return VPX_CODEC_OK ; }","<S2SV_ModStart> * ctx , <S2SV_ModEnd> va_list args ) <S2SV_ModStart> ( cfg -> <S2SV_ModEnd> g_pass == VPX_RC_FIRST_PASS",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-190,"CWE-190 void * <S2SV_StartBug> xmalloc ( size_t size ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> void * ptr = malloc ( size ) ; <S2SV_EndBug> if ( ! ptr && ( size != 0 ) ) { perror ( ""xmalloc:<S2SV_blank>Memory<S2SV_blank>allocation<S2SV_blank>failure"" ) ; abort ( ) ; } return ptr ; }","<S2SV_ModStart> xmalloc ( size_t num , size_t <S2SV_ModStart> size ) { size_t res ; if ( check_mul_overflow ( num , size , & res ) ) abort ( ) ; <S2SV_ModStart> = malloc ( res <S2SV_ModEnd> ) ; if",verdammelt@tnef/c5044689e50039635e7700fe2472fd632ac77176,CVE-2017-6308,https://github.com/verdammelt/tnef/commit/c5044689e50039635e7700fe2472fd632ac77176,2017-02-24T04:59Z
,"CWE-000 void sas_deform_port ( struct asd_sas_phy * phy , int gone ) { struct sas_ha_struct * sas_ha = phy -> ha ; struct asd_sas_port * port = phy -> port ; struct sas_internal * si = to_sas_internal ( sas_ha -> core . shost -> transportt ) ; struct domain_device * dev ; unsigned long flags ; if ( ! port ) return ; dev = port -> port_dev ; if ( dev ) dev -> pathways -- ; if ( port -> num_phys == 1 ) { sas_unregister_domain_devices ( port , gone ) ; <S2SV_StartBug> sas_port_delete ( port -> port ) ; <S2SV_EndBug> port -> port = NULL ; } else { sas_port_delete_phy ( port -> port , phy -> phy ) ; sas_device_set_phy ( dev , port -> port ) ; } if ( si -> dft -> lldd_port_deformed ) si -> dft -> lldd_port_deformed ( phy ) ; spin_lock_irqsave ( & sas_ha -> phy_port_lock , flags ) ; spin_lock ( & port -> phy_list_lock ) ; list_del_init ( & phy -> port_phy_el ) ; sas_phy_set_target ( phy , NULL ) ; phy -> port = NULL ; port -> num_phys -- ; port -> phy_mask &= ~ ( 1U << phy -> id ) ; if ( port -> num_phys == 0 ) { INIT_LIST_HEAD ( & port -> phy_list ) ; memset ( port -> sas_addr , 0 , SAS_ADDR_SIZE ) ; memset ( port -> attached_sas_addr , 0 , SAS_ADDR_SIZE ) ; port -> class = 0 ; port -> iproto = 0 ; port -> tproto = 0 ; port -> oob_mode = 0 ; port -> phy_mask = 0 ; } spin_unlock ( & port -> phy_list_lock ) ; spin_unlock_irqrestore ( & sas_ha -> phy_port_lock , flags ) ; return ; }",<S2SV_ModStart> gone ) ; sas_destruct_devices ( port ) ;,torvalds@linux/0558f33c06bb910e2879e355192227a8e8f0219d,CVE-2017-18232,https://github.com/torvalds/linux/commit/0558f33c06bb910e2879e355192227a8e8f0219d,2018-03-15T04:29Z
CWE-617,"CWE-000 static int pci_emul_mem_handler ( struct vmctx * ctx , int vcpu , int dir , uint64_t addr , int size , uint64_t * val , void * arg1 , long arg2 ) { struct pci_vdev * pdi = arg1 ; struct pci_vdev_ops * ops = pdi -> dev_ops ; uint64_t offset ; int bidx = ( int ) arg2 ; <S2SV_StartBug> assert ( bidx <= PCI_BARMAX ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( pdi -> bar [ bidx ] . type == PCIBAR_MEM32 || <S2SV_EndBug> <S2SV_StartBug> pdi -> bar [ bidx ] . type == PCIBAR_MEM64 ) ; <S2SV_EndBug> assert ( addr >= pdi -> bar [ bidx ] . addr && addr + size <= pdi -> bar [ bidx ] . addr + pdi -> bar [ bidx ] . size ) ; offset = addr - pdi -> bar [ bidx ] . addr ; if ( dir == MEM_F_WRITE ) { if ( size == 8 ) { ( * ops -> vdev_barwrite ) ( ctx , vcpu , pdi , bidx , offset , 4 , * val & 0xffffffff ) ; ( * ops -> vdev_barwrite ) ( ctx , vcpu , pdi , bidx , offset + 4 , 4 , * val >> 32 ) ; } else { ( * ops -> vdev_barwrite ) ( ctx , vcpu , pdi , bidx , offset , size , bar_value ( size , * val ) ) ; } } else { if ( size == 8 ) { uint64_t val_lo , val_hi ; val_lo = ( * ops -> vdev_barread ) ( ctx , vcpu , pdi , bidx , offset , 4 ) ; val_lo = bar_value ( 4 , val_lo ) ; val_hi = ( * ops -> vdev_barread ) ( ctx , vcpu , pdi , bidx , offset + 4 , 4 ) ; * val = val_lo | ( val_hi << 32 ) ; } else { * val = ( * ops -> vdev_barread ) ( ctx , vcpu , pdi , bidx , offset , size ) ; * val = bar_value ( size , * val ) ; } } return 0 ; }","<S2SV_ModStart> ) arg2 ; if ( addr + size > <S2SV_ModEnd> pdi -> bar <S2SV_ModStart> bidx ] . addr + <S2SV_ModEnd> pdi -> bar <S2SV_ModStart> bidx ] . size ) { pr_err ( ""%s,<S2SV_blank>Out<S2SV_blank>of<S2SV_blank>emulated<S2SV_blank>memory<S2SV_blank>range\\n"" , __func__ ) ; return - ESRCH ; } <S2SV_ModEnd> offset = addr",projectacrn@acrn-hypervisor/2b3dedfb9ba13f15887f22b935d373f36c9a59fa,CVE-2019-18844,https://github.com/projectacrn/acrn-hypervisor/commit/2b3dedfb9ba13f15887f22b935d373f36c9a59fa,2019-11-13T20:15Z
CWE-119,"CWE-119 void vp9_get_tile_n_bits ( int mi_cols , int * min_log2_tile_cols , int * max_log2_tile_cols ) { <S2SV_StartBug> const int sb_cols = mi_cols_aligned_to_sb ( mi_cols ) >> MI_BLOCK_SIZE_LOG2 ; <S2SV_EndBug> <S2SV_StartBug> int min_log2 = 0 , max_log2 = 0 ; <S2SV_EndBug> while ( ( sb_cols >> max_log2 ) >= MIN_TILE_WIDTH_B64 ) ++ max_log2 ; -- max_log2 ; if ( max_log2 < 0 ) max_log2 = 0 ; while ( ( MAX_TILE_WIDTH_B64 << min_log2 ) < sb_cols ) ++ min_log2 ; assert ( min_log2 <= max_log2 ) ; <S2SV_StartBug> * min_log2_tile_cols = min_log2 ; <S2SV_EndBug> <S2SV_StartBug> * max_log2_tile_cols = max_log2 ; <S2SV_EndBug> }",<S2SV_ModStart> { const int sb64_cols <S2SV_ModEnd> = mi_cols_aligned_to_sb ( <S2SV_ModStart> >> MI_BLOCK_SIZE_LOG2 ; <S2SV_ModEnd> * min_log2_tile_cols = <S2SV_ModStart> * min_log2_tile_cols = get_min_log2_tile_cols ( sb64_cols ) <S2SV_ModEnd> ; * max_log2_tile_cols <S2SV_ModStart> * max_log2_tile_cols = get_max_log2_tile_cols ( sb64_cols ) ; assert ( * min_log2_tile_cols <= * max_log2_tile_cols ) <S2SV_ModEnd> ; } <S2SV_null>,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-119,"CWE-119 static void filter_selectively_vert ( uint8_t * s , int pitch , unsigned int mask_16x16 , unsigned int mask_8x8 , unsigned int mask_4x4 , unsigned int mask_4x4_int , const loop_filter_info_n * lfi_n , const uint8_t * lfl ) { unsigned int mask ; for ( mask = mask_16x16 | mask_8x8 | mask_4x4 | mask_4x4_int ; mask ; mask >>= 1 ) { const loop_filter_thresh * lfi = lfi_n -> lfthr + * lfl ; if ( mask & 1 ) { if ( mask_16x16 & 1 ) { <S2SV_StartBug> vp9_lpf_vertical_16 ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr ) ; <S2SV_EndBug> } else if ( mask_8x8 & 1 ) { <S2SV_StartBug> vp9_lpf_vertical_8 ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ; <S2SV_EndBug> } else if ( mask_4x4 & 1 ) { <S2SV_StartBug> vp9_lpf_vertical_4 ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ; <S2SV_EndBug> } } if ( mask_4x4_int & 1 ) vp9_lpf_vertical_4 ( s + 4 , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ; s += 8 ; lfl += 1 ; mask_16x16 >>= 1 ; mask_8x8 >>= 1 ; mask_4x4 >>= 1 ; mask_4x4_int >>= 1 ; } }","<S2SV_ModStart> 1 ) { vpx_lpf_vertical_16 <S2SV_ModEnd> ( s , <S2SV_ModStart> 1 ) { vpx_lpf_vertical_8 <S2SV_ModEnd> ( s , <S2SV_ModStart> 1 ) { vpx_lpf_vertical_4 ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ; } } if ( mask_4x4_int & 1 ) vpx_lpf_vertical_4 <S2SV_ModEnd> ( s +",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-125,"CWE-125 static arg_ty ast_for_arg ( struct compiling * c , const node * n ) { identifier name ; expr_ty annotation = NULL ; node * ch ; arg_ty ret ; assert ( TYPE ( n ) == tfpdef || TYPE ( n ) == vfpdef ) ; ch = CHILD ( n , 0 ) ; name = NEW_IDENTIFIER ( ch ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , ch , 0 ) ) return NULL ; if ( NCH ( n ) == 3 && TYPE ( CHILD ( n , 1 ) ) == COLON ) { annotation = ast_for_expr ( c , CHILD ( n , 2 ) ) ; if ( ! annotation ) return NULL ; } <S2SV_StartBug> ret = arg ( name , annotation , LINENO ( n ) , n -> n_col_offset , <S2SV_EndBug> n -> n_end_lineno , n -> n_end_col_offset , c -> c_arena ) ; if ( ! ret ) return NULL ; return ret ; }","<S2SV_ModStart> , annotation , NULL ,",python@typed_ast/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,CVE-2019-19275,https://github.com/python/typed_ast/commit/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,2019-11-26T15:15Z
CWE-200,"CWE-200 static int pptp_bind ( struct socket * sock , struct sockaddr * uservaddr , int sockaddr_len ) { struct sock * sk = sock -> sk ; struct sockaddr_pppox * sp = ( struct sockaddr_pppox * ) uservaddr ; struct pppox_sock * po = pppox_sk ( sk ) ; struct pptp_opt * opt = & po -> proto . pptp ; int error = 0 ; <S2SV_StartBug> lock_sock ( sk ) ; <S2SV_EndBug> opt -> src_addr = sp -> sa_addr . pptp ; if ( add_chan ( po ) ) error = - EBUSY ; release_sock ( sk ) ; return error ; }",<S2SV_ModStart> = 0 ; if ( sockaddr_len < sizeof ( struct sockaddr_pppox ) ) return - EINVAL ;,torvalds@linux/09ccfd238e5a0e670d8178cf50180ea81ae09ae1,CVE-2015-8569,https://github.com/torvalds/linux/commit/09ccfd238e5a0e670d8178cf50180ea81ae09ae1,2015-12-28T11:59Z
,"CWE-000 static int em_syscall ( struct x86_emulate_ctxt * ctxt ) { struct x86_emulate_ops * ops = ctxt -> ops ; struct desc_struct cs , ss ; u64 msr_data ; u16 cs_sel , ss_sel ; u64 efer = 0 ; if ( ctxt -> mode == X86EMUL_MODE_REAL || ctxt -> mode == X86EMUL_MODE_VM86 ) return emulate_ud ( ctxt ) ; <S2SV_StartBug> ops -> get_msr ( ctxt , MSR_EFER , & efer ) ; <S2SV_EndBug> <S2SV_StartBug> setup_syscalls_segments ( ctxt , & cs , & ss ) ; <S2SV_EndBug> ops -> get_msr ( ctxt , MSR_STAR , & msr_data ) ; msr_data >>= 32 ; cs_sel = ( u16 ) ( msr_data & 0xfffc ) ; ss_sel = ( u16 ) ( msr_data + 8 ) ; if ( efer & EFER_LMA ) { cs . d = 0 ; cs . l = 1 ; } ops -> set_segment ( ctxt , cs_sel , & cs , 0 , VCPU_SREG_CS ) ; ops -> set_segment ( ctxt , ss_sel , & ss , 0 , VCPU_SREG_SS ) ; ctxt -> regs [ VCPU_REGS_RCX ] = ctxt -> _eip ; if ( efer & EFER_LMA ) { # ifdef CONFIG_X86_64 ctxt -> regs [ VCPU_REGS_R11 ] = ctxt -> eflags & ~ EFLG_RF ; ops -> get_msr ( ctxt , ctxt -> mode == X86EMUL_MODE_PROT64 ? MSR_LSTAR : MSR_CSTAR , & msr_data ) ; ctxt -> _eip = msr_data ; ops -> get_msr ( ctxt , MSR_SYSCALL_MASK , & msr_data ) ; ctxt -> eflags &= ~ ( msr_data | EFLG_RF ) ; # endif } else { ops -> get_msr ( ctxt , MSR_STAR , & msr_data ) ; ctxt -> _eip = ( u32 ) msr_data ; ctxt -> eflags &= ~ ( EFLG_VM | EFLG_IF | EFLG_RF ) ; } return X86EMUL_CONTINUE ; }","<S2SV_ModStart> ctxt ) ; if ( ! ( em_syscall_is_enabled ( ctxt ) ) ) return emulate_ud ( ctxt ) ; <S2SV_ModStart> , & ss ) ; if ( ! ( efer & EFER_SCE ) ) return emulate_ud ( ctxt",torvalds@linux/c2226fc9e87ba3da060e47333657cd6616652b84,CVE-2012-0045,https://github.com/torvalds/linux/commit/c2226fc9e87ba3da060e47333657cd6616652b84,2012-07-03T16:40Z
CWE-119,"CWE-119 static void open_output_file ( struct stream_state * stream , <S2SV_StartBug> struct VpxEncoderConfig * global ) { <S2SV_EndBug> const char * fn = stream -> config . out_fn ; const struct vpx_codec_enc_cfg * const cfg = & stream -> config . cfg ; if ( cfg -> g_pass == VPX_RC_FIRST_PASS ) return ; stream -> file = strcmp ( fn , ""-"" ) ? fopen ( fn , ""wb"" ) : set_binary_mode ( stdout ) ; if ( ! stream -> file ) fatal ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>output<S2SV_blank>file"" ) ; if ( stream -> config . write_webm && fseek ( stream -> file , 0 , SEEK_CUR ) ) fatal ( ""WebM<S2SV_blank>output<S2SV_blank>to<S2SV_blank>pipes<S2SV_blank>not<S2SV_blank>supported."" ) ; # if CONFIG_WEBM_IO if ( stream -> config . write_webm ) { stream -> ebml . stream = stream -> file ; write_webm_file_header ( & stream -> ebml , cfg , & global -> framerate , stream -> config . stereo_fmt , <S2SV_StartBug> global -> codec -> fourcc ) ; <S2SV_EndBug> } # endif if ( ! stream -> config . write_webm ) { ivf_write_file_header ( stream -> file , cfg , global -> codec -> fourcc , 0 ) ; } }","<S2SV_ModStart> VpxEncoderConfig * global , const struct VpxRational * pixel_aspect_ratio <S2SV_ModStart> codec -> fourcc , pixel_aspect_ratio",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-78,CWE-000 bool all_tests ( ) { mu_run_test ( test_r_str_newf ) ; mu_run_test ( test_r_str_replace_char_once ) ; mu_run_test ( test_r_str_replace_char ) ; mu_run_test ( test_r_str_replace ) ; mu_run_test ( test_r_str_bits64 ) ; mu_run_test ( test_r_str_rwx ) ; mu_run_test ( test_r_str_rwx_i ) ; mu_run_test ( test_r_str_bool ) ; mu_run_test ( test_r_str_trim ) ; mu_run_test ( test_r_str_case ) ; mu_run_test ( test_r_str_split ) ; mu_run_test ( test_r_str_tokenize ) ; mu_run_test ( test_r_str_char_count ) ; mu_run_test ( test_r_str_word_count ) ; mu_run_test ( test_r_str_ichr ) ; mu_run_test ( test_r_str_lchr ) ; mu_run_test ( test_r_sub_str_lchr ) ; mu_run_test ( test_r_sub_str_rchr ) ; mu_run_test ( test_r_str_rchr ) ; mu_run_test ( test_r_str_ansi_len ) ; mu_run_test ( test_r_str_len_utf8_ansi ) ; mu_run_test ( test_r_str_utf8_charsize ) ; mu_run_test ( test_r_str_utf8_charsize_prev ) ; mu_run_test ( test_r_str_sanitize_sdb_key ) ; <S2SV_StartBug> mu_run_test ( test_r_str_unescape ) ; <S2SV_EndBug> mu_run_test ( test_r_str_constpool ) ; mu_run_test ( test_r_str_format_msvc_argv ) ; mu_run_test ( test_r_str_str_xy ) ; return tests_passed != tests_run ; },<S2SV_ModStart> ; mu_run_test ( test_r_str_escape_sh ) ; mu_run_test (,radareorg@radare2/04edfa82c1f3fa2bc3621ccdad2f93bdbf00e4f9,CVE-2020-15121,https://github.com/radareorg/radare2/commit/04edfa82c1f3fa2bc3621ccdad2f93bdbf00e4f9,2020-07-20T18:15Z
CWE-617,"CWE-000 void pci_lintr_request ( struct pci_vdev * dev ) { struct businfo * bi ; struct slotinfo * si ; int bestpin , bestcount , pin ; bi = pci_businfo [ dev -> bus ] ; <S2SV_StartBug> assert ( bi != NULL ) ; <S2SV_EndBug> si = & bi -> slotinfo [ dev -> slot ] ; bestpin = 0 ; bestcount = si -> si_intpins [ 0 ] . ii_count ; for ( pin = 1 ; pin < 4 ; pin ++ ) { if ( si -> si_intpins [ pin ] . ii_count < bestcount ) { bestpin = pin ; bestcount = si -> si_intpins [ pin ] . ii_count ; } } si -> si_intpins [ bestpin ] . ii_count ++ ; dev -> lintr . pin = bestpin + 1 ; pci_set_cfgdata8 ( dev , PCIR_INTPIN , bestpin + 1 ) ; }","<S2SV_ModStart> bus ] ; if ( bi == NULL ) { pr_err ( ""%s:<S2SV_blank>pci<S2SV_blank>[%s]<S2SV_blank>has<S2SV_blank>wrong<S2SV_blank>bus<S2SV_blank>%d<S2SV_blank>info!\\n"" , __func__ , dev -> name , dev -> bus ) ; return ; } <S2SV_ModEnd> si = &",projectacrn@acrn-hypervisor/2b3dedfb9ba13f15887f22b935d373f36c9a59fa,CVE-2019-18844,https://github.com/projectacrn/acrn-hypervisor/commit/2b3dedfb9ba13f15887f22b935d373f36c9a59fa,2019-11-13T20:15Z
CWE-119,"CWE-119 <S2SV_StartBug> static void extend_to_full_distribution ( vp9_prob * probs , vp9_prob p ) { <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( probs , vp9_pareto8_full [ p = 0 ? 0 : p - 1 ] , <S2SV_EndBug> <S2SV_StartBug> MODEL_NODES * sizeof ( vp9_prob ) ) ; <S2SV_EndBug> }","<S2SV_ModStart> void extend_to_full_distribution ( vpx_prob <S2SV_ModEnd> * probs , <S2SV_ModStart> * probs , vpx_prob <S2SV_ModEnd> p ) { <S2SV_ModStart> p ) { memcpy <S2SV_ModEnd> ( probs , <S2SV_ModStart> * sizeof ( vpx_prob <S2SV_ModEnd> ) ) ;",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-264,"CWE-264 static void mark_screen_rdonly ( struct mm_struct * mm ) { pgd_t * pgd ; pud_t * pud ; pmd_t * pmd ; pte_t * pte ; spinlock_t * ptl ; int i ; <S2SV_StartBug> pgd = pgd_offset ( mm , 0xA0000 ) ; <S2SV_EndBug> if ( pgd_none_or_clear_bad ( pgd ) ) goto out ; pud = pud_offset ( pgd , 0xA0000 ) ; if ( pud_none_or_clear_bad ( pud ) ) goto out ; pmd = pmd_offset ( pud , 0xA0000 ) ; split_huge_page_pmd ( mm , pmd ) ; if ( pmd_none_or_clear_bad ( pmd ) ) goto out ; pte = pte_offset_map_lock ( mm , pmd , 0xA0000 , & ptl ) ; for ( i = 0 ; i < 32 ; i ++ ) { if ( pte_present ( * pte ) ) set_pte ( pte , pte_wrprotect ( * pte ) ) ; pte ++ ; } pte_unmap_unlock ( pte , ptl ) ; out : <S2SV_StartBug> flush_tlb ( ) ; <S2SV_EndBug> }",<S2SV_ModStart> int i ; down_write ( & mm -> mmap_sem ) ; <S2SV_ModStart> ; out : up_write ( & mm -> mmap_sem ) ;,torvalds@linux/4a1d704194a441bf83c636004a479e01360ec850,CVE-2012-1179,https://github.com/torvalds/linux/commit/4a1d704194a441bf83c636004a479e01360ec850,2012-05-17T11:00Z
CWE-119,"CWE-119 <S2SV_StartBug> static void inc_mvs ( const MB_MODE_INFO * mbmi , const int_mv mvs [ 2 ] , <S2SV_EndBug> nmv_context_counts * counts ) { int i ; for ( i = 0 ; i < 1 + has_second_ref ( mbmi ) ; ++ i ) { <S2SV_StartBug> const MV * ref = & mbmi -> ref_mvs [ mbmi -> ref_frame [ i ] ] [ 0 ] . as_mv ; <S2SV_EndBug> const MV diff = { mvs [ i ] . as_mv . row - ref -> row , mvs [ i ] . as_mv . col - ref -> col } ; vp9_inc_mv ( & diff , counts ) ; } }","<S2SV_ModStart> * mbmi , const MB_MODE_INFO_EXT * mbmi_ext , <S2SV_ModStart> ref = & mbmi_ext <S2SV_ModEnd> -> ref_mvs [",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-399,"CWE-399 void xsltGenerateIdFunction ( xmlXPathParserContextPtr ctxt , int nargs ) { <S2SV_StartBug> xmlNodePtr cur = NULL ; <S2SV_EndBug> long val ; xmlChar str [ 30 ] ; xmlDocPtr doc ; if ( nargs == 0 ) { cur = ctxt -> context -> node ; } else if ( nargs == 1 ) { <S2SV_StartBug> xmlXPathObjectPtr obj ; <S2SV_EndBug> xmlNodeSetPtr nodelist ; int i , ret ; if ( ( ctxt -> value == NULL ) || ( ctxt -> value -> type != XPATH_NODESET ) ) { ctxt -> error = XPATH_INVALID_TYPE ; xsltTransformError ( xsltXPathGetTransformContext ( ctxt ) , NULL , NULL , ""generate-id()<S2SV_blank>:<S2SV_blank>invalid<S2SV_blank>arg<S2SV_blank>expecting<S2SV_blank>a<S2SV_blank>node-set\\n"" ) ; return ; } obj = valuePop ( ctxt ) ; nodelist = obj -> nodesetval ; if ( ( nodelist == NULL ) || ( nodelist -> nodeNr <= 0 ) ) { xmlXPathFreeObject ( obj ) ; valuePush ( ctxt , xmlXPathNewCString ( """" ) ) ; return ; } cur = nodelist -> nodeTab [ 0 ] ; for ( i = 1 ; i < nodelist -> nodeNr ; i ++ ) { ret = xmlXPathCmpNodes ( cur , nodelist -> nodeTab [ i ] ) ; if ( ret == - 1 ) cur = nodelist -> nodeTab [ i ] ; } <S2SV_StartBug> xmlXPathFreeObject ( obj ) ; <S2SV_EndBug> } else { xsltTransformError ( xsltXPathGetTransformContext ( ctxt ) , NULL , NULL , ""generate-id()<S2SV_blank>:<S2SV_blank>invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>args<S2SV_blank>%d\\n"" , nargs ) ; ctxt -> error = XPATH_INVALID_ARITY ; return ; } if ( cur -> type != XML_NAMESPACE_DECL ) doc = cur -> doc ; else { xmlNsPtr ns = ( xmlNsPtr ) cur ; if ( ns -> context != NULL ) doc = ns -> context ; else doc = ctxt -> context -> doc ; } <S2SV_StartBug> val = ( long ) ( ( char * ) cur - ( char * ) doc ) ; <S2SV_EndBug> if ( val >= 0 ) { sprintf ( ( char * ) str , ""idp%ld"" , val ) ; } else { sprintf ( ( char * ) str , ""idm%ld"" , - val ) ; } valuePush ( ctxt , xmlXPathNewString ( str ) ) ; }",<S2SV_ModStart> { xmlNodePtr cur = NULL ; xmlXPathObjectPtr obj <S2SV_ModStart> 1 ) { <S2SV_ModEnd> xmlNodeSetPtr nodelist ; <S2SV_ModStart> ] ; } <S2SV_ModEnd> } else { <S2SV_ModStart> doc ; } if ( obj ) xmlXPathFreeObject ( obj ) ;,chromium@chromium/e741149a6b7872a2bf1f2b6cc0a56e836592fb77,CVE-2012-2870,https://github.com/chromium/chromium/commit/e741149a6b7872a2bf1f2b6cc0a56e836592fb77,2012-08-31T19:55Z
CWE-20,"CWE-20 static int sctp_getsockopt_assoc_stats ( struct sock * sk , int len , char __user * optval , int __user * optlen ) { struct sctp_assoc_stats sas ; struct sctp_association * asoc = NULL ; if ( len < sizeof ( sctp_assoc_t ) ) return - EINVAL ; <S2SV_StartBug> if ( copy_from_user ( & sas , optval , len ) ) <S2SV_EndBug> return - EFAULT ; asoc = sctp_id2assoc ( sk , sas . sas_assoc_id ) ; if ( ! asoc ) return - EINVAL ; sas . sas_rtxchunks = asoc -> stats . rtxchunks ; sas . sas_gapcnt = asoc -> stats . gapcnt ; sas . sas_outofseqtsns = asoc -> stats . outofseqtsns ; sas . sas_osacks = asoc -> stats . osacks ; sas . sas_isacks = asoc -> stats . isacks ; sas . sas_octrlchunks = asoc -> stats . octrlchunks ; sas . sas_ictrlchunks = asoc -> stats . ictrlchunks ; sas . sas_oodchunks = asoc -> stats . oodchunks ; sas . sas_iodchunks = asoc -> stats . iodchunks ; sas . sas_ouodchunks = asoc -> stats . ouodchunks ; sas . sas_iuodchunks = asoc -> stats . iuodchunks ; sas . sas_idupchunks = asoc -> stats . idupchunks ; sas . sas_opackets = asoc -> stats . opackets ; sas . sas_ipackets = asoc -> stats . ipackets ; sas . sas_maxrto = asoc -> stats . max_obs_rto ; memcpy ( & sas . sas_obs_rto_ipaddr , & asoc -> stats . obs_rto_ipaddr , sizeof ( struct sockaddr_storage ) ) ; asoc -> stats . max_obs_rto = asoc -> rto_min ; <S2SV_StartBug> len = min_t ( size_t , len , sizeof ( sas ) ) ; <S2SV_EndBug> if ( put_user ( len , optlen ) ) return - EFAULT ; SCTP_DEBUG_PRINTK ( ""sctp_getsockopt_assoc_stat(%d):<S2SV_blank>%d\\n"" , len , sas . sas_assoc_id ) ; if ( copy_to_user ( optval , & sas , len ) ) return - EFAULT ; return 0 ; }","<S2SV_ModStart> - EINVAL ; len = min_t ( size_t , len , sizeof ( sas ) ) ; <S2SV_ModStart> -> rto_min ; <S2SV_ModEnd> if ( put_user",torvalds@linux/726bc6b092da4c093eb74d13c07184b18c1af0f1,CVE-2013-1828,https://github.com/torvalds/linux/commit/726bc6b092da4c093eb74d13c07184b18c1af0f1,2013-03-22T11:59Z
CWE-125,"CWE-125 static expr_ty ast_for_call ( struct compiling * c , const node * n , expr_ty func ) { int i , nargs , nkeywords , ngens ; asdl_seq * args ; asdl_seq * keywords ; expr_ty vararg = NULL , kwarg = NULL ; REQ ( n , arglist ) ; nargs = 0 ; nkeywords = 0 ; ngens = 0 ; for ( i = 0 ; i < NCH ( n ) ; i ++ ) { node * ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == argument ) { if ( NCH ( ch ) == 1 ) nargs ++ ; else if ( TYPE ( CHILD ( ch , 1 ) ) == comp_for ) ngens ++ ; else nkeywords ++ ; } } if ( ngens > 1 || ( ngens && ( nargs || nkeywords ) ) ) { ast_error ( n , ""Generator<S2SV_blank>expression<S2SV_blank>must<S2SV_blank>be<S2SV_blank>parenthesized<S2SV_blank>"" ""if<S2SV_blank>not<S2SV_blank>sole<S2SV_blank>argument"" ) ; return NULL ; } if ( nargs + nkeywords + ngens > 255 ) { ast_error ( n , ""more<S2SV_blank>than<S2SV_blank>255<S2SV_blank>arguments"" ) ; return NULL ; } args = asdl_seq_new ( nargs + ngens , c -> c_arena ) ; if ( ! args ) return NULL ; keywords = asdl_seq_new ( nkeywords , c -> c_arena ) ; if ( ! keywords ) return NULL ; nargs = 0 ; nkeywords = 0 ; for ( i = 0 ; i < NCH ( n ) ; i ++ ) { node * ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == argument ) { expr_ty e ; if ( NCH ( ch ) == 1 ) { if ( nkeywords ) { ast_error ( CHILD ( ch , 0 ) , ""non-keyword<S2SV_blank>arg<S2SV_blank>after<S2SV_blank>keyword<S2SV_blank>arg"" ) ; return NULL ; } if ( vararg ) { ast_error ( CHILD ( ch , 0 ) , ""only<S2SV_blank>named<S2SV_blank>arguments<S2SV_blank>may<S2SV_blank>follow<S2SV_blank>*expression"" ) ; return NULL ; } e = ast_for_expr ( c , CHILD ( ch , 0 ) ) ; if ( ! e ) return NULL ; asdl_seq_SET ( args , nargs ++ , e ) ; } else if ( TYPE ( CHILD ( ch , 1 ) ) == comp_for ) { e = ast_for_genexp ( c , ch ) ; if ( ! e ) return NULL ; asdl_seq_SET ( args , nargs ++ , e ) ; } else { keyword_ty kw ; identifier key ; int k ; <S2SV_StartBug> char * tmp ; <S2SV_EndBug> e = ast_for_expr ( c , CHILD ( ch , 0 ) ) ; if ( ! e ) return NULL ; if ( e -> kind == Lambda_kind ) { ast_error ( CHILD ( ch , 0 ) , ""lambda<S2SV_blank>cannot<S2SV_blank>contain<S2SV_blank>assignment"" ) ; return NULL ; } else if ( e -> kind != Name_kind ) { ast_error ( CHILD ( ch , 0 ) , ""keyword<S2SV_blank>can\'t<S2SV_blank>be<S2SV_blank>an<S2SV_blank>expression"" ) ; return NULL ; } key = e -> v . Name . id ; if ( ! forbidden_check ( c , CHILD ( ch , 0 ) , PyUnicode_AsUTF8 ( key ) ) ) return NULL ; for ( k = 0 ; k < nkeywords ; k ++ ) { tmp = _PyUnicode_AsString ( ( ( keyword_ty ) asdl_seq_GET ( keywords , k ) ) -> arg ) ; if ( ! strcmp ( tmp , _PyUnicode_AsString ( key ) ) ) { ast_error ( CHILD ( ch , 0 ) , ""keyword<S2SV_blank>argument<S2SV_blank>repeated"" ) ; return NULL ; } } e = ast_for_expr ( c , CHILD ( ch , 2 ) ) ; if ( ! e ) return NULL ; kw = keyword ( key , e , c -> c_arena ) ; if ( ! kw ) return NULL ; asdl_seq_SET ( keywords , nkeywords ++ , kw ) ; } } else if ( TYPE ( ch ) == STAR ) { vararg = ast_for_expr ( c , CHILD ( n , i + 1 ) ) ; if ( ! vararg ) return NULL ; i ++ ; } else if ( TYPE ( ch ) == DOUBLESTAR ) { kwarg = ast_for_expr ( c , CHILD ( n , i + 1 ) ) ; if ( ! kwarg ) return NULL ; i ++ ; } } return Call ( func , args , keywords , vararg , kwarg , func -> lineno , func -> col_offset , c -> c_arena ) ; }",<S2SV_ModStart> int k ; const,python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z
CWE-59,"CWE-000 static int lxc_mount_auto_mounts ( struct lxc_conf * conf , int flags , struct lxc_handler * handler ) { int r ; size_t i ; static struct { int match_mask ; int match_flag ; const char * source ; const char * destination ; const char * fstype ; unsigned long flags ; const char * options ; } default_mounts [ ] = { { LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , ""proc"" , ""%r/proc"" , ""proc"" , MS_NODEV | MS_NOEXEC | MS_NOSUID , NULL } , <S2SV_StartBug> { LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , ""%r/proc/sys/net"" , ""%r/proc/net"" , NULL , MS_BIND , NULL } , <S2SV_EndBug> { LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , ""%r/proc/sys"" , ""%r/proc/sys"" , NULL , MS_BIND , NULL } , { LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , NULL , ""%r/proc/sys"" , NULL , MS_REMOUNT | MS_BIND | MS_RDONLY , NULL } , <S2SV_StartBug> { LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , ""%r/proc/net"" , ""%r/proc/sys/net"" , NULL , MS_MOVE , NULL } , <S2SV_EndBug> { LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , ""%r/proc/sysrq-trigger"" , ""%r/proc/sysrq-trigger"" , NULL , MS_BIND , NULL } , { LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , NULL , ""%r/proc/sysrq-trigger"" , NULL , MS_REMOUNT | MS_BIND | MS_RDONLY , NULL } , { LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_RW , ""proc"" , ""%r/proc"" , ""proc"" , MS_NODEV | MS_NOEXEC | MS_NOSUID , NULL } , { LXC_AUTO_SYS_MASK , LXC_AUTO_SYS_RW , ""sysfs"" , ""%r/sys"" , ""sysfs"" , 0 , NULL } , { LXC_AUTO_SYS_MASK , LXC_AUTO_SYS_RO , ""sysfs"" , ""%r/sys"" , ""sysfs"" , MS_RDONLY , NULL } , { LXC_AUTO_SYS_MASK , LXC_AUTO_SYS_MIXED , ""sysfs"" , ""%r/sys"" , ""sysfs"" , MS_NODEV | MS_NOEXEC | MS_NOSUID , NULL } , { LXC_AUTO_SYS_MASK , LXC_AUTO_SYS_MIXED , ""%r/sys"" , ""%r/sys"" , NULL , MS_BIND , NULL } , { LXC_AUTO_SYS_MASK , LXC_AUTO_SYS_MIXED , NULL , ""%r/sys"" , NULL , MS_REMOUNT | MS_BIND | MS_RDONLY , NULL } , { LXC_AUTO_SYS_MASK , LXC_AUTO_SYS_MIXED , ""sysfs"" , ""%r/sys/devices/virtual/net"" , ""sysfs"" , 0 , NULL } , { LXC_AUTO_SYS_MASK , LXC_AUTO_SYS_MIXED , ""%r/sys/devices/virtual/net/devices/virtual/net"" , ""%r/sys/devices/virtual/net"" , NULL , MS_BIND , NULL } , { LXC_AUTO_SYS_MASK , LXC_AUTO_SYS_MIXED , NULL , ""%r/sys/devices/virtual/net"" , NULL , MS_REMOUNT | MS_BIND | MS_NOSUID | MS_NODEV | MS_NOEXEC , NULL } , { 0 , 0 , NULL , NULL , NULL , 0 , NULL } } ; for ( i = 0 ; default_mounts [ i ] . match_mask ; i ++ ) { if ( ( flags & default_mounts [ i ] . match_mask ) == default_mounts [ i ] . match_flag ) { char * source = NULL ; char * destination = NULL ; int saved_errno ; unsigned long mflags ; if ( default_mounts [ i ] . source ) { source = lxc_string_replace ( ""%r"" , conf -> rootfs . path ? conf -> rootfs . mount : """" , default_mounts [ i ] . source ) ; if ( ! source ) { SYSERROR ( ""memory<S2SV_blank>allocation<S2SV_blank>error"" ) ; return - 1 ; } } if ( default_mounts [ i ] . destination ) { destination = lxc_string_replace ( ""%r"" , conf -> rootfs . path ? conf -> rootfs . mount : """" , default_mounts [ i ] . destination ) ; if ( ! destination ) { saved_errno = errno ; SYSERROR ( ""memory<S2SV_blank>allocation<S2SV_blank>error"" ) ; free ( source ) ; errno = saved_errno ; return - 1 ; } } mflags = add_required_remount_flags ( source , destination , default_mounts [ i ] . flags ) ; <S2SV_StartBug> r = mount ( source , destination , default_mounts [ i ] . fstype , mflags , default_mounts [ i ] . options ) ; <S2SV_EndBug> saved_errno = errno ; if ( r < 0 && errno == ENOENT ) { INFO ( ""Mount<S2SV_blank>source<S2SV_blank>or<S2SV_blank>target<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>doesn\'t<S2SV_blank>exist.<S2SV_blank>Skipping."" , source , destination ) ; r = 0 ; } else if ( r < 0 ) SYSERROR ( ""error<S2SV_blank>mounting<S2SV_blank>%s<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>flags<S2SV_blank>%lu"" , source , destination , mflags ) ; free ( source ) ; free ( destination ) ; if ( r < 0 ) { errno = saved_errno ; return - 1 ; } } } if ( flags & LXC_AUTO_CGROUP_MASK ) { int cg_flags ; cg_flags = flags & LXC_AUTO_CGROUP_MASK ; if ( cg_flags == LXC_AUTO_CGROUP_NOSPEC || cg_flags == LXC_AUTO_CGROUP_FULL_NOSPEC ) { int has_sys_admin = 0 ; if ( ! lxc_list_empty ( & conf -> keepcaps ) ) { has_sys_admin = in_caplist ( CAP_SYS_ADMIN , & conf -> keepcaps ) ; } else { has_sys_admin = ! in_caplist ( CAP_SYS_ADMIN , & conf -> caps ) ; } if ( cg_flags == LXC_AUTO_CGROUP_NOSPEC ) { cg_flags = has_sys_admin ? LXC_AUTO_CGROUP_RW : LXC_AUTO_CGROUP_MIXED ; } else { cg_flags = has_sys_admin ? LXC_AUTO_CGROUP_FULL_RW : LXC_AUTO_CGROUP_FULL_MIXED ; } } if ( ! cgroup_mount ( conf -> rootfs . path ? conf -> rootfs . mount : """" , handler , cg_flags ) ) { SYSERROR ( ""error<S2SV_blank>mounting<S2SV_blank>/sys/fs/cgroup"" ) ; return - 1 ; } } return 0 ; }","<S2SV_ModStart> , ""%r/proc/sys/net"" , ""%r/proc/tty"" <S2SV_ModEnd> , NULL , <S2SV_ModStart> , LXC_AUTO_PROC_MIXED , ""%r/proc/tty"" <S2SV_ModEnd> , ""%r/proc/sys/net"" , <S2SV_ModStart> ; r = safe_mount ( source , destination , default_mounts [ i ] . fstype , mflags , default_mounts [ i ] . options , conf -> rootfs . path ? conf -> rootfs . mount : NULL <S2SV_ModEnd> ) ; saved_errno",lxc@lxc/592fd47a6245508b79fe6ac819fe6d3b2c1289be,CVE-2015-1335,https://github.com/lxc/lxc/commit/592fd47a6245508b79fe6ac819fe6d3b2c1289be,2015-10-01T20:59Z
CWE-20,"CWE-20 uint16_t dm9000ReadPhyReg ( uint8_t address ) { <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_EPAR , 0x40 | address ) ; <S2SV_EndBug> <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_EPCR , EPCR_EPOS | EPCR_ERPRR ) ; <S2SV_EndBug> <S2SV_StartBug> while ( ( dm9000ReadReg ( DM9000_REG_EPCR ) & EPCR_ERRE ) != 0 ) <S2SV_EndBug> { } <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_EPCR , EPCR_EPOS ) ; <S2SV_EndBug> usleep ( 5 ) ; <S2SV_StartBug> return ( dm9000ReadReg ( DM9000_REG_EPDRH ) << 8 ) | dm9000ReadReg ( DM9000_REG_EPDRL ) ; <S2SV_EndBug> }","<S2SV_ModStart> { dm9000WriteReg ( DM9000_EPAR <S2SV_ModEnd> , 0x40 | <S2SV_ModStart> ; dm9000WriteReg ( DM9000_EPCR , DM9000_EPCR_EPOS | DM9000_EPCR_ERPRR <S2SV_ModEnd> ) ; while <S2SV_ModStart> ( dm9000ReadReg ( DM9000_EPCR ) & DM9000_EPCR_ERRE <S2SV_ModEnd> ) != 0 <S2SV_ModStart> } dm9000WriteReg ( DM9000_EPCR , DM9000_EPCR_EPOS <S2SV_ModEnd> ) ; usleep <S2SV_ModStart> ( dm9000ReadReg ( DM9000_EPDRH <S2SV_ModEnd> ) << 8 <S2SV_ModStart> | dm9000ReadReg ( DM9000_EPDRL <S2SV_ModEnd> ) ; }",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z
CWE-401,"CWE-000 static int nl80211_get_ftm_responder_stats ( struct sk_buff * skb , struct genl_info * info ) { struct cfg80211_registered_device * rdev = info -> user_ptr [ 0 ] ; struct net_device * dev = info -> user_ptr [ 1 ] ; struct wireless_dev * wdev = dev -> ieee80211_ptr ; struct cfg80211_ftm_responder_stats ftm_stats = { } ; struct sk_buff * msg ; void * hdr ; struct nlattr * ftm_stats_attr ; int err ; if ( wdev -> iftype != NL80211_IFTYPE_AP || ! wdev -> beacon_interval ) return - EOPNOTSUPP ; err = rdev_get_ftm_responder_stats ( rdev , dev , & ftm_stats ) ; if ( err ) return err ; if ( ! ftm_stats . filled ) return - ENODATA ; msg = nlmsg_new ( NLMSG_DEFAULT_SIZE , GFP_KERNEL ) ; if ( ! msg ) return - ENOMEM ; hdr = nl80211hdr_put ( msg , info -> snd_portid , info -> snd_seq , 0 , NL80211_CMD_GET_FTM_RESPONDER_STATS ) ; if ( ! hdr ) <S2SV_StartBug> return - ENOBUFS ; <S2SV_EndBug> if ( nla_put_u32 ( msg , NL80211_ATTR_IFINDEX , dev -> ifindex ) ) goto nla_put_failure ; ftm_stats_attr = nla_nest_start_noflag ( msg , NL80211_ATTR_FTM_RESPONDER_STATS ) ; if ( ! ftm_stats_attr ) goto nla_put_failure ; # define SET_FTM ( field , name , type ) do { if ( ( ftm_stats . filled & BIT ( NL80211_FTM_STATS_ ## name ) ) && nla_put_ ## type ( msg , NL80211_FTM_STATS_ ## name , ftm_stats . field ) ) goto nla_put_failure ; } while ( 0 ) # define SET_FTM_U64 ( field , name ) do { if ( ( ftm_stats . filled & BIT ( NL80211_FTM_STATS_ ## name ) ) && nla_put_u64_64bit ( msg , NL80211_FTM_STATS_ ## name , ftm_stats . field , NL80211_FTM_STATS_PAD ) ) goto nla_put_failure ; } while ( 0 ) SET_FTM ( success_num , SUCCESS_NUM , u32 ) ; SET_FTM ( partial_num , PARTIAL_NUM , u32 ) ; SET_FTM ( failed_num , FAILED_NUM , u32 ) ; SET_FTM ( asap_num , ASAP_NUM , u32 ) ; SET_FTM ( non_asap_num , NON_ASAP_NUM , u32 ) ; SET_FTM_U64 ( total_duration_ms , TOTAL_DURATION_MSEC ) ; SET_FTM ( unknown_triggers_num , UNKNOWN_TRIGGERS_NUM , u32 ) ; SET_FTM ( reschedule_requests_num , RESCHEDULE_REQUESTS_NUM , u32 ) ; SET_FTM ( out_of_window_triggers_num , OUT_OF_WINDOW_TRIGGERS_NUM , u32 ) ; # undef SET_FTM nla_nest_end ( msg , ftm_stats_attr ) ; genlmsg_end ( msg , hdr ) ; return genlmsg_reply ( msg , info ) ; nla_put_failure : nlmsg_free ( msg ) ; return - ENOBUFS ; }",<S2SV_ModStart> ! hdr ) goto nla_put_failure <S2SV_ModEnd> ; if (,torvalds@linux/1399c59fa92984836db90538cf92397fe7caaa57,CVE-2019-19055,https://github.com/torvalds/linux/commit/1399c59fa92984836db90538cf92397fe7caaa57,2019-11-18T06:15Z
CWE-416,"CWE-416 static void sig_server_connect_copy ( SERVER_CONNECT_REC * * dest , IRC_SERVER_CONNECT_REC * src ) { IRC_SERVER_CONNECT_REC * rec ; g_return_if_fail ( dest != NULL ) ; if ( ! IS_IRC_SERVER_CONNECT ( src ) ) return ; rec = g_new0 ( IRC_SERVER_CONNECT_REC , 1 ) ; rec -> chat_type = IRC_PROTOCOL ; rec -> max_cmds_at_once = src -> max_cmds_at_once ; rec -> cmd_queue_speed = src -> cmd_queue_speed ; rec -> max_query_chans = src -> max_query_chans ; rec -> max_kicks = src -> max_kicks ; rec -> max_modes = src -> max_modes ; rec -> max_msgs = src -> max_msgs ; rec -> max_whois = src -> max_whois ; rec -> usermode = g_strdup ( src -> usermode ) ; rec -> alternate_nick = g_strdup ( src -> alternate_nick ) ; rec -> sasl_mechanism = src -> sasl_mechanism ; <S2SV_StartBug> rec -> sasl_username = src -> sasl_username ; <S2SV_EndBug> <S2SV_StartBug> rec -> sasl_password = src -> sasl_password ; <S2SV_EndBug> * dest = ( SERVER_CONNECT_REC * ) rec ; }",<S2SV_ModStart> -> sasl_username = g_strdup ( <S2SV_ModStart> src -> sasl_username ) <S2SV_ModStart> -> sasl_password = g_strdup ( <S2SV_ModStart> src -> sasl_password ),irssi@irssi/d23b0d22cc611e43c88d99192a59f413f951a955,CVE-2019-13045,https://github.com/irssi/irssi/commit/d23b0d22cc611e43c88d99192a59f413f951a955,2019-06-29T14:15Z
CWE-362,"CWE-362 static int <S2SV_StartBug> mptctl_eventquery ( unsigned long arg ) <S2SV_EndBug> { struct mpt_ioctl_eventquery __user * uarg = ( void __user * ) arg ; <S2SV_StartBug> struct mpt_ioctl_eventquery karg ; <S2SV_EndBug> MPT_ADAPTER * ioc ; int iocnum ; if ( copy_from_user ( & karg , uarg , sizeof ( struct mpt_ioctl_eventquery ) ) ) { printk ( KERN_ERR MYNAM ""%s@%d::mptctl_eventquery<S2SV_blank>-<S2SV_blank>"" ""Unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>in<S2SV_blank>mpt_ioctl_eventquery<S2SV_blank>struct<S2SV_blank>@<S2SV_blank>%p\\n"" , __FILE__ , __LINE__ , uarg ) ; <S2SV_StartBug> return - EFAULT ; <S2SV_EndBug> } if ( ( ( iocnum = mpt_verify_adapter ( karg . hdr . iocnum , & ioc ) ) < 0 ) || ( ioc == NULL ) ) { printk ( KERN_DEBUG MYNAM ""%s::mptctl_eventquery()<S2SV_blank>@%d<S2SV_blank>-<S2SV_blank>ioc%d<S2SV_blank>not<S2SV_blank>found!\\n"" , __FILE__ , __LINE__ , iocnum ) ; return - ENODEV ; } dctlprintk ( ioc , printk ( MYIOC_s_DEBUG_FMT ""mptctl_eventquery<S2SV_blank>called.\\n"" , ioc -> name ) ) ; karg . eventEntries = MPTCTL_EVENT_LOG_SIZE ; karg . eventTypes = ioc -> eventTypes ; if ( copy_to_user ( ( char __user * ) arg , & karg , sizeof ( struct mpt_ioctl_eventquery ) ) ) { printk ( MYIOC_s_ERR_FMT ""%s@%d::mptctl_eventquery<S2SV_blank>-<S2SV_blank>"" ""Unable<S2SV_blank>to<S2SV_blank>write<S2SV_blank>out<S2SV_blank>mpt_ioctl_eventquery<S2SV_blank>struct<S2SV_blank>@<S2SV_blank>%p\\n"" , ioc -> name , __FILE__ , __LINE__ , uarg ) ; return - EFAULT ; } return 0 ; }","<S2SV_ModStart> int mptctl_eventquery ( MPT_ADAPTER * ioc , <S2SV_ModStart> struct mpt_ioctl_eventquery karg <S2SV_ModEnd> ; if ( <S2SV_ModStart> return - EFAULT <S2SV_ModEnd> ; } dctlprintk",torvalds@linux/28d76df18f0ad5bcf5fa48510b225f0ed262a99b,CVE-2020-12652,https://github.com/torvalds/linux/commit/28d76df18f0ad5bcf5fa48510b225f0ed262a99b,2020-05-05T05:15Z
CWE-119,"CWE-119 WORD32 ih264d_parse_nal_unit ( iv_obj_t * dec_hdl , ivd_video_decode_op_t * ps_dec_op , UWORD8 * pu1_buf , UWORD32 u4_length ) { dec_bit_stream_t * ps_bitstrm ; dec_struct_t * ps_dec = ( dec_struct_t * ) dec_hdl -> pv_codec_handle ; ivd_video_decode_ip_t * ps_dec_in = ( ivd_video_decode_ip_t * ) ps_dec -> pv_dec_in ; dec_slice_params_t * ps_cur_slice = ps_dec -> ps_cur_slice ; UWORD8 u1_first_byte , u1_nal_ref_idc ; UWORD8 u1_nal_unit_type ; WORD32 i_status = OK ; ps_bitstrm = ps_dec -> ps_bitstrm ; if ( pu1_buf ) { if ( u4_length ) { ps_dec_op -> u4_frame_decoded_flag = 0 ; ih264d_process_nal_unit ( ps_dec -> ps_bitstrm , pu1_buf , u4_length ) ; SWITCHOFFTRACE ; u1_first_byte = ih264d_get_bits_h264 ( ps_bitstrm , 8 ) ; if ( NAL_FORBIDDEN_BIT ( u1_first_byte ) ) { H264_DEC_DEBUG_PRINT ( ""\\nForbidden<S2SV_blank>bit<S2SV_blank>set<S2SV_blank>in<S2SV_blank>Nal<S2SV_blank>Unit,<S2SV_blank>Let\'s<S2SV_blank>try\\n"" ) ; } <S2SV_StartBug> u1_nal_unit_type = NAL_UNIT_TYPE ( u1_first_byte ) ; <S2SV_EndBug> ps_dec -> u1_nal_unit_type = u1_nal_unit_type ; u1_nal_ref_idc = ( UWORD8 ) ( NAL_REF_IDC ( u1_first_byte ) ) ; switch ( u1_nal_unit_type ) { case SLICE_DATA_PARTITION_A_NAL : case SLICE_DATA_PARTITION_B_NAL : case SLICE_DATA_PARTITION_C_NAL : if ( ! ps_dec -> i4_decode_header ) ih264d_parse_slice_partition ( ps_dec , ps_bitstrm ) ; break ; case IDR_SLICE_NAL : case SLICE_NAL : DEBUG_THREADS_PRINTF ( ""Decoding<S2SV_blank><S2SV_blank>a<S2SV_blank>slice<S2SV_blank>NAL\\n"" ) ; if ( ! ps_dec -> i4_decode_header ) { if ( ps_dec -> i4_header_decoded == 3 ) { ps_dec -> u4_slice_start_code_found = 1 ; ih264d_rbsp_to_sodb ( ps_dec -> ps_bitstrm ) ; i_status = ih264d_parse_decode_slice ( ( UWORD8 ) ( u1_nal_unit_type == IDR_SLICE_NAL ) , u1_nal_ref_idc , ps_dec ) ; if ( ( ps_dec -> u4_first_slice_in_pic != 0 ) && ( ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC ) == 0 ) ) { ps_dec -> u4_first_slice_in_pic = 1 ; } if ( i_status != OK ) { return i_status ; } } else { H264_DEC_DEBUG_PRINT ( ""\\nSlice<S2SV_blank>NAL<S2SV_blank>Supplied<S2SV_blank>but<S2SV_blank>no<S2SV_blank>header<S2SV_blank>has<S2SV_blank>been<S2SV_blank>supplied\\n"" ) ; } } break ; case SEI_NAL : if ( ! ps_dec -> i4_decode_header ) { ih264d_rbsp_to_sodb ( ps_dec -> ps_bitstrm ) ; i_status = ih264d_parse_sei_message ( ps_dec , ps_bitstrm ) ; if ( i_status != OK ) return i_status ; ih264d_parse_sei ( ps_dec , ps_bitstrm ) ; } break ; case SEQ_PARAM_NAL : ih264d_rbsp_to_sodb ( ps_dec -> ps_bitstrm ) ; i_status = ih264d_parse_sps ( ps_dec , ps_bitstrm ) ; if ( i_status == ERROR_INV_SPS_PPS_T ) return i_status ; if ( ! i_status ) ps_dec -> i4_header_decoded |= 0x1 ; break ; case PIC_PARAM_NAL : ih264d_rbsp_to_sodb ( ps_dec -> ps_bitstrm ) ; i_status = ih264d_parse_pps ( ps_dec , ps_bitstrm ) ; if ( i_status == ERROR_INV_SPS_PPS_T ) return i_status ; if ( ! i_status ) ps_dec -> i4_header_decoded |= 0x2 ; break ; case ACCESS_UNIT_DELIMITER_RBSP : if ( ! ps_dec -> i4_decode_header ) { ih264d_access_unit_delimiter_rbsp ( ps_dec ) ; } break ; case END_OF_STREAM_RBSP : if ( ! ps_dec -> i4_decode_header ) { ih264d_parse_end_of_stream ( ps_dec ) ; } break ; case FILLER_DATA_NAL : if ( ! ps_dec -> i4_decode_header ) { ih264d_parse_filler_data ( ps_dec , ps_bitstrm ) ; } break ; default : H264_DEC_DEBUG_PRINT ( ""\\nUnknown<S2SV_blank>NAL<S2SV_blank>type<S2SV_blank>%d\\n"" , u1_nal_unit_type ) ; break ; } } } return i_status ; }",<S2SV_ModStart> u1_first_byte ) ; if ( ( ps_dec -> u2_total_mbs_coded != 0 ) && ( u1_nal_unit_type > IDR_SLICE_NAL ) ) { return ERROR_INCOMPLETE_FRAME ; },external@libavc/a78887bcffbc2995cf9ed72e0697acf560875e9e,CVE-2016-3820,https://android.googlesource.com/platform/external/libavc/+/a78887bcffbc2995cf9ed72e0697acf560875e9e,2016-08-05T20:59Z
CWE-119,"CWE-119 static Image * ReadGRAYImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * canvas_image , * image ; MagickBooleanType status ; MagickOffsetType scene ; QuantumInfo * quantum_info ; QuantumType quantum_type ; size_t length ; ssize_t count , y ; unsigned char * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) ThrowReaderException ( OptionError , ""MustSpecifyImageSize"" ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } if ( DiscardBlobBytes ( image , ( size_t ) image -> offset ) == MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; SetImageColorspace ( image , GRAYColorspace ) ; canvas_image = CloneImage ( image , image -> extract_info . width , 1 , MagickFalse , exception ) ; ( void ) SetImageVirtualPixelMethod ( canvas_image , BlackVirtualPixelMethod ) ; quantum_type = GrayQuantum ; quantum_info = AcquireQuantumInfo ( image_info , canvas_image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixels = GetQuantumPixels ( quantum_info ) ; if ( image_info -> number_scenes != 0 ) while ( image -> scene < image_info -> scene ) { image -> scene ++ ; length = GetQuantumExtent ( canvas_image , quantum_info , quantum_type ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { count = ReadBlob ( image , length , pixels ) ; if ( count != ( ssize_t ) length ) break ; } } scene = 0 ; count = 0 ; length = 0 ; do { if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; <S2SV_StartBug> SetImageColorspace ( image , GRAYColorspace ) ; <S2SV_EndBug> if ( scene == 0 ) { length = GetQuantumExtent ( canvas_image , quantum_info , quantum_type ) ; count = ReadBlob ( image , length , pixels ) ; } for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { register const PixelPacket * restrict p ; register ssize_t x ; register PixelPacket * restrict q ; if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , quantum_info , quantum_type , pixels , exception ) ; if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) break ; if ( ( ( y - image -> extract_info . y ) >= 0 ) && ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) { p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , image -> columns , 1 , exception ) ; q = QueueAuthenticPixels ( image , 0 , y - image -> extract_info . y , image -> columns , 1 , exception ) ; if ( ( p == ( const PixelPacket * ) NULL ) || ( q == ( PixelPacket * ) NULL ) ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( q , GetPixelRed ( p ) ) ; SetPixelGreen ( q , GetPixelGreen ( p ) ) ; SetPixelBlue ( q , GetPixelBlue ( p ) ) ; p ++ ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } count = ReadBlob ( image , length , pixels ) ; } SetQuantumImageType ( image , quantum_type ) ; if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( count == ( ssize_t ) length ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } scene ++ ; } while ( count == ( ssize_t ) length ) ; quantum_info = DestroyQuantumInfo ( quantum_info ) ; InheritException ( & image -> exception , & canvas_image -> exception ) ; canvas_image = DestroyImage ( canvas_image ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }","<S2SV_ModStart> ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }",ImageMagick@ImageMagick/f6e9d0d9955e85bdd7540b251cd50d598dacc5e6,CVE-2016-10066,https://github.com/ImageMagick/ImageMagick/commit/f6e9d0d9955e85bdd7540b251cd50d598dacc5e6,2017-03-03T17:59Z
CWE-20,"CWE-20 void httpParseAuthorizationField ( HttpConnection * connection , char_t * value ) { char_t * p ; char_t * token ; token = osStrtok_r ( value , ""<S2SV_blank>\\t"" , & p ) ; if ( token == NULL ) { return ; } # if ( HTTP_SERVER_BASIC_AUTH_SUPPORT == ENABLED ) else if ( ! osStrcasecmp ( token , ""Basic"" ) ) { error_t error ; size_t n ; char_t * separator ; connection -> request . auth . mode = HTTP_AUTH_MODE_BASIC ; token = osStrtok_r ( NULL , ""<S2SV_blank>\\t"" , & p ) ; if ( token != NULL ) { error = base64Decode ( token , osStrlen ( token ) , token , & n ) ; if ( ! error ) { token [ n ] = '\\0' ; <S2SV_StartBug> separator = strchr ( token , ':' ) ; <S2SV_EndBug> if ( separator != NULL ) { * separator = '\\0' ; strSafeCopy ( connection -> request . auth . user , token , HTTP_SERVER_USERNAME_MAX_LEN ) ; token = separator + 1 ; connection -> request . auth . password = token ; } } } TRACE_DEBUG ( ""Authorization<S2SV_blank>header:\\r\\n"" ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>username:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . user ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>password:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . password ) ; } # endif # if ( HTTP_SERVER_DIGEST_AUTH_SUPPORT == ENABLED ) else if ( ! osStrcasecmp ( token , ""Digest"" ) ) { size_t n ; char_t * separator ; char_t * name ; connection -> request . auth . mode = HTTP_AUTH_MODE_DIGEST ; token = osStrtok_r ( NULL , "","" , & p ) ; while ( token != NULL ) { <S2SV_StartBug> separator = strchr ( token , '=' ) ; <S2SV_EndBug> if ( separator != NULL ) { * separator = '\\0' ; name = strTrimWhitespace ( token ) ; value = strTrimWhitespace ( separator + 1 ) ; n = osStrlen ( value ) ; if ( n > 0 && value [ n - 1 ] == \'\\""\' ) value [ n - 1 ] = '\\0' ; if ( value [ 0 ] == \'\\""\' ) value ++ ; if ( ! osStrcasecmp ( name , ""username"" ) ) { strSafeCopy ( connection -> request . auth . user , value , HTTP_SERVER_USERNAME_MAX_LEN ) ; } else if ( ! osStrcasecmp ( name , ""realm"" ) ) { connection -> request . auth . realm = value ; } else if ( ! osStrcasecmp ( name , ""nonce"" ) ) { connection -> request . auth . nonce = value ; } else if ( ! osStrcasecmp ( name , ""uri"" ) ) { connection -> request . auth . uri = value ; } else if ( ! osStrcasecmp ( name , ""qop"" ) ) { connection -> request . auth . qop = value ; } else if ( ! osStrcasecmp ( name , ""nc"" ) ) { connection -> request . auth . nc = value ; } else if ( ! osStrcasecmp ( name , ""cnonce"" ) ) { connection -> request . auth . cnonce = value ; } else if ( ! osStrcasecmp ( name , ""response"" ) ) { connection -> request . auth . response = value ; } else if ( ! osStrcasecmp ( name , ""opaque"" ) ) { connection -> request . auth . opaque = value ; } token = osStrtok_r ( NULL , "","" , & p ) ; } } TRACE_DEBUG ( ""Authorization<S2SV_blank>header:\\r\\n"" ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>username:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . user ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>realm:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . realm ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>nonce:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . nonce ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>uri:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . uri ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>qop:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . qop ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>nc:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . nc ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>cnonce:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . cnonce ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>response:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . response ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>opaque:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . opaque ) ; } # endif else { return ; } # if ( HTTP_SERVER_BASIC_AUTH_SUPPORT == ENABLED || HTTP_SERVER_DIGEST_AUTH_SUPPORT == ENABLED ) connection -> request . auth . found = TRUE ; if ( connection -> settings -> authCallback != NULL ) { connection -> status = connection -> settings -> authCallback ( connection , connection -> request . auth . user , connection -> request . uri ) ; } else { connection -> status = HTTP_ACCESS_ALLOWED ; } # endif }","<S2SV_ModStart> ; separator = osStrchr <S2SV_ModEnd> ( token , <S2SV_ModStart> { separator = osStrchr <S2SV_ModEnd> ( token ,",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z
CWE-119,"CWE-119 static int translate_hex_string ( char * s , char * saved_orphan ) { int c1 = * saved_orphan ; char * start = s ; char * t = s ; for ( ; * s ; s ++ ) { <S2SV_StartBug> if ( isspace ( * s ) ) <S2SV_EndBug> continue ; if ( c1 ) { * t ++ = ( hexval ( c1 ) << 4 ) + hexval ( * s ) ; c1 = 0 ; } else c1 = * s ; } * saved_orphan = c1 ; return t - start ; }",<S2SV_ModStart> ( isspace ( ( unsigned char ),kohler@t1utils/6b9d1aafcb61a3663c883663eb19ccdbfcde8d33,CVE-2015-3905,https://github.com/kohler/t1utils/commit/6b9d1aafcb61a3663c883663eb19ccdbfcde8d33,2015-06-08T14:59Z
CWE-119,"CWE-119 static void fwnet_receive_broadcast ( struct fw_iso_context * context , u32 cycle , size_t header_length , void * header , void * data ) { struct fwnet_device * dev ; struct fw_iso_packet packet ; __be16 * hdr_ptr ; __be32 * buf_ptr ; int retval ; u32 length ; <S2SV_StartBug> u16 source_node_id ; <S2SV_EndBug> u32 specifier_id ; u32 ver ; unsigned long offset ; unsigned long flags ; dev = data ; hdr_ptr = header ; length = be16_to_cpup ( hdr_ptr ) ; spin_lock_irqsave ( & dev -> lock , flags ) ; offset = dev -> rcv_buffer_size * dev -> broadcast_rcv_next_ptr ; buf_ptr = dev -> broadcast_rcv_buffer_ptrs [ dev -> broadcast_rcv_next_ptr ++ ] ; if ( dev -> broadcast_rcv_next_ptr == dev -> num_broadcast_rcv_ptrs ) dev -> broadcast_rcv_next_ptr = 0 ; spin_unlock_irqrestore ( & dev -> lock , flags ) ; <S2SV_StartBug> specifier_id = ( be32_to_cpu ( buf_ptr [ 0 ] ) & 0xffff ) << 8 <S2SV_EndBug> | ( be32_to_cpu ( buf_ptr [ 1 ] ) & 0xff000000 ) >> 24 ; ver = be32_to_cpu ( buf_ptr [ 1 ] ) & 0xffffff ; source_node_id = be32_to_cpu ( buf_ptr [ 0 ] ) >> 16 ; if ( specifier_id == IANA_SPECIFIER_ID && <S2SV_StartBug> ( ver == RFC2734_SW_VERSION <S2SV_EndBug> # if IS_ENABLED ( CONFIG_IPV6 ) <S2SV_StartBug> || ver == RFC3146_SW_VERSION <S2SV_EndBug> # endif <S2SV_StartBug> ) ) { <S2SV_EndBug> buf_ptr += 2 ; length -= IEEE1394_GASP_HDR_SIZE ; fwnet_incoming_packet ( dev , buf_ptr , length , source_node_id , context -> card -> generation , true ) ; <S2SV_StartBug> } <S2SV_EndBug> packet . payload_length = dev -> rcv_buffer_size ; packet . interrupt = 1 ; packet . skip = 0 ; packet . tag = 3 ; packet . sy = 0 ; packet . header_length = IEEE1394_GASP_HDR_SIZE ; spin_lock_irqsave ( & dev -> lock , flags ) ; retval = fw_iso_context_queue ( dev -> broadcast_rcv_context , & packet , & dev -> broadcast_rcv_buffer , offset ) ; spin_unlock_irqrestore ( & dev -> lock , flags ) ; if ( retval >= 0 ) fw_iso_context_queue_flush ( dev -> broadcast_rcv_context ) ; else dev_err ( & dev -> netdev -> dev , ""requeue<S2SV_blank>failed\\n"" ) ; }","<S2SV_ModStart> u32 length ; <S2SV_ModEnd> unsigned long offset <S2SV_ModStart> flags ) ; if ( length > IEEE1394_GASP_HDR_SIZE && gasp_specifier_id ( buf_ptr ) <S2SV_ModEnd> == IANA_SPECIFIER_ID && <S2SV_ModStart> IANA_SPECIFIER_ID && ( gasp_version ( buf_ptr ) <S2SV_ModEnd> == RFC2734_SW_VERSION # <S2SV_ModStart> CONFIG_IPV6 ) || gasp_version ( buf_ptr ) <S2SV_ModEnd> == RFC3146_SW_VERSION # <S2SV_ModStart> endif ) ) fwnet_incoming_packet ( dev , buf_ptr + 2 , length - IEEE1394_GASP_HDR_SIZE , gasp_source_id ( buf_ptr ) <S2SV_ModEnd> , context -> <S2SV_ModStart> true ) ; <S2SV_ModEnd> packet . payload_length",torvalds@linux/667121ace9dbafb368618dbabcf07901c962ddac,CVE-2016-8633,https://github.com/torvalds/linux/commit/667121ace9dbafb368618dbabcf07901c962ddac,2016-11-28T03:59Z
CWE-74,"CWE-000 static void child_setup_func ( gpointer user_data ) { ChildSetupData * data = ( ChildSetupData * ) user_data ; FdMapEntry * fd_map = data -> fd_map ; sigset_t set ; int i ; flatpak_close_fds_workaround ( 3 ) ; if ( data -> instance_id_fd != - 1 ) <S2SV_StartBug> drop_cloexec ( data -> instance_id_fd ) ; <S2SV_EndBug> sigemptyset ( & set ) ; if ( pthread_sigmask ( SIG_SETMASK , & set , NULL ) == - 1 ) { g_warning ( ""Failed<S2SV_blank>to<S2SV_blank>unblock<S2SV_blank>signals<S2SV_blank>when<S2SV_blank>starting<S2SV_blank>child"" ) ; return ; } for ( i = 1 ; i < NSIG ; i ++ ) { if ( i != SIGSTOP && i != SIGKILL ) signal ( i , SIG_DFL ) ; } for ( i = 0 ; i < data -> fd_map_len ; i ++ ) { if ( fd_map [ i ] . from != fd_map [ i ] . to ) { dup2 ( fd_map [ i ] . from , fd_map [ i ] . to ) ; close ( fd_map [ i ] . from ) ; } } for ( i = 0 ; i < data -> fd_map_len ; i ++ ) { if ( fd_map [ i ] . to != fd_map [ i ] . final ) { dup2 ( fd_map [ i ] . to , fd_map [ i ] . final ) ; close ( fd_map [ i ] . to ) ; } drop_cloexec ( fd_map [ i ] . final ) ; } setsid ( ) ; setpgid ( 0 , 0 ) ; if ( data -> set_tty ) { for ( i = 0 ; i < data -> fd_map_len ; i ++ ) { if ( fd_map [ i ] . from == data -> tty ) { if ( ioctl ( fd_map [ i ] . final , TIOCSCTTY , 0 ) == - 1 ) g_debug ( ""ioctl(%d,<S2SV_blank>TIOCSCTTY,<S2SV_blank>0)<S2SV_blank>failed:<S2SV_blank>%s"" , fd_map [ i ] . final , strerror ( errno ) ) ; break ; } } } }",<S2SV_ModStart> data -> instance_id_fd ) ; if ( data -> env_fd != - 1 ) drop_cloexec ( data -> env_fd,flatpak@flatpak/aeb6a7ab0abaac4a8f4ad98b3df476d9de6b8bd4,CVE-2021-21261,https://github.com/flatpak/flatpak/commit/aeb6a7ab0abaac4a8f4ad98b3df476d9de6b8bd4,2021-01-14T20:15Z
CWE-264,"CWE-264 static int fr_add_pvc ( struct net_device * frad , unsigned int dlci , int type ) { hdlc_device * hdlc = dev_to_hdlc ( frad ) ; pvc_device * pvc ; struct net_device * dev ; int used ; if ( ( pvc = add_pvc ( frad , dlci ) ) == NULL ) { netdev_warn ( frad , ""Memory<S2SV_blank>squeeze<S2SV_blank>on<S2SV_blank>fr_add_pvc()\\n"" ) ; return - ENOBUFS ; } if ( * get_dev_p ( pvc , type ) ) return - EEXIST ; used = pvc_is_used ( pvc ) ; <S2SV_StartBug> if ( type == ARPHRD_ETHER ) <S2SV_EndBug> dev = alloc_netdev ( 0 , ""pvceth%d"" , ether_setup ) ; <S2SV_StartBug> else <S2SV_EndBug> dev = alloc_netdev ( 0 , ""pvc%d"" , pvc_setup ) ; if ( ! dev ) { netdev_warn ( frad , ""Memory<S2SV_blank>squeeze<S2SV_blank>on<S2SV_blank>fr_pvc()\\n"" ) ; delete_unused_pvcs ( hdlc ) ; return - ENOBUFS ; } if ( type == ARPHRD_ETHER ) random_ether_addr ( dev -> dev_addr ) ; else { * ( __be16 * ) dev -> dev_addr = htons ( dlci ) ; dlci_to_q922 ( dev -> broadcast , dlci ) ; } dev -> netdev_ops = & pvc_ops ; dev -> mtu = HDLC_MAX_MTU ; dev -> tx_queue_len = 0 ; dev -> ml_priv = pvc ; if ( register_netdevice ( dev ) != 0 ) { free_netdev ( dev ) ; delete_unused_pvcs ( hdlc ) ; return - EIO ; } dev -> destructor = free_netdev ; * get_dev_p ( pvc , type ) = dev ; if ( ! used ) { state ( hdlc ) -> dce_changed = 1 ; state ( hdlc ) -> dce_pvc_count ++ ; } return 0 ; }",<S2SV_ModStart> == ARPHRD_ETHER ) { <S2SV_ModStart> ether_setup ) ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ; },torvalds@linux/550fd08c2cebad61c548def135f67aba284c6162,CVE-2011-4112,https://github.com/torvalds/linux/commit/550fd08c2cebad61c548def135f67aba284c6162,2012-05-17T11:00Z
CWE-134,"CWE-000 static rsRetVal createSocket ( instanceConf_t * info , void * * sock ) { int rv ; sublist * sub ; * sock = zsocket_new ( s_context , info -> type ) ; if ( ! sock ) { errmsg . LogError ( 0 , RS_RET_INVALID_PARAMS , ""zsocket_new<S2SV_blank>failed:<S2SV_blank>%s,<S2SV_blank>for<S2SV_blank>type<S2SV_blank>%d"" , zmq_strerror ( errno ) , info -> type ) ; return RS_RET_INVALID_PARAMS ; } DBGPRINTF ( ""imzmq3:<S2SV_blank>socket<S2SV_blank>of<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>created<S2SV_blank>successfully\\n"" , info -> type ) if ( info -> identity ) zsocket_set_identity ( * sock , info -> identity ) ; if ( info -> sndBuf > - 1 ) zsocket_set_sndbuf ( * sock , info -> sndBuf ) ; if ( info -> rcvBuf > - 1 ) zsocket_set_rcvbuf ( * sock , info -> rcvBuf ) ; if ( info -> linger > - 1 ) zsocket_set_linger ( * sock , info -> linger ) ; if ( info -> backlog > - 1 ) zsocket_set_backlog ( * sock , info -> backlog ) ; if ( info -> sndTimeout > - 1 ) zsocket_set_sndtimeo ( * sock , info -> sndTimeout ) ; if ( info -> rcvTimeout > - 1 ) zsocket_set_rcvtimeo ( * sock , info -> rcvTimeout ) ; if ( info -> maxMsgSize > - 1 ) zsocket_set_maxmsgsize ( * sock , info -> maxMsgSize ) ; if ( info -> rate > - 1 ) zsocket_set_rate ( * sock , info -> rate ) ; if ( info -> recoveryIVL > - 1 ) zsocket_set_recovery_ivl ( * sock , info -> recoveryIVL ) ; if ( info -> multicastHops > - 1 ) zsocket_set_multicast_hops ( * sock , info -> multicastHops ) ; if ( info -> reconnectIVL > - 1 ) zsocket_set_reconnect_ivl ( * sock , info -> reconnectIVL ) ; if ( info -> reconnectIVLMax > - 1 ) zsocket_set_reconnect_ivl_max ( * sock , info -> reconnectIVLMax ) ; if ( info -> ipv4Only > - 1 ) zsocket_set_ipv4only ( * sock , info -> ipv4Only ) ; if ( info -> affinity > - 1 ) zsocket_set_affinity ( * sock , info -> affinity ) ; if ( info -> sndHWM > - 1 ) zsocket_set_sndhwm ( * sock , info -> sndHWM ) ; if ( info -> rcvHWM > - 1 ) zsocket_set_rcvhwm ( * sock , info -> rcvHWM ) ; if ( info -> type == ZMQ_SUB ) { for ( sub = info -> subscriptions ; sub != NULL ; sub = sub -> next ) { zsocket_set_subscribe ( * sock , sub -> subscribe ) ; } } if ( info -> action == ACTION_CONNECT ) { <S2SV_StartBug> rv = zsocket_connect ( * sock , info -> description ) ; <S2SV_EndBug> if ( rv == - 1 ) { errmsg . LogError ( 0 , RS_RET_INVALID_PARAMS , ""zmq_connect<S2SV_blank>using<S2SV_blank>%s<S2SV_blank>failed:<S2SV_blank>%s"" , info -> description , zmq_strerror ( errno ) ) ; return RS_RET_INVALID_PARAMS ; } DBGPRINTF ( ""imzmq3:<S2SV_blank>connect<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>successful\\n"" , info -> description ) ; } else { <S2SV_StartBug> rv = zsocket_bind ( * sock , info -> description ) ; <S2SV_EndBug> if ( rv == - 1 ) { errmsg . LogError ( 0 , RS_RET_INVALID_PARAMS , ""zmq_bind<S2SV_blank>using<S2SV_blank>%s<S2SV_blank>failed:<S2SV_blank>%s"" , info -> description , zmq_strerror ( errno ) ) ; return RS_RET_INVALID_PARAMS ; } DBGPRINTF ( ""imzmq3:<S2SV_blank>bind<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>successful\\n"" , info -> description ) ; } return RS_RET_OK ; }","<S2SV_ModStart> * sock , ""%s"" , <S2SV_ModStart> * sock , ""%s"" ,",rsyslog@rsyslog/062d0c671a29f7c6f7dff4a2f1f35df375bbb30b,CVE-2017-12588,https://github.com/rsyslog/rsyslog/commit/062d0c671a29f7c6f7dff4a2f1f35df375bbb30b,2017-08-06T14:29Z
CWE-476,"CWE-476 static void filter_session_io ( struct io * io , int evt , void * arg ) { struct filter_session * fs = arg ; char * line = NULL ; ssize_t len ; log_trace ( TRACE_IO , ""filter<S2SV_blank>session:<S2SV_blank>%p:<S2SV_blank>%s<S2SV_blank>%s"" , fs , io_strevent ( evt ) , io_strio ( io ) ) ; switch ( evt ) { case IO_DATAIN : nextline : line = io_getline ( fs -> io , & len ) ; if ( line == NULL ) return ; filter_data ( fs -> id , line ) ; goto nextline ; <S2SV_StartBug> case IO_DISCONNECTED : <S2SV_EndBug> io_free ( fs -> io ) ; fs -> io = NULL ; break ; } }",<S2SV_ModStart> goto nextline ; <S2SV_ModEnd> } } <S2SV_null>,openbsd@src/6c3220444ed06b5796dedfd53a0f4becd903c0d1,CVE-2020-35680,https://github.com/openbsd/src/commit/6c3220444ed06b5796dedfd53a0f4becd903c0d1,2020-12-24T16:15Z
CWE-20,"CWE-20 static void * etm_setup_aux ( int event_cpu , void * * pages , int nr_pages , bool overwrite ) { int cpu ; cpumask_t * mask ; struct coresight_device * sink ; struct etm_event_data * event_data = NULL ; event_data = alloc_event_data ( event_cpu ) ; if ( ! event_data ) return NULL ; sink = coresight_get_enabled_sink ( true ) ; if ( ! sink ) goto err ; INIT_WORK ( & event_data -> work , free_event_data ) ; mask = & event_data -> mask ; for_each_cpu ( cpu , mask ) { struct coresight_device * csdev ; csdev = per_cpu ( csdev_src , cpu ) ; if ( ! csdev ) goto err ; event_data -> path [ cpu ] = coresight_build_path ( csdev , sink ) ; if ( IS_ERR ( event_data -> path [ cpu ] ) ) goto err ; } if ( ! sink_ops ( sink ) -> alloc_buffer ) goto err ; <S2SV_StartBug> event_data -> snk_config = <S2SV_EndBug> sink_ops ( sink ) -> alloc_buffer ( sink , cpu , pages , nr_pages , overwrite ) ; if ( ! event_data -> snk_config ) goto err ; out : return event_data ; err : etm_free_aux ( event_data ) ; event_data = NULL ; goto out ; }",<S2SV_ModStart> goto err ; cpu = cpumask_first ( mask ) ;,torvalds@linux/f09444639099584bc4784dfcd85ada67c6f33e0f,CVE-2018-11232,https://github.com/torvalds/linux/commit/f09444639099584bc4784dfcd85ada67c6f33e0f,2018-05-18T04:29Z
CWE-276,"CWE-000 static int rawsock_create ( struct net * net , struct socket * sock , const struct nfc_protocol * nfc_proto , int kern ) { struct sock * sk ; pr_debug ( ""sock=%p\\n"" , sock ) ; if ( ( sock -> type != SOCK_SEQPACKET ) && ( sock -> type != SOCK_RAW ) ) return - ESOCKTNOSUPPORT ; <S2SV_StartBug> if ( sock -> type == SOCK_RAW ) <S2SV_EndBug> sock -> ops = & rawsock_raw_ops ; <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> sock -> ops = & rawsock_ops ; <S2SV_EndBug> sk = sk_alloc ( net , PF_NFC , GFP_ATOMIC , nfc_proto -> proto , kern ) ; if ( ! sk ) return - ENOMEM ; sock_init_data ( sock , sk ) ; sk -> sk_protocol = nfc_proto -> id ; sk -> sk_destruct = rawsock_destruct ; sock -> state = SS_UNCONNECTED ; if ( sock -> type == SOCK_RAW ) nfc_sock_link ( & raw_sk_list , sk ) ; else { INIT_WORK ( & nfc_rawsock ( sk ) -> tx_work , rawsock_tx_work ) ; nfc_rawsock ( sk ) -> tx_work_scheduled = false ; } return 0 ; }",<S2SV_ModStart> == SOCK_RAW ) { if ( ! capable ( CAP_NET_RAW ) ) return - EPERM ; <S2SV_ModStart> & rawsock_raw_ops ; } else { <S2SV_ModEnd> sock -> ops <S2SV_ModStart> & rawsock_ops ; },torvalds@linux/26896f01467a28651f7a536143fe5ac8449d4041,CVE-2020-26088,https://github.com/torvalds/linux/commit/26896f01467a28651f7a536143fe5ac8449d4041,2020-09-24T15:15Z
CWE-119,"CWE-119 <S2SV_StartBug> static int cost_mv_ref ( const VP9_COMP * cpi , MB_PREDICTION_MODE mode , <S2SV_EndBug> <S2SV_StartBug> int mode_context ) { <S2SV_EndBug> const MACROBLOCK * const x = & cpi -> mb ; const int segment_id = x -> e_mbd . mi [ 0 ] -> mbmi . segment_id ; if ( ! vp9_segfeature_active ( & cpi -> common . seg , segment_id , SEG_LVL_SKIP ) ) { assert ( is_inter_mode ( mode ) ) ; <S2SV_StartBug> return x -> inter_mode_cost [ mode_context ] [ INTER_OFFSET ( mode ) ] ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> return 0 ; } }","<S2SV_ModStart> * cpi , PREDICTION_MODE <S2SV_ModEnd> mode , int <S2SV_ModStart> , int mode_context <S2SV_ModEnd> ) { assert <S2SV_ModStart> ) ; return cpi <S2SV_ModEnd> -> inter_mode_cost [ <S2SV_ModStart> ] ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-295,"CWE-000 static int int_x509_param_set_hosts ( X509_VERIFY_PARAM_ID * id , int mode , const char * name , size_t namelen ) { char * copy ; <S2SV_StartBug> if ( name && memchr ( name , '\\0' , namelen ) ) <S2SV_EndBug> return 0 ; if ( mode == SET_HOST && id -> hosts ) { string_stack_free ( id -> hosts ) ; id -> hosts = NULL ; } if ( name == NULL || namelen == 0 ) return 1 ; copy = strndup ( name , namelen ) ; if ( copy == NULL ) return 0 ; if ( id -> hosts == NULL && ( id -> hosts = sk_OPENSSL_STRING_new_null ( ) ) == NULL ) { free ( copy ) ; return 0 ; } if ( ! sk_OPENSSL_STRING_push ( id -> hosts , copy ) ) { free ( copy ) ; if ( sk_OPENSSL_STRING_num ( id -> hosts ) == 0 ) { sk_OPENSSL_STRING_free ( id -> hosts ) ; id -> hosts = NULL ; } return 0 ; } return 1 ; }",<S2SV_ModStart> if ( name != NULL && namelen == 0 ) namelen = strlen ( name ) ; if ( name,libressl-portable@openbsd/0654414afcce51a16d35d05060190a3ec4618d42,CVE-2018-8970,https://github.com/libressl-portable/openbsd/commit/0654414afcce51a16d35d05060190a3ec4618d42,2018-03-24T21:29Z
CWE-200,"CWE-200 unsigned paravirt_patch_call ( void * insnbuf , const void * target , u16 tgt_clobbers , unsigned long addr , u16 site_clobbers , unsigned len ) { struct branch * b = insnbuf ; unsigned long delta = ( unsigned long ) target - ( addr + 5 ) ; <S2SV_StartBug> if ( tgt_clobbers & ~ site_clobbers ) <S2SV_EndBug> return len ; <S2SV_StartBug> if ( len < 5 ) <S2SV_EndBug> return len ; b -> opcode = 0xe8 ; b -> delta = delta ; BUILD_BUG_ON ( sizeof ( * b ) != 5 ) ; return 5 ; }","<S2SV_ModStart> ; if ( len < 5 ) { # ifdef CONFIG_RETPOLINE WARN_ONCE ( ""Failing<S2SV_blank>to<S2SV_blank>patch<S2SV_blank>indirect<S2SV_blank>CALL<S2SV_blank>in<S2SV_blank>%ps\\n"" , ( void * ) addr ) ; # endif <S2SV_ModEnd> return len ; <S2SV_ModStart> return len ; } <S2SV_ModEnd> b -> opcode",torvalds@linux/5800dc5c19f34e6e03b5adab1282535cb102fafd,CVE-2018-15594,https://github.com/torvalds/linux/commit/5800dc5c19f34e6e03b5adab1282535cb102fafd,2018-08-20T08:29Z
CWE-119,"CWE-119 static INLINE int get_tx_eob ( const struct segmentation * seg , int segment_id , TX_SIZE tx_size ) { const int eob_max = 16 << ( tx_size << 1 ) ; <S2SV_StartBug> return vp9_segfeature_active ( seg , segment_id , SEG_LVL_SKIP ) ? 0 : eob_max ; <S2SV_EndBug> }","<S2SV_ModStart> ) ; return segfeature_active <S2SV_ModEnd> ( seg ,",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-125,"CWE-125 static void <S2SV_StartBug> l2tp_bearer_cap_print ( netdissect_options * ndo , const u_char * dat ) <S2SV_EndBug> { <S2SV_StartBug> const uint32_t * ptr = ( const uint32_t * ) dat ; <S2SV_EndBug> if ( EXTRACT_32BITS ( ptr ) & L2TP_BEARER_CAP_ANALOG_MASK ) { ND_PRINT ( ( ndo , ""A"" ) ) ; } if ( EXTRACT_32BITS ( ptr ) & L2TP_BEARER_CAP_DIGITAL_MASK ) { ND_PRINT ( ( ndo , ""D"" ) ) ; } }","<S2SV_ModStart> u_char * dat , u_int length <S2SV_ModStart> ) dat ; if ( length < 4 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; }",the-tcpdump-group@tcpdump/cc4a7391c616be7a64ed65742ef9ed3f106eb165,CVE-2017-13006,https://github.com/the-tcpdump-group/tcpdump/commit/cc4a7391c616be7a64ed65742ef9ed3f106eb165,2017-09-14T06:29Z
CWE-20,"CWE-20 void test_checkout_nasty__git_tilde1 ( void ) { <S2SV_StartBug> # ifdef GIT_WIN32 <S2SV_EndBug> test_checkout_fails ( ""refs/heads/git_tilde1"" , "".git/foobar"" ) ; <S2SV_StartBug> # endif <S2SV_EndBug> }","<S2SV_ModStart> void ) { <S2SV_ModEnd> test_checkout_fails ( ""refs/heads/git_tilde1"" <S2SV_ModStart> "".git/foobar"" ) ; test_checkout_fails ( ""refs/heads/git_tilde1"" , ""git~1/foobar"" ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>",libgit2@libgit2/64c612cc3e25eff5fb02c59ef5a66ba7a14751e4,CVE-2020-12279,https://github.com/libgit2/libgit2/commit/64c612cc3e25eff5fb02c59ef5a66ba7a14751e4,2020-04-27T17:15Z
CWE-119,"CWE-119 static void update_mbgraph_frame_stats ( VP9_COMP * cpi , MBGRAPH_FRAME_STATS * stats , YV12_BUFFER_CONFIG * buf , YV12_BUFFER_CONFIG * golden_ref , YV12_BUFFER_CONFIG * alt_ref ) { <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> MACROBLOCKD * const xd = & x -> e_mbd ; VP9_COMMON * const cm = & cpi -> common ; int mb_col , mb_row , offset = 0 ; int mb_y_offset = 0 , arf_y_offset = 0 , gld_y_offset = 0 ; <S2SV_StartBug> int_mv arf_top_mv , gld_top_mv ; <S2SV_EndBug> <S2SV_StartBug> MODE_INFO mi_local = { { 0 } } ; <S2SV_EndBug> arf_top_mv . as_int = 0 ; gld_top_mv . as_int = 0 ; x -> mv_row_min = - BORDER_MV_PIXELS_B16 ; x -> mv_row_max = ( cm -> mb_rows - 1 ) * 8 + BORDER_MV_PIXELS_B16 ; xd -> up_available = 0 ; xd -> plane [ 0 ] . dst . stride = buf -> y_stride ; xd -> plane [ 0 ] . pre [ 0 ] . stride = buf -> y_stride ; xd -> plane [ 1 ] . dst . stride = buf -> uv_stride ; xd -> mi [ 0 ] = & mi_local ; mi_local . mbmi . sb_type = BLOCK_16X16 ; mi_local . mbmi . ref_frame [ 0 ] = LAST_FRAME ; mi_local . mbmi . ref_frame [ 1 ] = NONE ; for ( mb_row = 0 ; mb_row < cm -> mb_rows ; mb_row ++ ) { <S2SV_StartBug> int_mv arf_left_mv , gld_left_mv ; <S2SV_EndBug> int mb_y_in_offset = mb_y_offset ; int arf_y_in_offset = arf_y_offset ; <S2SV_StartBug> int gld_y_in_offset = gld_y_offset ; <S2SV_EndBug> arf_left_mv . as_int = arf_top_mv . as_int ; gld_left_mv . as_int = gld_top_mv . as_int ; x -> mv_col_min = - BORDER_MV_PIXELS_B16 ; x -> mv_col_max = ( cm -> mb_cols - 1 ) * 8 + BORDER_MV_PIXELS_B16 ; xd -> left_available = 0 ; for ( mb_col = 0 ; mb_col < cm -> mb_cols ; mb_col ++ ) { MBGRAPH_MB_STATS * mb_stats = & stats -> mb_stats [ offset + mb_col ] ; update_mbgraph_mb_stats ( cpi , mb_stats , buf , mb_y_in_offset , golden_ref , & gld_left_mv , alt_ref , mb_row , mb_col ) ; <S2SV_StartBug> arf_left_mv . as_int = mb_stats -> ref [ ALTREF_FRAME ] . m . mv . as_int ; <S2SV_EndBug> gld_left_mv . as_int = mb_stats -> ref [ GOLDEN_FRAME ] . m . mv . as_int ; if ( mb_col == 0 ) { arf_top_mv . as_int = arf_left_mv . as_int ; gld_top_mv . as_int = gld_left_mv . as_int ; } xd -> left_available = 1 ; mb_y_in_offset += 16 ; gld_y_in_offset += 16 ; arf_y_in_offset += 16 ; x -> mv_col_min -= 16 ; x -> mv_col_max -= 16 ; } xd -> up_available = 1 ; mb_y_offset += buf -> y_stride * 16 ; gld_y_offset += golden_ref -> y_stride * 16 ; if ( alt_ref ) arf_y_offset += alt_ref -> y_stride * 16 ; x -> mv_row_min -= 16 ; x -> mv_row_max -= 16 ; offset += cm -> mb_cols ; } }","<S2SV_ModStart> & cpi -> td . <S2SV_ModStart> = 0 ; MV gld_top_mv = { 0 , 0 } <S2SV_ModEnd> ; MODE_INFO mi_local <S2SV_ModStart> ; MODE_INFO mi_local ; vp9_zero ( mi_local ) <S2SV_ModEnd> ; x -> <S2SV_ModStart> ++ ) { MV gld_left_mv = gld_top_mv <S2SV_ModEnd> ; int mb_y_in_offset <S2SV_ModStart> gld_y_in_offset = gld_y_offset <S2SV_ModEnd> ; x -> <S2SV_ModStart> mb_col ) ; gld_left_mv <S2SV_ModEnd> = mb_stats -> <S2SV_ModStart> -> ref [ GOLDEN_FRAME <S2SV_ModEnd> ] . m <S2SV_ModStart> . mv . as_mv ; if ( mb_col == 0 ) { gld_top_mv = gld_left_mv <S2SV_ModEnd> ; } xd",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-362,"CWE-362 static ssize_t environ_read ( struct file * file , char __user * buf , size_t count , loff_t * ppos ) { char * page ; unsigned long src = * ppos ; int ret = 0 ; struct mm_struct * mm = file -> private_data ; unsigned long env_start , env_end ; <S2SV_StartBug> if ( ! mm ) <S2SV_EndBug> return 0 ; page = ( char * ) __get_free_page ( GFP_TEMPORARY ) ; if ( ! page ) return - ENOMEM ; ret = 0 ; if ( ! atomic_inc_not_zero ( & mm -> mm_users ) ) goto free ; down_read ( & mm -> mmap_sem ) ; env_start = mm -> env_start ; env_end = mm -> env_end ; up_read ( & mm -> mmap_sem ) ; while ( count > 0 ) { size_t this_len , max_len ; int retval ; if ( src >= ( env_end - env_start ) ) break ; this_len = env_end - ( env_start + src ) ; max_len = min_t ( size_t , PAGE_SIZE , count ) ; this_len = min ( max_len , this_len ) ; retval = access_remote_vm ( mm , ( env_start + src ) , page , this_len , 0 ) ; if ( retval <= 0 ) { ret = retval ; break ; } if ( copy_to_user ( buf , page , retval ) ) { ret = - EFAULT ; break ; } ret += retval ; src += retval ; buf += retval ; count -= retval ; } * ppos = src ; mmput ( mm ) ; free : free_page ( ( unsigned long ) page ) ; return ret ; }",<S2SV_ModStart> ( ! mm || ! mm -> env_end,torvalds@linux/8148a73c9901a8794a50f950083c00ccf97d43b3,CVE-2016-7916,https://github.com/torvalds/linux/commit/8148a73c9901a8794a50f950083c00ccf97d43b3,2016-11-16T05:59Z
CWE-787,"CWE-787 int tcp_test ( const char * ip_str , const short port ) { int sock , i ; struct sockaddr_in s_in ; int packetsize = 1024 ; unsigned char packet [ packetsize ] ; struct timeval tv , tv2 , tv3 ; int caplen = 0 ; int times [ REQUESTS ] ; int min , avg , max , len ; struct net_hdr nh ; tv3 . tv_sec = 0 ; tv3 . tv_usec = 1 ; s_in . sin_family = PF_INET ; s_in . sin_port = htons ( port ) ; if ( ! inet_aton ( ip_str , & s_in . sin_addr ) ) return - 1 ; if ( ( sock = socket ( s_in . sin_family , SOCK_STREAM , IPPROTO_TCP ) ) == - 1 ) return - 1 ; if ( fcntl ( sock , F_SETFL , O_NONBLOCK ) < 0 ) { perror ( ""fcntl(O_NONBLOCK)<S2SV_blank>failed"" ) ; return ( 1 ) ; } gettimeofday ( & tv , NULL ) ; while ( 1 ) { if ( connect ( sock , ( struct sockaddr * ) & s_in , sizeof ( s_in ) ) == - 1 ) { if ( errno != EINPROGRESS && errno != EALREADY ) { perror ( ""connect"" ) ; close ( sock ) ; printf ( ""Failed<S2SV_blank>to<S2SV_blank>connect\\n"" ) ; return - 1 ; } } else { gettimeofday ( & tv2 , NULL ) ; break ; } gettimeofday ( & tv2 , NULL ) ; if ( ( ( tv2 . tv_sec * 1000000 - tv . tv_sec * 1000000 ) + ( tv2 . tv_usec - tv . tv_usec ) ) > ( 3000 * 1000 ) ) { printf ( ""Connection<S2SV_blank>timed<S2SV_blank>out\\n"" ) ; close ( sock ) ; return ( - 1 ) ; } usleep ( 10 ) ; } PCT ; printf ( ""TCP<S2SV_blank>connection<S2SV_blank>successful\\n"" ) ; memset ( & nh , 0 , sizeof ( nh ) ) ; nh . nh_type = 2 ; nh . nh_len = htonl ( 0 ) ; if ( send ( sock , & nh , sizeof ( nh ) , 0 ) != sizeof ( nh ) ) { perror ( ""send"" ) ; return - 1 ; } gettimeofday ( & tv , NULL ) ; i = 0 ; while ( 1 ) { caplen = read ( sock , & nh , sizeof ( nh ) ) ; if ( caplen == - 1 ) { if ( errno != EAGAIN ) { perror ( ""read"" ) ; return - 1 ; } } if ( ( unsigned ) caplen == sizeof ( nh ) ) { len = ntohl ( nh . nh_len ) ; <S2SV_StartBug> if ( nh . nh_type == 1 && i == 0 ) <S2SV_EndBug> { i = 1 ; caplen = read ( sock , packet , len ) ; if ( caplen == len ) { i = 2 ; break ; } else { i = 0 ; } } else { caplen = read ( sock , packet , len ) ; } } gettimeofday ( & tv2 , NULL ) ; if ( ( ( tv2 . tv_sec * 1000000 - tv . tv_sec * 1000000 ) + ( tv2 . tv_usec - tv . tv_usec ) ) > ( 1000 * 1000 ) ) { break ; } if ( caplen == - 1 ) usleep ( 10 ) ; } if ( i == 2 ) { PCT ; printf ( ""airserv-ng<S2SV_blank>found\\n"" ) ; } else { PCT ; printf ( ""airserv-ng<S2SV_blank>NOT<S2SV_blank>found\\n"" ) ; } close ( sock ) ; for ( i = 0 ; i < REQUESTS ; i ++ ) { if ( ( sock = socket ( s_in . sin_family , SOCK_STREAM , IPPROTO_TCP ) ) == - 1 ) return - 1 ; if ( fcntl ( sock , F_SETFL , O_NONBLOCK ) < 0 ) { perror ( ""fcntl(O_NONBLOCK)<S2SV_blank>failed"" ) ; return ( 1 ) ; } usleep ( 1000 ) ; gettimeofday ( & tv , NULL ) ; while ( 1 ) { if ( connect ( sock , ( struct sockaddr * ) & s_in , sizeof ( s_in ) ) == - 1 ) { if ( errno != EINPROGRESS && errno != EALREADY ) { perror ( ""connect"" ) ; close ( sock ) ; printf ( ""Failed<S2SV_blank>to<S2SV_blank>connect\\n"" ) ; return - 1 ; } } else { gettimeofday ( & tv2 , NULL ) ; break ; } gettimeofday ( & tv2 , NULL ) ; if ( ( ( tv2 . tv_sec * 1000000 - tv . tv_sec * 1000000 ) + ( tv2 . tv_usec - tv . tv_usec ) ) > ( 1000 * 1000 ) ) { break ; } select ( 1 , NULL , NULL , NULL , & tv3 ) ; } times [ i ] = ( ( tv2 . tv_sec * 1000000 - tv . tv_sec * 1000000 ) + ( tv2 . tv_usec - tv . tv_usec ) ) ; printf ( ""\\r%d/%d\\r"" , i , REQUESTS ) ; fflush ( stdout ) ; close ( sock ) ; } min = INT_MAX ; avg = 0 ; max = 0 ; for ( i = 0 ; i < REQUESTS ; i ++ ) { if ( times [ i ] < min ) min = times [ i ] ; if ( times [ i ] > max ) max = times [ i ] ; avg += times [ i ] ; } avg /= REQUESTS ; PCT ; printf ( ""ping<S2SV_blank>%s:%d<S2SV_blank>(min/avg/max):<S2SV_blank>%.3fms/%.3fms/%.3fms\\n"" , ip_str , port , min / 1000.0 , avg / 1000.0 , max / 1000.0 ) ; return 0 ; }",<S2SV_ModStart> ; if ( len > 1024 || len < 0 ) continue ; if (,aircrack-ng@aircrack-ng/091b153f294b9b695b0b2831e65936438b550d7b,CVE-2014-8322,https://github.com/aircrack-ng/aircrack-ng/commit/091b153f294b9b695b0b2831e65936438b550d7b,2020-01-31T22:15Z
CWE-264,"CWE-264 void setattr_copy ( struct inode * inode , const struct iattr * attr ) { unsigned int ia_valid = attr -> ia_valid ; if ( ia_valid & ATTR_UID ) inode -> i_uid = attr -> ia_uid ; if ( ia_valid & ATTR_GID ) inode -> i_gid = attr -> ia_gid ; if ( ia_valid & ATTR_ATIME ) inode -> i_atime = timespec_trunc ( attr -> ia_atime , inode -> i_sb -> s_time_gran ) ; if ( ia_valid & ATTR_MTIME ) inode -> i_mtime = timespec_trunc ( attr -> ia_mtime , inode -> i_sb -> s_time_gran ) ; if ( ia_valid & ATTR_CTIME ) inode -> i_ctime = timespec_trunc ( attr -> ia_ctime , inode -> i_sb -> s_time_gran ) ; if ( ia_valid & ATTR_MODE ) { umode_t mode = attr -> ia_mode ; if ( ! in_group_p ( inode -> i_gid ) && <S2SV_StartBug> ! inode_capable ( inode , CAP_FSETID ) ) <S2SV_EndBug> mode &= ~ S_ISGID ; inode -> i_mode = mode ; } }","<S2SV_ModStart> ) && ! capable_wrt_inode_uidgid <S2SV_ModEnd> ( inode ,",torvalds@linux/23adbe12ef7d3d4195e80800ab36b37bee28cd03,CVE-2014-4014,https://github.com/torvalds/linux/commit/23adbe12ef7d3d4195e80800ab36b37bee28cd03,2014-06-23T11:21Z
CWE-20,"CWE-20 <S2SV_StartBug> static int enable ( void ) { <S2SV_EndBug> <S2SV_StartBug> LOG_INFO ( ""%s"" , __func__ ) ; <S2SV_EndBug> if ( ! interface_ready ( ) ) return BT_STATUS_NOT_READY ; stack_manager_get_interface ( ) -> start_up_stack_async ( ) ; return BT_STATUS_SUCCESS ; }","<S2SV_ModStart> int enable ( bool start_restricted <S2SV_ModEnd> ) { LOG_INFO <S2SV_ModStart> { LOG_INFO ( LOG_TAG , ""%s:<S2SV_blank>start<S2SV_blank>restricted<S2SV_blank>=<S2SV_blank>%d"" , __func__ , start_restricted ) ; restricted_mode = start_restricted <S2SV_ModEnd> ; if (",system@bt/37c88107679d36c419572732b4af6e18bb2f7dce,CVE-2016-3760,https://android.googlesource.com/platform/system/bt/+/37c88107679d36c419572732b4af6e18bb2f7dce,2016-07-11T02:00Z
CWE-264,"CWE-264 static inline int ip_ufo_append_data ( struct sock * sk , struct sk_buff_head * queue , int getfrag ( void * from , char * to , int offset , int len , int odd , struct sk_buff * skb ) , void * from , int length , int hh_len , int fragheaderlen , int transhdrlen , int maxfraglen , unsigned int flags ) { struct sk_buff * skb ; int err ; if ( ( skb = skb_peek_tail ( queue ) ) == NULL ) { skb = sock_alloc_send_skb ( sk , hh_len + fragheaderlen + transhdrlen + 20 , ( flags & MSG_DONTWAIT ) , & err ) ; if ( skb == NULL ) return err ; skb_reserve ( skb , hh_len ) ; skb_put ( skb , fragheaderlen + transhdrlen ) ; skb_reset_network_header ( skb ) ; skb -> transport_header = skb -> network_header + fragheaderlen ; <S2SV_StartBug> skb -> ip_summed = CHECKSUM_PARTIAL ; <S2SV_EndBug> skb -> csum = 0 ; skb_shinfo ( skb ) -> gso_size = maxfraglen - fragheaderlen ; skb_shinfo ( skb ) -> gso_type = SKB_GSO_UDP ; <S2SV_StartBug> __skb_queue_tail ( queue , skb ) ; <S2SV_EndBug> } return skb_append_datato_frags ( sk , skb , getfrag , from , ( length - transhdrlen ) ) ; }","<S2SV_ModStart> ; skb -> csum = 0 ; __skb_queue_tail ( queue , skb ) ; } else if ( skb_is_gso ( skb ) ) { goto append ; } skb -> <S2SV_ModStart> ip_summed = CHECKSUM_PARTIAL <S2SV_ModEnd> ; skb_shinfo ( <S2SV_ModStart> = SKB_GSO_UDP ; append : <S2SV_ModEnd> return skb_append_datato_frags (",torvalds@linux/e93b7d748be887cd7639b113ba7d7ef792a7efb9,CVE-2013-4470,https://github.com/torvalds/linux/commit/e93b7d748be887cd7639b113ba7d7ef792a7efb9,2013-11-04T15:55Z
CWE-20,"CWE-20 static void * proc_pid_follow_link ( struct dentry * dentry , struct nameidata * nd ) { struct inode * inode = dentry -> d_inode ; int error = - EACCES ; path_put ( & nd -> path ) ; if ( ! proc_fd_access_allowed ( inode ) ) goto out ; error = PROC_I ( inode ) -> op . proc_get_link ( inode , & nd -> path ) ; <S2SV_StartBug> nd -> last_type = LAST_BIND ; <S2SV_EndBug> out : return ERR_PTR ( error ) ; }",<S2SV_ModStart> path ) ; <S2SV_ModEnd> out : return,torvalds@linux/86acdca1b63e6890540fa19495cfc708beff3d8b,CVE-2014-0203,https://github.com/torvalds/linux/commit/86acdca1b63e6890540fa19495cfc708beff3d8b,2014-06-23T11:21Z
CWE-119,"CWE-119 <S2SV_StartBug> static vpx_codec_err_t ctrl_set_svc_layer_id ( vpx_codec_alg_priv_t * ctx , <S2SV_EndBug> int ctr_id , va_list args ) { vpx_svc_layer_id_t * const data = va_arg ( args , vpx_svc_layer_id_t * ) ; VP9_COMP * const cpi = ( VP9_COMP * ) ctx -> cpi ; SVC * const svc = & cpi -> svc ; svc -> spatial_layer_id = data -> spatial_layer_id ; svc -> temporal_layer_id = data -> temporal_layer_id ; if ( svc -> temporal_layer_id < 0 || svc -> temporal_layer_id >= ( int ) ctx -> cfg . ts_number_layers ) { return VPX_CODEC_INVALID_PARAM ; } if ( svc -> spatial_layer_id < 0 || svc -> spatial_layer_id >= ( int ) ctx -> cfg . ss_number_layers ) { return VPX_CODEC_INVALID_PARAM ; } return VPX_CODEC_OK ; }","<S2SV_ModStart> vpx_codec_alg_priv_t * ctx <S2SV_ModEnd> , va_list args",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-190,"CWE-190 SPL_METHOD ( SplFileObject , fread ) { spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ; long length = 0 ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , ""l"" , & length ) == FAILURE ) { return ; } if ( length <= 0 ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Length<S2SV_blank>parameter<S2SV_blank>must<S2SV_blank>be<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>0"" ) ; RETURN_FALSE ; } <S2SV_StartBug> Z_STRVAL_P ( return_value ) = emalloc ( length + 1 ) ; <S2SV_EndBug> Z_STRLEN_P ( return_value ) = php_stream_read ( intern -> u . file . stream , Z_STRVAL_P ( return_value ) , length ) ; Z_STRVAL_P ( return_value ) [ Z_STRLEN_P ( return_value ) ] = 0 ; Z_TYPE_P ( return_value ) = IS_STRING ; }","<S2SV_ModStart> RETURN_FALSE ; } if ( length > INT_MAX ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Length<S2SV_blank>parameter<S2SV_blank>must<S2SV_blank>be<S2SV_blank>no<S2SV_blank>more<S2SV_blank>than<S2SV_blank>%d"" , INT_MAX ) ; RETURN_FALSE ; }",php@php-src/7245bff300d3fa8bacbef7897ff080a6f1c23eba,CVE-2016-5770,https://github.com/php/php-src/commit/7245bff300d3fa8bacbef7897ff080a6f1c23eba?w=1,2016-08-07T10:59Z
NVD-CWE-noinfo,"CWE-000 static struct sock * dccp_v6_request_recv_sock ( const struct sock * sk , struct sk_buff * skb , struct request_sock * req , struct dst_entry * dst , struct request_sock * req_unhash , bool * own_req ) { struct inet_request_sock * ireq = inet_rsk ( req ) ; struct ipv6_pinfo * newnp ; const struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct ipv6_txoptions * opt ; struct inet_sock * newinet ; struct dccp6_sock * newdp6 ; struct sock * newsk ; if ( skb -> protocol == htons ( ETH_P_IP ) ) { newsk = dccp_v4_request_recv_sock ( sk , skb , req , dst , req_unhash , own_req ) ; if ( newsk == NULL ) return NULL ; newdp6 = ( struct dccp6_sock * ) newsk ; newinet = inet_sk ( newsk ) ; newinet -> pinet6 = & newdp6 -> inet6 ; newnp = inet6_sk ( newsk ) ; memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; newnp -> saddr = newsk -> sk_v6_rcv_saddr ; inet_csk ( newsk ) -> icsk_af_ops = & dccp_ipv6_mapped ; newsk -> sk_backlog_rcv = dccp_v4_do_rcv ; newnp -> pktoptions = NULL ; newnp -> opt = NULL ; <S2SV_StartBug> newnp -> mcast_oif = inet6_iif ( skb ) ; <S2SV_EndBug> newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ; dccp_sync_mss ( newsk , inet_csk ( newsk ) -> icsk_pmtu_cookie ) ; return newsk ; } if ( sk_acceptq_is_full ( sk ) ) goto out_overflow ; if ( ! dst ) { struct flowi6 fl6 ; dst = inet6_csk_route_req ( sk , & fl6 , req , IPPROTO_DCCP ) ; if ( ! dst ) goto out ; } newsk = dccp_create_openreq_child ( sk , req , skb ) ; if ( newsk == NULL ) goto out_nonewsk ; ip6_dst_store ( newsk , dst , NULL , NULL ) ; newsk -> sk_route_caps = dst -> dev -> features & ~ ( NETIF_F_IP_CSUM | NETIF_F_TSO ) ; newdp6 = ( struct dccp6_sock * ) newsk ; newinet = inet_sk ( newsk ) ; newinet -> pinet6 = & newdp6 -> inet6 ; newnp = inet6_sk ( newsk ) ; memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; newsk -> sk_v6_daddr = ireq -> ir_v6_rmt_addr ; newnp -> saddr = ireq -> ir_v6_loc_addr ; newsk -> sk_v6_rcv_saddr = ireq -> ir_v6_loc_addr ; newsk -> sk_bound_dev_if = ireq -> ir_iif ; newinet -> inet_opt = NULL ; newnp -> rxopt . all = np -> rxopt . all ; <S2SV_StartBug> newnp -> pktoptions = NULL ; <S2SV_EndBug> newnp -> opt = NULL ; newnp -> mcast_oif = inet6_iif ( skb ) ; newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ; opt = ireq -> ipv6_opt ; if ( ! opt ) opt = rcu_dereference ( np -> opt ) ; if ( opt ) { opt = ipv6_dup_options ( newsk , opt ) ; RCU_INIT_POINTER ( newnp -> opt , opt ) ; } inet_csk ( newsk ) -> icsk_ext_hdr_len = 0 ; if ( opt ) inet_csk ( newsk ) -> icsk_ext_hdr_len = opt -> opt_nflen + opt -> opt_flen ; dccp_sync_mss ( newsk , dst_mtu ( dst ) ) ; newinet -> inet_daddr = newinet -> inet_saddr = LOOPBACK4_IPV6 ; newinet -> inet_rcv_saddr = LOOPBACK4_IPV6 ; if ( __inet_inherit_port ( sk , newsk ) < 0 ) { inet_csk_prepare_forced_close ( newsk ) ; dccp_done ( newsk ) ; goto out ; } * own_req = inet_ehash_nolisten ( newsk , req_to_sk ( req_unhash ) ) ; if ( * own_req && ireq -> pktopts ) { newnp -> pktoptions = skb_clone ( ireq -> pktopts , GFP_ATOMIC ) ; consume_skb ( ireq -> pktopts ) ; ireq -> pktopts = NULL ; if ( newnp -> pktoptions ) skb_set_owner_r ( newnp -> pktoptions , newsk ) ; } return newsk ; out_overflow : __NET_INC_STATS ( sock_net ( sk ) , LINUX_MIB_LISTENOVERFLOWS ) ; out_nonewsk : dst_release ( dst ) ; out : __NET_INC_STATS ( sock_net ( sk ) , LINUX_MIB_LISTENDROPS ) ; return NULL ; }",<S2SV_ModStart> ; newnp -> ipv6_mc_list = NULL ; newnp -> ipv6_ac_list = NULL ; newnp -> ipv6_fl_list = NULL ; newnp -> <S2SV_ModStart> ; newnp -> ipv6_mc_list = NULL ; newnp -> ipv6_ac_list = NULL ; newnp -> ipv6_fl_list = NULL ; newnp ->,torvalds@linux/83eaddab4378db256d00d295bda6ca997cd13a52,CVE-2017-9076,https://github.com/torvalds/linux/commit/83eaddab4378db256d00d295bda6ca997cd13a52,2017-05-19T07:29Z
CWE-119,"CWE-119 static vpx_codec_err_t ctrl_copy_reference ( vpx_codec_alg_priv_t * ctx , <S2SV_StartBug> int ctr_id , va_list args ) { <S2SV_EndBug> vpx_ref_frame_t * const frame = va_arg ( args , vpx_ref_frame_t * ) ; if ( frame != NULL ) { YV12_BUFFER_CONFIG sd ; image2yuvconfig ( & frame -> img , & sd ) ; vp9_copy_reference_enc ( ctx -> cpi , ref_frame_to_vp9_reframe ( frame -> frame_type ) , & sd ) ; return VPX_CODEC_OK ; } else { return VPX_CODEC_INVALID_PARAM ; } }","<S2SV_ModStart> * ctx , <S2SV_ModEnd> va_list args )",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-310,"CWE-000 static int crypto_report_one ( struct crypto_alg * alg , struct crypto_user_alg * ualg , struct sk_buff * skb ) { <S2SV_StartBug> memcpy ( & ualg -> cru_name , & alg -> cra_name , sizeof ( ualg -> cru_name ) ) ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( & ualg -> cru_driver_name , & alg -> cra_driver_name , <S2SV_EndBug> sizeof ( ualg -> cru_driver_name ) ) ; <S2SV_StartBug> memcpy ( & ualg -> cru_module_name , module_name ( alg -> cra_module ) , <S2SV_EndBug> <S2SV_StartBug> CRYPTO_MAX_ALG_NAME ) ; <S2SV_EndBug> ualg -> cru_flags = alg -> cra_flags ; ualg -> cru_refcnt = atomic_read ( & alg -> cra_refcnt ) ; if ( nla_put_u32 ( skb , CRYPTOCFGA_PRIORITY_VAL , alg -> cra_priority ) ) goto nla_put_failure ; if ( alg -> cra_flags & CRYPTO_ALG_LARVAL ) { struct crypto_report_larval rl ; <S2SV_StartBug> snprintf ( rl . type , CRYPTO_MAX_ALG_NAME , ""%s"" , ""larval"" ) ; <S2SV_EndBug> if ( nla_put ( skb , CRYPTOCFGA_REPORT_LARVAL , sizeof ( struct crypto_report_larval ) , & rl ) ) goto nla_put_failure ; goto out ; } if ( alg -> cra_type && alg -> cra_type -> report ) { if ( alg -> cra_type -> report ( skb , alg ) ) goto nla_put_failure ; goto out ; } switch ( alg -> cra_flags & ( CRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_LARVAL ) ) { case CRYPTO_ALG_TYPE_CIPHER : if ( crypto_report_cipher ( skb , alg ) ) goto nla_put_failure ; break ; case CRYPTO_ALG_TYPE_COMPRESS : if ( crypto_report_comp ( skb , alg ) ) goto nla_put_failure ; break ; } out : return 0 ; nla_put_failure : return - EMSGSIZE ; }","<S2SV_ModStart> skb ) { strncpy ( <S2SV_ModEnd> ualg -> cru_name <S2SV_ModStart> -> cru_name , <S2SV_ModEnd> alg -> cra_name <S2SV_ModStart> ) ) ; strncpy ( <S2SV_ModEnd> ualg -> cru_driver_name <S2SV_ModStart> -> cru_driver_name , <S2SV_ModEnd> alg -> cra_driver_name <S2SV_ModStart> ) ) ; strncpy ( <S2SV_ModEnd> ualg -> cru_module_name <S2SV_ModStart> cra_module ) , sizeof ( ualg -> cru_module_name ) ) ; ualg -> cru_type = 0 ; ualg -> cru_mask = 0 <S2SV_ModEnd> ; ualg -> <S2SV_ModStart> crypto_report_larval rl ; strncpy <S2SV_ModEnd> ( rl . <S2SV_ModStart> . type , ""larval"" , sizeof ( rl . type ) <S2SV_ModEnd> ) ; if",torvalds@linux/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6,CVE-2013-2547,https://github.com/torvalds/linux/commit/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6,2013-03-15T20:55Z
CWE-119,"CWE-119 <S2SV_StartBug> int vp9_compute_qdelta ( const RATE_CONTROL * rc , double qstart , double qtarget ) { <S2SV_EndBug> int start_index = rc -> worst_quality ; int target_index = rc -> worst_quality ; int i ; for ( i = rc -> best_quality ; i < rc -> worst_quality ; ++ i ) { start_index = i ; <S2SV_StartBug> if ( vp9_convert_qindex_to_q ( i ) >= qstart ) <S2SV_EndBug> break ; } for ( i = rc -> best_quality ; i < rc -> worst_quality ; ++ i ) { target_index = i ; <S2SV_StartBug> if ( vp9_convert_qindex_to_q ( i ) >= qtarget ) <S2SV_EndBug> break ; } return target_index - start_index ; }","<S2SV_ModStart> , double qtarget , vpx_bit_depth_t bit_depth <S2SV_ModStart> vp9_convert_qindex_to_q ( i , bit_depth <S2SV_ModStart> vp9_convert_qindex_to_q ( i , bit_depth",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-119,CWE-119 void vp9_rtcd ( ) { <S2SV_StartBug> vpx_scale_rtcd ( ) ; <S2SV_EndBug> once ( setup_rtcd_internal ) ; },<S2SV_ModStart> ( ) { <S2SV_ModEnd> once ( setup_rtcd_internal,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-119,"CWE-119 <S2SV_StartBug> void vp9_loop_filter_frame ( VP9_COMMON * cm , MACROBLOCKD * xd , <S2SV_EndBug> int frame_filter_level , int y_only , int partial_frame ) { int start_mi_row , end_mi_row , mi_rows_to_filter ; if ( ! frame_filter_level ) return ; start_mi_row = 0 ; mi_rows_to_filter = cm -> mi_rows ; if ( partial_frame && cm -> mi_rows > 8 ) { start_mi_row = cm -> mi_rows >> 1 ; start_mi_row &= 0xfffffff8 ; mi_rows_to_filter = MAX ( cm -> mi_rows / 8 , 8 ) ; } end_mi_row = start_mi_row + mi_rows_to_filter ; vp9_loop_filter_frame_init ( cm , frame_filter_level ) ; <S2SV_StartBug> vp9_loop_filter_rows ( cm -> frame_to_show , cm , xd , <S2SV_EndBug> start_mi_row , end_mi_row , y_only ) ; }","<S2SV_ModStart> void vp9_loop_filter_frame ( YV12_BUFFER_CONFIG * frame , <S2SV_ModStart> ; vp9_loop_filter_rows ( frame <S2SV_ModEnd> , cm , <S2SV_ModStart> cm , xd -> plane",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-119,"CWE-119 void dvb_usbv2_disconnect ( struct usb_interface * intf ) { struct dvb_usb_device * d = usb_get_intfdata ( intf ) ; <S2SV_StartBug> const char * name = d -> name ; <S2SV_EndBug> <S2SV_StartBug> struct device dev = d -> udev -> dev ; <S2SV_EndBug> dev_dbg ( & d -> udev -> dev , ""%s:<S2SV_blank>bInterfaceNumber=%d\\n"" , __func__ , intf -> cur_altsetting -> desc . bInterfaceNumber ) ; if ( d -> props -> exit ) d -> props -> exit ( d ) ; dvb_usbv2_exit ( d ) ; <S2SV_StartBug> dev_info ( & dev , ""%s:<S2SV_blank>\'%s\'<S2SV_blank>successfully<S2SV_blank>deinitialized<S2SV_blank>and<S2SV_blank>disconnected\\n"" , <S2SV_EndBug> <S2SV_StartBug> KBUILD_MODNAME , name ) ; <S2SV_EndBug> }","<S2SV_ModStart> const char * devname = kstrdup ( dev_name ( & <S2SV_ModEnd> d -> udev <S2SV_ModStart> udev -> dev ) , GFP_KERNEL ) ; const char * drvname = d -> name <S2SV_ModStart> d ) ; pr_info ( ""%s:<S2SV_blank>\'%s:%s\'<S2SV_blank>successfully<S2SV_blank>deinitialized<S2SV_blank>and<S2SV_blank>disconnected\\n"" <S2SV_ModEnd> , KBUILD_MODNAME , <S2SV_ModStart> , KBUILD_MODNAME , drvname , devname ) ; kfree ( devname <S2SV_ModEnd> ) ; }",torvalds@linux/005145378c9ad7575a01b6ce1ba118fb427f583a,CVE-2017-8064,https://github.com/torvalds/linux/commit/005145378c9ad7575a01b6ce1ba118fb427f583a,2017-04-23T05:59Z
CWE-476,"CWE-476 BOOL transport_connect_nla ( rdpTransport * transport ) { freerdp * instance ; rdpSettings * settings ; if ( transport -> layer == TRANSPORT_LAYER_TSG ) return TRUE ; if ( ! transport_connect_tls ( transport ) ) return FALSE ; if ( transport -> settings -> Authentication != TRUE ) return TRUE ; settings = transport -> settings ; instance = ( freerdp * ) settings -> instance ; if ( transport -> credssp == NULL ) transport -> credssp = credssp_new ( instance , transport , settings ) ; if ( credssp_authenticate ( transport -> credssp ) < 0 ) { if ( ! connectErrorCode ) connectErrorCode = AUTHENTICATIONERROR ; fprintf ( stderr , ""Authentication<S2SV_blank>failure,<S2SV_blank>check<S2SV_blank>credentials.\\n"" ""If<S2SV_blank>credentials<S2SV_blank>are<S2SV_blank>valid,<S2SV_blank>the<S2SV_blank>NTLMSSP<S2SV_blank>implementation<S2SV_blank>may<S2SV_blank>be<S2SV_blank>to<S2SV_blank>blame.\\n"" ) ; credssp_free ( transport -> credssp ) ; <S2SV_StartBug> return FALSE ; <S2SV_EndBug> } credssp_free ( transport -> credssp ) ; return TRUE ; }",<S2SV_ModStart> credssp ) ; transport -> credssp = NULL ;,FreeRDP@FreeRDP/0773bb9303d24473fe1185d85a424dfe159aff53,CVE-2013-4119,https://github.com/FreeRDP/FreeRDP/commit/0773bb9303d24473fe1185d85a424dfe159aff53,2016-10-03T21:59Z
NVD-CWE-noinfo,"CWE-000 int fit_check_format ( const void * fit , ulong size ) { int ret ; ret = fdt_check_header ( fit ) ; if ( ret ) { log_debug ( ""Wrong<S2SV_blank>FIT<S2SV_blank>format:<S2SV_blank>not<S2SV_blank>a<S2SV_blank>flattened<S2SV_blank>device<S2SV_blank>tree<S2SV_blank>(err=%d)\\n"" , ret ) ; return - ENOEXEC ; } <S2SV_StartBug> if ( ! fdt_getprop ( fit , 0 , FIT_DESC_PROP , NULL ) ) { <S2SV_EndBug> log_debug ( ""Wrong<S2SV_blank>FIT<S2SV_blank>format:<S2SV_blank>no<S2SV_blank>description\\n"" ) ; return - ENOMSG ; } if ( IMAGE_ENABLE_TIMESTAMP ) { if ( ! fdt_getprop ( fit , 0 , FIT_TIMESTAMP_PROP , NULL ) ) { log_debug ( ""Wrong<S2SV_blank>FIT<S2SV_blank>format:<S2SV_blank>no<S2SV_blank>timestamp\\n"" ) ; return - ENODATA ; } } if ( fdt_path_offset ( fit , FIT_IMAGES_PATH ) < 0 ) { log_debug ( ""Wrong<S2SV_blank>FIT<S2SV_blank>format:<S2SV_blank>no<S2SV_blank>images<S2SV_blank>parent<S2SV_blank>node\\n"" ) ; return - ENOENT ; } return 0 ; }","<S2SV_ModStart> } if ( CONFIG_IS_ENABLED ( FIT_FULL_CHECK ) ) { if ( size == IMAGE_SIZE_INVAL ) size = fdt_totalsize ( fit ) ; ret = fdt_check_full ( fit , size ) ; if ( ret ) { log_debug ( ""FIT<S2SV_blank>check<S2SV_blank>error<S2SV_blank>%d\\n"" , ret ) ; return - EINVAL ; } } if (",u-boot@u-boot/6f3c2d8aa5e6cbd80b5e869bbbddecb66c329d01,CVE-2021-27097,https://github.com/u-boot/u-boot/commit/6f3c2d8aa5e6cbd80b5e869bbbddecb66c329d01,2021-02-17T23:15Z
CWE-125,"CWE-125 static int str_lower_case_match ( OnigEncoding enc , int case_fold_flag , const UChar * t , const UChar * tend , const UChar * p , const UChar * end ) { int lowlen ; UChar * q , lowbuf [ ONIGENC_MBC_CASE_FOLD_MAXLEN ] ; while ( t < tend ) { lowlen = ONIGENC_MBC_CASE_FOLD ( enc , case_fold_flag , & p , end , lowbuf ) ; q = lowbuf ; while ( lowlen > 0 ) { <S2SV_StartBug> if ( * t ++ != * q ++ ) return 0 ; <S2SV_EndBug> lowlen -- ; } } return 1 ; }",<S2SV_ModStart> { if ( t >= tend ) return 0 ; if (,kkos@oniguruma/d3e402928b6eb3327f8f7d59a9edfa622fec557b,CVE-2019-19246,https://github.com/kkos/oniguruma/commit/d3e402928b6eb3327f8f7d59a9edfa622fec557b,2019-11-25T17:15Z
CWE-119,"CWE-119 static void y4m_convert_mono_420jpeg ( y4m_input * _y4m , unsigned char * _dst , unsigned char * _aux ) { <S2SV_StartBug> int c_sz ; <S2SV_EndBug> _dst += _y4m -> pic_w * _y4m -> pic_h ; c_sz = ( ( _y4m -> pic_w + _y4m -> dst_c_dec_h - 1 ) / _y4m -> dst_c_dec_h ) * ( ( _y4m -> pic_h + _y4m -> dst_c_dec_v - 1 ) / _y4m -> dst_c_dec_v ) ; memset ( _dst , 128 , c_sz * 2 ) ; }",<S2SV_ModStart> { int c_sz ; ( void ) _aux,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-22,"CWE-000 static int target_xcopy_locate_se_dev_e4_iter ( struct se_device * se_dev , <S2SV_StartBug> void * data ) <S2SV_EndBug> { struct xcopy_dev_search_info * info = data ; unsigned char tmp_dev_wwn [ XCOPY_NAA_IEEE_REGEX_LEN ] ; int rc ; <S2SV_StartBug> if ( ! se_dev -> dev_attrib . emulate_3pc ) <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> memset ( & tmp_dev_wwn [ 0 ] , 0 , XCOPY_NAA_IEEE_REGEX_LEN ) ; target_xcopy_gen_naa_ieee ( se_dev , & tmp_dev_wwn [ 0 ] ) ; <S2SV_StartBug> rc = memcmp ( & tmp_dev_wwn [ 0 ] , info -> dev_wwn , XCOPY_NAA_IEEE_REGEX_LEN ) ; <S2SV_EndBug> <S2SV_StartBug> if ( rc != 0 ) <S2SV_EndBug> return 0 ; <S2SV_StartBug> info -> found_dev = se_dev ; <S2SV_EndBug> pr_debug ( ""XCOPY<S2SV_blank>0xe4:<S2SV_blank>located<S2SV_blank>se_dev:<S2SV_blank>%p\\n"" , se_dev ) ; <S2SV_StartBug> rc = target_depend_item ( & se_dev -> dev_group . cg_item ) ; <S2SV_EndBug> if ( rc != 0 ) { pr_err ( ""configfs_depend_item<S2SV_blank>attempt<S2SV_blank>failed:<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>se_dev:<S2SV_blank>%p\\n"" , rc , se_dev ) ; return rc ; } pr_debug ( ""Called<S2SV_blank>configfs_depend_item<S2SV_blank>for<S2SV_blank>se_dev:<S2SV_blank>%p<S2SV_blank>se_dev->se_dev_group:<S2SV_blank>%p\\n"" , se_dev , & se_dev -> dev_group ) ; return 1 ; }","<S2SV_ModStart> * se_dev , const unsigned char * dev_wwn ) { <S2SV_ModEnd> unsigned char tmp_dev_wwn <S2SV_ModStart> . emulate_3pc ) { pr_debug ( ""XCOPY:<S2SV_blank>emulate_3pc<S2SV_blank>disabled<S2SV_blank>on<S2SV_blank>se_dev<S2SV_blank>%p\\n"" , se_dev ) ; <S2SV_ModStart> return 0 ; } <S2SV_ModStart> 0 ] , <S2SV_ModEnd> dev_wwn , XCOPY_NAA_IEEE_REGEX_LEN <S2SV_ModStart> != 0 ) { pr_debug ( ""XCOPY:<S2SV_blank>skip<S2SV_blank>non-matching:<S2SV_blank>%*ph\\n"" , XCOPY_NAA_IEEE_REGEX_LEN , tmp_dev_wwn ) ; <S2SV_ModStart> return 0 ; } <S2SV_ModEnd> pr_debug ( ""XCOPY<S2SV_blank>0xe4:<S2SV_blank>located<S2SV_blank>se_dev:<S2SV_blank>%p\\n"" <S2SV_ModStart> se_dev ) ; <S2SV_ModEnd> return 1 ;",torvalds@linux/2896c93811e39d63a4d9b63ccf12a8fbc226e5e4,CVE-2020-28374,https://github.com/torvalds/linux/commit/2896c93811e39d63a4d9b63ccf12a8fbc226e5e4,2021-01-13T04:15Z
,"CWE-000 static int asn1_find_indefinite_length ( const unsigned char * data , size_t datalen , size_t * _dp , size_t * _len , const char * * _errmsg ) { unsigned char tag , tmp ; size_t dp = * _dp , len , n ; int indef_level = 1 ; next_tag : if ( unlikely ( datalen - dp < 2 ) ) { if ( datalen == dp ) goto missing_eoc ; goto data_overrun_error ; } tag = data [ dp ++ ] ; <S2SV_StartBug> if ( tag == 0 ) { <S2SV_EndBug> if ( data [ dp ++ ] != 0 ) goto invalid_eoc ; if ( -- indef_level <= 0 ) { * _len = dp - * _dp ; * _dp = dp ; return 0 ; } goto next_tag ; } if ( unlikely ( ( tag & 0x1f ) == ASN1_LONG_TAG ) ) { do { if ( unlikely ( datalen - dp < 2 ) ) goto data_overrun_error ; tmp = data [ dp ++ ] ; } while ( tmp & 0x80 ) ; } len = data [ dp ++ ] ; <S2SV_StartBug> if ( len <= 0x7f ) { <S2SV_EndBug> dp += len ; goto next_tag ; } if ( unlikely ( len == ASN1_INDEFINITE_LENGTH ) ) { if ( unlikely ( ( tag & ASN1_CONS_BIT ) == ASN1_PRIM << 5 ) ) goto indefinite_len_primitive ; indef_level ++ ; goto next_tag ; } n = len - 0x80 ; <S2SV_StartBug> if ( unlikely ( n > sizeof ( size_t ) - 1 ) ) <S2SV_EndBug> goto length_too_long ; if ( unlikely ( n > datalen - dp ) ) goto data_overrun_error ; <S2SV_StartBug> for ( len = 0 ; n > 0 ; n -- ) { <S2SV_EndBug> len <<= 8 ; len |= data [ dp ++ ] ; } <S2SV_StartBug> dp += len ; <S2SV_EndBug> goto next_tag ; length_too_long : * _errmsg = ""Unsupported<S2SV_blank>length"" ; goto error ; indefinite_len_primitive : * _errmsg = ""Indefinite<S2SV_blank>len<S2SV_blank>primitive<S2SV_blank>not<S2SV_blank>permitted"" ; goto error ; invalid_eoc : * _errmsg = ""Invalid<S2SV_blank>length<S2SV_blank>EOC"" ; goto error ; data_overrun_error : * _errmsg = ""Data<S2SV_blank>overrun<S2SV_blank>error"" ; goto error ; missing_eoc : * _errmsg = ""Missing<S2SV_blank>EOC<S2SV_blank>in<S2SV_blank>indefinite<S2SV_blank>len<S2SV_blank>cons"" ; error : * _dp = dp ; return - 1 ; }",<S2SV_ModStart> ( tag == ASN1_EOC <S2SV_ModEnd> ) { if <S2SV_ModStart> <= 0x7f ) goto check_length ; <S2SV_ModEnd> if ( unlikely <S2SV_ModStart> > sizeof ( len <S2SV_ModEnd> ) - 1 <S2SV_ModStart> goto data_overrun_error ; len = 0 ; for ( <S2SV_ModEnd> ; n > <S2SV_ModStart> ] ; } check_length : if ( len > datalen - dp ) goto data_overrun_error ;,torvalds@linux/23c8a812dc3c621009e4f0e5342aa4e2ede1ceaa,CVE-2016-0758,https://github.com/torvalds/linux/commit/23c8a812dc3c621009e4f0e5342aa4e2ede1ceaa,2016-06-27T10:59Z
CWE-362,"CWE-362 static int newseg ( struct ipc_namespace * ns , struct ipc_params * params ) { key_t key = params -> key ; int shmflg = params -> flg ; size_t size = params -> u . size ; int error ; struct shmid_kernel * shp ; size_t numpages = ( size + PAGE_SIZE - 1 ) >> PAGE_SHIFT ; struct file * file ; char name [ 13 ] ; int id ; vm_flags_t acctflag = 0 ; if ( size < SHMMIN || size > ns -> shm_ctlmax ) return - EINVAL ; if ( numpages << PAGE_SHIFT < size ) return - ENOSPC ; if ( ns -> shm_tot + numpages < ns -> shm_tot || ns -> shm_tot + numpages > ns -> shm_ctlall ) return - ENOSPC ; shp = ipc_rcu_alloc ( sizeof ( * shp ) ) ; if ( ! shp ) return - ENOMEM ; shp -> shm_perm . key = key ; shp -> shm_perm . mode = ( shmflg & S_IRWXUGO ) ; shp -> mlock_user = NULL ; shp -> shm_perm . security = NULL ; error = security_shm_alloc ( shp ) ; if ( error ) { ipc_rcu_putref ( shp , ipc_rcu_free ) ; return error ; } sprintf ( name , ""SYSV%08x"" , key ) ; if ( shmflg & SHM_HUGETLB ) { struct hstate * hs ; size_t hugesize ; hs = hstate_sizelog ( ( shmflg >> SHM_HUGE_SHIFT ) & SHM_HUGE_MASK ) ; if ( ! hs ) { error = - EINVAL ; goto no_file ; } hugesize = ALIGN ( size , huge_page_size ( hs ) ) ; if ( shmflg & SHM_NORESERVE ) acctflag = VM_NORESERVE ; file = hugetlb_file_setup ( name , hugesize , acctflag , & shp -> mlock_user , HUGETLB_SHMFS_INODE , ( shmflg >> SHM_HUGE_SHIFT ) & SHM_HUGE_MASK ) ; } else { if ( ( shmflg & SHM_NORESERVE ) && sysctl_overcommit_memory != OVERCOMMIT_NEVER ) acctflag = VM_NORESERVE ; file = shmem_kernel_file_setup ( name , size , acctflag ) ; } error = PTR_ERR ( file ) ; if ( IS_ERR ( file ) ) goto no_file ; <S2SV_StartBug> id = ipc_addid ( & shm_ids ( ns ) , & shp -> shm_perm , ns -> shm_ctlmni ) ; <S2SV_EndBug> if ( id < 0 ) { error = id ; goto no_id ; } <S2SV_StartBug> shp -> shm_cprid = task_tgid_vnr ( current ) ; <S2SV_EndBug> shp -> shm_lprid = 0 ; shp -> shm_atim = shp -> shm_dtim = 0 ; shp -> shm_ctim = get_seconds ( ) ; shp -> shm_segsz = size ; shp -> shm_nattch = 0 ; shp -> shm_file = file ; shp -> shm_creator = current ; list_add ( & shp -> shm_clist , & current -> sysvshm . shm_clist ) ; file_inode ( file ) -> i_ino = shp -> shm_perm . id ; ns -> shm_tot += numpages ; error = shp -> shm_perm . id ; ipc_unlock_object ( & shp -> shm_perm ) ; rcu_read_unlock ( ) ; return error ; no_id : if ( is_file_hugepages ( file ) && shp -> mlock_user ) user_shm_unlock ( size , shp -> mlock_user ) ; fput ( file ) ; no_file : ipc_rcu_putref ( shp , shm_rcu_free ) ; return error ; }",<S2SV_ModStart> goto no_file ; shp -> shm_cprid = task_tgid_vnr ( current ) ; shp -> shm_lprid = 0 ; shp -> shm_atim = shp -> shm_dtim = 0 ; shp -> shm_ctim = get_seconds ( ) ; shp -> shm_segsz = size ; shp -> shm_nattch = 0 ; shp -> shm_file = file ; shp -> shm_creator = current ; <S2SV_ModStart> no_id ; } <S2SV_ModEnd> list_add ( &,torvalds@linux/b9a532277938798b53178d5a66af6e2915cb27cf,CVE-2015-7613,https://github.com/torvalds/linux/commit/b9a532277938798b53178d5a66af6e2915cb27cf,2015-10-19T10:59Z
CWE-476,"CWE-476 int validate_as_request ( kdc_realm_t * kdc_active_realm , register krb5_kdc_req * request , krb5_db_entry client , krb5_db_entry server , krb5_timestamp kdc_time , const char * * status , krb5_pa_data * * * e_data ) { int errcode ; krb5_error_code ret ; if ( request -> kdc_options & AS_INVALID_OPTIONS ) { * status = ""INVALID<S2SV_blank>AS<S2SV_blank>OPTIONS"" ; return KDC_ERR_BADOPTION ; } if ( client . expiration && client . expiration < kdc_time ) { * status = ""CLIENT<S2SV_blank>EXPIRED"" ; if ( vague_errors ) return ( KRB_ERR_GENERIC ) ; else return ( KDC_ERR_NAME_EXP ) ; } if ( client . pw_expiration && client . pw_expiration < kdc_time && ! isflagset ( server . attributes , KRB5_KDB_PWCHANGE_SERVICE ) ) { * status = ""CLIENT<S2SV_blank>KEY<S2SV_blank>EXPIRED"" ; if ( vague_errors ) return ( KRB_ERR_GENERIC ) ; else return ( KDC_ERR_KEY_EXP ) ; } if ( server . expiration && server . expiration < kdc_time ) { * status = ""SERVICE<S2SV_blank>EXPIRED"" ; return ( KDC_ERR_SERVICE_EXP ) ; } if ( isflagset ( client . attributes , KRB5_KDB_REQUIRES_PWCHANGE ) && ! isflagset ( server . attributes , KRB5_KDB_PWCHANGE_SERVICE ) ) { * status = ""REQUIRED<S2SV_blank>PWCHANGE"" ; return ( KDC_ERR_KEY_EXP ) ; } if ( ( isflagset ( request -> kdc_options , KDC_OPT_ALLOW_POSTDATE ) || isflagset ( request -> kdc_options , KDC_OPT_POSTDATED ) ) && ( isflagset ( client . attributes , KRB5_KDB_DISALLOW_POSTDATED ) || isflagset ( server . attributes , KRB5_KDB_DISALLOW_POSTDATED ) ) ) { * status = ""POSTDATE<S2SV_blank>NOT<S2SV_blank>ALLOWED"" ; return ( KDC_ERR_CANNOT_POSTDATE ) ; } if ( isflagset ( request -> kdc_options , KDC_OPT_PROXIABLE ) && ( isflagset ( client . attributes , KRB5_KDB_DISALLOW_PROXIABLE ) || isflagset ( server . attributes , KRB5_KDB_DISALLOW_PROXIABLE ) ) ) { * status = ""PROXIABLE<S2SV_blank>NOT<S2SV_blank>ALLOWED"" ; return ( KDC_ERR_POLICY ) ; } if ( isflagset ( client . attributes , KRB5_KDB_DISALLOW_ALL_TIX ) ) { * status = ""CLIENT<S2SV_blank>LOCKED<S2SV_blank>OUT"" ; return ( KDC_ERR_CLIENT_REVOKED ) ; } if ( isflagset ( server . attributes , KRB5_KDB_DISALLOW_ALL_TIX ) ) { * status = ""SERVICE<S2SV_blank>LOCKED<S2SV_blank>OUT"" ; return ( KDC_ERR_S_PRINCIPAL_UNKNOWN ) ; } if ( isflagset ( server . attributes , KRB5_KDB_DISALLOW_SVR ) ) { * status = ""SERVICE<S2SV_blank>NOT<S2SV_blank>ALLOWED"" ; return ( KDC_ERR_MUST_USE_USER2USER ) ; } <S2SV_StartBug> if ( check_anon ( kdc_active_realm , request -> client , request -> server ) != 0 ) { <S2SV_EndBug> * status = ""ANONYMOUS<S2SV_blank>NOT<S2SV_blank>ALLOWED"" ; return ( KDC_ERR_POLICY ) ; } ret = krb5_db_check_policy_as ( kdc_context , request , & client , & server , kdc_time , status , e_data ) ; if ( ret && ret != KRB5_PLUGIN_OP_NOTSUPP ) return errcode_to_protocol ( ret ) ; errcode = against_local_policy_as ( request , client , server , kdc_time , status , e_data ) ; if ( errcode ) return errcode ; return 0 ; }","<S2SV_ModStart> ( kdc_active_realm , client . princ <S2SV_ModEnd> , request ->",krb5@krb5/93b4a6306a0026cf1cc31ac4bd8a49ba5d034ba7,CVE-2016-3120,https://github.com/krb5/krb5/commit/93b4a6306a0026cf1cc31ac4bd8a49ba5d034ba7,2016-08-01T02:59Z
CWE-119,"CWE-119 static ssize_t oz_cdev_write ( struct file * filp , const char __user * buf , size_t count , loff_t * fpos ) { struct oz_pd * pd ; struct oz_elt_buf * eb ; struct oz_elt_info * ei ; struct oz_elt * elt ; struct oz_app_hdr * app_hdr ; struct oz_serial_ctx * ctx ; <S2SV_StartBug> spin_lock_bh ( & g_cdev . lock ) ; <S2SV_EndBug> pd = g_cdev . active_pd ; if ( pd ) oz_pd_get ( pd ) ; spin_unlock_bh ( & g_cdev . lock ) ; if ( pd == NULL ) return - ENXIO ; if ( ! ( pd -> state & OZ_PD_S_CONNECTED ) ) return - EAGAIN ; eb = & pd -> elt_buff ; ei = oz_elt_info_alloc ( eb ) ; if ( ei == NULL ) { count = 0 ; goto out ; } elt = ( struct oz_elt * ) ei -> data ; app_hdr = ( struct oz_app_hdr * ) ( elt + 1 ) ; elt -> length = sizeof ( struct oz_app_hdr ) + count ; elt -> type = OZ_ELT_APP_DATA ; ei -> app_id = OZ_APPID_SERIAL ; ei -> length = elt -> length + sizeof ( struct oz_elt ) ; app_hdr -> app_id = OZ_APPID_SERIAL ; if ( copy_from_user ( app_hdr + 1 , buf , count ) ) goto out ; spin_lock_bh ( & pd -> app_lock [ OZ_APPID_USB - 1 ] ) ; ctx = ( struct oz_serial_ctx * ) pd -> app_ctx [ OZ_APPID_SERIAL - 1 ] ; if ( ctx ) { app_hdr -> elt_seq_num = ctx -> tx_seq_num ++ ; if ( ctx -> tx_seq_num == 0 ) ctx -> tx_seq_num = 1 ; spin_lock ( & eb -> lock ) ; if ( oz_queue_elt_info ( eb , 0 , 0 , ei ) == 0 ) ei = NULL ; spin_unlock ( & eb -> lock ) ; } spin_unlock_bh ( & pd -> app_lock [ OZ_APPID_USB - 1 ] ) ; out : if ( ei ) { count = 0 ; spin_lock_bh ( & eb -> lock ) ; oz_elt_info_free ( eb , ei ) ; spin_unlock_bh ( & eb -> lock ) ; } oz_pd_put ( pd ) ; return count ; }",<S2SV_ModStart> * ctx ; if ( count > sizeof ( ei -> data ) - sizeof ( * elt ) - sizeof ( * app_hdr ) ) return - EINVAL ;,torvalds@linux/c2c65cd2e14ada6de44cb527e7f1990bede24e15,CVE-2013-4513,https://github.com/torvalds/linux/commit/c2c65cd2e14ada6de44cb527e7f1990bede24e15,2013-11-12T14:35Z
CWE-119,"CWE-119 static void update_best_mode ( BEST_MODE * best_mode , int this_rd , RATE_DISTORTION * rd , int other_cost , MACROBLOCK * x ) { MB_PREDICTION_MODE this_mode = x -> e_mbd . mode_info_context -> mbmi . mode ; other_cost += x -> ref_frame_cost [ x -> e_mbd . mode_info_context -> mbmi . ref_frame ] ; best_mode -> yrd = RDCOST ( x -> rdmult , x -> rddiv , ( rd -> rate2 - rd -> rate_uv - other_cost ) , ( rd -> distortion2 - rd -> distortion_uv ) ) ; best_mode -> rd = this_rd ; <S2SV_StartBug> vpx_memcpy ( & best_mode -> mbmode , & x -> e_mbd . mode_info_context -> mbmi , sizeof ( MB_MODE_INFO ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & best_mode -> partition , x -> partition_info , sizeof ( PARTITION_INFO ) ) ; <S2SV_EndBug> if ( ( this_mode == B_PRED ) || ( this_mode == SPLITMV ) ) { int i ; for ( i = 0 ; i < 16 ; i ++ ) { best_mode -> bmodes [ i ] = x -> e_mbd . block [ i ] . bmi ; } } }",<S2SV_ModStart> = this_rd ; memcpy <S2SV_ModEnd> ( & best_mode <S2SV_ModStart> ) ) ; memcpy <S2SV_ModEnd> ( & best_mode,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-617,"CWE-000 static void pci_emul_capwrite ( struct pci_vdev * dev , int offset , int bytes , uint32_t val ) { int capid ; uint8_t capoff , nextoff ; if ( ( offset & ( bytes - 1 ) ) != 0 ) return ; capoff = CAP_START_OFFSET ; while ( 1 ) { nextoff = pci_get_cfgdata8 ( dev , capoff + 1 ) ; if ( nextoff == 0 ) break ; if ( offset >= capoff && offset < nextoff ) break ; capoff = nextoff ; } <S2SV_StartBug> assert ( offset >= capoff ) ; <S2SV_EndBug> if ( offset == capoff || offset == capoff + 1 ) { if ( offset == capoff && bytes == 4 ) { bytes = 2 ; offset += 2 ; val >>= 16 ; } else return ; } capid = pci_get_cfgdata8 ( dev , capoff ) ; switch ( capid ) { case PCIY_MSI : msicap_cfgwrite ( dev , capoff , offset , bytes , val ) ; break ; case PCIY_MSIX : msixcap_cfgwrite ( dev , capoff , offset , bytes , val ) ; break ; case PCIY_EXPRESS : pciecap_cfgwrite ( dev , capoff , offset , bytes , val ) ; break ; default : CFGWRITE ( dev , offset , val , bytes ) ; break ; } }",<S2SV_ModStart> nextoff ; } <S2SV_ModEnd> if ( offset,projectacrn@acrn-hypervisor/2b3dedfb9ba13f15887f22b935d373f36c9a59fa,CVE-2019-18844,https://github.com/projectacrn/acrn-hypervisor/commit/2b3dedfb9ba13f15887f22b935d373f36c9a59fa,2019-11-13T20:15Z
CWE-346,"CWE-000 void receive_carbon ( void * * state ) { prof_input ( ""/carbons<S2SV_blank>on"" ) ; prof_connect ( ) ; assert_true ( stbbr_received ( ""<iq<S2SV_blank>id=\'*\'<S2SV_blank>type=\'set\'><enable<S2SV_blank>xmlns=\'urn:xmpp:carbons:2\'/></iq>"" ) ) ; stbbr_send ( ""<presence<S2SV_blank>to=\'stabber@localhost\'<S2SV_blank>from=\'buddy1@localhost/mobile\'>"" ""<priority>10</priority>"" ""<status>On<S2SV_blank>my<S2SV_blank>mobile</status>"" ""</presence>"" ) ; assert_true ( prof_output_exact ( ""Buddy1<S2SV_blank>(mobile)<S2SV_blank>is<S2SV_blank>online,<S2SV_blank>\\""On<S2SV_blank>my<S2SV_blank>mobile\\"""" ) ) ; prof_input ( ""/msg<S2SV_blank>Buddy1"" ) ; assert_true ( prof_output_exact ( ""unencrypted"" ) ) ; stbbr_send ( <S2SV_StartBug> ""<message<S2SV_blank>type=\'chat\'<S2SV_blank>to=\'stabber@localhost/profanity\'<S2SV_blank>from=\'buddy1@localhost\'>"" <S2SV_EndBug> ""<received<S2SV_blank>xmlns=\'urn:xmpp:carbons:2\'>"" ""<forwarded<S2SV_blank>xmlns=\'urn:xmpp:forward:0\'>"" ""<message<S2SV_blank>id=\'prof_msg_7\'<S2SV_blank>xmlns=\'jabber:client\'<S2SV_blank>type=\'chat\'<S2SV_blank>lang=\'en\'<S2SV_blank>to=\'stabber@localhost/profanity\'<S2SV_blank>from=\'buddy1@localhost/mobile\'>"" ""<body>test<S2SV_blank>carbon<S2SV_blank>from<S2SV_blank>recipient</body>"" ""</message>"" ""</forwarded>"" ""</received>"" ""</message>"" ) ; assert_true ( prof_output_regex ( ""Buddy1/mobile:<S2SV_blank>.+test<S2SV_blank>carbon<S2SV_blank>from<S2SV_blank>recipient"" ) ) ; }","<S2SV_ModStart> ; stbbr_send ( ""<message<S2SV_blank>type=\'chat\'<S2SV_blank>to=\'stabber@localhost/profanity\'<S2SV_blank>from=\'stabber@localhost\'>"" <S2SV_ModEnd> ""<received<S2SV_blank>xmlns=\'urn:xmpp:carbons:2\'>"" ""<forwarded<S2SV_blank>xmlns=\'urn:xmpp:forward:0\'>"" ""<message<S2SV_blank>id=\'prof_msg_7\'<S2SV_blank>xmlns=\'jabber:client\'<S2SV_blank>type=\'chat\'<S2SV_blank>lang=\'en\'<S2SV_blank>to=\'stabber@localhost/profanity\'<S2SV_blank>from=\'buddy1@localhost/mobile\'>""",boothj5@profanity/8e75437a7e43d4c55e861691f74892e666e29b0b,CVE-2017-5592,https://github.com/boothj5/profanity/commit/8e75437a7e43d4c55e861691f74892e666e29b0b,2017-02-09T20:59Z
,"CWE-000 int sas_discover_end_dev ( struct domain_device * dev ) { int res ; res = sas_notify_lldd_dev_found ( dev ) ; if ( res ) return res ; <S2SV_StartBug> sas_discover_event ( dev -> port , DISCE_PROBE ) ; <S2SV_EndBug> return 0 ; }",<S2SV_ModStart> return res ; <S2SV_ModEnd> return 0 ;,torvalds@linux/0558f33c06bb910e2879e355192227a8e8f0219d,CVE-2017-18232,https://github.com/torvalds/linux/commit/0558f33c06bb910e2879e355192227a8e8f0219d,2018-03-15T04:29Z
CWE-125,"CWE-125 char * Util_urlDecode ( char * url ) { if ( url && * url ) { register int x , y ; for ( x = 0 , y = 0 ; url [ y ] ; x ++ , y ++ ) { <S2SV_StartBug> if ( ( url [ x ] = url [ y ] ) == '+' ) <S2SV_EndBug> url [ x ] = '<S2SV_blank>' ; <S2SV_StartBug> else if ( url [ x ] == '%' ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! ( url [ x + 1 ] && url [ x + 2 ] ) ) <S2SV_EndBug> break ; <S2SV_StartBug> url [ x ] = x2c ( url + y + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> y += 2 ; <S2SV_EndBug> } } url [ x ] = 0 ; } return url ; }",<S2SV_ModStart> { if ( <S2SV_ModEnd> url [ y <S2SV_ModStart> [ y ] <S2SV_ModEnd> == '+' ) <S2SV_ModStart> == '+' ) { <S2SV_ModStart> = '<S2SV_blank>' ; } <S2SV_ModStart> ( url [ y <S2SV_ModEnd> ] == '%' <S2SV_ModStart> if ( ! url [ y <S2SV_ModEnd> + 1 ] <S2SV_ModStart> + 1 ] || ! url [ y <S2SV_ModEnd> + 2 ] <S2SV_ModStart> + 2 ] <S2SV_ModEnd> ) break ; <S2SV_ModStart> x ] = _x2c <S2SV_ModEnd> ( url + <S2SV_ModStart> y += 2 ; } else { url [ x ] = url [ y ],tildeslash@monit/f12d0cdb42d4e74dffe1525d4062c815c48ac57a,CVE-2019-11455,https://bitbucket.org/tildeslash/monit/commit/f12d0cdb42d4e74dffe1525d4062c815c48ac57a,2019-04-22T16:29Z
CWE-125,"CWE-125 static void test_bson_validate ( void ) { char filename [ 64 ] ; size_t offset ; bson_t * b ; int i ; bson_error_t error ; for ( i = 1 ; i <= 38 ; i ++ ) { bson_snprintf ( filename , sizeof filename , ""test%u.bson"" , i ) ; b = get_bson ( filename ) ; BSON_ASSERT ( bson_validate ( b , BSON_VALIDATE_NONE , & offset ) ) ; bson_destroy ( b ) ; } b = get_bson ( ""codewscope.bson"" ) ; BSON_ASSERT ( bson_validate ( b , BSON_VALIDATE_NONE , & offset ) ) ; bson_destroy ( b ) ; b = get_bson ( ""empty_key.bson"" ) ; BSON_ASSERT ( bson_validate ( b , BSON_VALIDATE_NONE | BSON_VALIDATE_UTF8 | BSON_VALIDATE_DOLLAR_KEYS | BSON_VALIDATE_DOT_KEYS , & offset ) ) ; bson_destroy ( b ) ; # define VALIDATE_TEST ( _filename , _flags , _offset , _flag , _msg ) b = get_bson ( _filename ) ; BSON_ASSERT ( ! bson_validate ( b , _flags , & offset ) ) ; ASSERT_CMPSIZE_T ( offset , == , ( size_t ) _offset ) ; BSON_ASSERT ( ! bson_validate_with_error ( b , _flags , & error ) ) ; ASSERT_ERROR_CONTAINS ( error , BSON_ERROR_INVALID , _flag , _msg ) ; bson_destroy ( b ) VALIDATE_TEST ( ""overflow2.bson"" , BSON_VALIDATE_NONE , 9 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""trailingnull.bson"" , BSON_VALIDATE_NONE , 14 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""dollarquery.bson"" , BSON_VALIDATE_DOLLAR_KEYS | BSON_VALIDATE_DOT_KEYS , 4 , BSON_VALIDATE_DOLLAR_KEYS , ""keys<S2SV_blank>cannot<S2SV_blank>begin<S2SV_blank>with<S2SV_blank>\\""$\\"":<S2SV_blank>\\""$query\\"""" ) ; VALIDATE_TEST ( ""dotquery.bson"" , BSON_VALIDATE_DOLLAR_KEYS | BSON_VALIDATE_DOT_KEYS , 4 , BSON_VALIDATE_DOT_KEYS , ""keys<S2SV_blank>cannot<S2SV_blank>contain<S2SV_blank>\\"".\\"":<S2SV_blank>\\""abc.def\\"""" ) ; VALIDATE_TEST ( ""overflow3.bson"" , BSON_VALIDATE_NONE , 9 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""overflow3.bson"" , BSON_VALIDATE_UTF8 , 9 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""overflow4.bson"" , BSON_VALIDATE_NONE , 9 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""empty_key.bson"" , BSON_VALIDATE_EMPTY_KEYS , 4 , BSON_VALIDATE_EMPTY_KEYS , ""empty<S2SV_blank>key"" ) ; VALIDATE_TEST ( ""test40.bson"" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""test41.bson"" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""test42.bson"" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""test43.bson"" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""test44.bson"" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""test45.bson"" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""test46.bson"" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""test47.bson"" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""test48.bson"" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""test49.bson"" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""test50.bson"" , BSON_VALIDATE_NONE , 10 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>code-with-scope"" ) ; VALIDATE_TEST ( ""test51.bson"" , BSON_VALIDATE_NONE , 10 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>code-with-scope"" ) ; VALIDATE_TEST ( ""test52.bson"" , BSON_VALIDATE_NONE , 9 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""test53.bson"" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""test54.bson"" , BSON_VALIDATE_NONE , 12 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; <S2SV_StartBug> b = BCON_NEW ( ""my_dbref"" , <S2SV_EndBug> ""{"" , ""$ref"" , BCON_UTF8 ( ""collection"" ) , ""$id"" , BCON_INT32 ( 1 ) , ""}"" ) ; BSON_ASSERT ( bson_validate_with_error ( b , BSON_VALIDATE_NONE , & error ) ) ; BSON_ASSERT ( bson_validate_with_error ( b , BSON_VALIDATE_DOLLAR_KEYS , & error ) ) ; bson_destroy ( b ) ; b = BCON_NEW ( ""my_dbref"" , ""{"" , ""$id"" , BCON_INT32 ( 1 ) , ""}"" ) ; BSON_ASSERT ( bson_validate_with_error ( b , BSON_VALIDATE_NONE , & error ) ) ; BSON_ASSERT ( ! bson_validate_with_error ( b , BSON_VALIDATE_DOLLAR_KEYS , & error ) ) ; ASSERT_ERROR_CONTAINS ( error , BSON_ERROR_INVALID , BSON_VALIDATE_DOLLAR_KEYS , ""keys<S2SV_blank>cannot<S2SV_blank>begin<S2SV_blank>with<S2SV_blank>\\""$\\"":<S2SV_blank>\\""$id\\"""" ) ; bson_destroy ( b ) ; b = BCON_NEW ( ""my_dbref"" , ""{"" , ""$ref"" , BCON_UTF8 ( ""collection"" ) , ""$ref"" , BCON_UTF8 ( ""collection"" ) , ""}"" ) ; BSON_ASSERT ( bson_validate_with_error ( b , BSON_VALIDATE_NONE , & error ) ) ; BSON_ASSERT ( ! bson_validate_with_error ( b , BSON_VALIDATE_DOLLAR_KEYS , & error ) ) ; ASSERT_ERROR_CONTAINS ( error , BSON_ERROR_INVALID , BSON_VALIDATE_DOLLAR_KEYS , ""keys<S2SV_blank>cannot<S2SV_blank>begin<S2SV_blank>with<S2SV_blank>\\""$\\"":<S2SV_blank>\\""$ref\\"""" ) ; bson_destroy ( b ) ; b = BCON_NEW ( ""my_dbref"" , ""{"" , ""$ref"" , BCON_UTF8 ( ""collection"" ) , ""extra"" , BCON_INT32 ( 2 ) , ""$id"" , BCON_INT32 ( 1 ) , ""}"" ) ; BSON_ASSERT ( bson_validate_with_error ( b , BSON_VALIDATE_NONE , & error ) ) ; BSON_ASSERT ( ! bson_validate_with_error ( b , BSON_VALIDATE_DOLLAR_KEYS , & error ) ) ; ASSERT_ERROR_CONTAINS ( error , BSON_ERROR_INVALID , BSON_VALIDATE_DOLLAR_KEYS , ""invalid<S2SV_blank>key<S2SV_blank>within<S2SV_blank>DBRef<S2SV_blank>subdocument:<S2SV_blank>\\""extra\\"""" ) ; bson_destroy ( b ) ; # undef VALIDATE_TEST }","<S2SV_ModStart> ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""test59.bson"" , BSON_VALIDATE_NONE , 9 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ;",mongodb@mongo-c-driver/0d9a4d98bfdf4acd2c0138d4aaeb4e2e0934bd84,CVE-2018-16790,https://github.com/mongodb/mongo-c-driver/commit/0d9a4d98bfdf4acd2c0138d4aaeb4e2e0934bd84,2018-09-10T05:29Z
CWE-476,CWE-476 static int crypto_rng_init_tfm ( struct crypto_tfm * tfm ) { <S2SV_StartBug> struct crypto_rng * rng = __crypto_rng_cast ( tfm ) ; <S2SV_EndBug> struct rng_alg * alg = crypto_rng_alg ( rng ) ; struct old_rng_alg * oalg = crypto_old_rng_alg ( rng ) ; if ( oalg -> rng_make_random ) { rng -> generate = generate ; rng -> seed = rngapi_reset ; rng -> seedsize = oalg -> seedsize ; return 0 ; } rng -> generate = alg -> generate ; rng -> seed = alg -> seed ; rng -> seedsize = alg -> seedsize ; return 0 ; },<S2SV_ModStart> tfm ) { <S2SV_ModEnd> return 0 ;,torvalds@linux/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6,CVE-2017-15116,https://github.com/torvalds/linux/commit/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6,2017-11-30T18:29Z
CWE-20,"CWE-20 static inline void VectorClamp3 ( DDSVector3 * value ) { <S2SV_StartBug> value -> x = MinF ( 1.0f , MaxF ( 0.0f , value -> x ) ) ; <S2SV_EndBug> <S2SV_StartBug> value -> y = MinF ( 1.0f , MaxF ( 0.0f , value -> y ) ) ; <S2SV_EndBug> <S2SV_StartBug> value -> z = MinF ( 1.0f , MaxF ( 0.0f , value -> z ) ) ; <S2SV_EndBug> }","<S2SV_ModStart> -> x = MagickMin <S2SV_ModEnd> ( 1.0f , <S2SV_ModStart> ( 1.0f , MagickMax <S2SV_ModEnd> ( 0.0f , <S2SV_ModStart> -> y = MagickMin <S2SV_ModEnd> ( 1.0f , <S2SV_ModStart> ( 1.0f , MagickMax <S2SV_ModEnd> ( 0.0f , <S2SV_ModStart> -> z = MagickMin <S2SV_ModEnd> ( 1.0f , <S2SV_ModStart> ( 1.0f , MagickMax <S2SV_ModEnd> ( 0.0f ,",ImageMagick@ImageMagick/d7325bac173492b358417a0ad49fabad44447d52,CVE-2014-9907,https://github.com/ImageMagick/ImageMagick/commit/d7325bac173492b358417a0ad49fabad44447d52,2017-04-19T14:59Z
,"CWE-000 static int create_fixed_stream_quirk ( struct snd_usb_audio * chip , struct usb_interface * iface , struct usb_driver * driver , const struct snd_usb_audio_quirk * quirk ) { struct audioformat * fp ; struct usb_host_interface * alts ; struct usb_interface_descriptor * altsd ; int stream , err ; unsigned * rate_table = NULL ; fp = kmemdup ( quirk -> data , sizeof ( * fp ) , GFP_KERNEL ) ; if ( ! fp ) { usb_audio_err ( chip , ""cannot<S2SV_blank>memdup\\n"" ) ; return - ENOMEM ; } if ( fp -> nr_rates > MAX_NR_RATES ) { kfree ( fp ) ; return - EINVAL ; } if ( fp -> nr_rates > 0 ) { rate_table = kmemdup ( fp -> rate_table , sizeof ( int ) * fp -> nr_rates , GFP_KERNEL ) ; if ( ! rate_table ) { kfree ( fp ) ; return - ENOMEM ; } fp -> rate_table = rate_table ; } stream = ( fp -> endpoint & USB_DIR_IN ) ? SNDRV_PCM_STREAM_CAPTURE : SNDRV_PCM_STREAM_PLAYBACK ; err = snd_usb_add_audio_stream ( chip , stream , fp ) ; if ( err < 0 ) { kfree ( fp ) ; kfree ( rate_table ) ; return err ; } if ( fp -> iface != get_iface_desc ( & iface -> altsetting [ 0 ] ) -> bInterfaceNumber || fp -> altset_idx >= iface -> num_altsetting ) { kfree ( fp ) ; kfree ( rate_table ) ; return - EINVAL ; } alts = & iface -> altsetting [ fp -> altset_idx ] ; altsd = get_iface_desc ( alts ) ; <S2SV_StartBug> fp -> protocol = altsd -> bInterfaceProtocol ; <S2SV_EndBug> if ( fp -> datainterval == 0 ) fp -> datainterval = snd_usb_parse_datainterval ( chip , alts ) ; if ( fp -> maxpacksize == 0 ) fp -> maxpacksize = le16_to_cpu ( get_endpoint ( alts , 0 ) -> wMaxPacketSize ) ; usb_set_interface ( chip -> dev , fp -> iface , 0 ) ; snd_usb_init_pitch ( chip , fp -> iface , alts , fp ) ; snd_usb_init_sample_rate ( chip , fp -> iface , alts , fp , fp -> rate_max ) ; return 0 ; }",<S2SV_ModStart> alts ) ; if ( altsd -> bNumEndpoints < 1 ) { kfree ( fp ) ; kfree ( rate_table ) ; return - EINVAL ; },torvalds@linux/0f886ca12765d20124bd06291c82951fd49a33be,CVE-2016-2184,https://github.com/torvalds/linux/commit/0f886ca12765d20124bd06291c82951fd49a33be,2016-04-27T17:59Z
CWE-125,"CWE-125 mod_ty string_object_to_c_ast ( const char * s , PyObject * filename , int start , PyCompilerFlags * flags , int feature_version , PyArena * arena ) { mod_ty mod ; PyCompilerFlags localflags ; perrdetail err ; int iflags = PARSER_FLAGS ( flags ) ; <S2SV_StartBug> node * n = Ta3Parser_ParseStringObject ( s , filename , <S2SV_EndBug> & _Ta3Parser_Grammar , start , & err , & iflags ) ; if ( flags == NULL ) { localflags . cf_flags = 0 ; flags = & localflags ; } if ( n ) { flags -> cf_flags |= iflags & PyCF_MASK ; mod = Ta3AST_FromNodeObject ( n , flags , filename , feature_version , arena ) ; Ta3Node_Free ( n ) ; } else { err_input ( & err ) ; mod = NULL ; } err_free ( & err ) ; return mod ; }",<S2SV_ModStart> ; node * n ; if ( feature_version >= 7 ) iflags |= PyPARSE_ASYNC_ALWAYS ;,python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z
CWE-755,"CWE-000 struct dst_entry * fib6_rule_lookup ( struct net * net , struct flowi6 * fl6 , const struct sk_buff * skb , int flags , pol_lookup_t lookup ) { struct rt6_info * rt ; rt = lookup ( net , net -> ipv6 . fib6_main_tbl , fl6 , skb , flags ) ; if ( rt -> dst . error == - EAGAIN ) { ip6_rt_put_flags ( rt , flags ) ; rt = net -> ipv6 . ip6_null_entry ; <S2SV_StartBug> if ( ! ( flags | RT6_LOOKUP_F_DST_NOREF ) ) <S2SV_EndBug> dst_hold ( & rt -> dst ) ; } return & rt -> dst ; }",<S2SV_ModStart> ! ( flags & <S2SV_ModEnd> RT6_LOOKUP_F_DST_NOREF ) ),torvalds@linux/7b09c2d052db4b4ad0b27b97918b46a7746966fa,CVE-2019-20422,https://github.com/torvalds/linux/commit/7b09c2d052db4b4ad0b27b97918b46a7746966fa,2020-01-27T05:15Z
CWE-284,"CWE-284 static void mntput_no_expire ( struct mount * mnt ) { rcu_read_lock ( ) ; mnt_add_count ( mnt , - 1 ) ; if ( likely ( mnt -> mnt_ns ) ) { rcu_read_unlock ( ) ; return ; } lock_mount_hash ( ) ; if ( mnt_get_count ( mnt ) ) { rcu_read_unlock ( ) ; unlock_mount_hash ( ) ; return ; } if ( unlikely ( mnt -> mnt . mnt_flags & MNT_DOOMED ) ) { rcu_read_unlock ( ) ; unlock_mount_hash ( ) ; return ; } mnt -> mnt . mnt_flags |= MNT_DOOMED ; rcu_read_unlock ( ) ; list_del ( & mnt -> mnt_instance ) ; <S2SV_StartBug> unlock_mount_hash ( ) ; <S2SV_EndBug> if ( likely ( ! ( mnt -> mnt . mnt_flags & MNT_INTERNAL ) ) ) { struct task_struct * task = current ; if ( likely ( ! ( task -> flags & PF_KTHREAD ) ) ) { init_task_work ( & mnt -> mnt_rcu , __cleanup_mnt ) ; if ( ! task_work_add ( task , & mnt -> mnt_rcu , true ) ) return ; } if ( llist_add ( & mnt -> mnt_llist , & delayed_mntput_list ) ) schedule_delayed_work ( & delayed_mntput_work , 1 ) ; return ; } cleanup_mnt ( mnt ) ; }","<S2SV_ModStart> mnt_instance ) ; if ( unlikely ( ! list_empty ( & mnt -> mnt_mounts ) ) ) { struct mount * p , * tmp ; list_for_each_entry_safe ( p , tmp , & mnt -> mnt_mounts , mnt_child ) { umount_mnt ( p ) ; } }",torvalds@linux/ce07d891a0891d3c0d0c2d73d577490486b809e1,CVE-2014-9717,https://github.com/torvalds/linux/commit/ce07d891a0891d3c0d0c2d73d577490486b809e1,2016-05-02T10:59Z
CWE-416,"CWE-416 static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; <S2SV_StartBug> if ( ! head ) { <S2SV_EndBug> WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; <S2SV_StartBug> } <S2SV_EndBug> hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }",<S2SV_ModStart> ; if ( WARN_ON_ONCE ( <S2SV_ModStart> ! head ) ) <S2SV_ModEnd> return - EINVAL <S2SV_ModStart> - EINVAL ; <S2SV_ModEnd> hlist_add_head_rcu ( &,torvalds@linux/12ca6ad2e3a896256f086497a7c7406a547ee373,CVE-2015-8963,https://github.com/torvalds/linux/commit/12ca6ad2e3a896256f086497a7c7406a547ee373,2016-11-16T05:59Z
CWE-284,"CWE-284 void _modinit ( module_t * m ) { service_named_bind_command ( ""chanserv"" , & cs_flags ) ; <S2SV_StartBug> } <S2SV_EndBug>","<S2SV_ModStart> cs_flags ) ; add_bool_conf_item ( ""ANOPE_FLAGS_COMPAT"" , & chansvs . me -> conf_table , 0 , & anope_flags_compat , true ) ; hook_add_event ( ""nick_can_register"" ) ; hook_add_nick_can_register ( check_registration_keywords ) ; hook_add_event ( ""user_can_register"" ) ; hook_add_user_can_register ( check_registration_keywords ) ;",atheme@atheme/c597156adc60a45b5f827793cd420945f47bc03b,CVE-2014-9773,https://github.com/atheme/atheme/commit/c597156adc60a45b5f827793cd420945f47bc03b,2016-06-13T19:59Z
CWE-399,"CWE-399 static void rpc_init_task ( struct rpc_task * task , const struct rpc_task_setup * task_setup_data ) { memset ( task , 0 , sizeof ( * task ) ) ; atomic_set ( & task -> tk_count , 1 ) ; task -> tk_flags = task_setup_data -> flags ; task -> tk_ops = task_setup_data -> callback_ops ; task -> tk_calldata = task_setup_data -> callback_data ; INIT_LIST_HEAD ( & task -> tk_task ) ; task -> tk_garb_retry = 2 ; task -> tk_cred_retry = 2 ; <S2SV_StartBug> task -> tk_priority = task_setup_data -> priority - RPC_PRIORITY_LOW ; <S2SV_EndBug> task -> tk_owner = current -> tgid ; task -> tk_workqueue = task_setup_data -> workqueue ; if ( task -> tk_ops -> rpc_call_prepare != NULL ) task -> tk_action = rpc_prepare_task ; task -> tk_start = ktime_get ( ) ; dprintk ( ""RPC:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>new<S2SV_blank>task<S2SV_blank>initialized,<S2SV_blank>procpid<S2SV_blank>%u\\n"" , task_pid_nr ( current ) ) ; }",<S2SV_ModStart> ; task -> tk_rebind_retry = 2 ; task ->,torvalds@linux/0b760113a3a155269a3fba93a409c640031dd68f,CVE-2011-2491,https://github.com/torvalds/linux/commit/0b760113a3a155269a3fba93a409c640031dd68f,2013-03-01T12:37Z
CWE-200,"CWE-200 static int recv_stream ( struct kiocb * iocb , struct socket * sock , struct msghdr * m , size_t buf_len , int flags ) { struct sock * sk = sock -> sk ; struct tipc_port * tport = tipc_sk_port ( sk ) ; struct sk_buff * buf ; struct tipc_msg * msg ; long timeout ; unsigned int sz ; int sz_to_copy , target , needed ; int sz_copied = 0 ; u32 err ; int res = 0 ; if ( unlikely ( ! buf_len ) ) return - EINVAL ; lock_sock ( sk ) ; if ( unlikely ( ( sock -> state == SS_UNCONNECTED ) || ( sock -> state == SS_CONNECTING ) ) ) { res = - ENOTCONN ; goto exit ; <S2SV_StartBug> } <S2SV_EndBug> target = sock_rcvlowat ( sk , flags & MSG_WAITALL , buf_len ) ; timeout = sock_rcvtimeo ( sk , flags & MSG_DONTWAIT ) ; restart : while ( skb_queue_empty ( & sk -> sk_receive_queue ) ) { if ( sock -> state == SS_DISCONNECTING ) { res = - ENOTCONN ; goto exit ; } if ( timeout <= 0L ) { res = timeout ? timeout : - EWOULDBLOCK ; goto exit ; } release_sock ( sk ) ; timeout = wait_event_interruptible_timeout ( * sk_sleep ( sk ) , tipc_rx_ready ( sock ) , timeout ) ; lock_sock ( sk ) ; } buf = skb_peek ( & sk -> sk_receive_queue ) ; msg = buf_msg ( buf ) ; sz = msg_data_sz ( msg ) ; err = msg_errcode ( msg ) ; if ( ( ! sz ) && ( ! err ) ) { advance_rx_queue ( sk ) ; goto restart ; } if ( sz_copied == 0 ) { set_orig_addr ( m , msg ) ; res = anc_data_recv ( m , msg , tport ) ; if ( res ) goto exit ; } if ( ! err ) { u32 offset = ( u32 ) ( unsigned long ) ( TIPC_SKB_CB ( buf ) -> handle ) ; sz -= offset ; needed = ( buf_len - sz_copied ) ; sz_to_copy = ( sz <= needed ) ? sz : needed ; res = skb_copy_datagram_iovec ( buf , msg_hdr_sz ( msg ) + offset , m -> msg_iov , sz_to_copy ) ; if ( res ) goto exit ; sz_copied += sz_to_copy ; if ( sz_to_copy < sz ) { if ( ! ( flags & MSG_PEEK ) ) TIPC_SKB_CB ( buf ) -> handle = ( void * ) ( unsigned long ) ( offset + sz_to_copy ) ; goto exit ; } } else { if ( sz_copied != 0 ) goto exit ; if ( ( err == TIPC_CONN_SHUTDOWN ) || m -> msg_control ) res = 0 ; else res = - ECONNRESET ; } if ( likely ( ! ( flags & MSG_PEEK ) ) ) { if ( unlikely ( ++ tport -> conn_unacked >= TIPC_FLOW_CONTROL_WIN ) ) tipc_acknowledge ( tport -> ref , tport -> conn_unacked ) ; advance_rx_queue ( sk ) ; } if ( ( sz_copied < buf_len ) && ( ! skb_queue_empty ( & sk -> sk_receive_queue ) || ( sz_copied < target ) ) && ( ! ( flags & MSG_PEEK ) ) && ( ! err ) ) goto restart ; exit : release_sock ( sk ) ; return sz_copied ? sz_copied : res ; }",<S2SV_ModStart> exit ; } m -> msg_namelen = 0 ;,torvalds@linux/60085c3d009b0df252547adb336d1ccca5ce52ec,CVE-2013-3235,https://github.com/torvalds/linux/commit/60085c3d009b0df252547adb336d1ccca5ce52ec,2013-04-22T11:41Z
CWE-119,"CWE-119 <S2SV_StartBug> void impeg2d_dec_pnb_mb_params ( dec_state_t * ps_dec ) <S2SV_EndBug> { stream_t * ps_stream = & ps_dec -> s_bit_stream ; UWORD16 u2_mb_addr_incr ; UWORD16 u2_total_len ; UWORD16 u2_len ; UWORD16 u2_mb_type ; UWORD32 u4_next_word ; const dec_mb_params_t * ps_dec_mb_params ; if ( impeg2d_bit_stream_nxt ( ps_stream , 1 ) == 1 ) { impeg2d_bit_stream_flush ( ps_stream , 1 ) ; } else { u2_mb_addr_incr = impeg2d_get_mb_addr_incr ( ps_stream ) ; if ( ps_dec -> u2_first_mb ) { ps_dec -> u2_mb_x = u2_mb_addr_incr - 1 ; ps_dec -> u2_mb_x = MIN ( ps_dec -> u2_mb_x , ( ps_dec -> u2_num_horiz_mb - 1 ) ) ; u2_mb_addr_incr = 1 ; ps_dec -> u2_first_mb = 0 ; } else { if ( ps_dec -> u2_is_mpeg2 && ( ( ps_dec -> u2_mb_x + u2_mb_addr_incr ) > ps_dec -> u2_num_horiz_mb ) ) { u2_mb_addr_incr = ps_dec -> u2_num_horiz_mb - ps_dec -> u2_mb_x ; } impeg2d_dec_skip_mbs ( ps_dec , ( UWORD16 ) ( u2_mb_addr_incr - 1 ) ) ; } } u4_next_word = ( UWORD16 ) impeg2d_bit_stream_nxt ( ps_stream , 16 ) ; { u2_mb_type = ps_dec -> pu2_mb_type [ BITS ( ( UWORD16 ) u4_next_word , 15 , 10 ) ] ; u2_len = BITS ( u2_mb_type , 15 , 8 ) ; u2_total_len = u2_len ; u4_next_word = ( UWORD16 ) LSW ( ( UWORD16 ) u4_next_word << u2_len ) ; } { WORD32 i4_motion_type = ps_dec -> u2_motion_type ; if ( ( u2_mb_type & MB_FORW_OR_BACK ) && ps_dec -> u2_read_motion_type ) { ps_dec -> u2_motion_type = BITS ( ( UWORD16 ) u4_next_word , 15 , 14 ) ; u2_total_len += MB_MOTION_TYPE_LEN ; u4_next_word = ( UWORD16 ) LSW ( ( UWORD16 ) u4_next_word << MB_MOTION_TYPE_LEN ) ; i4_motion_type = ps_dec -> u2_motion_type ; } if ( ( u2_mb_type & MB_FORW_OR_BACK ) && ( ( i4_motion_type == 0 ) || ( i4_motion_type == 3 ) || ( i4_motion_type == 4 ) || ( i4_motion_type >= 7 ) ) ) { i4_motion_type = 1 ; } } { if ( ( u2_mb_type & MB_CODED ) && ps_dec -> u2_read_dct_type ) { ps_dec -> u2_field_dct = BIT ( ( UWORD16 ) u4_next_word , 15 ) ; u2_total_len += MB_DCT_TYPE_LEN ; u4_next_word = ( UWORD16 ) LSW ( ( UWORD16 ) u4_next_word << MB_DCT_TYPE_LEN ) ; } } if ( u2_mb_type & MB_QUANT ) { UWORD16 u2_quant_scale_code ; u2_quant_scale_code = BITS ( ( UWORD16 ) u4_next_word , 15 , 11 ) ; ps_dec -> u1_quant_scale = ( ps_dec -> u2_q_scale_type ) ? gau1_impeg2_non_linear_quant_scale [ u2_quant_scale_code ] : ( u2_quant_scale_code << 1 ) ; u2_total_len += MB_QUANT_SCALE_CODE_LEN ; } impeg2d_bit_stream_flush ( ps_stream , u2_total_len ) ; ps_dec -> u2_coded_mb = ( UWORD16 ) ( u2_mb_type & MB_CODED ) ; if ( u2_mb_type & MB_BIDRECT ) { UWORD16 u2_index = ( ps_dec -> u2_motion_type ) ; ps_dec -> u2_prev_intra_mb = 0 ; ps_dec -> e_mb_pred = BIDIRECT ; ps_dec_mb_params = & ps_dec -> ps_func_bi_direct [ u2_index ] ; ps_dec -> s_mb_type = ps_dec_mb_params -> s_mb_type ; <S2SV_StartBug> ps_dec_mb_params -> pf_func_mb_params ( ps_dec ) ; <S2SV_EndBug> } else if ( u2_mb_type & MB_FORW_OR_BACK ) { UWORD16 u2_refPic = ! ( u2_mb_type & MB_MV_FORW ) ; UWORD16 u2_index = ( ps_dec -> u2_motion_type ) ; ps_dec -> u2_prev_intra_mb = 0 ; ps_dec -> e_mb_pred = ( e_pred_direction_t ) u2_refPic ; ps_dec_mb_params = & ps_dec -> ps_func_forw_or_back [ u2_index ] ; ps_dec -> s_mb_type = ps_dec_mb_params -> s_mb_type ; <S2SV_StartBug> ps_dec_mb_params -> pf_func_mb_params ( ps_dec ) ; <S2SV_EndBug> } else if ( u2_mb_type & MB_TYPE_INTRA ) { ps_dec -> u2_prev_intra_mb = 1 ; impeg2d_dec_intra_mb ( ps_dec ) ; } else { ps_dec -> u2_prev_intra_mb = 0 ; ps_dec -> e_mb_pred = FORW ; ps_dec -> u2_motion_type = 0 ; impeg2d_dec_0mv_coded_mb ( ps_dec ) ; } if ( ( u2_mb_type & MB_TYPE_INTRA ) ) { ps_dec -> u2_cbp = 0x3f ; ps_dec -> u2_prev_intra_mb = 1 ; } else { ps_dec -> u2_prev_intra_mb = 0 ; ps_dec -> u2_def_dc_pred [ Y_LUMA ] = 128 << ps_dec -> u2_intra_dc_precision ; ps_dec -> u2_def_dc_pred [ U_CHROMA ] = 128 << ps_dec -> u2_intra_dc_precision ; ps_dec -> u2_def_dc_pred [ V_CHROMA ] = 128 << ps_dec -> u2_intra_dc_precision ; if ( ( ps_dec -> u2_coded_mb ) ) { UWORD16 cbpValue ; cbpValue = gau2_impeg2d_cbp_code [ impeg2d_bit_stream_nxt ( ps_stream , MB_CBP_LEN ) ] ; ps_dec -> u2_cbp = cbpValue & 0xFF ; impeg2d_bit_stream_flush ( ps_stream , ( cbpValue >> 8 ) & 0x0FF ) ; } else { ps_dec -> u2_cbp = 0 ; } } <S2SV_StartBug> } <S2SV_EndBug>",<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> WORD32 <S2SV_ModEnd> impeg2d_dec_pnb_mb_params ( dec_state_t <S2SV_ModStart> -> s_mb_type ; if ( NULL == ps_dec_mb_params -> pf_func_mb_params ) return - 1 ; <S2SV_ModStart> -> s_mb_type ; if ( NULL == ps_dec_mb_params -> pf_func_mb_params ) return - 1 ; <S2SV_ModStart> ; } } return 0 ;,external@libmpeg2/58a6822d7140137ce957c6d2fc20bae1374186c1,CVE-2016-0835,https://android.googlesource.com/platform/external/libmpeg2/+/58a6822d7140137ce957c6d2fc20bae1374186c1,2016-04-18T00:59Z
CWE-200,"CWE-200 long dgnc_mgmt_ioctl ( struct file * file , unsigned int cmd , unsigned long arg ) { unsigned long flags ; void __user * uarg = ( void __user * ) arg ; switch ( cmd ) { case DIGI_GETDD : { struct digi_dinfo ddi ; spin_lock_irqsave ( & dgnc_global_lock , flags ) ; <S2SV_StartBug> ddi . dinfo_nboards = dgnc_NumBoards ; <S2SV_EndBug> sprintf ( ddi . dinfo_version , ""%s"" , DG_PART ) ; spin_unlock_irqrestore ( & dgnc_global_lock , flags ) ; if ( copy_to_user ( uarg , & ddi , sizeof ( ddi ) ) ) return - EFAULT ; break ; } case DIGI_GETBD : { int brd ; struct digi_info di ; if ( copy_from_user ( & brd , uarg , sizeof ( int ) ) ) return - EFAULT ; if ( brd < 0 || brd >= dgnc_NumBoards ) return - ENODEV ; memset ( & di , 0 , sizeof ( di ) ) ; di . info_bdnum = brd ; spin_lock_irqsave ( & dgnc_Board [ brd ] -> bd_lock , flags ) ; di . info_bdtype = dgnc_Board [ brd ] -> dpatype ; di . info_bdstate = dgnc_Board [ brd ] -> dpastatus ; di . info_ioport = 0 ; di . info_physaddr = ( ulong ) dgnc_Board [ brd ] -> membase ; di . info_physsize = ( ulong ) dgnc_Board [ brd ] -> membase - dgnc_Board [ brd ] -> membase_end ; if ( dgnc_Board [ brd ] -> state != BOARD_FAILED ) di . info_nports = dgnc_Board [ brd ] -> nasync ; else di . info_nports = 0 ; spin_unlock_irqrestore ( & dgnc_Board [ brd ] -> bd_lock , flags ) ; if ( copy_to_user ( uarg , & di , sizeof ( di ) ) ) return - EFAULT ; break ; } case DIGI_GET_NI_INFO : { struct channel_t * ch ; struct ni_info ni ; unsigned char mstat = 0 ; uint board = 0 ; uint channel = 0 ; if ( copy_from_user ( & ni , uarg , sizeof ( ni ) ) ) return - EFAULT ; board = ni . board ; channel = ni . channel ; if ( board >= dgnc_NumBoards ) return - ENODEV ; if ( channel >= dgnc_Board [ board ] -> nasync ) return - ENODEV ; ch = dgnc_Board [ board ] -> channels [ channel ] ; if ( ! ch || ch -> magic != DGNC_CHANNEL_MAGIC ) return - ENODEV ; memset ( & ni , 0 , sizeof ( ni ) ) ; ni . board = board ; ni . channel = channel ; spin_lock_irqsave ( & ch -> ch_lock , flags ) ; mstat = ( ch -> ch_mostat | ch -> ch_mistat ) ; if ( mstat & UART_MCR_DTR ) { ni . mstat |= TIOCM_DTR ; ni . dtr = TIOCM_DTR ; } if ( mstat & UART_MCR_RTS ) { ni . mstat |= TIOCM_RTS ; ni . rts = TIOCM_RTS ; } if ( mstat & UART_MSR_CTS ) { ni . mstat |= TIOCM_CTS ; ni . cts = TIOCM_CTS ; } if ( mstat & UART_MSR_RI ) { ni . mstat |= TIOCM_RI ; ni . ri = TIOCM_RI ; } if ( mstat & UART_MSR_DCD ) { ni . mstat |= TIOCM_CD ; ni . dcd = TIOCM_CD ; } if ( mstat & UART_MSR_DSR ) ni . mstat |= TIOCM_DSR ; ni . iflag = ch -> ch_c_iflag ; ni . oflag = ch -> ch_c_oflag ; ni . cflag = ch -> ch_c_cflag ; ni . lflag = ch -> ch_c_lflag ; if ( ch -> ch_digi . digi_flags & CTSPACE || ch -> ch_c_cflag & CRTSCTS ) ni . hflow = 1 ; else ni . hflow = 0 ; if ( ( ch -> ch_flags & CH_STOPI ) || ( ch -> ch_flags & CH_FORCED_STOPI ) ) ni . recv_stopped = 1 ; else ni . recv_stopped = 0 ; if ( ( ch -> ch_flags & CH_STOP ) || ( ch -> ch_flags & CH_FORCED_STOP ) ) ni . xmit_stopped = 1 ; else ni . xmit_stopped = 0 ; ni . curtx = ch -> ch_txcount ; ni . currx = ch -> ch_rxcount ; ni . baud = ch -> ch_old_baud ; spin_unlock_irqrestore ( & ch -> ch_lock , flags ) ; if ( copy_to_user ( uarg , & ni , sizeof ( ni ) ) ) return - EFAULT ; break ; } } return 0 ; }","<S2SV_ModStart> flags ) ; memset ( & ddi , 0 , sizeof ( ddi ) ) ;",torvalds@linux/4b6184336ebb5c8dc1eae7f7ab46ee608a748b05,CVE-2015-7885,https://github.com/torvalds/linux/commit/4b6184336ebb5c8dc1eae7f7ab46ee608a748b05,2015-12-28T11:59Z
CWE-200,"CWE-200 static void ipv6_select_ident ( struct frag_hdr * fhdr , struct rt6_info * rt ) { static u32 ip6_idents_hashrnd __read_mostly ; <S2SV_StartBug> u32 hash , id ; <S2SV_EndBug> <S2SV_StartBug> net_get_random_once ( & ip6_idents_hashrnd , sizeof ( ip6_idents_hashrnd ) ) ; <S2SV_EndBug> hash = __ipv6_addr_jhash ( & rt -> rt6i_dst . addr , ip6_idents_hashrnd ) ; hash = __ipv6_addr_jhash ( & rt -> rt6i_src . addr , hash ) ; <S2SV_StartBug> id = ip_idents_reserve ( hash , 1 ) ; <S2SV_EndBug> fhdr -> identification = htonl ( id ) ; }","<S2SV_ModStart> ip6_idents_hashrnd __read_mostly ; static u32 ip6_idents_hashrnd_extra __read_mostly ; <S2SV_ModStart> sizeof ( ip6_idents_hashrnd ) ) ; net_get_random_once ( & ip6_idents_hashrnd_extra , sizeof ( ip6_idents_hashrnd_extra <S2SV_ModStart> hash ) ; hash = jhash_1word ( hash , ip6_idents_hashrnd_extra ) ;",torvalds@linux/55f0fc7a02de8f12757f4937143d8d5091b2e40b,CVE-2019-10638,https://github.com/torvalds/linux/commit/55f0fc7a02de8f12757f4937143d8d5091b2e40b,2019-07-05T23:15Z
CWE-120,"CWE-000 int parse_sym_line ( buf , which_set ) char * buf ; int which_set ; { int val , i ; struct symparse * symp ; <S2SV_StartBug> char * bufp , * commentp , * altp ; <S2SV_EndBug> mungspaces ( buf ) ; if ( ( commentp = rindex ( buf , '#' ) ) != 0 && commentp [ - 1 ] == '<S2SV_blank>' ) commentp [ - 1 ] = '\\0' ; bufp = index ( buf , '=' ) ; altp = index ( buf , ':' ) ; if ( ! bufp || ( altp && altp < bufp ) ) bufp = altp ; if ( ! bufp ) { if ( strncmpi ( buf , ""finish"" , 6 ) == 0 ) { if ( chosen_symset_start ) chosen_symset_end = TRUE ; chosen_symset_start = FALSE ; return 1 ; } config_error_add ( ""No<S2SV_blank>\\""finish\\"""" ) ; return 0 ; } ++ bufp ; if ( * bufp == '<S2SV_blank>' ) ++ bufp ; symp = match_sym ( buf ) ; if ( ! symp ) { config_error_add ( ""Unknown<S2SV_blank>sym<S2SV_blank>keyword"" ) ; return 0 ; } if ( ! symset [ which_set ] . name ) { if ( symp -> range == SYM_CONTROL ) { struct symsetentry * tmpsp , * lastsp ; for ( lastsp = symset_list ; lastsp ; lastsp = lastsp -> next ) if ( ! lastsp -> next ) break ; switch ( symp -> idx ) { case 0 : tmpsp = ( struct symsetentry * ) alloc ( sizeof * tmpsp ) ; tmpsp -> next = ( struct symsetentry * ) 0 ; if ( ! lastsp ) symset_list = tmpsp ; else lastsp -> next = tmpsp ; tmpsp -> idx = symset_count ++ ; tmpsp -> name = dupstr ( bufp ) ; tmpsp -> desc = ( char * ) 0 ; tmpsp -> handling = H_UNK ; tmpsp -> nocolor = 0 ; tmpsp -> primary = 0 ; tmpsp -> rogue = 0 ; break ; case 2 : tmpsp = lastsp ; for ( i = 0 ; known_handling [ i ] ; ++ i ) if ( ! strcmpi ( known_handling [ i ] , bufp ) ) { tmpsp -> handling = i ; break ; } break ; case 3 : tmpsp = lastsp ; if ( tmpsp && ! tmpsp -> desc ) tmpsp -> desc = dupstr ( bufp ) ; break ; case 5 : tmpsp = lastsp ; for ( i = 0 ; known_restrictions [ i ] ; ++ i ) { if ( ! strcmpi ( known_restrictions [ i ] , bufp ) ) { switch ( i ) { case 0 : tmpsp -> primary = 1 ; break ; case 1 : tmpsp -> rogue = 1 ; break ; } break ; } } break ; } } return 1 ; } if ( symp -> range ) { if ( symp -> range == SYM_CONTROL ) { switch ( symp -> idx ) { case 0 : if ( ! strcmpi ( bufp , symset [ which_set ] . name ) ) { chosen_symset_start = TRUE ; if ( which_set == ROGUESET ) init_rogue_symbols ( ) ; else if ( which_set == PRIMARY ) init_primary_symbols ( ) ; } break ; case 1 : if ( chosen_symset_start ) chosen_symset_end = TRUE ; chosen_symset_start = FALSE ; break ; case 2 : if ( chosen_symset_start ) set_symhandling ( bufp , which_set ) ; break ; case 4 : if ( chosen_symset_start ) { if ( bufp ) { if ( ! strcmpi ( bufp , ""true"" ) || ! strcmpi ( bufp , ""yes"" ) || ! strcmpi ( bufp , ""on"" ) ) symset [ which_set ] . nocolor = 0 ; else if ( ! strcmpi ( bufp , ""false"" ) || ! strcmpi ( bufp , ""no"" ) || ! strcmpi ( bufp , ""off"" ) ) symset [ which_set ] . nocolor = 1 ; } } break ; case 5 : if ( chosen_symset_start ) { int n = 0 ; while ( known_restrictions [ n ] ) { if ( ! strcmpi ( known_restrictions [ n ] , bufp ) ) { switch ( n ) { case 0 : symset [ which_set ] . primary = 1 ; break ; case 1 : symset [ which_set ] . rogue = 1 ; break ; } break ; } n ++ ; } } break ; } } else { val = sym_val ( bufp ) ; if ( chosen_symset_start ) { if ( which_set == PRIMARY ) { update_primary_symset ( symp , val ) ; } else if ( which_set == ROGUESET ) { update_rogue_symset ( symp , val ) ; } } } } return 1 ; }","<S2SV_ModStart> , * altp ; if ( strlen ( buf ) >= BUFSZ ) buf [ BUFSZ - 1 ] = '\\0'",NetHack@NetHack/f4a840a48f4bcf11757b3d859e9d53cc9d5ef226,CVE-2019-19905,https://github.com/NetHack/NetHack/commit/f4a840a48f4bcf11757b3d859e9d53cc9d5ef226,2019-12-19T18:15Z
CWE-617,CWE-000 void pci_lintr_assert ( struct pci_vdev * dev ) { <S2SV_StartBug> assert ( dev -> lintr . pin > 0 ) ; <S2SV_EndBug> pthread_mutex_lock ( & dev -> lintr . lock ) ; if ( dev -> lintr . state == IDLE ) { if ( pci_lintr_permitted ( dev ) ) { dev -> lintr . state = ASSERTED ; pci_irq_assert ( dev ) ; } else dev -> lintr . state = PENDING ; } pthread_mutex_unlock ( & dev -> lintr . lock ) ; },"<S2SV_ModStart> dev ) { if <S2SV_ModEnd> ( dev -> <S2SV_ModStart> lintr . pin <= 0 ) { pr_warn ( ""%s:<S2SV_blank>Invalid<S2SV_blank>intr<S2SV_blank>pin<S2SV_blank>on<S2SV_blank>dev<S2SV_blank>[%s]\\n"" , __func__ , dev -> name ) ; return ; } <S2SV_ModEnd> pthread_mutex_lock ( &",projectacrn@acrn-hypervisor/2b3dedfb9ba13f15887f22b935d373f36c9a59fa,CVE-2019-18844,https://github.com/projectacrn/acrn-hypervisor/commit/2b3dedfb9ba13f15887f22b935d373f36c9a59fa,2019-11-13T20:15Z
CWE-415,"CWE-415 static struct usmStateReference * usm_malloc_usmStateReference ( void ) { <S2SV_StartBug> struct usmStateReference * retval = ( struct usmStateReference * ) <S2SV_EndBug> calloc ( 1 , sizeof ( struct usmStateReference ) ) ; <S2SV_StartBug> return retval ; <S2SV_EndBug> }",<S2SV_ModStart> usmStateReference * retval ; retval = <S2SV_ModEnd> calloc ( 1 <S2SV_ModStart> ) ) ; if ( retval ) retval -> refcnt = 1 ;,net-snmp@net-snmp/5f881d3bf24599b90d67a45cae7a3eb099cd71c9,CVE-2019-20892,https://github.com/net-snmp/net-snmp/commit/5f881d3bf24599b90d67a45cae7a3eb099cd71c9,2020-06-25T10:15Z
CWE-772,"CWE-772 generic_ret * modify_policy_2_svc ( mpol_arg * arg , struct svc_req * rqstp ) { static generic_ret ret ; char * prime_arg ; <S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> service_name ; OM_uint32 minor_stat ; kadm5_server_handle_t handle ; const char * errmsg = NULL ; xdr_free ( xdr_generic_ret , & ret ) ; if ( ( ret . code = new_server_handle ( arg -> api_version , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; ret . api_version = handle -> api_version ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = KADM5_FAILURE ; goto exit_func ; } prime_arg = arg -> rec . policy ; if ( CHANGEPW_SERVICE ( rqstp ) || ! kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , ACL_MODIFY , NULL , NULL ) ) { log_unauth ( ""kadm5_modify_policy"" , prime_arg , & client_name , & service_name , rqstp ) ; ret . code = KADM5_AUTH_MODIFY ; } else { ret . code = kadm5_modify_policy ( ( void * ) handle , & arg -> rec , arg -> mask ) ; if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ; log_done ( ""kadm5_modify_policy"" , ( ( prime_arg == NULL ) ? ""(null)"" : prime_arg ) , errmsg , & client_name , & service_name , rqstp ) ; if ( errmsg != NULL ) krb5_free_error_message ( handle -> context , errmsg ) ; } <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> gss_release_buffer ( & minor_stat , & service_name ) ; exit_func : free_server_handle ( handle ) ; return & ret ; }","<S2SV_ModStart> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; OM_uint32 minor_stat <S2SV_ModStart> ) ; } exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_ModEnd> free_server_handle ( handle",krb5@krb5/83ed75feba32e46f736fcce0d96a0445f29b96c2,CVE-2015-8631,https://github.com/krb5/krb5/commit/83ed75feba32e46f736fcce0d96a0445f29b96c2,2016-02-13T02:59Z
CWE-20,"CWE-20 static int ovl_remove_upper ( struct dentry * dentry , bool is_dir ) { struct dentry * upperdir = ovl_dentry_upper ( dentry -> d_parent ) ; struct inode * dir = upperdir -> d_inode ; <S2SV_StartBug> struct dentry * upper = ovl_dentry_upper ( dentry ) ; <S2SV_EndBug> int err ; inode_lock_nested ( dir , I_MUTEX_PARENT ) ; <S2SV_StartBug> err = - ESTALE ; <S2SV_EndBug> <S2SV_StartBug> if ( upper -> d_parent == upperdir ) { <S2SV_EndBug> dget ( upper ) ; if ( is_dir ) err = vfs_rmdir ( dir , upper ) ; else err = vfs_unlink ( dir , upper , NULL ) ; <S2SV_StartBug> dput ( upper ) ; <S2SV_EndBug> ovl_dentry_version_inc ( dentry -> d_parent ) ; <S2SV_StartBug> } <S2SV_EndBug> if ( ! err ) d_drop ( dentry ) ; <S2SV_StartBug> inode_unlock ( dir ) ; <S2SV_EndBug> return err ; }","<S2SV_ModStart> dentry * upper <S2SV_ModEnd> ; int err <S2SV_ModStart> I_MUTEX_PARENT ) ; upper = lookup_one_len ( dentry -> d_name . name , upperdir , dentry -> d_name . len ) ; err = PTR_ERR ( upper ) ; if ( IS_ERR ( upper ) ) goto out_unlock ; <S2SV_ModStart> if ( upper == ovl_dentry_upper ( dentry ) ) { <S2SV_ModEnd> if ( is_dir <S2SV_ModStart> NULL ) ; <S2SV_ModEnd> ovl_dentry_version_inc ( dentry <S2SV_ModStart> ) ; } dput ( upper ) ; <S2SV_ModStart> dentry ) ; out_unlock :",torvalds@linux/11f3710417d026ea2f4fcf362d866342c5274185,CVE-2016-6197,https://github.com/torvalds/linux/commit/11f3710417d026ea2f4fcf362d866342c5274185,2016-08-06T20:59Z
CWE-19,"CWE-000 static void <S2SV_StartBug> ext4_xattr_cache_insert ( struct mb_cache * ext4_mb_cache , struct buffer_head * bh ) <S2SV_EndBug> { __u32 hash = le32_to_cpu ( BHDR ( bh ) -> h_hash ) ; <S2SV_StartBug> struct mb_cache_entry * ce ; <S2SV_EndBug> int error ; <S2SV_StartBug> ce = mb_cache_entry_alloc ( ext4_mb_cache , GFP_NOFS ) ; <S2SV_EndBug> if ( ! ce ) { ea_bdebug ( bh , ""out<S2SV_blank>of<S2SV_blank>memory"" ) ; return ; } <S2SV_StartBug> error = mb_cache_entry_insert ( ce , bh -> b_bdev , bh -> b_blocknr , hash ) ; <S2SV_EndBug> if ( error ) { <S2SV_StartBug> mb_cache_entry_free ( ce ) ; <S2SV_EndBug> <S2SV_StartBug> if ( error == - EBUSY ) { <S2SV_EndBug> ea_bdebug ( bh , ""already<S2SV_blank>in<S2SV_blank>cache"" ) ; <S2SV_StartBug> error = 0 ; <S2SV_EndBug> } } else { ea_bdebug ( bh , ""inserting<S2SV_blank>[%x]"" , ( int ) hash ) ; <S2SV_StartBug> mb_cache_entry_release ( ce ) ; <S2SV_EndBug> } }","<S2SV_ModStart> ext4_xattr_cache_insert ( struct mb2_cache <S2SV_ModEnd> * ext4_mb_cache , <S2SV_ModStart> h_hash ) ; <S2SV_ModEnd> int error ; <S2SV_ModStart> int error ; error = mb2_cache_entry_create <S2SV_ModEnd> ( ext4_mb_cache , <S2SV_ModStart> ext4_mb_cache , GFP_NOFS , hash , <S2SV_ModEnd> bh -> b_blocknr <S2SV_ModStart> bh -> b_blocknr <S2SV_ModEnd> ) ; if <S2SV_ModStart> error ) { <S2SV_ModEnd> if ( error <S2SV_ModStart> - EBUSY ) <S2SV_ModEnd> ea_bdebug ( bh <S2SV_ModStart> ""already<S2SV_blank>in<S2SV_blank>cache"" ) ; } else <S2SV_ModEnd> ea_bdebug ( bh <S2SV_ModStart> hash ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>",torvalds@linux/82939d7999dfc1f1998c4b1c12e2f19edbdff272,CVE-2015-8952,https://github.com/torvalds/linux/commit/82939d7999dfc1f1998c4b1c12e2f19edbdff272,2016-10-16T21:59Z
CWE-119,"CWE-119 static int futex_wait ( u32 __user * uaddr , int fshared , u32 val , ktime_t * abs_time , u32 bitset , int clockrt ) { struct hrtimer_sleeper timeout , * to = NULL ; struct restart_block * restart ; struct futex_hash_bucket * hb ; struct futex_q q ; int ret ; if ( ! bitset ) return - EINVAL ; q . pi_state = NULL ; q . bitset = bitset ; q . rt_waiter = NULL ; q . requeue_pi_key = NULL ; if ( abs_time ) { to = & timeout ; hrtimer_init_on_stack ( & to -> timer , clockrt ? CLOCK_REALTIME : CLOCK_MONOTONIC , HRTIMER_MODE_ABS ) ; hrtimer_init_sleeper ( to , current ) ; hrtimer_set_expires_range_ns ( & to -> timer , * abs_time , current -> timer_slack_ns ) ; } retry : ret = futex_wait_setup ( uaddr , val , fshared , & q , & hb ) ; if ( ret ) goto out ; futex_wait_queue_me ( hb , & q , to ) ; ret = 0 ; if ( ! unqueue_me ( & q ) ) <S2SV_StartBug> goto out_put_key ; <S2SV_EndBug> ret = - ETIMEDOUT ; if ( to && ! to -> task ) <S2SV_StartBug> goto out_put_key ; <S2SV_EndBug> <S2SV_StartBug> if ( ! signal_pending ( current ) ) { <S2SV_EndBug> put_futex_key ( fshared , & q . key ) ; goto retry ; <S2SV_StartBug> } <S2SV_EndBug> ret = - ERESTARTSYS ; if ( ! abs_time ) <S2SV_StartBug> goto out_put_key ; <S2SV_EndBug> restart = & current_thread_info ( ) -> restart_block ; restart -> fn = futex_wait_restart ; restart -> futex . uaddr = ( u32 * ) uaddr ; restart -> futex . val = val ; restart -> futex . time = abs_time -> tv64 ; restart -> futex . bitset = bitset ; restart -> futex . flags = FLAGS_HAS_TIMEOUT ; if ( fshared ) restart -> futex . flags |= FLAGS_SHARED ; if ( clockrt ) restart -> futex . flags |= FLAGS_CLOCKRT ; ret = - ERESTART_RESTARTBLOCK ; <S2SV_StartBug> out_put_key : <S2SV_EndBug> put_futex_key ( fshared , & q . key ) ; out : if ( to ) { hrtimer_cancel ( & to -> timer ) ; destroy_hrtimer_on_stack ( & to -> timer ) ; } return ret ; }",<S2SV_ModStart> ) ) goto out <S2SV_ModEnd> ; ret = <S2SV_ModStart> task ) goto out <S2SV_ModEnd> ; if ( <S2SV_ModStart> current ) ) <S2SV_ModEnd> goto retry ; <S2SV_ModStart> goto retry ; <S2SV_ModEnd> ret = - <S2SV_ModStart> abs_time ) goto out <S2SV_ModEnd> ; restart = <S2SV_ModStart> - ERESTART_RESTARTBLOCK ; <S2SV_ModEnd> out : if,torvalds@linux/7ada876a8703f23befbb20a7465a702ee39b1704,CVE-2014-0205,https://github.com/torvalds/linux/commit/7ada876a8703f23befbb20a7465a702ee39b1704,2014-09-28T19:55Z
CWE-190,"CWE-190 static int on_http_message_complete ( http_parser * parser ) { struct clt_info * info = parser -> data ; ws_svr * svr = ws_svr_from_ses ( info -> ses ) ; info -> request -> version_major = parser -> http_major ; info -> request -> version_minor = parser -> http_minor ; info -> request -> method = parser -> method ; dict_entry * entry ; dict_iterator * iter = dict_get_iterator ( info -> request -> headers ) ; while ( ( entry = dict_next ( iter ) ) != NULL ) { log_trace ( ""Header:<S2SV_blank>%s:<S2SV_blank>%s"" , ( char * ) entry -> key , ( char * ) entry -> val ) ; } dict_release_iterator ( iter ) ; if ( info -> request -> method != HTTP_GET ) goto error ; if ( http_request_get_header ( info -> request , ""Host"" ) == NULL ) goto error ; double version = info -> request -> version_major + info -> request -> version_minor * 0.1 ; if ( version < 1.1 ) goto error ; const char * upgrade = http_request_get_header ( info -> request , ""Upgrade"" ) ; if ( upgrade == NULL || strcasecmp ( upgrade , ""websocket"" ) != 0 ) goto error ; const char * connection = http_request_get_header ( info -> request , ""Connection"" ) ; <S2SV_StartBug> if ( connection == NULL ) <S2SV_EndBug> goto error ; else { bool found_upgrade = false ; int count ; sds * tokens = sdssplitlen ( connection , strlen ( connection ) , "","" , 1 , & count ) ; if ( tokens == NULL ) goto error ; for ( int i = 0 ; i < count ; i ++ ) { sds token = tokens [ i ] ; sdstrim ( token , ""<S2SV_blank>"" ) ; if ( strcasecmp ( token , ""Upgrade"" ) == 0 ) { found_upgrade = true ; break ; } } sdsfreesplitres ( tokens , count ) ; if ( ! found_upgrade ) goto error ; } const char * ws_version = http_request_get_header ( info -> request , ""Sec-WebSocket-Version"" ) ; if ( ws_version == NULL || strcmp ( ws_version , ""13"" ) != 0 ) goto error ; const char * ws_key = http_request_get_header ( info -> request , ""Sec-WebSocket-Key"" ) ; if ( ws_key == NULL ) goto error ; const char * protocol_list = http_request_get_header ( info -> request , ""Sec-WebSocket-Protocol"" ) ; if ( protocol_list && ! is_good_protocol ( protocol_list , svr -> protocol ) ) goto error ; if ( strlen ( svr -> origin ) > 0 ) { const char * origin = http_request_get_header ( info -> request , ""Origin"" ) ; if ( origin == NULL || ! is_good_origin ( origin , svr -> origin ) ) goto error ; } if ( svr -> type . on_privdata_alloc ) { info -> privdata = svr -> type . on_privdata_alloc ( svr ) ; if ( info -> privdata == NULL ) goto error ; } info -> upgrade = true ; info -> remote = sdsnew ( http_get_remote_ip ( info -> ses , info -> request ) ) ; info -> url = sdsnew ( info -> request -> url ) ; if ( svr -> type . on_upgrade ) { svr -> type . on_upgrade ( info -> ses , info -> remote ) ; } if ( protocol_list ) { send_hand_shake_reply ( info -> ses , svr -> protocol , ws_key ) ; } else { send_hand_shake_reply ( info -> ses , NULL , ws_key ) ; } return 0 ; error : ws_svr_close_clt ( ws_svr_from_ses ( info -> ses ) , info -> ses ) ; return - 1 ; }",<S2SV_ModStart> connection == NULL || strlen ( connection ) > UT_WS_SVR_MAX_HEADER_SIZE,viabtc@viabtc_exchange_server/4a7c27bfe98f409623d4d857894d017ff0672cc9,CVE-2018-17568,https://github.com/viabtc/viabtc_exchange_server/commit/4a7c27bfe98f409623d4d857894d017ff0672cc9#diff-0c23effa84a7b85053bac7981a8580c8,2018-09-26T22:29Z
CWE-772,"CWE-772 generic_ret * delete_principal_2_svc ( dprinc_arg * arg , struct svc_req * rqstp ) { static generic_ret ret ; char * prime_arg ; <S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> service_name ; OM_uint32 minor_stat ; kadm5_server_handle_t handle ; const char * errmsg = NULL ; xdr_free ( xdr_generic_ret , & ret ) ; if ( ( ret . code = new_server_handle ( arg -> api_version , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; ret . api_version = handle -> api_version ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = KADM5_FAILURE ; goto exit_func ; } if ( krb5_unparse_name ( handle -> context , arg -> princ , & prime_arg ) ) { ret . code = KADM5_BAD_PRINCIPAL ; goto exit_func ; } if ( CHANGEPW_SERVICE ( rqstp ) || ! kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , ACL_DELETE , arg -> princ , NULL ) ) { ret . code = KADM5_AUTH_DELETE ; log_unauth ( ""kadm5_delete_principal"" , prime_arg , & client_name , & service_name , rqstp ) ; } else { ret . code = kadm5_delete_principal ( ( void * ) handle , arg -> princ ) ; if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ; log_done ( ""kadm5_delete_principal"" , prime_arg , errmsg , & client_name , & service_name , rqstp ) ; if ( errmsg != NULL ) krb5_free_error_message ( handle -> context , errmsg ) ; } free ( prime_arg ) ; <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_StartBug> exit_func : <S2SV_EndBug> free_server_handle ( handle ) ; return & ret ; }",<S2SV_ModStart> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; OM_uint32 minor_stat <S2SV_ModStart> prime_arg ) ; exit_func : <S2SV_ModStart> service_name ) ; <S2SV_ModEnd> free_server_handle ( handle,krb5@krb5/83ed75feba32e46f736fcce0d96a0445f29b96c2,CVE-2015-8631,https://github.com/krb5/krb5/commit/83ed75feba32e46f736fcce0d96a0445f29b96c2,2016-02-13T02:59Z
CWE-200,"CWE-200 static int xfrm_alloc_replay_state_esn ( struct xfrm_replay_state_esn * * replay_esn , struct xfrm_replay_state_esn * * preplay_esn , struct nlattr * rta ) { struct xfrm_replay_state_esn * p , * pp , * up ; <S2SV_StartBug> if ( ! rta ) <S2SV_EndBug> return 0 ; up = nla_data ( rta ) ; <S2SV_StartBug> p = kmemdup ( up , xfrm_replay_state_esn_len ( up ) , GFP_KERNEL ) ; <S2SV_EndBug> if ( ! p ) return - ENOMEM ; <S2SV_StartBug> pp = kmemdup ( up , xfrm_replay_state_esn_len ( up ) , GFP_KERNEL ) ; <S2SV_EndBug> if ( ! pp ) { kfree ( p ) ; return - ENOMEM ; } <S2SV_StartBug> * replay_esn = p ; <S2SV_EndBug> * preplay_esn = pp ; return 0 ; }","<S2SV_ModStart> * up ; int klen , ulen ; <S2SV_ModStart> rta ) ; klen = <S2SV_ModEnd> xfrm_replay_state_esn_len ( up <S2SV_ModStart> ( up ) ; ulen = nla_len ( rta ) >= klen ? klen : sizeof ( * up ) ; p = kzalloc ( klen <S2SV_ModStart> ; pp = kzalloc ( klen <S2SV_ModEnd> , GFP_KERNEL ) <S2SV_ModStart> ENOMEM ; } memcpy ( p , up , ulen ) ; memcpy ( pp , up , ulen ) ;",torvalds@linux/ecd7918745234e423dd87fcc0c077da557909720,CVE-2012-6536,https://github.com/torvalds/linux/commit/ecd7918745234e423dd87fcc0c077da557909720,2013-03-15T20:55Z
CWE-19,"CWE-000 int xfs_attr3_leaf_clearflag ( struct xfs_da_args * args ) { struct xfs_attr_leafblock * leaf ; struct xfs_attr_leaf_entry * entry ; struct xfs_attr_leaf_name_remote * name_rmt ; struct xfs_buf * bp ; int error ; # ifdef DEBUG struct xfs_attr3_icleaf_hdr ichdr ; xfs_attr_leaf_name_local_t * name_loc ; int namelen ; char * name ; # endif trace_xfs_attr_leaf_clearflag ( args ) ; error = xfs_attr3_leaf_read ( args -> trans , args -> dp , args -> blkno , - 1 , & bp ) ; if ( error ) return ( error ) ; leaf = bp -> b_addr ; entry = & xfs_attr3_leaf_entryp ( leaf ) [ args -> index ] ; ASSERT ( entry -> flags & XFS_ATTR_INCOMPLETE ) ; # ifdef DEBUG xfs_attr3_leaf_hdr_from_disk ( & ichdr , leaf ) ; ASSERT ( args -> index < ichdr . count ) ; ASSERT ( args -> index >= 0 ) ; if ( entry -> flags & XFS_ATTR_LOCAL ) { name_loc = xfs_attr3_leaf_name_local ( leaf , args -> index ) ; namelen = name_loc -> namelen ; name = ( char * ) name_loc -> nameval ; } else { name_rmt = xfs_attr3_leaf_name_remote ( leaf , args -> index ) ; namelen = name_rmt -> namelen ; name = ( char * ) name_rmt -> name ; } ASSERT ( be32_to_cpu ( entry -> hashval ) == args -> hashval ) ; ASSERT ( namelen == args -> namelen ) ; ASSERT ( memcmp ( name , args -> name , namelen ) == 0 ) ; # endif entry -> flags &= ~ XFS_ATTR_INCOMPLETE ; xfs_trans_log_buf ( args -> trans , bp , XFS_DA_LOGRANGE ( leaf , entry , sizeof ( * entry ) ) ) ; if ( args -> rmtblkno ) { ASSERT ( ( entry -> flags & XFS_ATTR_LOCAL ) == 0 ) ; name_rmt = xfs_attr3_leaf_name_remote ( leaf , args -> index ) ; name_rmt -> valueblk = cpu_to_be32 ( args -> rmtblkno ) ; <S2SV_StartBug> name_rmt -> valuelen = cpu_to_be32 ( args -> valuelen ) ; <S2SV_EndBug> xfs_trans_log_buf ( args -> trans , bp , XFS_DA_LOGRANGE ( leaf , name_rmt , sizeof ( * name_rmt ) ) ) ; } return xfs_trans_roll ( & args -> trans , args -> dp ) ; }",<S2SV_ModStart> ( args -> rmtvaluelen <S2SV_ModEnd> ) ; xfs_trans_log_buf,torvalds@linux/8275cdd0e7ac550dcce2b3ef6d2fb3b808c1ae59,CVE-2015-0274,https://github.com/torvalds/linux/commit/8275cdd0e7ac550dcce2b3ef6d2fb3b808c1ae59,2015-03-16T10:59Z
CWE-120,"CWE-000 MagickExport void * AcquireQuantumMemory ( const size_t count , const size_t quantum ) { size_t extent ; <S2SV_StartBug> if ( CheckMemoryOverflow ( count , quantum ) != MagickFalse ) <S2SV_EndBug> return ( ( void * ) NULL ) ; extent = count * quantum ; return ( AcquireMagickMemory ( extent ) ) ; }","<S2SV_ModStart> ; if ( HeapOverflowSanityCheck <S2SV_ModEnd> ( count ,",ImageMagick@ImageMagick/e45e48b881038487d0bc94d92a16c1537616cc0a,CVE-2016-10066,https://github.com/ImageMagick/ImageMagick/commit/e45e48b881038487d0bc94d92a16c1537616cc0a,2017-03-03T17:59Z
CWE-476,"CWE-476 static int stv06xx_start ( struct gspca_dev * gspca_dev ) { struct sd * sd = ( struct sd * ) gspca_dev ; struct usb_host_interface * alt ; struct usb_interface * intf ; int err , packet_size ; intf = usb_ifnum_to_if ( sd -> gspca_dev . dev , sd -> gspca_dev . iface ) ; alt = usb_altnum_to_altsetting ( intf , sd -> gspca_dev . alt ) ; if ( ! alt ) { gspca_err ( gspca_dev , ""Couldn\'t<S2SV_blank>get<S2SV_blank>altsetting\\n"" ) ; return - EIO ; } <S2SV_StartBug> packet_size = le16_to_cpu ( alt -> endpoint [ 0 ] . desc . wMaxPacketSize ) ; <S2SV_EndBug> err = stv06xx_write_bridge ( sd , STV_ISO_SIZE_L , packet_size ) ; if ( err < 0 ) return err ; err = sd -> sensor -> start ( sd ) ; if ( err < 0 ) goto out ; err = stv06xx_write_bridge ( sd , STV_ISO_ENABLE , 1 ) ; out : if ( err < 0 ) gspca_dbg ( gspca_dev , D_STREAM , ""Starting<S2SV_blank>stream<S2SV_blank>failed\\n"" ) ; else gspca_dbg ( gspca_dev , D_STREAM , ""Started<S2SV_blank>streaming\\n"" ) ; return ( err < 0 ) ? err : 0 ; }",<S2SV_ModStart> EIO ; } if ( alt -> desc . bNumEndpoints < 1 ) return - ENODEV ;,torvalds@linux/485b06aadb933190f4bc44e006076bc27a23f205,CVE-2020-11609,https://github.com/torvalds/linux/commit/485b06aadb933190f4bc44e006076bc27a23f205,2020-04-07T17:15Z
CWE-125,"CWE-125 static int <S2SV_StartBug> l_strnstart ( const char * tstr1 , u_int tl1 , const char * str2 , u_int l2 ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> if ( tl1 > l2 ) return 0 ; return ( strncmp ( tstr1 , str2 , tl1 ) == 0 ? 1 : 0 ) ; }","<S2SV_ModStart> int l_strnstart ( netdissect_options * ndo , <S2SV_ModStart> l2 ) { if ( ! ND_TTEST2 ( * str2 , tl1 ) ) { return 0 ; }",the-tcpdump-group@tcpdump/877b66b398518d9501513e0860c9f3a8acc70892,CVE-2017-13010,https://github.com/the-tcpdump-group/tcpdump/commit/877b66b398518d9501513e0860c9f3a8acc70892,2017-09-14T06:29Z
CWE-119,"CWE-119 static void mt_decode_macroblock ( VP8D_COMP * pbi , MACROBLOCKD * xd , unsigned int mb_idx ) { MB_PREDICTION_MODE mode ; int i ; # if CONFIG_ERROR_CONCEALMENT int corruption_detected = 0 ; <S2SV_StartBug> # endif <S2SV_EndBug> if ( xd -> mode_info_context -> mbmi . mb_skip_coeff ) { vp8_reset_mb_tokens_context ( xd ) ; } else if ( ! vp8dx_bool_error ( xd -> current_bc ) ) { int eobtotal ; eobtotal = vp8_decode_mb_tokens ( pbi , xd ) ; xd -> mode_info_context -> mbmi . mb_skip_coeff = ( eobtotal == 0 ) ; } mode = xd -> mode_info_context -> mbmi . mode ; if ( xd -> segmentation_enabled ) vp8_mb_init_dequantizer ( pbi , xd ) ; # if CONFIG_ERROR_CONCEALMENT if ( pbi -> ec_active ) { int throw_residual ; throw_residual = ( ! pbi -> independent_partitions && pbi -> frame_corrupt_residual ) ; throw_residual = ( throw_residual || vp8dx_bool_error ( xd -> current_bc ) ) ; if ( ( mb_idx >= pbi -> mvs_corrupt_from_mb || throw_residual ) ) { pbi -> frame_corrupt_residual = 1 ; <S2SV_StartBug> vpx_memset ( xd -> qcoeff , 0 , sizeof ( xd -> qcoeff ) ) ; <S2SV_EndBug> vp8_conceal_corrupt_mb ( xd ) ; corruption_detected = 1 ; <S2SV_StartBug> vpx_memset ( xd -> eobs , 0 , 25 ) ; <S2SV_EndBug> } } # endif if ( xd -> mode_info_context -> mbmi . ref_frame == INTRA_FRAME ) { vp8_build_intra_predictors_mbuv_s ( xd , xd -> recon_above [ 1 ] , xd -> recon_above [ 2 ] , xd -> recon_left [ 1 ] , xd -> recon_left [ 2 ] , xd -> recon_left_stride [ 1 ] , xd -> dst . u_buffer , xd -> dst . v_buffer , xd -> dst . uv_stride ) ; if ( mode != B_PRED ) { vp8_build_intra_predictors_mby_s ( xd , xd -> recon_above [ 0 ] , xd -> recon_left [ 0 ] , xd -> recon_left_stride [ 0 ] , xd -> dst . y_buffer , xd -> dst . y_stride ) ; } else { short * DQC = xd -> dequant_y1 ; int dst_stride = xd -> dst . y_stride ; if ( xd -> mode_info_context -> mbmi . mb_skip_coeff ) <S2SV_StartBug> vpx_memset ( xd -> eobs , 0 , 25 ) ; <S2SV_EndBug> intra_prediction_down_copy ( xd , xd -> recon_above [ 0 ] + 16 ) ; for ( i = 0 ; i < 16 ; i ++ ) { BLOCKD * b = & xd -> block [ i ] ; unsigned char * dst = xd -> dst . y_buffer + b -> offset ; B_PREDICTION_MODE b_mode = xd -> mode_info_context -> bmi [ i ] . as_mode ; unsigned char * Above ; unsigned char * yleft ; int left_stride ; unsigned char top_left ; if ( i < 4 && pbi -> common . filter_level ) Above = xd -> recon_above [ 0 ] + b -> offset ; else Above = dst - dst_stride ; if ( i % 4 == 0 && pbi -> common . filter_level ) { yleft = xd -> recon_left [ 0 ] + i ; left_stride = 1 ; } else { yleft = dst - 1 ; left_stride = dst_stride ; } if ( ( i == 4 || i == 8 || i == 12 ) && pbi -> common . filter_level ) top_left = * ( xd -> recon_left [ 0 ] + i - 1 ) ; else top_left = Above [ - 1 ] ; vp8_intra4x4_predict ( Above , yleft , left_stride , b_mode , dst , dst_stride , top_left ) ; if ( xd -> eobs [ i ] ) { if ( xd -> eobs [ i ] > 1 ) { vp8_dequant_idct_add ( b -> qcoeff , DQC , dst , dst_stride ) ; } else { vp8_dc_only_idct_add ( b -> qcoeff [ 0 ] * DQC [ 0 ] , dst , dst_stride , dst , dst_stride ) ; <S2SV_StartBug> vpx_memset ( b -> qcoeff , 0 , 2 * sizeof ( b -> qcoeff [ 0 ] ) ) ; <S2SV_EndBug> } } } } } else { vp8_build_inter_predictors_mb ( xd ) ; } # if CONFIG_ERROR_CONCEALMENT if ( corruption_detected ) { return ; } # endif if ( ! xd -> mode_info_context -> mbmi . mb_skip_coeff ) { if ( mode != B_PRED ) { short * DQC = xd -> dequant_y1 ; if ( mode != SPLITMV ) { BLOCKD * b = & xd -> block [ 24 ] ; if ( xd -> eobs [ 24 ] > 1 ) { vp8_dequantize_b ( b , xd -> dequant_y2 ) ; vp8_short_inv_walsh4x4 ( & b -> dqcoeff [ 0 ] , xd -> qcoeff ) ; <S2SV_StartBug> vpx_memset ( b -> qcoeff , 0 , 16 * sizeof ( b -> qcoeff [ 0 ] ) ) ; <S2SV_EndBug> } else { b -> dqcoeff [ 0 ] = b -> qcoeff [ 0 ] * xd -> dequant_y2 [ 0 ] ; vp8_short_inv_walsh4x4_1 ( & b -> dqcoeff [ 0 ] , xd -> qcoeff ) ; <S2SV_StartBug> vpx_memset ( b -> qcoeff , 0 , 2 * sizeof ( b -> qcoeff [ 0 ] ) ) ; <S2SV_EndBug> } DQC = xd -> dequant_y1_dc ; } vp8_dequant_idct_add_y_block ( xd -> qcoeff , DQC , xd -> dst . y_buffer , xd -> dst . y_stride , xd -> eobs ) ; } vp8_dequant_idct_add_uv_block ( xd -> qcoeff + 16 * 16 , xd -> dequant_uv , xd -> dst . u_buffer , xd -> dst . v_buffer , xd -> dst . uv_stride , xd -> eobs + 16 ) ; } }",<S2SV_ModStart> 0 ; # else ( void ) mb_idx ; # <S2SV_ModStart> = 1 ; memset <S2SV_ModEnd> ( xd -> <S2SV_ModStart> = 1 ; memset <S2SV_ModEnd> ( xd -> <S2SV_ModStart> . mb_skip_coeff ) memset <S2SV_ModEnd> ( xd -> <S2SV_ModStart> dst_stride ) ; memset <S2SV_ModEnd> ( b -> <S2SV_ModStart> qcoeff ) ; memset <S2SV_ModEnd> ( b -> <S2SV_ModStart> qcoeff ) ; memset <S2SV_ModEnd> ( b ->,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-399,"CWE-399 static void record_and_restart ( struct perf_event * event , unsigned long val , <S2SV_StartBug> struct pt_regs * regs , int nmi ) <S2SV_EndBug> { u64 period = event -> hw . sample_period ; s64 prev , delta , left ; int record = 0 ; if ( event -> hw . state & PERF_HES_STOPPED ) { write_pmc ( event -> hw . idx , 0 ) ; return ; } prev = local64_read ( & event -> hw . prev_count ) ; delta = check_and_compute_delta ( prev , val ) ; local64_add ( delta , & event -> count ) ; val = 0 ; left = local64_read ( & event -> hw . period_left ) - delta ; if ( period ) { if ( left <= 0 ) { left += period ; if ( left <= 0 ) left = period ; record = 1 ; event -> hw . last_period = event -> hw . sample_period ; } if ( left < 0x80000000LL ) val = 0x80000000LL - left ; } write_pmc ( event -> hw . idx , val ) ; local64_set ( & event -> hw . prev_count , val ) ; local64_set ( & event -> hw . period_left , left ) ; perf_event_update_userpage ( event ) ; if ( record ) { struct perf_sample_data data ; perf_sample_data_init ( & data , ~ 0ULL ) ; data . period = event -> hw . last_period ; if ( event -> attr . sample_type & PERF_SAMPLE_ADDR ) perf_get_data_addr ( regs , & data . addr ) ; <S2SV_StartBug> if ( perf_event_overflow ( event , nmi , & data , regs ) ) <S2SV_EndBug> power_pmu_stop ( event , 0 ) ; } }","<S2SV_ModStart> pt_regs * regs <S2SV_ModEnd> ) { u64 <S2SV_ModStart> ( event , <S2SV_ModEnd> & data ,",torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z
CWE-125,"CWE-125 static int num_stmts ( const node * n ) { int i , l ; node * ch ; switch ( TYPE ( n ) ) { case single_input : if ( TYPE ( CHILD ( n , 0 ) ) == NEWLINE ) return 0 ; else return num_stmts ( CHILD ( n , 0 ) ) ; case file_input : l = 0 ; for ( i = 0 ; i < NCH ( n ) ; i ++ ) { ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == stmt ) l += num_stmts ( ch ) ; } return l ; case stmt : return num_stmts ( CHILD ( n , 0 ) ) ; case compound_stmt : return 1 ; case simple_stmt : return NCH ( n ) / 2 ; case suite : <S2SV_StartBug> if ( NCH ( n ) == 1 ) <S2SV_EndBug> return num_stmts ( CHILD ( n , 0 ) ) ; else { <S2SV_StartBug> l = 0 ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 2 ; i < ( NCH ( n ) - 1 ) ; i ++ ) <S2SV_EndBug> l += num_stmts ( CHILD ( n , i ) ) ; return l ; } default : { char buf [ 128 ] ; sprintf ( buf , ""Non-statement<S2SV_blank>found:<S2SV_blank>%d<S2SV_blank>%d"" , TYPE ( n ) , NCH ( n ) ) ; Py_FatalError ( buf ) ; } } Py_UNREACHABLE ( ) ; }","<S2SV_ModStart> case suite : case func_body_suite : <S2SV_ModStart> ; else { i = 2 ; l = 0 ; if ( TYPE ( CHILD ( n , 1 ) ) == TYPE_COMMENT ) i += 2 <S2SV_ModEnd> ; for ( <S2SV_ModStart> ; for ( <S2SV_ModEnd> ; i <",python@typed_ast/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,CVE-2019-19275,https://github.com/python/typed_ast/commit/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,2019-11-26T15:15Z
CWE-552,"CWE-000 static ssize_t _hostsock_sendmsg ( oe_fd_t * sock_ , const struct oe_msghdr * msg , int flags ) { ssize_t ret = - 1 ; sock_t * sock = _cast_sock ( sock_ ) ; void * buf = NULL ; <S2SV_StartBug> size_t buf_size = 0 ; <S2SV_EndBug> oe_errno = 0 ; if ( ! sock || ! msg || ( msg -> msg_iovlen && ! msg -> msg_iov ) ) OE_RAISE_ERRNO ( OE_EINVAL ) ; <S2SV_StartBug> if ( oe_iov_pack ( msg -> msg_iov , ( int ) msg -> msg_iovlen , & buf , & buf_size ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> OE_RAISE_ERRNO ( OE_ENOMEM ) ; <S2SV_EndBug> if ( oe_syscall_sendmsg_ocall ( & ret , sock -> host_fd , msg -> msg_name , msg -> msg_namelen , buf , msg -> msg_iovlen , buf_size , msg -> msg_control , msg -> msg_controllen , flags ) != OE_OK ) { OE_RAISE_ERRNO ( OE_EINVAL ) ; } <S2SV_StartBug> done : <S2SV_EndBug> if ( buf ) oe_free ( buf ) ; return ret ; }","<S2SV_ModStart> ; size_t buf_size = 0 ; size_t data_size <S2SV_ModStart> , & buf_size , & data_size <S2SV_ModStart> OE_RAISE_ERRNO ( OE_ENOMEM ) ; if ( data_size > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL <S2SV_ModStart> ) ; } if ( ret > ( ssize_t ) data_size ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; }",openenclave@openenclave/bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b,CVE-2020-15224,https://github.com/openenclave/openenclave/commit/bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b,2020-10-14T19:15Z
CWE-20,"CWE-20 static MagickBooleanType ReadDXT1 ( Image * image , DDSInfo * dds_info , ExceptionInfo * exception ) { DDSColors colors ; PixelPacket * q ; register ssize_t i , x ; size_t bits ; ssize_t j , y ; unsigned char code ; unsigned short c0 , c1 ; for ( y = 0 ; y < ( ssize_t ) dds_info -> height ; y += 4 ) { for ( x = 0 ; x < ( ssize_t ) dds_info -> width ; x += 4 ) { <S2SV_StartBug> q = QueueAuthenticPixels ( image , x , y , Min ( 4 , dds_info -> width - x ) , <S2SV_EndBug> <S2SV_StartBug> Min ( 4 , dds_info -> height - y ) , exception ) ; <S2SV_EndBug> if ( q == ( PixelPacket * ) NULL ) return MagickFalse ; c0 = ReadBlobLSBShort ( image ) ; c1 = ReadBlobLSBShort ( image ) ; bits = ReadBlobLSBLong ( image ) ; CalculateColors ( c0 , c1 , & colors , MagickFalse ) ; for ( j = 0 ; j < 4 ; j ++ ) { for ( i = 0 ; i < 4 ; i ++ ) { if ( ( x + i ) < ( ssize_t ) dds_info -> width && ( y + j ) < ( ssize_t ) dds_info -> height ) { code = ( unsigned char ) ( ( bits >> ( ( j * 4 + i ) * 2 ) ) & 0x3 ) ; SetPixelRed ( q , ScaleCharToQuantum ( colors . r [ code ] ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( colors . g [ code ] ) ) ; SetPixelBlue ( q , ScaleCharToQuantum ( colors . b [ code ] ) ) ; SetPixelOpacity ( q , ScaleCharToQuantum ( colors . a [ code ] ) ) ; if ( colors . a [ code ] && image -> matte == MagickFalse ) image -> matte = MagickTrue ; q ++ ; } } } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) return MagickFalse ; } } <S2SV_StartBug> SkipDXTMipmaps ( image , dds_info , 8 ) ; <S2SV_EndBug> return MagickTrue ; }","<S2SV_ModStart> , y , MagickMin <S2SV_ModEnd> ( 4 , <S2SV_ModStart> x ) , MagickMin <S2SV_ModEnd> ( 4 , <S2SV_ModStart> ; } } return ( <S2SV_ModStart> dds_info , 8 , exception ) ) <S2SV_ModEnd> ; } <S2SV_null>",ImageMagick@ImageMagick/d7325bac173492b358417a0ad49fabad44447d52,CVE-2014-9907,https://github.com/ImageMagick/ImageMagick/commit/d7325bac173492b358417a0ad49fabad44447d52,2017-04-19T14:59Z
CWE-119,"CWE-119 <S2SV_StartBug> static inline bool unconditional ( const struct ipt_ip * ip ) <S2SV_EndBug> { static const struct ipt_ip uncond ; <S2SV_StartBug> return memcmp ( ip , & uncond , sizeof ( uncond ) ) == 0 ; <S2SV_EndBug> # undef FWINV }","<S2SV_ModStart> ( const struct ipt_entry * e <S2SV_ModEnd> ) { static <S2SV_ModStart> uncond ; return e -> target_offset == sizeof ( struct ipt_entry ) && memcmp ( & e -> <S2SV_ModEnd> ip , &",torvalds@linux/54d83fc74aa9ec72794373cb47432c5f7fb1a309,CVE-2016-3134,https://github.com/torvalds/linux/commit/54d83fc74aa9ec72794373cb47432c5f7fb1a309,2016-04-27T17:59Z
CWE-20,"CWE-20 static void server_real_connect ( SERVER_REC * server , IPADDR * ip , const char * unix_socket ) { GIOChannel * handle ; IPADDR * own_ip = NULL ; const char * errmsg ; char * errmsg2 ; char ipaddr [ MAX_IP_LEN ] ; int port ; g_return_if_fail ( ip != NULL || unix_socket != NULL ) ; signal_emit ( ""server<S2SV_blank>connecting"" , 2 , server , ip ) ; if ( server -> connrec -> no_connect ) return ; if ( ip != NULL ) { own_ip = ip == NULL ? NULL : ( IPADDR_IS_V6 ( ip ) ? server -> connrec -> own_ip6 : server -> connrec -> own_ip4 ) ; port = server -> connrec -> proxy != NULL ? server -> connrec -> proxy_port : server -> connrec -> port ; handle = server -> connrec -> use_ssl ? <S2SV_StartBug> net_connect_ip_ssl ( ip , port , own_ip , server -> connrec -> ssl_cert , server -> connrec -> ssl_pkey , <S2SV_EndBug> server -> connrec -> ssl_cafile , server -> connrec -> ssl_capath , server -> connrec -> ssl_verify ) : net_connect_ip ( ip , port , own_ip ) ; } else { handle = net_connect_unix ( unix_socket ) ; } if ( handle == NULL ) { errmsg = g_strerror ( errno ) ; errmsg2 = NULL ; if ( errno == EADDRNOTAVAIL ) { if ( own_ip != NULL ) { net_ip2host ( own_ip , ipaddr ) ; errmsg2 = g_strconcat ( errmsg , "":<S2SV_blank>"" , ipaddr , NULL ) ; } server -> no_reconnect = TRUE ; } if ( server -> connrec -> use_ssl && errno == ENOSYS ) server -> no_reconnect = TRUE ; server -> connection_lost = TRUE ; server_connect_failed ( server , errmsg2 ? errmsg2 : errmsg ) ; g_free ( errmsg2 ) ; } else { server -> handle = net_sendbuffer_create ( handle , 0 ) ; # ifdef HAVE_OPENSSL if ( server -> connrec -> use_ssl ) server_connect_callback_init_ssl ( server , handle ) ; else # endif server -> connect_tag = g_input_add ( handle , G_INPUT_WRITE | G_INPUT_READ , ( GInputFunction ) server_connect_callback_init , server ) ; } }","<S2SV_ModStart> , port , server -> connrec -> address ,",ensc@irssi-proxy/85bbc05b21678e80423815d2ef1dfe26208491ab,CVE-2010-1155,https://github.com/ensc/irssi-proxy/commit/85bbc05b21678e80423815d2ef1dfe26208491ab,2010-04-16T19:30Z
CWE-284,"CWE-284 static int check_rpcsec_auth ( struct svc_req * rqstp ) { gss_ctx_id_t ctx ; krb5_context kctx ; OM_uint32 maj_stat , min_stat ; gss_name_t name ; krb5_principal princ ; int ret , success ; krb5_data * c1 , * c2 , * realm ; gss_buffer_desc gss_str ; kadm5_server_handle_t handle ; size_t slen ; char * sdots ; success = 0 ; handle = ( kadm5_server_handle_t ) global_server_handle ; if ( rqstp -> rq_cred . oa_flavor != RPCSEC_GSS ) return 0 ; ctx = rqstp -> rq_svccred ; maj_stat = gss_inquire_context ( & min_stat , ctx , NULL , & name , NULL , NULL , NULL , NULL , NULL ) ; if ( maj_stat != GSS_S_COMPLETE ) { krb5_klog_syslog ( LOG_ERR , _ ( ""check_rpcsec_auth:<S2SV_blank>failed<S2SV_blank>"" ""inquire_context,<S2SV_blank>stat=%u"" ) , maj_stat ) ; log_badauth ( maj_stat , min_stat , rqstp -> rq_xprt , NULL ) ; goto fail_name ; } kctx = handle -> context ; ret = gss_to_krb5_name_1 ( rqstp , kctx , name , & princ , & gss_str ) ; if ( ret == 0 ) goto fail_name ; slen = gss_str . length ; trunc_name ( & slen , & sdots ) ; if ( krb5_princ_size ( kctx , princ ) != 2 ) goto fail_princ ; c1 = krb5_princ_component ( kctx , princ , 0 ) ; c2 = krb5_princ_component ( kctx , princ , 1 ) ; realm = krb5_princ_realm ( kctx , princ ) ; <S2SV_StartBug> if ( strncmp ( handle -> params . realm , realm -> data , realm -> length ) == 0 <S2SV_EndBug> && strncmp ( ""kadmin"" , c1 -> data , c1 -> length ) == 0 ) { if ( strncmp ( ""history"" , c2 -> data , c2 -> length ) == 0 ) goto fail_princ ; else success = 1 ; } fail_princ : if ( ! success ) { krb5_klog_syslog ( LOG_ERR , _ ( ""bad<S2SV_blank>service<S2SV_blank>principal<S2SV_blank>%.*s%s"" ) , ( int ) slen , ( char * ) gss_str . value , sdots ) ; } gss_release_buffer ( & min_stat , & gss_str ) ; krb5_free_principal ( kctx , princ ) ; fail_name : gss_release_name ( & min_stat , & name ) ; return success ; }","<S2SV_ModStart> princ ) ; success = data_eq_string ( * realm , <S2SV_ModEnd> handle -> params <S2SV_ModStart> params . realm ) && data_eq_string ( * c1 , ""kadmin"" ) && ! data_eq_string ( * c2 , ""history"" ) ; <S2SV_ModEnd> fail_princ : if",krb5@krb5/6609658db0799053fbef0d7d0aa2f1fd68ef32d8,CVE-2014-9422,https://github.com/krb5/krb5/commit/6609658db0799053fbef0d7d0aa2f1fd68ef32d8,2015-02-19T11:59Z
CWE-119,"CWE-119 void set_cfg_option ( char * opt_string ) { char * sep , * sep2 , szSec [ 1024 ] , szKey [ 1024 ] , szVal [ 1024 ] ; sep = strchr ( opt_string , ':' ) ; if ( ! sep ) { fprintf ( stderr , ""Badly<S2SV_blank>formatted<S2SV_blank>option<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>expected<S2SV_blank>Section:Name=Value\\n"" , opt_string ) ; return ; } { const size_t sepIdx = sep - opt_string ; <S2SV_StartBug> strncpy ( szSec , opt_string , sepIdx ) ; <S2SV_EndBug> szSec [ sepIdx ] = 0 ; } sep ++ ; sep2 = strchr ( sep , '=' ) ; if ( ! sep2 ) { fprintf ( stderr , ""Badly<S2SV_blank>formatted<S2SV_blank>option<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>expected<S2SV_blank>Section:Name=Value\\n"" , opt_string ) ; return ; } { const size_t sepIdx = sep2 - sep ; <S2SV_StartBug> strncpy ( szKey , sep , sepIdx ) ; <S2SV_EndBug> szKey [ sepIdx ] = 0 ; <S2SV_StartBug> strcpy ( szVal , sep2 + 1 ) ; <S2SV_EndBug> } if ( ! stricmp ( szKey , ""*"" ) ) { if ( stricmp ( szVal , ""null"" ) ) { fprintf ( stderr , ""Badly<S2SV_blank>formatted<S2SV_blank>option<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>expected<S2SV_blank>Section:*=null\\n"" , opt_string ) ; return ; } gf_cfg_del_section ( cfg_file , szSec ) ; return ; } if ( ! stricmp ( szVal , ""null"" ) ) { szVal [ 0 ] = 0 ; } gf_cfg_set_key ( cfg_file , szSec , szKey , szVal [ 0 ] ? szVal : NULL ) ; }","<S2SV_ModStart> - opt_string ; if ( sepIdx >= sizeof ( szSec ) ) { fprintf ( stderr , ""Badly<S2SV_blank>formatted<S2SV_blank>option<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>Section<S2SV_blank>name<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long\\n"" , opt_string ) ; return ; } <S2SV_ModStart> - sep ; if ( sepIdx >= sizeof ( szKey ) ) { fprintf ( stderr , ""Badly<S2SV_blank>formatted<S2SV_blank>option<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>key<S2SV_blank>name<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long\\n"" , opt_string ) ; return ; } <S2SV_ModStart> = 0 ; if ( strlen ( <S2SV_ModEnd> sep2 + 1 <S2SV_ModStart> + 1 ) >= sizeof ( szVal ) ) { fprintf ( stderr , ""Badly<S2SV_blank>formatted<S2SV_blank>option<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>value<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long\\n"" , opt_string ) ; return ; } strcpy ( szVal , sep2 + 1 )",gpac@gpac/35ab4475a7df9b2a4bcab235e379c0c3ec543658,CVE-2018-20761,https://github.com/gpac/gpac/commit/35ab4475a7df9b2a4bcab235e379c0c3ec543658,2019-02-06T23:29Z
,"CWE-000 sctp_disposition_t sctp_sf_do_5_2_4_dupcook ( struct net * net , const struct sctp_endpoint * ep , const struct sctp_association * asoc , const sctp_subtype_t type , void * arg , sctp_cmd_seq_t * commands ) { sctp_disposition_t retval ; struct sctp_chunk * chunk = arg ; struct sctp_association * new_asoc ; int error = 0 ; char action ; struct sctp_chunk * err_chk_p ; if ( ! sctp_chunk_length_valid ( chunk , sizeof ( sctp_chunkhdr_t ) ) ) return sctp_sf_violation_chunklen ( net , ep , asoc , type , arg , commands ) ; chunk -> subh . cookie_hdr = ( struct sctp_signed_cookie * ) chunk -> skb -> data ; if ( ! pskb_pull ( chunk -> skb , ntohs ( chunk -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ) ) goto nomem ; new_asoc = sctp_unpack_cookie ( ep , asoc , chunk , GFP_ATOMIC , & error , & err_chk_p ) ; if ( ! new_asoc ) { switch ( error ) { case - SCTP_IERROR_NOMEM : goto nomem ; case - SCTP_IERROR_STALE_COOKIE : sctp_send_stale_cookie_err ( net , ep , asoc , chunk , commands , err_chk_p ) ; return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; case - SCTP_IERROR_BAD_SIG : default : return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; } } action = sctp_tietags_compare ( new_asoc , asoc ) ; switch ( action ) { case 'A' : retval = sctp_sf_do_dupcook_a ( net , ep , asoc , chunk , commands , new_asoc ) ; break ; case 'B' : retval = sctp_sf_do_dupcook_b ( net , ep , asoc , chunk , commands , new_asoc ) ; break ; case 'C' : retval = sctp_sf_do_dupcook_c ( net , ep , asoc , chunk , commands , new_asoc ) ; break ; case 'D' : retval = sctp_sf_do_dupcook_d ( net , ep , asoc , chunk , commands , new_asoc ) ; break ; default : retval = sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; break ; } <S2SV_StartBug> sctp_add_cmd_sf ( commands , SCTP_CMD_NEW_ASOC , SCTP_ASOC ( new_asoc ) ) ; <S2SV_EndBug> sctp_add_cmd_sf ( commands , SCTP_CMD_DELETE_TCB , SCTP_NULL ( ) ) ; sctp_add_cmd_sf ( commands , SCTP_CMD_SET_ASOC , SCTP_ASOC ( ( struct sctp_association * ) asoc ) ) ; return retval ; nomem : return SCTP_DISPOSITION_NOMEM ; }","<S2SV_ModStart> ( commands , SCTP_CMD_SET_ASOC <S2SV_ModEnd> , SCTP_ASOC (",torvalds@linux/f2815633504b442ca0b0605c16bf3d88a3a0fcea,CVE-2013-2206,https://github.com/torvalds/linux/commit/f2815633504b442ca0b0605c16bf3d88a3a0fcea,2013-07-04T21:55Z
CWE-787,"CWE-787 <S2SV_StartBug> static MagickPixelPacket * * AcquirePixelThreadSet ( const Image * image ) <S2SV_EndBug> { MagickPixelPacket * * pixels ; register ssize_t i , j ; size_t <S2SV_StartBug> number_threads ; <S2SV_EndBug> number_threads = ( size_t ) GetMagickResourceLimit ( ThreadResource ) ; pixels = ( MagickPixelPacket * * ) AcquireQuantumMemory ( number_threads , sizeof ( * pixels ) ) ; if ( pixels == ( MagickPixelPacket * * ) NULL ) return ( ( MagickPixelPacket * * ) NULL ) ; ( void ) memset ( pixels , 0 , number_threads * sizeof ( * pixels ) ) ; <S2SV_StartBug> for ( i = 0 ; i < ( ssize_t ) number_threads ; i ++ ) <S2SV_EndBug> { <S2SV_StartBug> pixels [ i ] = ( MagickPixelPacket * ) AcquireQuantumMemory ( image -> columns , <S2SV_EndBug> sizeof ( * * pixels ) ) ; if ( pixels [ i ] == ( MagickPixelPacket * ) NULL ) return ( DestroyPixelThreadSet ( pixels ) ) ; <S2SV_StartBug> for ( j = 0 ; j < ( ssize_t ) image -> columns ; j ++ ) <S2SV_EndBug> <S2SV_StartBug> GetMagickPixelPacket ( image , & pixels [ i ] [ j ] ) ; <S2SV_EndBug> } return ( pixels ) ; }","<S2SV_ModStart> const Image * images ) { const Image * next ; <S2SV_ModEnd> MagickPixelPacket * * <S2SV_ModStart> j ; size_t columns , <S2SV_ModStart> ) ) ; columns = images -> columns ; for ( next = images ; next != ( Image * ) NULL ; next = next -> next ) columns = MagickMax ( next -> columns , columns ) ; for ( <S2SV_ModEnd> i = 0 <S2SV_ModStart> ) AcquireQuantumMemory ( <S2SV_ModEnd> columns , sizeof <S2SV_ModStart> ( ssize_t ) <S2SV_ModEnd> columns ; j <S2SV_ModStart> ) GetMagickPixelPacket ( images <S2SV_ModEnd> , & pixels",ImageMagick@ImageMagick/5e409ae7a389cdf2ed17469303be3f3f21cec450,CVE-2019-13300,https://github.com/ImageMagick/ImageMagick/commit/5e409ae7a389cdf2ed17469303be3f3f21cec450,2019-07-05T01:15Z
CWE-119,"CWE-119 <S2SV_StartBug> static vpx_codec_err_t vp8_get_last_ref_frame ( vpx_codec_alg_priv_t * ctx , <S2SV_EndBug> int ctrl_id , va_list args ) { int * ref_info = va_arg ( args , int * ) ; if ( ref_info && ! ctx -> yv12_frame_buffers . use_frame_threads ) { VP8D_COMP * pbi = ( VP8D_COMP * ) ctx -> yv12_frame_buffers . pbi [ 0 ] ; VP8_COMMON * oci = & pbi -> common ; * ref_info = ( vp8dx_references_buffer ( oci , ALTREF_FRAME ) ? VP8_ALTR_FRAME : 0 ) | ( vp8dx_references_buffer ( oci , GOLDEN_FRAME ) ? VP8_GOLD_FRAME : 0 ) | ( vp8dx_references_buffer ( oci , LAST_FRAME ) ? VP8_LAST_FRAME : 0 ) ; return VPX_CODEC_OK ; } else return VPX_CODEC_INVALID_PARAM ; }","<S2SV_ModStart> vpx_codec_alg_priv_t * ctx <S2SV_ModEnd> , va_list args",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-125,"CWE-125 static char * search_make_new ( const struct search_state * const state , int n , const char * const base_name ) { const size_t base_len = strlen ( base_name ) ; <S2SV_StartBug> const char need_to_append_dot = base_name [ base_len - 1 ] == '.' ? 0 : 1 ; <S2SV_EndBug> <S2SV_StartBug> struct search_domain * dom ; <S2SV_EndBug> for ( dom = state -> head ; dom ; dom = dom -> next ) { if ( ! n -- ) { const u8 * const postfix = ( ( u8 * ) dom ) + sizeof ( struct search_domain ) ; const int postfix_len = dom -> len ; char * const newname = ( char * ) mm_malloc ( base_len + need_to_append_dot + postfix_len + 1 ) ; if ( ! newname ) return NULL ; memcpy ( newname , base_name , base_len ) ; if ( need_to_append_dot ) newname [ base_len ] = '.' ; memcpy ( newname + base_len + need_to_append_dot , postfix , postfix_len ) ; newname [ base_len + need_to_append_dot + postfix_len ] = 0 ; return newname ; } } EVUTIL_ASSERT ( 0 ) ; return NULL ; }",<S2SV_ModStart> base_name ) ; char need_to_append_dot ; struct search_domain * dom ; if ( ! base_len ) return NULL ; <S2SV_ModEnd> need_to_append_dot = base_name <S2SV_ModStart> : 1 ; <S2SV_ModEnd> for ( dom,libevent@libevent/ec65c42052d95d2c23d1d837136d1cf1d9ecef9e,CVE-2016-10197,https://github.com/libevent/libevent/commit/ec65c42052d95d2c23d1d837136d1cf1d9ecef9e,2017-03-15T15:59Z
CWE-20,"CWE-20 static struct key * construct_key_and_link ( struct keyring_search_context * ctx , const char * callout_info , size_t callout_len , void * aux , struct key * dest_keyring , unsigned long flags ) { struct key_user * user ; struct key * key ; int ret ; kenter ( """" ) ; <S2SV_StartBug> user = key_user_lookup ( current_fsuid ( ) ) ; <S2SV_EndBug> if ( ! user ) return ERR_PTR ( - ENOMEM ) ; construct_get_dest_keyring ( & dest_keyring ) ; ret = construct_alloc_key ( ctx , dest_keyring , flags , user , & key ) ; key_user_put ( user ) ; if ( ret == 0 ) { ret = construct_key ( key , callout_info , callout_len , aux , dest_keyring ) ; if ( ret < 0 ) { kdebug ( ""cons<S2SV_blank>failed"" ) ; goto construction_failed ; } } else if ( ret == - EINPROGRESS ) { ret = 0 ; } else { goto couldnt_alloc_key ; } key_put ( dest_keyring ) ; kleave ( ""<S2SV_blank>=<S2SV_blank>key<S2SV_blank>%d"" , key_serial ( key ) ) ; return key ; construction_failed : key_negate_and_link ( key , key_negative_timeout , NULL , NULL ) ; key_put ( key ) ; couldnt_alloc_key : key_put ( dest_keyring ) ; kleave ( ""<S2SV_blank>=<S2SV_blank>%d"" , ret ) ; return ERR_PTR ( ret ) ; }","<S2SV_ModStart> """" ) ; if ( ctx -> index_key . type == & key_type_keyring ) return ERR_PTR ( - EPERM ) ;",torvalds@linux/ce1fad2740c648a4340f6f6c391a8a83769d2e8c,CVE-2015-7872,https://github.com/torvalds/linux/commit/ce1fad2740c648a4340f6f6c391a8a83769d2e8c,2015-11-16T11:59Z
CWE-362,"CWE-362 void inet_sock_destruct ( struct sock * sk ) { struct inet_sock * inet = inet_sk ( sk ) ; __skb_queue_purge ( & sk -> sk_receive_queue ) ; __skb_queue_purge ( & sk -> sk_error_queue ) ; sk_mem_reclaim ( sk ) ; if ( sk -> sk_type == SOCK_STREAM && sk -> sk_state != TCP_CLOSE ) { pr_err ( ""Attempt<S2SV_blank>to<S2SV_blank>release<S2SV_blank>TCP<S2SV_blank>socket<S2SV_blank>in<S2SV_blank>state<S2SV_blank>%d<S2SV_blank>%p\\n"" , sk -> sk_state , sk ) ; return ; } if ( ! sock_flag ( sk , SOCK_DEAD ) ) { pr_err ( ""Attempt<S2SV_blank>to<S2SV_blank>release<S2SV_blank>alive<S2SV_blank>inet<S2SV_blank>socket<S2SV_blank>%p\\n"" , sk ) ; return ; } WARN_ON ( atomic_read ( & sk -> sk_rmem_alloc ) ) ; WARN_ON ( atomic_read ( & sk -> sk_wmem_alloc ) ) ; WARN_ON ( sk -> sk_wmem_queued ) ; WARN_ON ( sk -> sk_forward_alloc ) ; <S2SV_StartBug> kfree ( inet -> opt ) ; <S2SV_EndBug> dst_release ( rcu_dereference_check ( sk -> sk_dst_cache , 1 ) ) ; sk_refcnt_debug_dec ( sk ) ; }","<S2SV_ModStart> ; kfree ( rcu_dereference_protected ( inet -> inet_opt , 1 ) <S2SV_ModEnd> ) ; dst_release",torvalds@linux/f6d8bd051c391c1c0458a30b2a7abcd939329259,CVE-2012-3552,https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259,2012-10-03T11:02Z
CWE-119,"CWE-119 int nfs3svc_decode_symlinkargs ( struct svc_rqst * rqstp , __be32 * p , struct nfsd3_symlinkargs * args ) { unsigned int len , avail ; char * old , * new ; struct kvec * vec ; if ( ! ( p = decode_fh ( p , & args -> ffh ) ) || ! ( p = decode_filename ( p , & args -> fname , & args -> flen ) ) ) return 0 ; p = decode_sattr3 ( p , & args -> attrs ) ; len = ntohl ( * p ++ ) ; if ( len == 0 || len > NFS3_MAXPATHLEN || len >= PAGE_SIZE ) return 0 ; args -> tname = new = page_address ( * ( rqstp -> rq_next_page ++ ) ) ; args -> tlen = len ; old = ( char * ) p ; vec = & rqstp -> rq_arg . head [ 0 ] ; <S2SV_StartBug> avail = vec -> iov_len - ( old - ( char * ) vec -> iov_base ) ; <S2SV_EndBug> while ( len && avail && * old ) { * new ++ = * old ++ ; len -- ; avail -- ; } if ( len && ! avail && rqstp -> rq_arg . page_len ) { avail = min_t ( unsigned int , rqstp -> rq_arg . page_len , PAGE_SIZE ) ; old = page_address ( rqstp -> rq_arg . pages [ 0 ] ) ; } while ( len && avail && * old ) { * new ++ = * old ++ ; len -- ; avail -- ; } * new = '\\0' ; if ( len ) return 0 ; return 1 ; }",<S2SV_ModStart> 0 ] ; if ( ( void * ) old > vec -> iov_base + vec -> iov_len ) return 0 ;,torvalds@linux/13bf9fbff0e5e099e2b6f003a0ab8ae145436309,CVE-2017-7895,https://github.com/torvalds/linux/commit/13bf9fbff0e5e099e2b6f003a0ab8ae145436309,2017-04-28T10:59Z
CWE-326,"CWE-000 int secure_check ( void * data ) { const at91_secure_header_t * header ; void * file ; <S2SV_StartBug> if ( secure_decrypt ( data , sizeof ( * header ) , 0 ) ) <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> header = ( const at91_secure_header_t * ) data ; if ( header -> magic != AT91_SECURE_MAGIC ) <S2SV_StartBug> return - 1 ; <S2SV_EndBug> file = ( unsigned char * ) data + sizeof ( * header ) ; <S2SV_StartBug> return secure_decrypt ( file , header -> file_size , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>",<S2SV_ModStart> * file ; int ret = - 1 ; <S2SV_ModStart> 0 ) ) goto secure_wipe_keys <S2SV_ModEnd> ; header = <S2SV_ModStart> != AT91_SECURE_MAGIC ) goto secure_wipe_keys <S2SV_ModEnd> ; file = <S2SV_ModStart> header ) ; ret = <S2SV_ModEnd> secure_decrypt ( file <S2SV_ModStart> 1 ) ; secure_wipe_keys : wipe_keys ( ) ; return ret ;,linux4sam@at91bootstrap/45419497309ffbf27c17ea7938499aca99168927,CVE-2020-11684,https://github.com/linux4sam/at91bootstrap/commit/45419497309ffbf27c17ea7938499aca99168927,2020-09-14T14:15Z
,"CWE-000 static void ip_expire ( unsigned long arg ) { struct ipq * qp ; struct net * net ; qp = container_of ( ( struct inet_frag_queue * ) arg , struct ipq , q ) ; net = container_of ( qp -> q . net , struct net , ipv4 . frags ) ; spin_lock ( & qp -> q . lock ) ; if ( qp -> q . last_in & INET_FRAG_COMPLETE ) goto out ; ipq_kill ( qp ) ; IP_INC_STATS_BH ( net , IPSTATS_MIB_REASMTIMEOUT ) ; IP_INC_STATS_BH ( net , IPSTATS_MIB_REASMFAILS ) ; if ( ( qp -> q . last_in & INET_FRAG_FIRST_IN ) && qp -> q . fragments != NULL ) { struct sk_buff * head = qp -> q . fragments ; <S2SV_StartBug> rcu_read_lock ( ) ; <S2SV_EndBug> head -> dev = dev_get_by_index_rcu ( net , qp -> iif ) ; <S2SV_StartBug> if ( ! head -> dev ) <S2SV_EndBug> goto out_rcu_unlock ; <S2SV_StartBug> if ( qp -> user == IP_DEFRAG_CONNTRACK_IN && ! skb_dst ( head ) ) { <S2SV_EndBug> const struct iphdr * iph = ip_hdr ( head ) ; int err = ip_route_input ( head , iph -> daddr , iph -> saddr , iph -> tos , head -> dev ) ; if ( unlikely ( err ) ) goto out_rcu_unlock ; if ( skb_rtable ( head ) -> rt_type != RTN_LOCAL ) goto out_rcu_unlock ; <S2SV_StartBug> } <S2SV_EndBug> icmp_send ( head , ICMP_TIME_EXCEEDED , ICMP_EXC_FRAGTIME , 0 ) ; out_rcu_unlock : rcu_read_unlock ( ) ; } out : spin_unlock ( & qp -> q . lock ) ; ipq_put ( qp ) ; }","<S2SV_ModStart> . fragments ; const struct iphdr * iph ; int err ; <S2SV_ModStart> head -> dev ) goto out_rcu_unlock ; skb_dst_drop ( head ) ; iph = ip_hdr ( head ) ; err = ip_route_input_noref ( head , iph -> daddr , iph -> saddr , iph -> tos , head -> dev ) ; if ( err <S2SV_ModStart> == IP_DEFRAG_CONNTRACK_IN && <S2SV_ModEnd> skb_rtable ( head <S2SV_ModStart> goto out_rcu_unlock ; <S2SV_ModEnd> icmp_send ( head",torvalds@linux/64f3b9e203bd06855072e295557dca1485a2ecba,CVE-2011-1927,https://github.com/torvalds/linux/commit/64f3b9e203bd06855072e295557dca1485a2ecba,2012-06-13T10:24Z
CWE-310,CWE-000 static void * my_malloc ( size_t size ) { <S2SV_StartBug> malloc_called += 1 ; <S2SV_EndBug> return malloc ( size ) ; },<S2SV_ModStart> ) { malloc_called = <S2SV_ModEnd> 1 ; return,akheron@jansson/8f80c2d83808150724d31793e6ade92749b1faa4,CVE-2013-6401,https://github.com/akheron/jansson/commit/8f80c2d83808150724d31793e6ade92749b1faa4,2014-03-21T01:04Z
CWE-295,"CWE-000 NOEXPORT int init_section ( int eof , SERVICE_OPTIONS * * section_ptr ) { char * errstr ; # ifndef USE_WIN32 ( * section_ptr ) -> option . log_stderr = new_global_options . option . log_stderr ; # endif if ( * section_ptr == & new_service_options ) { <S2SV_StartBug> errstr = parse_global_option ( CMD_INITIALIZE , NULL , NULL ) ; <S2SV_EndBug> if ( errstr ) { s_log ( LOG_ERR , ""Global<S2SV_blank>options:<S2SV_blank>%s"" , errstr ) ; return 1 ; } } if ( * section_ptr != & new_service_options || eof ) { <S2SV_StartBug> if ( * section_ptr == & new_service_options ) <S2SV_EndBug> s_log ( LOG_INFO , ""Initializing<S2SV_blank>inetd<S2SV_blank>mode<S2SV_blank>configuration"" ) ; else s_log ( LOG_INFO , ""Initializing<S2SV_blank>service<S2SV_blank>[%s]"" , ( * section_ptr ) -> servname ) ; errstr = parse_service_option ( CMD_INITIALIZE , section_ptr , NULL , NULL ) ; if ( errstr ) { if ( * section_ptr == & new_service_options ) s_log ( LOG_ERR , ""Inetd<S2SV_blank>mode:<S2SV_blank>%s"" , errstr ) ; else s_log ( LOG_ERR , ""Service<S2SV_blank>[%s]:<S2SV_blank>%s"" , ( * section_ptr ) -> servname , errstr ) ; return 1 ; } } return 0 ; }","<S2SV_ModStart> ( CMD_INITIALIZE , & new_global_options , <S2SV_ModStart> eof ) { <S2SV_ModEnd> errstr = parse_service_option",mtrojnar@stunnel/ebad9ddc4efb2635f37174c9d800d06206f1edf9,CVE-2021-20230,https://github.com/mtrojnar/stunnel/commit/ebad9ddc4efb2635f37174c9d800d06206f1edf9,2021-02-23T17:15Z
CWE-264,"CWE-264 SYSCALL_DEFINE5 ( osf_getsysinfo , unsigned long , op , void __user * , buffer , unsigned long , nbytes , int __user * , start , void __user * , arg ) { unsigned long w ; struct percpu_struct * cpu ; switch ( op ) { case GSI_IEEE_FP_CONTROL : w = current_thread_info ( ) -> ieee_state & IEEE_SW_MASK ; w = swcr_update_status ( w , rdfpcr ( ) ) ; if ( put_user ( w , ( unsigned long __user * ) buffer ) ) return - EFAULT ; return 0 ; case GSI_IEEE_STATE_AT_SIGNAL : break ; case GSI_UACPROC : if ( nbytes < sizeof ( unsigned int ) ) return - EINVAL ; w = ( current_thread_info ( ) -> flags >> UAC_SHIFT ) & UAC_BITMASK ; if ( put_user ( w , ( unsigned int __user * ) buffer ) ) return - EFAULT ; return 1 ; case GSI_PROC_TYPE : if ( nbytes < sizeof ( unsigned long ) ) return - EINVAL ; cpu = ( struct percpu_struct * ) ( ( char * ) hwrpb + hwrpb -> processor_offset ) ; w = cpu -> type ; if ( put_user ( w , ( unsigned long __user * ) buffer ) ) return - EFAULT ; return 1 ; case GSI_GET_HWRPB : <S2SV_StartBug> if ( nbytes < sizeof ( * hwrpb ) ) <S2SV_EndBug> return - EINVAL ; if ( copy_to_user ( buffer , hwrpb , nbytes ) != 0 ) return - EFAULT ; return 1 ; default : break ; } return - EOPNOTSUPP ; }",<S2SV_ModStart> if ( nbytes > <S2SV_ModEnd> sizeof ( *,torvalds@linux/21c5977a836e399fc710ff2c5367845ed5c2527f,CVE-2011-2210,https://github.com/torvalds/linux/commit/21c5977a836e399fc710ff2c5367845ed5c2527f,2012-06-13T10:24Z
CWE-119,"CWE-119 MagickExport void * AcquireAlignedMemory ( const size_t count , const size_t quantum ) { # define AlignedExtent ( size , alignment ) ( ( ( size ) + ( ( alignment ) - 1 ) ) & ~ ( ( alignment ) - 1 ) ) size_t alignment , extent , size ; void * memory ; <S2SV_StartBug> if ( CheckMemoryOverflow ( count , quantum ) != MagickFalse ) <S2SV_EndBug> return ( ( void * ) NULL ) ; memory = NULL ; alignment = CACHE_LINE_SIZE ; size = count * quantum ; extent = AlignedExtent ( size , alignment ) ; if ( ( size == 0 ) || ( alignment < sizeof ( void * ) ) || ( extent < size ) ) return ( ( void * ) NULL ) ; # if defined ( MAGICKCORE_HAVE_POSIX_MEMALIGN ) if ( posix_memalign ( & memory , alignment , extent ) != 0 ) memory = NULL ; # elif defined ( MAGICKCORE_HAVE__ALIGNED_MALLOC ) memory = _aligned_malloc ( extent , alignment ) ; # else { void * p ; extent = ( size + alignment - 1 ) + sizeof ( void * ) ; if ( extent > size ) { p = malloc ( extent ) ; if ( p != NULL ) { memory = ( void * ) AlignedExtent ( ( size_t ) p + sizeof ( void * ) , alignment ) ; * ( ( void * * ) memory - 1 ) = p ; } } } # endif return ( memory ) ; }","<S2SV_ModStart> ; if ( HeapOverflowSanityCheck <S2SV_ModEnd> ( count ,",ImageMagick@ImageMagick/0474237508f39c4f783208123431815f1ededb76,CVE-2016-10067,https://github.com/ImageMagick/ImageMagick/commit/0474237508f39c4f783208123431815f1ededb76,2017-03-02T21:59Z
CWE-125,"CWE-125 static int FstringParser_ConcatFstring ( FstringParser * state , const char * * str , const char * end , int raw , int recurse_lvl , struct compiling * c , const node * n ) { FstringParser_check_invariants ( state ) ; <S2SV_StartBug> while ( 1 ) { <S2SV_EndBug> PyObject * literal = NULL ; expr_ty expression = NULL ; int result = fstring_find_literal_and_expr ( str , end , raw , recurse_lvl , & literal , & expression , c , n ) ; if ( result < 0 ) return - 1 ; if ( ! literal ) { } else if ( ! state -> last_str ) { state -> last_str = literal ; literal = NULL ; } else { assert ( PyUnicode_GET_LENGTH ( literal ) != 0 ) ; if ( FstringParser_ConcatAndDel ( state , literal ) < 0 ) return - 1 ; literal = NULL ; } <S2SV_StartBug> assert ( ! state -> last_str || <S2SV_EndBug> PyUnicode_GET_LENGTH ( state -> last_str ) != 0 ) ; assert ( literal == NULL ) ; if ( result == 1 ) continue ; if ( ! expression ) break ; if ( ! state -> last_str ) { } else { expr_ty str = make_str_node_and_del ( & state -> last_str , c , n ) ; if ( ! str || ExprList_Append ( & state -> expr_list , str ) < 0 ) return - 1 ; } if ( ExprList_Append ( & state -> expr_list , expression ) < 0 ) return - 1 ; } if ( recurse_lvl == 0 && * str < end - 1 ) { ast_error ( c , n , ""f-string:<S2SV_blank>unexpected<S2SV_blank>end<S2SV_blank>of<S2SV_blank>string"" ) ; return - 1 ; } if ( recurse_lvl != 0 && * * str != '}' ) { ast_error ( c , n , ""f-string:<S2SV_blank>expecting<S2SV_blank>\'}\'"" ) ; return - 1 ; } FstringParser_check_invariants ( state ) ; return 0 ; }",<S2SV_ModStart> state ) ; state -> fmode = 1 ; <S2SV_ModStart> } assert ( <S2SV_ModEnd> literal == NULL,python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z
CWE-401,"CWE-000 static int mlx5_fpga_conn_create_cq ( struct mlx5_fpga_conn * conn , int cq_size ) { struct mlx5_fpga_device * fdev = conn -> fdev ; struct mlx5_core_dev * mdev = fdev -> mdev ; u32 temp_cqc [ MLX5_ST_SZ_DW ( cqc ) ] = { 0 } ; u32 out [ MLX5_ST_SZ_DW ( create_cq_out ) ] ; struct mlx5_wq_param wqp ; struct mlx5_cqe64 * cqe ; int inlen , err , eqn ; unsigned int irqn ; void * cqc , * in ; __be64 * pas ; u32 i ; cq_size = roundup_pow_of_two ( cq_size ) ; MLX5_SET ( cqc , temp_cqc , log_cq_size , ilog2 ( cq_size ) ) ; wqp . buf_numa_node = mdev -> priv . numa_node ; wqp . db_numa_node = mdev -> priv . numa_node ; err = mlx5_cqwq_create ( mdev , & wqp , temp_cqc , & conn -> cq . wq , & conn -> cq . wq_ctrl ) ; if ( err ) return err ; for ( i = 0 ; i < mlx5_cqwq_get_size ( & conn -> cq . wq ) ; i ++ ) { cqe = mlx5_cqwq_get_wqe ( & conn -> cq . wq , i ) ; cqe -> op_own = MLX5_CQE_INVALID << 4 | MLX5_CQE_OWNER_MASK ; } inlen = MLX5_ST_SZ_BYTES ( create_cq_in ) + sizeof ( u64 ) * conn -> cq . wq_ctrl . buf . npages ; in = kvzalloc ( inlen , GFP_KERNEL ) ; if ( ! in ) { err = - ENOMEM ; goto err_cqwq ; } err = mlx5_vector2eqn ( mdev , smp_processor_id ( ) , & eqn , & irqn ) ; <S2SV_StartBug> if ( err ) <S2SV_EndBug> <S2SV_StartBug> goto err_cqwq ; <S2SV_EndBug> cqc = MLX5_ADDR_OF ( create_cq_in , in , cq_context ) ; MLX5_SET ( cqc , cqc , log_cq_size , ilog2 ( cq_size ) ) ; MLX5_SET ( cqc , cqc , c_eqn , eqn ) ; MLX5_SET ( cqc , cqc , uar_page , fdev -> conn_res . uar -> index ) ; MLX5_SET ( cqc , cqc , log_page_size , conn -> cq . wq_ctrl . buf . page_shift - MLX5_ADAPTER_PAGE_SHIFT ) ; MLX5_SET64 ( cqc , cqc , dbr_addr , conn -> cq . wq_ctrl . db . dma ) ; pas = ( __be64 * ) MLX5_ADDR_OF ( create_cq_in , in , pas ) ; mlx5_fill_page_frag_array ( & conn -> cq . wq_ctrl . buf , pas ) ; err = mlx5_core_create_cq ( mdev , & conn -> cq . mcq , in , inlen , out , sizeof ( out ) ) ; kvfree ( in ) ; if ( err ) goto err_cqwq ; conn -> cq . mcq . cqe_sz = 64 ; conn -> cq . mcq . set_ci_db = conn -> cq . wq_ctrl . db . db ; conn -> cq . mcq . arm_db = conn -> cq . wq_ctrl . db . db + 1 ; * conn -> cq . mcq . set_ci_db = 0 ; * conn -> cq . mcq . arm_db = 0 ; conn -> cq . mcq . vector = 0 ; conn -> cq . mcq . comp = mlx5_fpga_conn_cq_complete ; conn -> cq . mcq . event = mlx5_fpga_conn_cq_event ; conn -> cq . mcq . irqn = irqn ; conn -> cq . mcq . uar = fdev -> conn_res . uar ; tasklet_init ( & conn -> cq . tasklet , mlx5_fpga_conn_cq_tasklet , ( unsigned long ) conn ) ; mlx5_fpga_dbg ( fdev , ""Created<S2SV_blank>CQ<S2SV_blank>#0x%x\\n"" , conn -> cq . mcq . cqn ) ; goto out ; err_cqwq : mlx5_wq_destroy ( & conn -> cq . wq_ctrl ) ; out : return err ; }",<S2SV_ModStart> ( err ) { kvfree ( in ) ; <S2SV_ModStart> goto err_cqwq ; },torvalds@linux/c8c2a057fdc7de1cd16f4baa51425b932a42eb39,CVE-2019-19045,https://github.com/torvalds/linux/commit/c8c2a057fdc7de1cd16f4baa51425b932a42eb39,2019-11-18T06:15Z
CWE-362,"CWE-362 void __kvm_migrate_pit_timer ( struct kvm_vcpu * vcpu ) { struct kvm_pit * pit = vcpu -> kvm -> arch . vpit ; struct hrtimer * timer ; if ( ! kvm_vcpu_is_bsp ( vcpu ) || ! pit ) return ; timer = & pit -> pit_state . timer ; <S2SV_StartBug> if ( hrtimer_cancel ( timer ) ) <S2SV_EndBug> hrtimer_start_expires ( timer , HRTIMER_MODE_ABS ) ; <S2SV_StartBug> } <S2SV_EndBug>",<S2SV_ModStart> . timer ; mutex_lock ( & pit -> pit_state . lock ) ; <S2SV_ModStart> HRTIMER_MODE_ABS ) ; mutex_unlock ( & pit -> pit_state . lock ) ;,torvalds@linux/2febc839133280d5a5e8e1179c94ea674489dae2,CVE-2014-3611,https://github.com/torvalds/linux/commit/2febc839133280d5a5e8e1179c94ea674489dae2,2014-11-10T11:55Z
CWE-787,"CWE-787 int my_csr_reader ( const char * i_csr_file_in , unsigned int * * o_row_idx , unsigned int * * o_column_idx , REALTYPE * * o_values , unsigned int * o_row_count , unsigned int * o_column_count , unsigned int * o_element_count ) { FILE * l_csr_file_handle ; const unsigned int l_line_length = 512 ; char l_line [ 512 + 1 ] ; unsigned int l_header_read = 0 ; unsigned int * l_row_idx_id = NULL ; unsigned int l_i = 0 ; l_csr_file_handle = fopen ( i_csr_file_in , ""r"" ) ; if ( l_csr_file_handle == NULL ) { fprintf ( stderr , ""cannot<S2SV_blank>open<S2SV_blank>CSR<S2SV_blank>file!\\n"" ) ; return - 1 ; } while ( fgets ( l_line , l_line_length , l_csr_file_handle ) != NULL ) { if ( strlen ( l_line ) == l_line_length ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>read<S2SV_blank>file<S2SV_blank>length!\\n"" ) ; return - 1 ; } if ( l_line [ 0 ] == '%' ) { continue ; } else { if ( l_header_read == 0 ) { <S2SV_StartBug> if ( sscanf ( l_line , ""%u<S2SV_blank>%u<S2SV_blank>%u"" , o_row_count , o_column_count , o_element_count ) == 3 ) { <S2SV_EndBug> * o_column_idx = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_element_count ) ) ; * o_row_idx = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_row_count + 1 ) ) ; * o_values = ( REALTYPE * ) malloc ( sizeof ( double ) * ( * o_element_count ) ) ; l_row_idx_id = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_row_count ) ) ; if ( ( * o_row_idx == NULL ) || ( * o_column_idx == NULL ) || ( * o_values == NULL ) || ( l_row_idx_id == NULL ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>sp<S2SV_blank>data!\\n"" ) ; return - 1 ; } memset ( * o_row_idx , 0 , sizeof ( unsigned int ) * ( * o_row_count + 1 ) ) ; memset ( * o_column_idx , 0 , sizeof ( unsigned int ) * ( * o_element_count ) ) ; memset ( * o_values , 0 , sizeof ( double ) * ( * o_element_count ) ) ; memset ( l_row_idx_id , 0 , sizeof ( unsigned int ) * ( * o_row_count ) ) ; for ( l_i = 0 ; l_i < ( * o_row_count + 1 ) ; l_i ++ ) ( * o_row_idx ) [ l_i ] = ( * o_element_count ) ; ( * o_row_idx ) [ 0 ] = 0 ; l_i = 0 ; l_header_read = 1 ; } else { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>csr<S2SV_blank>description!\\n"" ) ; return - 1 ; } } else { unsigned int l_row , l_column ; REALTYPE l_value ; if ( sscanf ( l_line , ""%u<S2SV_blank>%u<S2SV_blank>%lf"" , & l_row , & l_column , & l_value ) != 3 ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>read<S2SV_blank>element!\\n"" ) ; return - 1 ; } l_row -- ; l_column -- ; ( * o_column_idx ) [ l_i ] = l_column ; ( * o_values ) [ l_i ] = l_value ; l_i ++ ; l_row_idx_id [ l_row ] = 1 ; ( * o_row_idx ) [ l_row + 1 ] = l_i ; } } } fclose ( l_csr_file_handle ) ; if ( l_i != ( * o_element_count ) ) { fprintf ( stderr , ""we<S2SV_blank>were<S2SV_blank>not<S2SV_blank>able<S2SV_blank>to<S2SV_blank>read<S2SV_blank>all<S2SV_blank>elements!\\n"" ) ; return - 1 ; } for ( l_i = 0 ; l_i < ( * o_row_count ) ; l_i ++ ) { if ( l_row_idx_id [ l_i ] == 0 ) { ( * o_row_idx ) [ l_i + 1 ] = ( * o_row_idx ) [ l_i ] ; } } if ( l_row_idx_id != NULL ) { free ( l_row_idx_id ) ; } return 0 ; }","<S2SV_ModStart> { if ( 3 == <S2SV_ModStart> , o_element_count ) && 0 != * o_row_count && 0 != * o_column_count && 0 != * o_element_count ) <S2SV_ModEnd> { * o_column_idx",hfp@libxsmm/151481489192e6d1997f8bde52c5c425ea41741d,CVE-2018-20541,https://github.com/hfp/libxsmm/commit/151481489192e6d1997f8bde52c5c425ea41741d,2018-12-28T16:29Z
CWE-119,"CWE-119 void vp9_setup_pre_planes ( MACROBLOCKD * xd , int idx , const YV12_BUFFER_CONFIG * src , int mi_row , int mi_col , const struct scale_factors * sf ) { if ( src != NULL ) { int i ; <S2SV_StartBug> uint8_t * const buffers [ 4 ] = { src -> y_buffer , src -> u_buffer , src -> v_buffer , <S2SV_EndBug> src -> alpha_buffer } ; <S2SV_StartBug> const int strides [ 4 ] = { src -> y_stride , src -> uv_stride , src -> uv_stride , <S2SV_EndBug> src -> alpha_stride } ; for ( i = 0 ; i < MAX_MB_PLANE ; ++ i ) { struct macroblockd_plane * const pd = & xd -> plane [ i ] ; setup_pred_plane ( & pd -> pre [ idx ] , buffers [ i ] , strides [ i ] , mi_row , mi_col , sf , pd -> subsampling_x , pd -> subsampling_y ) ; } } }",<S2SV_ModStart> const buffers [ MAX_MB_PLANE <S2SV_ModEnd> ] = { <S2SV_ModStart> src -> v_buffer <S2SV_ModEnd> } ; const <S2SV_ModStart> int strides [ MAX_MB_PLANE <S2SV_ModEnd> ] = { <S2SV_ModStart> src -> uv_stride <S2SV_ModEnd> } ; for,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-284,"CWE-284 ssize_t socket_read ( const socket_t * socket , void * buf , size_t count ) { assert ( socket != NULL ) ; assert ( buf != NULL ) ; <S2SV_StartBug> return recv ( socket -> fd , buf , count , MSG_DONTWAIT ) ; <S2SV_EndBug> }","<S2SV_ModStart> ) ; return TEMP_FAILURE_RETRY ( <S2SV_ModStart> , MSG_DONTWAIT ) )",system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z
CWE-119,CWE-119 void vp9_init_mv_probs ( VP9_COMMON * cm ) { <S2SV_StartBug> cm -> fc . nmvc = default_nmv_context ; <S2SV_EndBug> },<S2SV_ModStart> cm -> fc -> <S2SV_ModEnd> nmvc = default_nmv_context,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-20,"CWE-20 void big_key_describe ( const struct key * key , struct seq_file * m ) { size_t datalen = ( size_t ) key -> payload . data [ big_key_len ] ; seq_puts ( m , key -> description ) ; <S2SV_StartBug> if ( key_is_instantiated ( key ) ) <S2SV_EndBug> seq_printf ( m , "":<S2SV_blank>%zu<S2SV_blank>[%s]"" , datalen , datalen > BIG_KEY_FILE_THRESHOLD ? ""file"" : ""buff"" ) ; }",<S2SV_ModStart> ; if ( key_is_positive <S2SV_ModEnd> ( key ),torvalds@linux/363b02dab09b3226f3bd1420dad9c72b79a42a76,CVE-2017-15951,https://github.com/torvalds/linux/commit/363b02dab09b3226f3bd1420dad9c72b79a42a76,2017-10-28T02:29Z
CWE-20,"CWE-20 error_t enc624j600UpdateMacAddrFilter ( NetInterface * interface ) { uint_t i ; uint_t k ; uint32_t crc ; uint16_t hashTable [ 4 ] ; MacFilterEntry * entry ; TRACE_DEBUG ( ""Updating<S2SV_blank>MAC<S2SV_blank>filter...\\r\\n"" ) ; osMemset ( hashTable , 0 , sizeof ( hashTable ) ) ; for ( i = 0 ; i < MAC_ADDR_FILTER_SIZE ; i ++ ) { entry = & interface -> macAddrFilter [ i ] ; if ( entry -> refCount > 0 ) { crc = enc624j600CalcCrc ( & entry -> addr , sizeof ( MacAddr ) ) ; k = ( crc >> 23 ) & 0x3F ; hashTable [ k / 16 ] |= ( 1 << ( k % 16 ) ) ; } } <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_EHT1 , hashTable [ 0 ] ) ; <S2SV_EndBug> enc624j600WriteReg ( interface , ENC624J600_REG_EHT2 , hashTable [ 1 ] ) ; <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_EHT3 , hashTable [ 2 ] ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_EHT4 , hashTable [ 3 ] ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT1<S2SV_blank>=<S2SV_blank>%04"" PRIX16 ""\\r\\n"" , enc624j600ReadReg ( interface , ENC624J600_REG_EHT1 ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT2<S2SV_blank>=<S2SV_blank>%04"" PRIX16 ""\\r\\n"" , enc624j600ReadReg ( interface , ENC624J600_REG_EHT2 ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT3<S2SV_blank>=<S2SV_blank>%04"" PRIX16 ""\\r\\n"" , enc624j600ReadReg ( interface , ENC624J600_REG_EHT3 ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT4<S2SV_blank>=<S2SV_blank>%04"" PRIX16 ""\\r\\n"" , enc624j600ReadReg ( interface , ENC624J600_REG_EHT4 ) ) ; <S2SV_EndBug> return NO_ERROR ; }","<S2SV_ModStart> ( interface , ENC624J600_EHT1 , hashTable [ 0 ] ) ; enc624j600WriteReg ( interface , ENC624J600_EHT2 <S2SV_ModEnd> , hashTable [ <S2SV_ModStart> ( interface , ENC624J600_EHT3 <S2SV_ModEnd> , hashTable [ <S2SV_ModStart> ( interface , ENC624J600_EHT4 <S2SV_ModEnd> , hashTable [ <S2SV_ModStart> ( interface , ENC624J600_EHT1 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , ENC624J600_EHT2 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , ENC624J600_EHT3 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , ENC624J600_EHT4 <S2SV_ModEnd> ) ) ;",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z
CWE-119,"CWE-119 static void write_modes_sb ( VP9_COMP * cpi , const TileInfo * const tile , <S2SV_StartBug> vp9_writer * w , TOKENEXTRA * * tok , TOKENEXTRA * tok_end , <S2SV_EndBug> int mi_row , int mi_col , BLOCK_SIZE bsize ) { <S2SV_StartBug> VP9_COMMON * const cm = & cpi -> common ; <S2SV_EndBug> <S2SV_StartBug> MACROBLOCKD * const xd = & cpi -> mb . e_mbd ; <S2SV_EndBug> <S2SV_StartBug> const int bsl = b_width_log2 ( bsize ) ; <S2SV_EndBug> const int bs = ( 1 << bsl ) / 4 ; PARTITION_TYPE partition ; BLOCK_SIZE subsize ; <S2SV_StartBug> MODE_INFO * m = cm -> mi_grid_visible [ mi_row * cm -> mi_stride + mi_col ] ; <S2SV_EndBug> if ( mi_row >= cm -> mi_rows || mi_col >= cm -> mi_cols ) return ; partition = partition_lookup [ bsl ] [ m -> mbmi . sb_type ] ; write_partition ( cm , xd , bs , mi_row , mi_col , partition , bsize , w ) ; subsize = get_subsize ( bsize , partition ) ; if ( subsize < BLOCK_8X8 ) { write_modes_b ( cpi , tile , w , tok , tok_end , mi_row , mi_col ) ; } else { switch ( partition ) { case PARTITION_NONE : write_modes_b ( cpi , tile , w , tok , tok_end , mi_row , mi_col ) ; break ; case PARTITION_HORZ : write_modes_b ( cpi , tile , w , tok , tok_end , mi_row , mi_col ) ; if ( mi_row + bs < cm -> mi_rows ) write_modes_b ( cpi , tile , w , tok , tok_end , mi_row + bs , mi_col ) ; break ; case PARTITION_VERT : write_modes_b ( cpi , tile , w , tok , tok_end , mi_row , mi_col ) ; if ( mi_col + bs < cm -> mi_cols ) write_modes_b ( cpi , tile , w , tok , tok_end , mi_row , mi_col + bs ) ; break ; case PARTITION_SPLIT : write_modes_sb ( cpi , tile , w , tok , tok_end , mi_row , mi_col , subsize ) ; write_modes_sb ( cpi , tile , w , tok , tok_end , mi_row , mi_col + bs , subsize ) ; write_modes_sb ( cpi , tile , w , tok , tok_end , mi_row + bs , mi_col , subsize ) ; write_modes_sb ( cpi , tile , w , tok , tok_end , mi_row + bs , mi_col + bs , subsize ) ; break ; default : assert ( 0 ) ; } } if ( bsize >= BLOCK_8X8 && ( bsize == BLOCK_8X8 || partition != PARTITION_SPLIT ) ) update_partition_context ( xd , mi_row , mi_col , subsize , bsize ) ; }","<S2SV_ModStart> const tile , vpx_writer * w , <S2SV_ModEnd> TOKENEXTRA * * <S2SV_ModStart> * tok , const TOKENEXTRA * const <S2SV_ModEnd> tok_end , int <S2SV_ModStart> bsize ) { const <S2SV_ModStart> & cpi -> td . <S2SV_ModStart> int bsl = b_width_log2_lookup [ bsize ] <S2SV_ModEnd> ; const int <S2SV_ModStart> BLOCK_SIZE subsize ; const MODE_INFO * m = NULL ; if ( mi_row >= cm -> mi_rows || mi_col >= cm -> mi_cols ) return ; <S2SV_ModEnd> m = cm <S2SV_ModStart> + mi_col ] <S2SV_ModEnd> ; partition =",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-189,"CWE-189 TSQuery parse_tsquery ( char * buf , PushFunction pushval , Datum opaque , bool isplain ) { struct TSQueryParserStateData state ; int i ; TSQuery query ; int commonlen ; QueryItem * ptr ; ListCell * cell ; state . buffer = buf ; state . buf = buf ; state . state = ( isplain ) ? WAITSINGLEOPERAND : WAITFIRSTOPERAND ; state . count = 0 ; state . polstr = NIL ; state . valstate = init_tsvector_parser ( state . buffer , true , true ) ; state . sumlen = 0 ; state . lenop = 64 ; state . curop = state . op = ( char * ) palloc ( state . lenop ) ; * ( state . curop ) = '\\0' ; makepol ( & state , pushval , opaque ) ; close_tsvector_parser ( state . valstate ) ; if ( list_length ( state . polstr ) == 0 ) { ereport ( NOTICE , ( errmsg ( ""text-search<S2SV_blank>query<S2SV_blank>doesn\'t<S2SV_blank>contain<S2SV_blank>lexemes:<S2SV_blank>\\""%s\\"""" , state . buffer ) ) ) ; query = ( TSQuery ) palloc ( HDRSIZETQ ) ; SET_VARSIZE ( query , HDRSIZETQ ) ; query -> size = 0 ; return query ; <S2SV_StartBug> } <S2SV_EndBug> commonlen = COMPUTESIZE ( list_length ( state . polstr ) , state . sumlen ) ; query = ( TSQuery ) palloc0 ( commonlen ) ; SET_VARSIZE ( query , commonlen ) ; query -> size = list_length ( state . polstr ) ; ptr = GETQUERY ( query ) ; i = 0 ; foreach ( cell , state . polstr ) { QueryItem * item = ( QueryItem * ) lfirst ( cell ) ; switch ( item -> type ) { case QI_VAL : memcpy ( & ptr [ i ] , item , sizeof ( QueryOperand ) ) ; break ; case QI_VALSTOP : ptr [ i ] . type = QI_VALSTOP ; break ; case QI_OPR : memcpy ( & ptr [ i ] , item , sizeof ( QueryOperator ) ) ; break ; default : elog ( ERROR , ""unrecognized<S2SV_blank>QueryItem<S2SV_blank>type:<S2SV_blank>%d"" , item -> type ) ; } i ++ ; } memcpy ( ( void * ) GETOPERAND ( query ) , ( void * ) state . op , state . sumlen ) ; pfree ( state . op ) ; findoprnd ( ptr , query -> size ) ; return query ; }","<S2SV_ModStart> query ; } if ( TSQUERY_TOO_BIG ( list_length ( state . polstr ) , state . sumlen ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""tsquery<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large"" ) ) ) ;",postgres@postgres/31400a673325147e1205326008e32135a78b4d8a,CVE-2014-0064,https://github.com/postgres/postgres/commit/31400a673325147e1205326008e32135a78b4d8a,2014-03-31T14:58Z
CWE-190,"CWE-190 static int _gd2GetHeader ( gdIOCtxPtr in , int * sx , int * sy , int * cs , int * vers , int * fmt , int * ncx , int * ncy , t_chunk_info * * chunkIdx ) { int i ; int ch ; char id [ 5 ] ; t_chunk_info * cidx ; int sidx ; int nc ; GD2_DBG ( php_gd_error ( ""Reading<S2SV_blank>gd2<S2SV_blank>header<S2SV_blank>info"" ) ) ; for ( i = 0 ; i < 4 ; i ++ ) { ch = gdGetC ( in ) ; if ( ch == EOF ) { goto fail1 ; } id [ i ] = ch ; } id [ 4 ] = 0 ; GD2_DBG ( php_gd_error ( ""Got<S2SV_blank>file<S2SV_blank>code:<S2SV_blank>%s"" , id ) ) ; if ( strcmp ( id , GD2_ID ) != 0 ) { GD2_DBG ( php_gd_error ( ""Not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>gd2<S2SV_blank>file"" ) ) ; goto fail1 ; } if ( gdGetWord ( vers , in ) != 1 ) { goto fail1 ; } GD2_DBG ( php_gd_error ( ""Version:<S2SV_blank>%d"" , * vers ) ) ; if ( ( * vers != 1 ) && ( * vers != 2 ) ) { GD2_DBG ( php_gd_error ( ""Bad<S2SV_blank>version:<S2SV_blank>%d"" , * vers ) ) ; goto fail1 ; } if ( ! gdGetWord ( sx , in ) ) { GD2_DBG ( php_gd_error ( ""Could<S2SV_blank>not<S2SV_blank>get<S2SV_blank>x-size"" ) ) ; goto fail1 ; } if ( ! gdGetWord ( sy , in ) ) { GD2_DBG ( php_gd_error ( ""Could<S2SV_blank>not<S2SV_blank>get<S2SV_blank>y-size"" ) ) ; goto fail1 ; } GD2_DBG ( php_gd_error ( ""Image<S2SV_blank>is<S2SV_blank>%dx%d"" , * sx , * sy ) ) ; if ( gdGetWord ( cs , in ) != 1 ) { goto fail1 ; } GD2_DBG ( php_gd_error ( ""ChunkSize:<S2SV_blank>%d"" , * cs ) ) ; if ( ( * cs < GD2_CHUNKSIZE_MIN ) || ( * cs > GD2_CHUNKSIZE_MAX ) ) { GD2_DBG ( php_gd_error ( ""Bad<S2SV_blank>chunk<S2SV_blank>size:<S2SV_blank>%d"" , * cs ) ) ; goto fail1 ; } if ( gdGetWord ( fmt , in ) != 1 ) { goto fail1 ; } GD2_DBG ( php_gd_error ( ""Format:<S2SV_blank>%d"" , * fmt ) ) ; if ( ( * fmt != GD2_FMT_RAW ) && ( * fmt != GD2_FMT_COMPRESSED ) && ( * fmt != GD2_FMT_TRUECOLOR_RAW ) && ( * fmt != GD2_FMT_TRUECOLOR_COMPRESSED ) ) { GD2_DBG ( php_gd_error ( ""Bad<S2SV_blank>data<S2SV_blank>format:<S2SV_blank>%d"" , * fmt ) ) ; goto fail1 ; } if ( gdGetWord ( ncx , in ) != 1 ) { goto fail1 ; } GD2_DBG ( php_gd_error ( ""%d<S2SV_blank>Chunks<S2SV_blank>Wide"" , * ncx ) ) ; if ( gdGetWord ( ncy , in ) != 1 ) { goto fail1 ; } GD2_DBG ( php_gd_error ( ""%d<S2SV_blank>Chunks<S2SV_blank>vertically"" , * ncy ) ) ; if ( gd2_compressed ( * fmt ) ) { nc = ( * ncx ) * ( * ncy ) ; GD2_DBG ( php_gd_error ( ""Reading<S2SV_blank>%d<S2SV_blank>chunk<S2SV_blank>index<S2SV_blank>entries"" , nc ) ) ; <S2SV_StartBug> sidx = sizeof ( t_chunk_info ) * nc ; <S2SV_EndBug> if ( sidx <= 0 ) { goto fail1 ; } <S2SV_StartBug> cidx = gdCalloc ( sidx , 1 ) ; <S2SV_EndBug> for ( i = 0 ; i < nc ; i ++ ) { if ( gdGetInt ( & cidx [ i ] . offset , in ) != 1 ) { gdFree ( cidx ) ; goto fail1 ; } if ( gdGetInt ( & cidx [ i ] . size , in ) != 1 ) { gdFree ( cidx ) ; goto fail1 ; } if ( cidx [ i ] . offset < 0 || cidx [ i ] . size < 0 ) { gdFree ( cidx ) ; goto fail1 ; } } * chunkIdx = cidx ; } GD2_DBG ( php_gd_error ( ""gd2<S2SV_blank>header<S2SV_blank>complete"" ) ) ; return 1 ; fail1 : return 0 ; }","<S2SV_ModStart> ) ) ; if ( overflow2 ( sidx , nc ) ) { goto fail1 ; } <S2SV_ModStart> 1 ) ; if ( cidx == NULL ) { goto fail1 ; }",php@php-src/7722455726bec8c53458a32851d2a87982cf0eac,CVE-2016-5766,https://github.com/php/php-src/commit/7722455726bec8c53458a32851d2a87982cf0eac?w=1,2016-08-07T10:59Z
CWE-269,"CWE-000 static void setup_namespaces ( struct lo_data * lo , struct fuse_session * se ) { <S2SV_StartBug> pid_t child ; <S2SV_EndBug> char template [ ] = ""virtiofsd-XXXXXX"" ; char * tmpdir ; if ( unshare ( CLONE_NEWPID | CLONE_NEWNS | CLONE_NEWNET ) != 0 ) { fuse_log ( FUSE_LOG_ERR , ""unshare(CLONE_NEWPID<S2SV_blank>|<S2SV_blank>CLONE_NEWNS):<S2SV_blank>%m\\n"" ) ; exit ( 1 ) ; } child = fork ( ) ; if ( child < 0 ) { fuse_log ( FUSE_LOG_ERR , ""fork()<S2SV_blank>failed:<S2SV_blank>%m\\n"" ) ; exit ( 1 ) ; } if ( child > 0 ) { pid_t waited ; int wstatus ; setup_wait_parent_capabilities ( ) ; do { waited = waitpid ( child , & wstatus , 0 ) ; } while ( waited < 0 && errno == EINTR && ! se -> exited ) ; if ( se -> exited ) { exit ( 0 ) ; } if ( WIFEXITED ( wstatus ) ) { exit ( WEXITSTATUS ( wstatus ) ) ; } exit ( 1 ) ; } prctl ( PR_SET_PDEATHSIG , SIGTERM ) ; if ( mount ( NULL , ""/"" , NULL , MS_REC | MS_SLAVE , NULL ) < 0 ) { fuse_log ( FUSE_LOG_ERR , ""mount(/,<S2SV_blank>MS_REC|MS_SLAVE):<S2SV_blank>%m\\n"" ) ; exit ( 1 ) ; } if ( mount ( ""proc"" , ""/proc"" , ""proc"" , MS_NODEV | MS_NOEXEC | MS_NOSUID | MS_RELATIME , NULL ) < 0 ) { fuse_log ( FUSE_LOG_ERR , ""mount(/proc):<S2SV_blank>%m\\n"" ) ; exit ( 1 ) ; } <S2SV_StartBug> tmpdir = mkdtemp ( template ) ; <S2SV_EndBug> if ( ! tmpdir ) { fuse_log ( FUSE_LOG_ERR , ""tmpdir(%s):<S2SV_blank>%m\\n"" , template ) ; exit ( 1 ) ; } <S2SV_StartBug> if ( mount ( ""/proc/self/fd"" , tmpdir , NULL , MS_BIND , NULL ) < 0 ) { <S2SV_EndBug> <S2SV_StartBug> fuse_log ( FUSE_LOG_ERR , ""mount(/proc/self/fd,<S2SV_blank>%s,<S2SV_blank>MS_BIND):<S2SV_blank>%m\\n"" , <S2SV_EndBug> tmpdir ) ; exit ( 1 ) ; } <S2SV_StartBug> lo -> proc_self_fd = open ( tmpdir , O_PATH ) ; <S2SV_EndBug> if ( lo -> proc_self_fd == - 1 ) { <S2SV_StartBug> fuse_log ( FUSE_LOG_ERR , ""open(%s,<S2SV_blank>O_PATH):<S2SV_blank>%m\\n"" , tmpdir ) ; <S2SV_EndBug> exit ( 1 ) ; } if ( umount2 ( tmpdir , MNT_DETACH ) < 0 ) { fuse_log ( FUSE_LOG_ERR , ""umount2(%s,<S2SV_blank>MNT_DETACH):<S2SV_blank>%m\\n"" , tmpdir ) ; exit ( 1 ) ; } if ( rmdir ( tmpdir ) < 0 ) { fuse_log ( FUSE_LOG_ERR , ""rmdir(%s):<S2SV_blank>%m\\n"" , tmpdir ) ; } }","<S2SV_ModStart> { pid_t child <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) ; } <S2SV_ModEnd> if ( mount <S2SV_ModStart> ( ""/proc/self/fd"" , ""/proc"" <S2SV_ModEnd> , NULL , <S2SV_ModStart> ( FUSE_LOG_ERR , ""mount(/proc/self/fd,<S2SV_blank>MS_BIND):<S2SV_blank>%m\\n"" <S2SV_ModEnd> ) ; exit <S2SV_ModStart> = open ( ""/proc"" <S2SV_ModEnd> , O_PATH ) <S2SV_ModStart> ( FUSE_LOG_ERR , ""open(/proc,<S2SV_blank>O_PATH):<S2SV_blank>%m\\n"" ) ; exit ( 1 <S2SV_ModEnd> ) ; }",qemu@qemu/ebf101955ce8f8d72fba103b5151115a4335de2c,CVE-2020-35517,https://github.com/qemu/qemu/commit/ebf101955ce8f8d72fba103b5151115a4335de2c,2021-01-28T20:15Z
CWE-119,"CWE-119 static int parse_device ( dev_t * pdev , struct archive * a , char * val ) { # define MAX_PACK_ARGS 3 unsigned long numbers [ MAX_PACK_ARGS ] ; char * p , * dev ; int argc ; pack_t * pack ; dev_t result ; const char * error = NULL ; memset ( pdev , 0 , sizeof ( * pdev ) ) ; if ( ( dev = strchr ( val , ',' ) ) != NULL ) { * dev ++ = '\\0' ; if ( ( pack = pack_find ( val ) ) == NULL ) { archive_set_error ( a , ARCHIVE_ERRNO_FILE_FORMAT , ""Unknown<S2SV_blank>format<S2SV_blank>`%s\'"" , val ) ; return ARCHIVE_WARN ; } argc = 0 ; while ( ( p = la_strsep ( & dev , "","" ) ) != NULL ) { if ( * p == '\\0' ) { archive_set_error ( a , ARCHIVE_ERRNO_FILE_FORMAT , ""Missing<S2SV_blank>number"" ) ; return ARCHIVE_WARN ; } <S2SV_StartBug> numbers [ argc ++ ] = ( unsigned long ) mtree_atol ( & p ) ; <S2SV_EndBug> <S2SV_StartBug> if ( argc > MAX_PACK_ARGS ) { <S2SV_EndBug> archive_set_error ( a , ARCHIVE_ERRNO_FILE_FORMAT , ""Too<S2SV_blank>many<S2SV_blank>arguments"" ) ; return ARCHIVE_WARN ; } } if ( argc < 2 ) { archive_set_error ( a , ARCHIVE_ERRNO_FILE_FORMAT , ""Not<S2SV_blank>enough<S2SV_blank>arguments"" ) ; return ARCHIVE_WARN ; } result = ( * pack ) ( argc , numbers , & error ) ; if ( error != NULL ) { archive_set_error ( a , ARCHIVE_ERRNO_FILE_FORMAT , ""%s"" , error ) ; return ARCHIVE_WARN ; } } else { result = ( dev_t ) mtree_atol ( & val ) ; } * pdev = result ; return ARCHIVE_OK ; # undef MAX_PACK_ARGS }","<S2SV_ModStart> ARCHIVE_WARN ; } if ( argc >= MAX_PACK_ARGS ) { archive_set_error ( a , ARCHIVE_ERRNO_FILE_FORMAT , ""Too<S2SV_blank>many<S2SV_blank>arguments"" ) ; return ARCHIVE_WARN ; } <S2SV_ModStart> p ) ; <S2SV_ModEnd> } if (",libarchive@libarchive/a550daeecf6bc689ade371349892ea17b5b97c77,CVE-2016-4301,https://github.com/libarchive/libarchive/commit/a550daeecf6bc689ade371349892ea17b5b97c77,2016-09-21T14:25Z
CWE-190,CWE-190 size_t jsuGetFreeStack ( ) { # ifdef ARM void * frame = __builtin_frame_address ( 0 ) ; size_t stackPos = ( size_t ) ( ( char * ) frame ) ; size_t stackEnd = ( size_t ) ( ( char * ) & LINKER_END_VAR ) ; if ( stackPos < stackEnd ) return 0 ; return stackPos - stackEnd ; # elif defined ( LINUX ) char ptr ; extern void * STACK_BASE ; uint32_t count = ( uint32_t ) ( ( size_t ) STACK_BASE - ( size_t ) & ptr ) ; <S2SV_StartBug> return 1000000 - count ; <S2SV_EndBug> # else return 1000000 ; # endif },<S2SV_ModStart> ptr ) ; const uint32_t max_stack = 1000000 ; if ( count > max_stack ) return 0 ; return max_stack <S2SV_ModEnd> - count ;,espruino@Espruino/a0d7f432abee692402c00e8b615ff5982dde9780,CVE-2018-11590,https://github.com/espruino/Espruino/commit/a0d7f432abee692402c00e8b615ff5982dde9780,2018-05-31T16:29Z
CWE-119,"CWE-119 static void decode_macroblock ( VP8D_COMP * pbi , MACROBLOCKD * xd , unsigned int mb_idx ) { MB_PREDICTION_MODE mode ; int i ; # if CONFIG_ERROR_CONCEALMENT int corruption_detected = 0 ; <S2SV_StartBug> # endif <S2SV_EndBug> if ( xd -> mode_info_context -> mbmi . mb_skip_coeff ) { vp8_reset_mb_tokens_context ( xd ) ; } else if ( ! vp8dx_bool_error ( xd -> current_bc ) ) { int eobtotal ; eobtotal = vp8_decode_mb_tokens ( pbi , xd ) ; xd -> mode_info_context -> mbmi . mb_skip_coeff = ( eobtotal == 0 ) ; } mode = xd -> mode_info_context -> mbmi . mode ; if ( xd -> segmentation_enabled ) vp8_mb_init_dequantizer ( pbi , xd ) ; # if CONFIG_ERROR_CONCEALMENT if ( pbi -> ec_active ) { int throw_residual ; throw_residual = ( ! pbi -> independent_partitions && pbi -> frame_corrupt_residual ) ; throw_residual = ( throw_residual || vp8dx_bool_error ( xd -> current_bc ) ) ; if ( ( mb_idx >= pbi -> mvs_corrupt_from_mb || throw_residual ) ) { pbi -> frame_corrupt_residual = 1 ; <S2SV_StartBug> vpx_memset ( xd -> qcoeff , 0 , sizeof ( xd -> qcoeff ) ) ; <S2SV_EndBug> vp8_conceal_corrupt_mb ( xd ) ; corruption_detected = 1 ; <S2SV_StartBug> vpx_memset ( xd -> eobs , 0 , 25 ) ; <S2SV_EndBug> } } # endif if ( xd -> mode_info_context -> mbmi . ref_frame == INTRA_FRAME ) { vp8_build_intra_predictors_mbuv_s ( xd , xd -> recon_above [ 1 ] , xd -> recon_above [ 2 ] , xd -> recon_left [ 1 ] , xd -> recon_left [ 2 ] , xd -> recon_left_stride [ 1 ] , xd -> dst . u_buffer , xd -> dst . v_buffer , xd -> dst . uv_stride ) ; if ( mode != B_PRED ) { vp8_build_intra_predictors_mby_s ( xd , xd -> recon_above [ 0 ] , xd -> recon_left [ 0 ] , xd -> recon_left_stride [ 0 ] , xd -> dst . y_buffer , xd -> dst . y_stride ) ; } else { short * DQC = xd -> dequant_y1 ; int dst_stride = xd -> dst . y_stride ; if ( xd -> mode_info_context -> mbmi . mb_skip_coeff ) <S2SV_StartBug> vpx_memset ( xd -> eobs , 0 , 25 ) ; <S2SV_EndBug> intra_prediction_down_copy ( xd , xd -> recon_above [ 0 ] + 16 ) ; for ( i = 0 ; i < 16 ; i ++ ) { BLOCKD * b = & xd -> block [ i ] ; unsigned char * dst = xd -> dst . y_buffer + b -> offset ; B_PREDICTION_MODE b_mode = xd -> mode_info_context -> bmi [ i ] . as_mode ; unsigned char * Above = dst - dst_stride ; unsigned char * yleft = dst - 1 ; int left_stride = dst_stride ; unsigned char top_left = Above [ - 1 ] ; vp8_intra4x4_predict ( Above , yleft , left_stride , b_mode , dst , dst_stride , top_left ) ; if ( xd -> eobs [ i ] ) { if ( xd -> eobs [ i ] > 1 ) { vp8_dequant_idct_add ( b -> qcoeff , DQC , dst , dst_stride ) ; } else { vp8_dc_only_idct_add ( b -> qcoeff [ 0 ] * DQC [ 0 ] , dst , dst_stride , dst , dst_stride ) ; <S2SV_StartBug> vpx_memset ( b -> qcoeff , 0 , 2 * sizeof ( b -> qcoeff [ 0 ] ) ) ; <S2SV_EndBug> } } } } } else { vp8_build_inter_predictors_mb ( xd ) ; } # if CONFIG_ERROR_CONCEALMENT if ( corruption_detected ) { return ; } # endif if ( ! xd -> mode_info_context -> mbmi . mb_skip_coeff ) { if ( mode != B_PRED ) { short * DQC = xd -> dequant_y1 ; if ( mode != SPLITMV ) { BLOCKD * b = & xd -> block [ 24 ] ; if ( xd -> eobs [ 24 ] > 1 ) { vp8_dequantize_b ( b , xd -> dequant_y2 ) ; vp8_short_inv_walsh4x4 ( & b -> dqcoeff [ 0 ] , xd -> qcoeff ) ; <S2SV_StartBug> vpx_memset ( b -> qcoeff , 0 , 16 * sizeof ( b -> qcoeff [ 0 ] ) ) ; <S2SV_EndBug> } else { b -> dqcoeff [ 0 ] = b -> qcoeff [ 0 ] * xd -> dequant_y2 [ 0 ] ; vp8_short_inv_walsh4x4_1 ( & b -> dqcoeff [ 0 ] , xd -> qcoeff ) ; <S2SV_StartBug> vpx_memset ( b -> qcoeff , 0 , 2 * sizeof ( b -> qcoeff [ 0 ] ) ) ; <S2SV_EndBug> } DQC = xd -> dequant_y1_dc ; } vp8_dequant_idct_add_y_block ( xd -> qcoeff , DQC , xd -> dst . y_buffer , xd -> dst . y_stride , xd -> eobs ) ; } vp8_dequant_idct_add_uv_block ( xd -> qcoeff + 16 * 16 , xd -> dequant_uv , xd -> dst . u_buffer , xd -> dst . v_buffer , xd -> dst . uv_stride , xd -> eobs + 16 ) ; } }",<S2SV_ModStart> 0 ; # else ( void ) mb_idx ; # <S2SV_ModStart> = 1 ; memset <S2SV_ModEnd> ( xd -> <S2SV_ModStart> = 1 ; memset <S2SV_ModEnd> ( xd -> <S2SV_ModStart> . mb_skip_coeff ) memset <S2SV_ModEnd> ( xd -> <S2SV_ModStart> dst_stride ) ; memset <S2SV_ModEnd> ( b -> <S2SV_ModStart> qcoeff ) ; memset <S2SV_ModEnd> ( b -> <S2SV_ModStart> qcoeff ) ; memset <S2SV_ModEnd> ( b ->,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-119,"CWE-119 static int pop_sync_mailbox ( struct Context * ctx , int * index_hint ) { int i , j , ret = 0 ; char buf [ LONG_STRING ] ; struct PopData * pop_data = ( struct PopData * ) ctx -> data ; struct Progress progress ; # ifdef USE_HCACHE header_cache_t * hc = NULL ; # endif pop_data -> check_time = 0 ; while ( true ) { if ( pop_reconnect ( ctx ) < 0 ) return - 1 ; mutt_progress_init ( & progress , _ ( ""Marking<S2SV_blank>messages<S2SV_blank>deleted..."" ) , MUTT_PROGRESS_MSG , WriteInc , ctx -> deleted ) ; # ifdef USE_HCACHE hc = pop_hcache_open ( pop_data , ctx -> path ) ; # endif for ( i = 0 , j = 0 , ret = 0 ; ret == 0 && i < ctx -> msgcount ; i ++ ) { if ( ctx -> hdrs [ i ] -> deleted && ctx -> hdrs [ i ] -> refno != - 1 ) { j ++ ; if ( ! ctx -> quiet ) mutt_progress_update ( & progress , j , - 1 ) ; snprintf ( buf , sizeof ( buf ) , ""DELE<S2SV_blank>%d\\r\\n"" , ctx -> hdrs [ i ] -> refno ) ; ret = pop_query ( pop_data , buf , sizeof ( buf ) ) ; if ( ret == 0 ) { <S2SV_StartBug> mutt_bcache_del ( pop_data -> bcache , ctx -> hdrs [ i ] -> data ) ; <S2SV_EndBug> # ifdef USE_HCACHE mutt_hcache_delete ( hc , ctx -> hdrs [ i ] -> data , strlen ( ctx -> hdrs [ i ] -> data ) ) ; # endif } } # ifdef USE_HCACHE if ( ctx -> hdrs [ i ] -> changed ) { mutt_hcache_store ( hc , ctx -> hdrs [ i ] -> data , strlen ( ctx -> hdrs [ i ] -> data ) , ctx -> hdrs [ i ] , 0 ) ; } # endif } # ifdef USE_HCACHE mutt_hcache_close ( hc ) ; # endif if ( ret == 0 ) { mutt_str_strfcpy ( buf , ""QUIT\\r\\n"" , sizeof ( buf ) ) ; ret = pop_query ( pop_data , buf , sizeof ( buf ) ) ; } if ( ret == 0 ) { pop_data -> clear_cache = true ; pop_clear_cache ( pop_data ) ; pop_data -> status = POP_DISCONNECTED ; return 0 ; } if ( ret == - 2 ) { mutt_error ( ""%s"" , pop_data -> err_msg ) ; return - 1 ; } } }","<S2SV_ModStart> -> bcache , cache_id ( <S2SV_ModStart> ] -> data )",neomutt@neomutt/9bfab35522301794483f8f9ed60820bdec9be59e,CVE-2018-14362,https://github.com/neomutt/neomutt/commit/9bfab35522301794483f8f9ed60820bdec9be59e,2018-07-17T17:29Z
,"CWE-000 static int kvm_vm_ioctl_set_pit2 ( struct kvm * kvm , struct kvm_pit_state2 * ps ) { <S2SV_StartBug> int start = 0 ; <S2SV_EndBug> u32 prev_legacy , cur_legacy ; mutex_lock ( & kvm -> arch . vpit -> pit_state . lock ) ; prev_legacy = kvm -> arch . vpit -> pit_state . flags & KVM_PIT_FLAGS_HPET_LEGACY ; cur_legacy = ps -> flags & KVM_PIT_FLAGS_HPET_LEGACY ; if ( ! prev_legacy && cur_legacy ) start = 1 ; memcpy ( & kvm -> arch . vpit -> pit_state . channels , & ps -> channels , sizeof ( kvm -> arch . vpit -> pit_state . channels ) ) ; kvm -> arch . vpit -> pit_state . flags = ps -> flags ; <S2SV_StartBug> kvm_pit_load_count ( kvm , 0 , kvm -> arch . vpit -> pit_state . channels [ 0 ] . count , start ) ; <S2SV_EndBug> mutex_unlock ( & kvm -> arch . vpit -> pit_state . lock ) ; return 0 ; }","<S2SV_ModStart> start = 0 ; int i <S2SV_ModStart> -> flags ; for ( i = 0 ; i < 3 ; i ++ ) <S2SV_ModStart> ( kvm , i <S2SV_ModEnd> , kvm -> <S2SV_ModStart> . channels [ i <S2SV_ModEnd> ] . count",torvalds@linux/0185604c2d82c560dab2f2933a18f797e74ab5a8,CVE-2015-7513,https://github.com/torvalds/linux/commit/0185604c2d82c560dab2f2933a18f797e74ab5a8,2016-02-08T03:59Z
,"CWE-000 static int cdc_ncm_bind ( struct usbnet * dev , struct usb_interface * intf ) { <S2SV_StartBug> int ret ; <S2SV_EndBug> if ( cdc_ncm_select_altsetting ( intf ) != CDC_NCM_COMM_ALTSETTING_NCM ) return - ENODEV ; <S2SV_StartBug> ret = cdc_ncm_bind_common ( dev , intf , CDC_NCM_DATA_ALTSETTING_NCM , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> usbnet_link_change ( dev , 0 , 0 ) ; <S2SV_EndBug> return ret ; }",<S2SV_ModStart> intf ) { <S2SV_ModEnd> if ( cdc_ncm_select_altsetting <S2SV_ModStart> - ENODEV ; return <S2SV_ModEnd> cdc_ncm_bind_common ( dev <S2SV_ModStart> 0 ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>,torvalds@linux/4d06dd537f95683aba3651098ae288b7cbff8274,CVE-2016-3951,https://github.com/torvalds/linux/commit/4d06dd537f95683aba3651098ae288b7cbff8274,2016-05-02T10:59Z
CWE-119,"CWE-119 static int store_icy ( URLContext * h , int size ) { HTTPContext * s = h -> priv_data ; <S2SV_StartBug> int remaining = s -> icy_metaint - s -> icy_data_read ; <S2SV_EndBug> if ( remaining < 0 ) return AVERROR_INVALIDDATA ; if ( ! remaining ) { uint8_t ch ; int len = http_read_stream_all ( h , & ch , 1 ) ; if ( len < 0 ) return len ; if ( ch > 0 ) { char data [ 255 * 16 + 1 ] ; int ret ; len = ch * 16 ; ret = http_read_stream_all ( h , data , len ) ; if ( ret < 0 ) return ret ; data [ len + 1 ] = 0 ; if ( ( ret = av_opt_set ( s , ""icy_metadata_packet"" , data , 0 ) ) < 0 ) return ret ; update_metadata ( s , data ) ; } s -> icy_data_read = 0 ; remaining = s -> icy_metaint ; } return FFMIN ( size , remaining ) ; }",<S2SV_ModStart> -> priv_data ; uint64_t remaining ; if ( s -> icy_metaint < s -> icy_data_read ) return AVERROR_INVALIDDATA ; <S2SV_ModEnd> remaining = s <S2SV_ModStart> s -> icy_data_read <S2SV_ModEnd> ; if (,FFmpeg@FFmpeg/2a05c8f813de6f2278827734bf8102291e7484aa,CVE-2016-10190,https://github.com/FFmpeg/FFmpeg/commit/2a05c8f813de6f2278827734bf8102291e7484aa,2017-02-09T15:59Z
CWE-189,"CWE-189 static int sgi_timer_set ( struct k_itimer * timr , int flags , struct itimerspec * new_setting , struct itimerspec * old_setting ) { unsigned long when , period , irqflags ; int err = 0 ; cnodeid_t nodeid ; struct mmtimer * base ; struct rb_node * n ; if ( old_setting ) sgi_timer_get ( timr , old_setting ) ; sgi_timer_del ( timr ) ; <S2SV_StartBug> when = timespec_to_ns ( new_setting -> it_value ) ; <S2SV_EndBug> <S2SV_StartBug> period = timespec_to_ns ( new_setting -> it_interval ) ; <S2SV_EndBug> if ( when == 0 ) return 0 ; base = kmalloc ( sizeof ( struct mmtimer ) , GFP_KERNEL ) ; if ( base == NULL ) return - ENOMEM ; if ( flags & TIMER_ABSTIME ) { struct timespec n ; unsigned long now ; getnstimeofday ( & n ) ; <S2SV_StartBug> now = timespec_to_ns ( n ) ; <S2SV_EndBug> if ( when > now ) when -= now ; else when = 0 ; } when = ( when + sgi_clock_period - 1 ) / sgi_clock_period + rtc_time ( ) ; period = ( period + sgi_clock_period - 1 ) / sgi_clock_period ; preempt_disable ( ) ; nodeid = cpu_to_node ( smp_processor_id ( ) ) ; spin_lock_irqsave ( & timers [ nodeid ] . lock , irqflags ) ; base -> timer = timr ; base -> cpu = smp_processor_id ( ) ; timr -> it . mmtimer . clock = TIMER_SET ; timr -> it . mmtimer . node = nodeid ; timr -> it . mmtimer . incr = period ; timr -> it . mmtimer . expires = when ; n = timers [ nodeid ] . next ; mmtimer_add_list ( base ) ; if ( timers [ nodeid ] . next == n ) { spin_unlock_irqrestore ( & timers [ nodeid ] . lock , irqflags ) ; preempt_enable ( ) ; return err ; } if ( n ) mmtimer_disable_int ( cnodeid_to_nasid ( nodeid ) , COMPARATOR ) ; mmtimer_set_next_timer ( nodeid ) ; spin_unlock_irqrestore ( & timers [ nodeid ] . lock , irqflags ) ; preempt_enable ( ) ; return err ; }",<S2SV_ModStart> = timespec_to_ns ( & <S2SV_ModStart> = timespec_to_ns ( & <S2SV_ModStart> = timespec_to_ns ( &,torvalds@linux/f8bd2258e2d520dff28c855658bd24bdafb5102d,CVE-2011-3209,https://github.com/torvalds/linux/commit/f8bd2258e2d520dff28c855658bd24bdafb5102d,2012-10-03T11:02Z
CWE-119,"CWE-119 void vp8dx_bool_decoder_fill ( BOOL_DECODER * br ) { const unsigned char * bufptr = br -> user_buffer ; VP8_BD_VALUE value = br -> value ; int count = br -> count ; <S2SV_StartBug> int shift = VP8_BD_VALUE_SIZE - 8 - ( count + 8 ) ; <S2SV_EndBug> size_t bytes_left = br -> user_buffer_end - bufptr ; size_t bits_left = bytes_left * CHAR_BIT ; int x = ( int ) ( shift + CHAR_BIT - bits_left ) ; int loop_end = 0 ; unsigned char decrypted [ sizeof ( VP8_BD_VALUE ) + 1 ] ; if ( br -> decrypt_cb ) { <S2SV_StartBug> size_t n = bytes_left > sizeof ( decrypted ) ? sizeof ( decrypted ) : bytes_left ; <S2SV_EndBug> br -> decrypt_cb ( br -> decrypt_state , bufptr , decrypted , ( int ) n ) ; bufptr = decrypted ; } if ( x >= 0 ) { count += VP8_LOTS_OF_BITS ; loop_end = x ; } if ( x < 0 || bits_left ) { while ( shift >= loop_end ) { count += CHAR_BIT ; value |= ( VP8_BD_VALUE ) * bufptr << shift ; ++ bufptr ; ++ br -> user_buffer ; shift -= CHAR_BIT ; } } br -> value = value ; br -> count = count ; }","<S2SV_ModStart> = VP8_BD_VALUE_SIZE - CHAR_BIT <S2SV_ModEnd> - ( count <S2SV_ModStart> ( count + CHAR_BIT <S2SV_ModEnd> ) ; size_t <S2SV_ModStart> size_t n = MIN ( sizeof ( decrypted ) , bytes_left ) <S2SV_ModEnd> ; br ->",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-119,"CWE-119 static int get_cox ( Jpeg2000DecoderContext * s , Jpeg2000CodingStyle * c ) { uint8_t byte ; if ( bytestream2_get_bytes_left ( & s -> g ) < 5 ) return AVERROR_INVALIDDATA ; c -> nreslevels = bytestream2_get_byteu ( & s -> g ) + 1 ; if ( c -> nreslevels >= JPEG2000_MAX_RESLEVELS ) { av_log ( s -> avctx , AV_LOG_ERROR , ""nreslevels<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>invalid\\n"" , c -> nreslevels ) ; return AVERROR_INVALIDDATA ; } if ( c -> nreslevels < s -> reduction_factor ) c -> nreslevels2decode = 1 ; else c -> nreslevels2decode = c -> nreslevels - s -> reduction_factor ; c -> log2_cblk_width = ( bytestream2_get_byteu ( & s -> g ) & 15 ) + 2 ; c -> log2_cblk_height = ( bytestream2_get_byteu ( & s -> g ) & 15 ) + 2 ; if ( c -> log2_cblk_width > 10 || c -> log2_cblk_height > 10 || c -> log2_cblk_width + c -> log2_cblk_height > 12 ) { av_log ( s -> avctx , AV_LOG_ERROR , ""cblk<S2SV_blank>size<S2SV_blank>invalid\\n"" ) ; return AVERROR_INVALIDDATA ; } <S2SV_StartBug> c -> cblk_style = bytestream2_get_byteu ( & s -> g ) ; <S2SV_EndBug> if ( c -> cblk_style != 0 ) { av_log ( s -> avctx , AV_LOG_WARNING , ""extra<S2SV_blank>cblk<S2SV_blank>styles<S2SV_blank>%X\\n"" , c -> cblk_style ) ; } c -> transform = bytestream2_get_byteu ( & s -> g ) ; if ( ( s -> avctx -> flags & CODEC_FLAG_BITEXACT ) && ( c -> transform == FF_DWT97 ) ) c -> transform = FF_DWT97_INT ; if ( c -> csty & JPEG2000_CSTY_PREC ) { int i ; for ( i = 0 ; i < c -> nreslevels ; i ++ ) { byte = bytestream2_get_byte ( & s -> g ) ; c -> log2_prec_widths [ i ] = byte & 0x0F ; c -> log2_prec_heights [ i ] = ( byte >> 4 ) & 0x0F ; } } else { memset ( c -> log2_prec_widths , 15 , sizeof ( c -> log2_prec_widths ) ) ; memset ( c -> log2_prec_heights , 15 , sizeof ( c -> log2_prec_heights ) ) ; } return 0 ; }","<S2SV_ModStart> AVERROR_INVALIDDATA ; } if ( c -> log2_cblk_width > 6 || c -> log2_cblk_height > 6 ) { avpriv_request_sample ( s -> avctx , ""cblk<S2SV_blank>size<S2SV_blank>><S2SV_blank>64"" ) ; return AVERROR_PATCHWELCOME ; }",FFmpeg@FFmpeg/9a271a9368eaabf99e6c2046103acb33957e63b7,CVE-2013-7018,https://github.com/FFmpeg/FFmpeg/commit/9a271a9368eaabf99e6c2046103acb33957e63b7,2013-12-09T16:36Z
CWE-119,"CWE-119 <S2SV_StartBug> static void <S2SV_EndBug> horAcc8 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { tmsize_t stride = PredictorState ( tif ) -> stride ; unsigned char * cp = ( unsigned char * ) cp0 ; <S2SV_StartBug> assert ( ( cc % stride ) == 0 ) ; <S2SV_EndBug> if ( cc > stride ) { if ( stride == 3 ) { unsigned int cr = cp [ 0 ] ; unsigned int cg = cp [ 1 ] ; unsigned int cb = cp [ 2 ] ; cc -= 3 ; cp += 3 ; while ( cc > 0 ) { cp [ 0 ] = ( unsigned char ) ( ( cr += cp [ 0 ] ) & 0xff ) ; cp [ 1 ] = ( unsigned char ) ( ( cg += cp [ 1 ] ) & 0xff ) ; cp [ 2 ] = ( unsigned char ) ( ( cb += cp [ 2 ] ) & 0xff ) ; cc -= 3 ; cp += 3 ; } } else if ( stride == 4 ) { unsigned int cr = cp [ 0 ] ; unsigned int cg = cp [ 1 ] ; unsigned int cb = cp [ 2 ] ; unsigned int ca = cp [ 3 ] ; cc -= 4 ; cp += 4 ; while ( cc > 0 ) { cp [ 0 ] = ( unsigned char ) ( ( cr += cp [ 0 ] ) & 0xff ) ; cp [ 1 ] = ( unsigned char ) ( ( cg += cp [ 1 ] ) & 0xff ) ; cp [ 2 ] = ( unsigned char ) ( ( cb += cp [ 2 ] ) & 0xff ) ; cp [ 3 ] = ( unsigned char ) ( ( ca += cp [ 3 ] ) & 0xff ) ; cc -= 4 ; cp += 4 ; } } else { cc -= stride ; do { REPEAT4 ( stride , cp [ stride ] = ( unsigned char ) ( ( cp [ stride ] + * cp ) & 0xff ) ; cp ++ ) cc -= stride ; } while ( cc > 0 ) ; } } <S2SV_StartBug> } <S2SV_EndBug>","<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> horAcc8 ( TIFF <S2SV_ModStart> ) cp0 ; if <S2SV_ModEnd> ( ( cc <S2SV_ModStart> % stride ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , ""horAcc8"" , ""%s"" , ""(cc%stride)!=0"" ) ; return 0 ; } <S2SV_ModEnd> if ( cc <S2SV_ModStart> ; } } return 1 ;",vadz@libtiff/3ca657a8793dd011bf869695d72ad31c779c3cc1,CVE-2016-9535,https://github.com/vadz/libtiff/commit/3ca657a8793dd011bf869695d72ad31c779c3cc1,2016-11-22T19:59Z
CWE-119,"CWE-119 <S2SV_StartBug> int release_vp9_frame_buffer ( void * cb_priv , <S2SV_EndBug> vpx_codec_frame_buffer_t * fb ) { struct ExternalFrameBuffer * const ext_fb = ( struct ExternalFrameBuffer * ) fb -> priv ; ( void ) cb_priv ; ext_fb -> in_use = 0 ; return 0 ; }",<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-264,"CWE-264 void eval_js ( WebKitWebView * web_view , gchar * script , GString * result ) { WebKitWebFrame * frame ; JSGlobalContextRef context ; <S2SV_StartBug> JSObjectRef globalobject ; <S2SV_EndBug> JSStringRef var_name ; JSStringRef js_script ; JSValueRef js_result ; JSStringRef js_result_string ; size_t js_result_size ; js_init ( ) ; frame = webkit_web_view_get_main_frame ( WEBKIT_WEB_VIEW ( web_view ) ) ; context = webkit_web_frame_get_global_context ( frame ) ; <S2SV_StartBug> globalobject = JSContextGetGlobalObject ( context ) ; <S2SV_EndBug> var_name = JSStringCreateWithUTF8CString ( ""Uzbl"" ) ; JSObjectSetProperty ( context , globalobject , var_name , JSObjectMake ( context , uzbl . js . classref , NULL ) , kJSClassAttributeNone , NULL ) ; js_script = JSStringCreateWithUTF8CString ( script ) ; js_result = JSEvaluateScript ( context , js_script , globalobject , NULL , 0 , NULL ) ; if ( js_result && ! JSValueIsUndefined ( context , js_result ) ) { js_result_string = JSValueToStringCopy ( context , js_result , NULL ) ; js_result_size = JSStringGetMaximumUTF8CStringSize ( js_result_string ) ; if ( js_result_size ) { char js_result_utf8 [ js_result_size ] ; JSStringGetUTF8CString ( js_result_string , js_result_utf8 , js_result_size ) ; g_string_assign ( result , js_result_utf8 ) ; } JSStringRelease ( js_result_string ) ; } <S2SV_StartBug> JSObjectDeleteProperty ( context , globalobject , var_name , NULL ) ; <S2SV_EndBug> JSStringRelease ( var_name ) ; JSStringRelease ( js_script ) ; }",<S2SV_ModStart> ; JSObjectRef globalobject <S2SV_ModEnd> ; JSStringRef js_script <S2SV_ModStart> JSContextGetGlobalObject ( context <S2SV_ModEnd> ) ; js_script <S2SV_ModStart> ) ; } <S2SV_ModEnd> JSStringRelease ( js_script,Dieterbe@uzbl/1958b52d41cba96956dc1995660de49525ed1047,CVE-2010-0011,https://github.com/Dieterbe/uzbl/commit/1958b52d41cba96956dc1995660de49525ed1047,2010-02-25T19:30Z
CWE-264,"CWE-264 static int read_exceptions ( struct pstore * ps , int ( * callback ) ( void * callback_context , chunk_t old , chunk_t new ) , void * callback_context ) { int r , full = 1 ; for ( ps -> current_area = 0 ; full ; ps -> current_area ++ ) { r = area_io ( ps , READ ) ; if ( r ) return r ; r = insert_exceptions ( ps , callback , callback_context , & full ) ; if ( r ) return r ; } ps -> current_area -- ; <S2SV_StartBug> return 0 ; <S2SV_EndBug> }",<S2SV_ModStart> current_area -- ; skip_metadata ( ps ) ;,torvalds@linux/e9c6a182649f4259db704ae15a91ac820e63b0ca,CVE-2013-4299,https://github.com/torvalds/linux/commit/e9c6a182649f4259db704ae15a91ac820e63b0ca,2013-10-24T10:53Z
CWE-119,"CWE-119 void ih264d_rest_of_residual_cav_chroma_dc_block ( UWORD32 u4_total_coeff_trail_one , dec_bit_stream_t * ps_bitstrm ) { UWORD32 u4_total_zeroes ; WORD16 i ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 u4_bitstream_offset = ps_bitstrm -> u4_ofst ; UWORD32 u4_trailing_ones = u4_total_coeff_trail_one & 0xFFFF ; UWORD32 u4_total_coeff = u4_total_coeff_trail_one >> 16 ; <S2SV_StartBug> WORD16 i2_level_arr [ 4 ] ; <S2SV_EndBug> tu_sblk4x4_coeff_data_t * ps_tu_4x4 ; WORD16 * pi2_coeff_data ; dec_struct_t * ps_dec = ( dec_struct_t * ) ps_bitstrm -> pv_codec_handle ; ps_tu_4x4 = ( tu_sblk4x4_coeff_data_t * ) ps_dec -> pv_parse_tu_coeff_data ; ps_tu_4x4 -> u2_sig_coeff_map = 0 ; pi2_coeff_data = & ps_tu_4x4 -> ai2_level [ 0 ] ; i = u4_total_coeff - 1 ; if ( u4_trailing_ones ) { UWORD32 u4_signs , u4_cnt = u4_trailing_ones ; WORD16 ( * ppi2_trlone_lkup ) [ 3 ] = ( WORD16 ( * ) [ 3 ] ) gai2_ih264d_trailing_one_level ; WORD16 * pi2_trlone_lkup ; GETBITS ( u4_signs , u4_bitstream_offset , pu4_bitstrm_buf , u4_cnt ) ; pi2_trlone_lkup = ppi2_trlone_lkup [ ( 1 << u4_cnt ) - 2 + u4_signs ] ; while ( u4_cnt -- ) i2_level_arr [ i -- ] = * pi2_trlone_lkup ++ ; } if ( i >= 0 ) { UWORD32 u4_lev_suffix , u4_suffix_len , u4_lev_suffix_size ; UWORD16 u2_lev_code , u2_abs_value ; UWORD32 u4_lev_prefix ; FIND_ONE_IN_STREAM_32 ( u4_lev_prefix , u4_bitstream_offset , pu4_bitstrm_buf ) ; u2_lev_code = MIN ( 15 , u4_lev_prefix ) ; u2_lev_code += ( 3 == u4_trailing_ones ) ? 0 : ( 2 ) ; if ( 14 == u4_lev_prefix ) u4_lev_suffix_size = 4 ; else if ( 15 <= u4_lev_prefix ) { u2_lev_code += 15 ; u4_lev_suffix_size = u4_lev_prefix - 3 ; } else u4_lev_suffix_size = 0 ; if ( 16 <= u4_lev_prefix ) { u2_lev_code += ( ( 1 << ( u4_lev_prefix - 3 ) ) - 4096 ) ; } if ( u4_lev_suffix_size ) { GETBITS ( u4_lev_suffix , u4_bitstream_offset , pu4_bitstrm_buf , u4_lev_suffix_size ) ; u2_lev_code += u4_lev_suffix ; } u2_abs_value = ( u2_lev_code + 2 ) >> 1 ; i2_level_arr [ i -- ] = ( u2_lev_code & 1 ) ? - u2_abs_value : u2_abs_value ; u4_suffix_len = ( u2_abs_value > 3 ) ? 2 : 1 ; while ( i >= 0 ) { FIND_ONE_IN_STREAM_32 ( u4_lev_prefix , u4_bitstream_offset , pu4_bitstrm_buf ) ; u4_lev_suffix_size = ( 15 <= u4_lev_prefix ) ? ( u4_lev_prefix - 3 ) : u4_suffix_len ; GETBITS ( u4_lev_suffix , u4_bitstream_offset , pu4_bitstrm_buf , u4_lev_suffix_size ) ; u2_lev_code = ( MIN ( u4_lev_prefix , 15 ) << u4_suffix_len ) + u4_lev_suffix ; if ( 16 <= u4_lev_prefix ) { u2_lev_code += ( ( 1 << ( u4_lev_prefix - 3 ) ) - 4096 ) ; } u2_abs_value = ( u2_lev_code + 2 ) >> 1 ; i2_level_arr [ i -- ] = ( u2_lev_code & 1 ) ? - u2_abs_value : u2_abs_value ; u4_suffix_len += ( u2_abs_value > ( 3 << ( u4_suffix_len - 1 ) ) ) ; } } if ( u4_total_coeff < 4 ) { UWORD32 u4_max_ldz = ( 4 - u4_total_coeff ) ; FIND_ONE_IN_STREAM_LEN ( u4_total_zeroes , u4_bitstream_offset , pu4_bitstrm_buf , u4_max_ldz ) ; } else u4_total_zeroes = 0 ; { const UWORD8 * pu1_table_runbefore ; UWORD32 u4_run ; UWORD32 u4_scan_pos = ( u4_total_coeff + u4_total_zeroes - 1 ) ; UWORD32 u4_zeroes_left = u4_total_zeroes ; i = u4_total_coeff - 1 ; pu1_table_runbefore = ( UWORD8 * ) gau1_ih264d_table_run_before ; while ( u4_zeroes_left && i ) { UWORD32 u4_code ; NEXTBITS ( u4_code , u4_bitstream_offset , pu4_bitstrm_buf , 3 ) ; u4_code = pu1_table_runbefore [ u4_code + ( u4_zeroes_left << 3 ) ] ; u4_run = u4_code >> 2 ; FLUSHBITS ( u4_bitstream_offset , ( u4_code & 0x03 ) ) ; SET_BIT ( ps_tu_4x4 -> u2_sig_coeff_map , u4_scan_pos ) ; * pi2_coeff_data ++ = i2_level_arr [ i -- ] ; u4_zeroes_left -= u4_run ; u4_scan_pos -= ( u4_run + 1 ) ; } while ( i >= 0 ) { SET_BIT ( ps_tu_4x4 -> u2_sig_coeff_map , u4_scan_pos ) ; * pi2_coeff_data ++ = i2_level_arr [ i -- ] ; u4_scan_pos -- ; } } { WORD32 offset ; offset = ( UWORD8 * ) pi2_coeff_data - ( UWORD8 * ) ps_tu_4x4 ; offset = ALIGN4 ( offset ) ; ps_dec -> pv_parse_tu_coeff_data = ( void * ) ( ( UWORD8 * ) ps_dec -> pv_parse_tu_coeff_data + offset ) ; } ps_bitstrm -> u4_ofst = u4_bitstream_offset ; }",<S2SV_ModStart> 16 ; WORD16 ai2_level_arr [ 7 ] ; WORD16 * i2_level_arr = & ai2_level_arr [ 3 <S2SV_ModEnd> ] ; tu_sblk4x4_coeff_data_t,external@libavc/c57fc3703ae2e0d41b1f6580c50015937f2d23c1,CVE-2016-0840,https://android.googlesource.com/platform/external/libavc/+/c57fc3703ae2e0d41b1f6580c50015937f2d23c1,2016-04-18T00:59Z
,"CWE-000 int main ( int argc , char * argv [ ] ) { OM_uint32 minor , major ; gss_ctx_id_t context ; gss_union_ctx_id_desc uctx ; krb5_gss_ctx_id_rec kgctx ; krb5_key k1 , k2 ; krb5_keyblock kb1 , kb2 ; gss_buffer_desc in , out ; unsigned char k1buf [ 32 ] , k2buf [ 32 ] , outbuf [ 44 ] ; size_t i ; context = ( gss_ctx_id_t ) & uctx ; uctx . mech_type = & mech_krb5 ; uctx . internal_ctx_id = ( gss_ctx_id_t ) & kgctx ; kgctx . k5_context = NULL ; <S2SV_StartBug> kgctx . have_acceptor_subkey = 1 ; <S2SV_EndBug> kb1 . contents = k1buf ; kb2 . contents = k2buf ; for ( i = 0 ; i < sizeof ( tests ) / sizeof ( * tests ) ; i ++ ) { kb1 . enctype = tests [ i ] . enctype ; kb1 . length = fromhex ( tests [ i ] . key1 , k1buf ) ; check_k5err ( NULL , ""create_key"" , krb5_k_create_key ( NULL , & kb1 , & k1 ) ) ; kgctx . subkey = k1 ; kb2 . enctype = tests [ i ] . enctype ; kb2 . length = fromhex ( tests [ i ] . key2 , k2buf ) ; check_k5err ( NULL , ""create_key"" , krb5_k_create_key ( NULL , & kb2 , & k2 ) ) ; kgctx . acceptor_subkey = k2 ; in . length = 0 ; in . value = NULL ; major = gss_pseudo_random ( & minor , context , GSS_C_PRF_KEY_PARTIAL , & in , 44 , & out ) ; check_gsserr ( ""gss_pseudo_random"" , major , minor ) ; ( void ) fromhex ( tests [ i ] . out1 , outbuf ) ; assert ( out . length == 44 && memcmp ( out . value , outbuf , 44 ) == 0 ) ; ( void ) gss_release_buffer ( & minor , & out ) ; in . length = strlen ( inputstr ) ; in . value = ( char * ) inputstr ; major = gss_pseudo_random ( & minor , context , GSS_C_PRF_KEY_FULL , & in , 44 , & out ) ; check_gsserr ( ""gss_pseudo_random"" , major , minor ) ; ( void ) fromhex ( tests [ i ] . out2 , outbuf ) ; assert ( out . length == 44 && memcmp ( out . value , outbuf , 44 ) == 0 ) ; ( void ) gss_release_buffer ( & minor , & out ) ; major = gss_pseudo_random ( & minor , context , GSS_C_PRF_KEY_FULL , & in , 0 , & out ) ; check_gsserr ( ""gss_pseudo_random"" , major , minor ) ; assert ( out . length == 0 ) ; ( void ) gss_release_buffer ( & minor , & out ) ; krb5_k_free_key ( NULL , k1 ) ; krb5_k_free_key ( NULL , k2 ) ; } return 0 ; }",<S2SV_ModStart> ; kgctx . established = 1 ; kgctx .,krb5@krb5/82dc33da50338ac84c7b4102dc6513d897d0506a,CVE-2014-5352,https://github.com/krb5/krb5/commit/82dc33da50338ac84c7b4102dc6513d897d0506a,2015-02-19T11:59Z
CWE-119,"CWE-119 static int filter_frame ( AVFilterLink * inlink , AVFrame * in ) { DelogoContext * s = inlink -> dst -> priv ; AVFilterLink * outlink = inlink -> dst -> outputs [ 0 ] ; const AVPixFmtDescriptor * desc = av_pix_fmt_desc_get ( inlink -> format ) ; AVFrame * out ; int hsub0 = desc -> log2_chroma_w ; int vsub0 = desc -> log2_chroma_h ; int direct = 0 ; int plane ; AVRational sar ; if ( av_frame_is_writable ( in ) ) { direct = 1 ; out = in ; } else { out = ff_get_video_buffer ( outlink , outlink -> w , outlink -> h ) ; if ( ! out ) { av_frame_free ( & in ) ; return AVERROR ( ENOMEM ) ; } av_frame_copy_props ( out , in ) ; } sar = in -> sample_aspect_ratio ; if ( ! sar . num ) sar . num = sar . den = 1 ; <S2SV_StartBug> for ( plane = 0 ; plane < 4 && in -> data [ plane ] ; plane ++ ) { <S2SV_EndBug> int hsub = plane == 1 || plane == 2 ? hsub0 : 0 ; int vsub = plane == 1 || plane == 2 ? vsub0 : 0 ; apply_delogo ( out -> data [ plane ] , out -> linesize [ plane ] , in -> data [ plane ] , in -> linesize [ plane ] , FF_CEIL_RSHIFT ( inlink -> w , hsub ) , FF_CEIL_RSHIFT ( inlink -> h , vsub ) , sar , s -> x >> hsub , s -> y >> vsub , FF_CEIL_RSHIFT ( s -> w + ( s -> x & ( ( 1 << hsub ) - 1 ) ) , hsub ) , FF_CEIL_RSHIFT ( s -> h + ( s -> y & ( ( 1 << vsub ) - 1 ) ) , vsub ) , s -> band >> FFMIN ( hsub , vsub ) , s -> show , direct ) ; } if ( ! direct ) av_frame_free ( & in ) ; return ff_filter_frame ( outlink , out ) ; }",<S2SV_ModStart> in -> data [ plane ] && in -> linesize,FFmpeg@FFmpeg/e43a0a232dbf6d3c161823c2e07c52e76227a1bc,CVE-2013-4263,https://github.com/FFmpeg/FFmpeg/commit/e43a0a232dbf6d3c161823c2e07c52e76227a1bc,2013-11-23T17:55Z
CWE-119,"CWE-119 static vpx_codec_err_t vp8_set_decryptor ( vpx_codec_alg_priv_t * ctx , <S2SV_StartBug> int ctrl_id , <S2SV_EndBug> va_list args ) { <S2SV_StartBug> vp8_decrypt_init * init = va_arg ( args , vp8_decrypt_init * ) ; <S2SV_EndBug> if ( init ) { ctx -> decrypt_cb = init -> decrypt_cb ; ctx -> decrypt_state = init -> decrypt_state ; } else { ctx -> decrypt_cb = NULL ; ctx -> decrypt_state = NULL ; } return VPX_CODEC_OK ; }","<S2SV_ModStart> * ctx , <S2SV_ModEnd> va_list args ) <S2SV_ModStart> args ) { vpx_decrypt_init <S2SV_ModEnd> * init = <S2SV_ModStart> ( args , vpx_decrypt_init <S2SV_ModEnd> * ) ;",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
,"CWE-000 static int http_rxchunk ( struct http * hp ) { char * q ; int l , i ; l = hp -> prxbuf ; do ( void ) http_rxchar ( hp , 1 , 0 ) ; while ( hp -> rxbuf [ hp -> prxbuf - 1 ] != '\\n' ) ; vtc_dump ( hp -> vl , 4 , ""len"" , hp -> rxbuf + l , - 1 ) ; i = strtoul ( hp -> rxbuf + l , & q , 16 ) ; bprintf ( hp -> chunklen , ""%d"" , i ) ; if ( ( q == hp -> rxbuf + l ) || ( * q != '\\0' && ! vct_islws ( * q ) ) ) { vtc_log ( hp -> vl , hp -> fatal , ""chunked<S2SV_blank>fail<S2SV_blank>%02x<S2SV_blank>@<S2SV_blank>%d"" , * q , q - ( hp -> rxbuf + l ) ) ; } assert ( q != hp -> rxbuf + l ) ; assert ( * q == '\\0' || vct_islws ( * q ) ) ; hp -> prxbuf = l ; if ( i > 0 ) { ( void ) http_rxchar ( hp , i , 0 ) ; vtc_dump ( hp -> vl , 4 , ""chunk"" , hp -> rxbuf + l , i ) ; } l = hp -> prxbuf ; ( void ) http_rxchar ( hp , 2 , 0 ) ; <S2SV_StartBug> if ( ! vct_iscrlf ( hp -> rxbuf [ l ] ) ) <S2SV_EndBug> vtc_log ( hp -> vl , hp -> fatal , ""Wrong<S2SV_blank>chunk<S2SV_blank>tail[0]<S2SV_blank>=<S2SV_blank>%02x"" , hp -> rxbuf [ l ] & 0xff ) ; <S2SV_StartBug> if ( ! vct_iscrlf ( hp -> rxbuf [ l + 1 ] ) ) <S2SV_EndBug> vtc_log ( hp -> vl , hp -> fatal , ""Wrong<S2SV_blank>chunk<S2SV_blank>tail[1]<S2SV_blank>=<S2SV_blank>%02x"" , hp -> rxbuf [ l + 1 ] & 0xff ) ; hp -> prxbuf = l ; hp -> rxbuf [ l ] = '\\0' ; return ( i ) ; }",<S2SV_ModStart> ! vct_iscrlf ( & <S2SV_ModStart> ! vct_iscrlf ( &,varnish@Varnish-Cache/85e8468bec9416bd7e16b0d80cb820ecd2b330c3,CVE-2015-8852,https://github.com/varnish/Varnish-Cache/commit/85e8468bec9416bd7e16b0d80cb820ecd2b330c3,2016-04-25T14:59Z
,"CWE-000 static Curves16Data * CurvesAlloc ( cmsContext ContextID , int nCurves , int nElements , cmsToneCurve * * G ) { int i , j ; Curves16Data * c16 ; c16 = _cmsMallocZero ( ContextID , sizeof ( Curves16Data ) ) ; if ( c16 == NULL ) return NULL ; c16 -> nCurves = nCurves ; c16 -> nElements = nElements ; c16 -> Curves = _cmsCalloc ( ContextID , nCurves , sizeof ( cmsUInt16Number * ) ) ; if ( c16 -> Curves == NULL ) return NULL ; for ( i = 0 ; i < nCurves ; i ++ ) { <S2SV_StartBug> c16 -> Curves [ i ] = _cmsCalloc ( ContextID , nElements , sizeof ( cmsUInt16Number ) ) ; <S2SV_EndBug> if ( nElements == 256 ) { for ( j = 0 ; j < nElements ; j ++ ) { c16 -> Curves [ i ] [ j ] = cmsEvalToneCurve16 ( G [ i ] , FROM_8_TO_16 ( j ) ) ; } } else { for ( j = 0 ; j < nElements ; j ++ ) { c16 -> Curves [ i ] [ j ] = cmsEvalToneCurve16 ( G [ i ] , ( cmsUInt16Number ) j ) ; } } } return c16 ; }","<S2SV_ModStart> ) ) ; if ( c16 -> Curves [ i ] == NULL ) { for ( j = 0 ; j < i ; j ++ ) { _cmsFree ( ContextID , c16 -> Curves [ j ] ) ; } _cmsFree ( ContextID , c16 -> Curves ) ; _cmsFree ( ContextID , c16 ) ; return NULL ; }",mm2@Little-CMS/91c2db7f2559be504211b283bc3a2c631d6f06d9,CVE-2013-4160,https://github.com/mm2/Little-CMS/commit/91c2db7f2559be504211b283bc3a2c631d6f06d9,2014-01-21T18:55Z
CWE-20,"CWE-20 int bt_sock_stream_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; int err = 0 ; size_t target , copied = 0 ; long timeo ; if ( flags & MSG_OOB ) <S2SV_StartBug> return - EOPNOTSUPP ; <S2SV_EndBug> msg -> msg_namelen = 0 ; BT_DBG ( ""sk<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%zu"" , sk , size ) ; lock_sock ( sk ) ; target = sock_rcvlowat ( sk , flags & MSG_WAITALL , size ) ; timeo = sock_rcvtimeo ( sk , flags & MSG_DONTWAIT ) ; do { struct sk_buff * skb ; int chunk ; skb = skb_dequeue ( & sk -> sk_receive_queue ) ; if ( ! skb ) { if ( copied >= target ) break ; err = sock_error ( sk ) ; if ( err ) break ; if ( sk -> sk_shutdown & RCV_SHUTDOWN ) break ; err = - EAGAIN ; if ( ! timeo ) break ; timeo = bt_sock_data_wait ( sk , timeo ) ; if ( signal_pending ( current ) ) { err = sock_intr_errno ( timeo ) ; goto out ; } continue ; } chunk = min_t ( unsigned int , skb -> len , size ) ; if ( skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , chunk ) ) { skb_queue_head ( & sk -> sk_receive_queue , skb ) ; if ( ! copied ) copied = - EFAULT ; break ; } copied += chunk ; size -= chunk ; sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( ! ( flags & MSG_PEEK ) ) { int skb_len = skb_headlen ( skb ) ; if ( chunk <= skb_len ) { __skb_pull ( skb , chunk ) ; } else { struct sk_buff * frag ; __skb_pull ( skb , skb_len ) ; chunk -= skb_len ; skb_walk_frags ( skb , frag ) { if ( chunk <= frag -> len ) { skb -> len -= chunk ; skb -> data_len -= chunk ; __skb_pull ( frag , chunk ) ; break ; } else if ( frag -> len ) { chunk -= frag -> len ; skb -> len -= frag -> len ; skb -> data_len -= frag -> len ; __skb_pull ( frag , frag -> len ) ; } } } if ( skb -> len ) { skb_queue_head ( & sk -> sk_receive_queue , skb ) ; break ; } kfree_skb ( skb ) ; } else { skb_queue_head ( & sk -> sk_receive_queue , skb ) ; break ; } } while ( size ) ; out : release_sock ( sk ) ; return copied ? : err ; }",<S2SV_ModStart> return - EOPNOTSUPP <S2SV_ModEnd> ; BT_DBG (,torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7270,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z
CWE-119,"CWE-119 static inline void header_put_le_int ( SF_PRIVATE * psf , int x ) <S2SV_StartBug> { if ( psf -> headindex < SIGNED_SIZEOF ( psf -> header ) - 4 ) <S2SV_EndBug> <S2SV_StartBug> { psf -> header [ psf -> headindex ++ ] = x ; <S2SV_EndBug> <S2SV_StartBug> psf -> header [ psf -> headindex ++ ] = ( x >> 8 ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> header [ psf -> headindex ++ ] = ( x >> 16 ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> header [ psf -> headindex ++ ] = ( x >> 24 ) ; <S2SV_EndBug> <S2SV_StartBug> } ; <S2SV_EndBug> }",<S2SV_ModStart> x ) { <S2SV_ModEnd> psf -> header <S2SV_ModStart> psf -> header . ptr [ <S2SV_ModEnd> psf -> header <S2SV_ModStart> psf -> header . indx <S2SV_ModEnd> ++ ] = <S2SV_ModStart> psf -> header . ptr <S2SV_ModStart> [ psf -> header . indx <S2SV_ModEnd> ++ ] = <S2SV_ModStart> psf -> header . ptr <S2SV_ModStart> [ psf -> header . indx <S2SV_ModEnd> ++ ] = <S2SV_ModStart> psf -> header . ptr <S2SV_ModStart> [ psf -> header . indx <S2SV_ModEnd> ++ ] = <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>,erikd@libsndfile/708e996c87c5fae77b104ccfeb8f6db784c32074,CVE-2017-7586,https://github.com/erikd/libsndfile/commit/708e996c87c5fae77b104ccfeb8f6db784c32074,2017-04-07T20:59Z
CWE-119,"CWE-119 static vpx_codec_err_t vp8e_mr_alloc_mem ( const vpx_codec_enc_cfg_t * cfg , void * * mem_loc ) { vpx_codec_err_t res = 0 ; # if CONFIG_MULTI_RES_ENCODING LOWER_RES_FRAME_INFO * shared_mem_loc ; int mb_rows = ( ( cfg -> g_w + 15 ) >> 4 ) ; int mb_cols = ( ( cfg -> g_h + 15 ) >> 4 ) ; shared_mem_loc = calloc ( 1 , sizeof ( LOWER_RES_FRAME_INFO ) ) ; if ( ! shared_mem_loc ) { res = VPX_CODEC_MEM_ERROR ; } shared_mem_loc -> mb_info = calloc ( mb_rows * mb_cols , sizeof ( LOWER_RES_MB_INFO ) ) ; if ( ! ( shared_mem_loc -> mb_info ) ) { res = VPX_CODEC_MEM_ERROR ; } else { * mem_loc = ( void * ) shared_mem_loc ; res = VPX_CODEC_OK ; } <S2SV_StartBug> # endif <S2SV_EndBug> return res ; }",<S2SV_ModStart> ; } # else ( void ) cfg ; ( void ) mem_loc ; #,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-416,"CWE-416 static int snd_ctl_elem_add ( struct snd_ctl_file * file , struct snd_ctl_elem_info * info , int replace ) { struct snd_card * card = file -> card ; struct snd_kcontrol kctl , * _kctl ; unsigned int access ; long private_size ; struct user_element * ue ; int idx , err ; <S2SV_StartBug> if ( ! replace && card -> user_ctl_count >= MAX_USER_CONTROLS ) <S2SV_EndBug> <S2SV_StartBug> return - ENOMEM ; <S2SV_EndBug> if ( info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_READWRITE : ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_INACTIVE | SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE ) ) ; info -> id . numid = 0 ; memset ( & kctl , 0 , sizeof ( kctl ) ) ; down_write ( & card -> controls_rwsem ) ; _kctl = snd_ctl_find_id ( card , & info -> id ) ; err = 0 ; if ( _kctl ) { if ( replace ) err = snd_ctl_remove ( card , _kctl ) ; else err = - EBUSY ; } else { if ( replace ) err = - ENOENT ; } up_write ( & card -> controls_rwsem ) ; if ( err < 0 ) return err ; memcpy ( & kctl . id , & info -> id , sizeof ( info -> id ) ) ; kctl . count = info -> owner ? info -> owner : 1 ; access |= SNDRV_CTL_ELEM_ACCESS_USER ; if ( info -> type == SNDRV_CTL_ELEM_TYPE_ENUMERATED ) kctl . info = snd_ctl_elem_user_enum_info ; else kctl . info = snd_ctl_elem_user_info ; if ( access & SNDRV_CTL_ELEM_ACCESS_READ ) kctl . get = snd_ctl_elem_user_get ; if ( access & SNDRV_CTL_ELEM_ACCESS_WRITE ) kctl . put = snd_ctl_elem_user_put ; if ( access & SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE ) { kctl . tlv . c = snd_ctl_elem_user_tlv ; access |= SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK ; } switch ( info -> type ) { case SNDRV_CTL_ELEM_TYPE_BOOLEAN : case SNDRV_CTL_ELEM_TYPE_INTEGER : private_size = sizeof ( long ) ; if ( info -> count > 128 ) return - EINVAL ; break ; case SNDRV_CTL_ELEM_TYPE_INTEGER64 : private_size = sizeof ( long long ) ; if ( info -> count > 64 ) return - EINVAL ; break ; case SNDRV_CTL_ELEM_TYPE_ENUMERATED : private_size = sizeof ( unsigned int ) ; if ( info -> count > 128 || info -> value . enumerated . items == 0 ) return - EINVAL ; break ; case SNDRV_CTL_ELEM_TYPE_BYTES : private_size = sizeof ( unsigned char ) ; if ( info -> count > 512 ) return - EINVAL ; break ; case SNDRV_CTL_ELEM_TYPE_IEC958 : private_size = sizeof ( struct snd_aes_iec958 ) ; if ( info -> count != 1 ) return - EINVAL ; break ; default : return - EINVAL ; } private_size *= info -> count ; ue = kzalloc ( sizeof ( struct user_element ) + private_size , GFP_KERNEL ) ; if ( ue == NULL ) return - ENOMEM ; ue -> card = card ; ue -> info = * info ; ue -> info . access = 0 ; ue -> elem_data = ( char * ) ue + sizeof ( * ue ) ; ue -> elem_data_size = private_size ; if ( ue -> info . type == SNDRV_CTL_ELEM_TYPE_ENUMERATED ) { err = snd_ctl_elem_init_enum_names ( ue ) ; if ( err < 0 ) { kfree ( ue ) ; return err ; } } kctl . private_free = snd_ctl_elem_user_free ; _kctl = snd_ctl_new ( & kctl , access ) ; if ( _kctl == NULL ) { kfree ( ue -> priv_data ) ; kfree ( ue ) ; return - ENOMEM ; } _kctl -> private_data = ue ; for ( idx = 0 ; idx < _kctl -> count ; idx ++ ) _kctl -> vd [ idx ] . owner = file ; err = snd_ctl_add ( card , _kctl ) ; if ( err < 0 ) return err ; down_write ( & card -> controls_rwsem ) ; card -> user_ctl_count ++ ; up_write ( & card -> controls_rwsem ) ; return 0 ; }","<S2SV_ModStart> ; if ( info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_READWRITE : ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_INACTIVE | SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE ) ) ; info -> id . numid = 0 ; memset ( & kctl , 0 , sizeof ( kctl ) ) ; if ( replace ) { err = snd_ctl_remove_user_ctl ( file , & info -> id ) ; if ( err ) return err ; } if ( <S2SV_ModEnd> card -> user_ctl_count <S2SV_ModStart> return - ENOMEM <S2SV_ModEnd> ; memcpy (",torvalds@linux/82262a46627bebb0febcc26664746c25cef08563,CVE-2014-4654,https://github.com/torvalds/linux/commit/82262a46627bebb0febcc26664746c25cef08563,2014-07-03T04:22Z
CWE-476,"CWE-476 void formUpdateBuffer ( Anchor * a , Buffer * buf , FormItemList * form ) { Buffer save ; char * p ; int spos , epos , rows , c_rows , pos , col = 0 ; Line * l ; copyBuffer ( & save , buf ) ; gotoLine ( buf , a -> start . line ) ; switch ( form -> type ) { case FORM_TEXTAREA : case FORM_INPUT_TEXT : case FORM_INPUT_FILE : case FORM_INPUT_PASSWORD : case FORM_INPUT_CHECKBOX : case FORM_INPUT_RADIO : # ifdef MENU_SELECT case FORM_SELECT : # endif spos = a -> start . pos ; epos = a -> end . pos ; break ; default : spos = a -> start . pos + 1 ; epos = a -> end . pos - 1 ; } switch ( form -> type ) { case FORM_INPUT_CHECKBOX : case FORM_INPUT_RADIO : if ( buf -> currentLine == NULL || spos >= buf -> currentLine -> len || spos < 0 ) break ; if ( form -> checked ) buf -> currentLine -> lineBuf [ spos ] = '*' ; else buf -> currentLine -> lineBuf [ spos ] = '<S2SV_blank>' ; break ; case FORM_INPUT_TEXT : case FORM_INPUT_FILE : case FORM_INPUT_PASSWORD : case FORM_TEXTAREA : # ifdef MENU_SELECT case FORM_SELECT : if ( form -> type == FORM_SELECT ) { p = form -> label -> ptr ; updateSelectOption ( form , form -> select_option ) ; } else # endif { if ( ! form -> value ) break ; p = form -> value -> ptr ; } l = buf -> currentLine ; if ( ! l ) break ; if ( form -> type == FORM_TEXTAREA ) { int n = a -> y - buf -> currentLine -> linenumber ; if ( n > 0 ) for ( ; l && n ; l = l -> prev , n -- ) ; else if ( n < 0 ) for ( ; l && n ; l = l -> prev , n ++ ) ; if ( ! l ) break ; } rows = form -> rows ? form -> rows : 1 ; col = COLPOS ( l , a -> start . pos ) ; for ( c_rows = 0 ; c_rows < rows ; c_rows ++ , l = l -> next ) { <S2SV_StartBug> if ( rows > 1 ) { <S2SV_EndBug> pos = columnPos ( l , col ) ; a = retrieveAnchor ( buf -> formitem , l -> linenumber , pos ) ; if ( a == NULL ) break ; spos = a -> start . pos ; epos = a -> end . pos ; } if ( a -> start . line != a -> end . line || spos > epos || epos >= l -> len || spos < 0 || epos < 0 || COLPOS ( l , epos ) < col ) break ; pos = form_update_line ( l , & p , spos , epos , COLPOS ( l , epos ) - col , rows > 1 , form -> type == FORM_INPUT_PASSWORD ) ; if ( pos != epos ) { shiftAnchorPosition ( buf -> href , buf -> hmarklist , a -> start . line , spos , pos - epos ) ; shiftAnchorPosition ( buf -> name , buf -> hmarklist , a -> start . line , spos , pos - epos ) ; shiftAnchorPosition ( buf -> img , buf -> hmarklist , a -> start . line , spos , pos - epos ) ; shiftAnchorPosition ( buf -> formitem , buf -> hmarklist , a -> start . line , spos , pos - epos ) ; } } break ; } copyBuffer ( buf , & save ) ; arrangeLine ( buf ) ; }",<S2SV_ModStart> { if ( l == NULL ) break ; if (,tats@w3m/7fdc83b0364005a0b5ed869230dd81752ba022e8,CVE-2018-6197,https://github.com/tats/w3m/commit/7fdc83b0364005a0b5ed869230dd81752ba022e8,2018-01-25T03:29Z
CWE-362,"CWE-362 static int <S2SV_StartBug> mptctl_readtest ( unsigned long arg ) <S2SV_EndBug> { struct mpt_ioctl_test __user * uarg = ( void __user * ) arg ; struct mpt_ioctl_test karg ; <S2SV_StartBug> MPT_ADAPTER * ioc ; <S2SV_EndBug> int iocnum ; if ( copy_from_user ( & karg , uarg , sizeof ( struct mpt_ioctl_test ) ) ) { printk ( KERN_ERR MYNAM ""%s@%d::mptctl_readtest<S2SV_blank>-<S2SV_blank>"" ""Unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>in<S2SV_blank>mpt_ioctl_test<S2SV_blank>struct<S2SV_blank>@<S2SV_blank>%p\\n"" , __FILE__ , __LINE__ , uarg ) ; return - EFAULT ; } <S2SV_StartBug> if ( ( ( iocnum = mpt_verify_adapter ( karg . hdr . iocnum , & ioc ) ) < 0 ) || <S2SV_EndBug> ( ioc == NULL ) ) { printk ( KERN_DEBUG MYNAM ""%s::mptctl_readtest()<S2SV_blank>@%d<S2SV_blank>-<S2SV_blank>ioc%d<S2SV_blank>not<S2SV_blank>found!\\n"" , __FILE__ , __LINE__ , iocnum ) ; return - ENODEV ; } dctlprintk ( ioc , printk ( MYIOC_s_DEBUG_FMT ""mptctl_readtest<S2SV_blank>called.\\n"" , ioc -> name ) ) ; # ifdef MFCNT karg . chip_type = ioc -> mfcnt ; # else karg . chip_type = ioc -> pcidev -> device ; # endif strncpy ( karg . name , ioc -> name , MPT_MAX_NAME ) ; karg . name [ MPT_MAX_NAME - 1 ] = '\\0' ; strncpy ( karg . product , ioc -> prod_name , MPT_PRODUCT_LENGTH ) ; karg . product [ MPT_PRODUCT_LENGTH - 1 ] = '\\0' ; if ( copy_to_user ( ( char __user * ) arg , & karg , sizeof ( struct mpt_ioctl_test ) ) ) { printk ( MYIOC_s_ERR_FMT ""%s@%d::mptctl_readtest<S2SV_blank>-<S2SV_blank>"" ""Unable<S2SV_blank>to<S2SV_blank>write<S2SV_blank>out<S2SV_blank>mpt_ioctl_test<S2SV_blank>struct<S2SV_blank>@<S2SV_blank>%p\\n"" , ioc -> name , __FILE__ , __LINE__ , uarg ) ; return - EFAULT ; } return 0 ; }","<S2SV_ModStart> int mptctl_readtest ( MPT_ADAPTER * ioc , <S2SV_ModStart> mpt_ioctl_test karg ; <S2SV_ModEnd> if ( copy_from_user <S2SV_ModStart> EFAULT ; } <S2SV_ModEnd> dctlprintk ( ioc",torvalds@linux/28d76df18f0ad5bcf5fa48510b225f0ed262a99b,CVE-2020-12652,https://github.com/torvalds/linux/commit/28d76df18f0ad5bcf5fa48510b225f0ed262a99b,2020-05-05T05:15Z
CWE-119,"CWE-119 static int check_dual_ref_flags ( VP9_COMP * cpi ) { const int ref_flags = cpi -> ref_frame_flags ; <S2SV_StartBug> if ( vp9_segfeature_active ( & cpi -> common . seg , 1 , SEG_LVL_REF_FRAME ) ) { <S2SV_EndBug> return 0 ; } else { return ( ! ! ( ref_flags & VP9_GOLD_FLAG ) + ! ! ( ref_flags & VP9_LAST_FLAG ) + ! ! ( ref_flags & VP9_ALT_FLAG ) ) >= 2 ; } }",<S2SV_ModStart> ; if ( segfeature_active <S2SV_ModEnd> ( & cpi,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-787,"CWE-787 static int reverseSamplesBytes ( uint16 spp , uint16 bps , uint32 width , uint8 * src , uint8 * dst ) { int i ; uint32 col , bytes_per_pixel , col_offset ; uint8 bytebuff1 ; unsigned char swapbuff [ 32 ] ; if ( ( src == NULL ) || ( dst == NULL ) ) { TIFFError ( ""reverseSamplesBytes"" , ""Invalid<S2SV_blank>input<S2SV_blank>or<S2SV_blank>output<S2SV_blank>buffer"" ) ; return ( 1 ) ; } bytes_per_pixel = ( ( bps * spp ) + 7 ) / 8 ; <S2SV_StartBug> switch ( bps / 8 ) <S2SV_EndBug> { case 8 : case 4 : case 3 : case 2 : for ( col = 0 ; col < ( width / 2 ) ; col ++ ) { col_offset = col * bytes_per_pixel ; _TIFFmemcpy ( swapbuff , src + col_offset , bytes_per_pixel ) ; _TIFFmemcpy ( src + col_offset , dst - col_offset - bytes_per_pixel , bytes_per_pixel ) ; _TIFFmemcpy ( dst - col_offset - bytes_per_pixel , swapbuff , bytes_per_pixel ) ; } break ; case 1 : for ( col = 0 ; col < ( width / 2 ) ; col ++ ) { for ( i = 0 ; i < spp ; i ++ ) { bytebuff1 = * src ; * src ++ = * ( dst - spp + i ) ; * ( dst - spp + i ) = bytebuff1 ; } dst -= spp ; } break ; default : TIFFError ( ""reverseSamplesBytes"" , ""Unsupported<S2SV_blank>bit<S2SV_blank>depth<S2SV_blank>%d"" , bps ) ; return ( 1 ) ; } return ( 0 ) ; }","<S2SV_ModStart> / 8 ; if ( bytes_per_pixel > sizeof ( swapbuff ) ) { TIFFError ( ""reverseSamplesBytes"" , ""bytes_per_pixel<S2SV_blank>too<S2SV_blank>large"" ) ; return ( 1 ) ; }",vadz@libtiff/83a4b92815ea04969d494416eaae3d4c6b338e4a,CVE-2016-9533,https://github.com/vadz/libtiff/commit/83a4b92815ea04969d494416eaae3d4c6b338e4a#diff-bdc795f6afeb9558c1012b3cfae729ef,2016-11-22T19:59Z
CWE-264,"CWE-264 int _mkp_stage_30 ( struct plugin * p , struct client_session * cs , struct session_request * sr ) { mk_ptr_t referer ; ( void ) p ; ( void ) cs ; PLUGIN_TRACE ( ""[FD<S2SV_blank>%i]<S2SV_blank>Mandril<S2SV_blank>validating<S2SV_blank>URL"" , cs -> socket ) ; <S2SV_StartBug> if ( mk_security_check_url ( sr -> uri ) < 0 ) { <S2SV_EndBug> PLUGIN_TRACE ( ""[FD<S2SV_blank>%i]<S2SV_blank>Close<S2SV_blank>connection,<S2SV_blank>blocked<S2SV_blank>URL"" , cs -> socket ) ; mk_api -> header_set_http_status ( sr , MK_CLIENT_FORBIDDEN ) ; return MK_PLUGIN_RET_CLOSE_CONX ; } PLUGIN_TRACE ( ""[FD<S2SV_blank>%d]<S2SV_blank>Mandril<S2SV_blank>validating<S2SV_blank>hotlinking"" , cs -> socket ) ; referer = mk_api -> header_get ( & sr -> headers_toc , ""Referer"" , strlen ( ""Referer"" ) ) ; if ( mk_security_check_hotlink ( sr -> uri_processed , sr -> host , referer ) < 0 ) { PLUGIN_TRACE ( ""[FD<S2SV_blank>%i]<S2SV_blank>Close<S2SV_blank>connection,<S2SV_blank>deny<S2SV_blank>hotlinking."" , cs -> socket ) ; mk_api -> header_set_http_status ( sr , MK_CLIENT_FORBIDDEN ) ; return MK_PLUGIN_RET_CLOSE_CONX ; } return MK_PLUGIN_RET_NOT_ME ; }",<S2SV_ModStart> ( sr -> uri_processed <S2SV_ModEnd> ) < 0,monkey@monkey/15f72c1ee5e0afad20232bdf0fcecab8d62a5d89,CVE-2013-2182,https://github.com/monkey/monkey/commit/15f72c1ee5e0afad20232bdf0fcecab8d62a5d89,2014-06-13T14:55Z
,"CWE-000 OM_uint32 gss_krb5int_export_lucid_sec_context ( OM_uint32 * minor_status , const gss_ctx_id_t context_handle , const gss_OID desired_object , gss_buffer_set_t * data_set ) { krb5_error_code kret = 0 ; OM_uint32 retval ; krb5_gss_ctx_id_t ctx = ( krb5_gss_ctx_id_t ) context_handle ; void * lctx = NULL ; int version = 0 ; gss_buffer_desc rep ; retval = GSS_S_FAILURE ; * minor_status = 0 ; * data_set = GSS_C_NO_BUFFER_SET ; <S2SV_StartBug> retval = generic_gss_oid_decompose ( minor_status , <S2SV_EndBug> GSS_KRB5_EXPORT_LUCID_SEC_CONTEXT_OID , GSS_KRB5_EXPORT_LUCID_SEC_CONTEXT_OID_LENGTH , desired_object , & version ) ; if ( GSS_ERROR ( retval ) ) return retval ; switch ( version ) { case 1 : kret = make_external_lucid_ctx_v1 ( ( krb5_pointer ) ctx , version , & lctx ) ; break ; default : kret = ( OM_uint32 ) KG_LUCID_VERSION ; break ; } if ( kret ) goto error_out ; rep . value = & lctx ; rep . length = sizeof ( lctx ) ; retval = generic_gss_add_buffer_set_member ( minor_status , & rep , data_set ) ; if ( GSS_ERROR ( retval ) ) goto error_out ; error_out : if ( * minor_status == 0 ) * minor_status = ( OM_uint32 ) kret ; return ( retval ) ; }",<S2SV_ModStart> = GSS_C_NO_BUFFER_SET ; if ( ctx -> terminated || ! ctx -> established ) { * minor_status = KG_CTX_INCOMPLETE ; return GSS_S_NO_CONTEXT ; },krb5@krb5/82dc33da50338ac84c7b4102dc6513d897d0506a,CVE-2014-5352,https://github.com/krb5/krb5/commit/82dc33da50338ac84c7b4102dc6513d897d0506a,2015-02-19T11:59Z
CWE-264,CWE-264 <S2SV_StartBug> static unsigned int stack_maxrandom_size ( void ) <S2SV_EndBug> { <S2SV_StartBug> unsigned int max = 0 ; <S2SV_EndBug> if ( ( current -> flags & PF_RANDOMIZE ) && ! ( current -> personality & ADDR_NO_RANDOMIZE ) ) { <S2SV_StartBug> max = ( ( - 1U ) & STACK_RND_MASK ) << PAGE_SHIFT ; <S2SV_EndBug> } return max ; },<S2SV_ModStart> <S2SV_null> static unsigned long <S2SV_ModEnd> stack_maxrandom_size ( void <S2SV_ModStart> ) { unsigned long <S2SV_ModEnd> max = 0 <S2SV_ModStart> ( ( - 1UL <S2SV_ModEnd> ) & STACK_RND_MASK,torvalds@linux/4e7c22d447bb6d7e37bfe39ff658486ae78e8d77,CVE-2015-1593,https://github.com/torvalds/linux/commit/4e7c22d447bb6d7e37bfe39ff658486ae78e8d77,2015-03-16T10:59Z
CWE-264,"CWE-264 static void chase_port ( struct edgeport_port * port , unsigned long timeout , int flush ) { int baud_rate ; struct tty_struct * tty = tty_port_tty_get ( & port -> port -> port ) ; struct usb_serial * serial = port -> port -> serial ; wait_queue_t wait ; <S2SV_StartBug> unsigned long flags ; <S2SV_EndBug> if ( ! timeout ) timeout = ( HZ * EDGE_CLOSING_WAIT ) / 100 ; spin_lock_irqsave ( & port -> ep_lock , flags ) ; init_waitqueue_entry ( & wait , current ) ; add_wait_queue ( & tty -> write_wait , & wait ) ; for ( ; ; ) { set_current_state ( TASK_INTERRUPTIBLE ) ; if ( kfifo_len ( & port -> write_fifo ) == 0 || timeout == 0 || signal_pending ( current ) || serial -> disconnected ) break ; spin_unlock_irqrestore ( & port -> ep_lock , flags ) ; timeout = schedule_timeout ( timeout ) ; spin_lock_irqsave ( & port -> ep_lock , flags ) ; } set_current_state ( TASK_RUNNING ) ; remove_wait_queue ( & tty -> write_wait , & wait ) ; if ( flush ) kfifo_reset_out ( & port -> write_fifo ) ; spin_unlock_irqrestore ( & port -> ep_lock , flags ) ; tty_kref_put ( tty ) ; timeout += jiffies ; while ( ( long ) ( jiffies - timeout ) < 0 && ! signal_pending ( current ) && ! serial -> disconnected ) { if ( ! tx_active ( port ) ) break ; msleep ( 10 ) ; } if ( serial -> disconnected ) return ; baud_rate = port -> baud_rate ; if ( baud_rate == 0 ) baud_rate = 50 ; msleep ( max ( 1 , DIV_ROUND_UP ( 10000 , baud_rate ) ) ) ; }",<S2SV_ModStart> unsigned long flags ; if ( ! tty ) return,torvalds@linux/1ee0a224bc9aad1de496c795f96bc6ba2c394811,CVE-2013-1774,https://github.com/torvalds/linux/commit/1ee0a224bc9aad1de496c795f96bc6ba2c394811,2013-02-28T19:55Z
CWE-264,"CWE-264 static inline int check_sticky ( struct inode * dir , struct inode * inode ) { kuid_t fsuid = current_fsuid ( ) ; if ( ! ( dir -> i_mode & S_ISVTX ) ) return 0 ; if ( uid_eq ( inode -> i_uid , fsuid ) ) return 0 ; if ( uid_eq ( dir -> i_uid , fsuid ) ) return 0 ; <S2SV_StartBug> return ! inode_capable ( inode , CAP_FOWNER ) ; <S2SV_EndBug> }","<S2SV_ModStart> ; return ! capable_wrt_inode_uidgid <S2SV_ModEnd> ( inode ,",torvalds@linux/23adbe12ef7d3d4195e80800ab36b37bee28cd03,CVE-2014-4014,https://github.com/torvalds/linux/commit/23adbe12ef7d3d4195e80800ab36b37bee28cd03,2014-06-23T11:21Z
CWE-119,"CWE-119 <S2SV_StartBug> void usage_exit ( ) { <S2SV_EndBug> fprintf ( stderr , ""Usage:<S2SV_blank>%s<S2SV_blank><codec><S2SV_blank><width><S2SV_blank><height><S2SV_blank><infile><S2SV_blank><outfile>\\n"" , exec_name ) ; exit ( EXIT_FAILURE ) ; }",<S2SV_ModStart> void usage_exit ( void,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-189,"CWE-189 void dwc3_gadget_giveback ( struct dwc3_ep * dep , struct dwc3_request * req , int status ) { struct dwc3 * dwc = dep -> dwc ; <S2SV_StartBug> req -> started = false ; <S2SV_EndBug> list_del ( & req -> list ) ; req -> remaining = 0 ; if ( req -> request . status == - EINPROGRESS ) req -> request . status = status ; if ( req -> trb ) usb_gadget_unmap_request_by_dev ( dwc -> sysdev , & req -> request , req -> direction ) ; req -> trb = NULL ; trace_dwc3_gadget_giveback ( req ) ; spin_unlock ( & dwc -> lock ) ; usb_gadget_giveback_request ( & dep -> endpoint , & req -> request ) ; spin_lock ( & dwc -> lock ) ; <S2SV_StartBug> if ( dep -> number > 1 ) <S2SV_EndBug> pm_runtime_put ( dwc -> dev ) ; }","<S2SV_ModStart> -> dwc ; dwc3_gadget_del_and_unmap_request ( dep , req , status <S2SV_ModEnd> ) ; spin_unlock <S2SV_ModStart> lock ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>",torvalds@linux/c91815b596245fd7da349ecc43c8def670d2269e,CVE-2019-14763,https://github.com/torvalds/linux/commit/c91815b596245fd7da349ecc43c8def670d2269e,2019-08-07T22:15Z
CWE-119,"CWE-119 <S2SV_StartBug> void vp9_iht16x16_add ( TX_TYPE tx_type , const int16_t * input , uint8_t * dest , <S2SV_EndBug> int stride , int eob ) { if ( tx_type == DCT_DCT ) { vp9_idct16x16_add ( input , dest , stride , eob ) ; } else { vp9_iht16x16_256_add ( input , dest , stride , tx_type ) ; } }","<S2SV_ModStart> tx_type , const tran_low_t <S2SV_ModEnd> * input ,",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-20,"CWE-20 static Image * ReadDDSImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; MagickBooleanType status , cubemap = MagickFalse , volume = MagickFalse , matte ; CompressionType compression ; DDSInfo dds_info ; DDSDecoder * decoder ; size_t n , num_images ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } if ( ReadDDSInfo ( image , & dds_info ) != MagickTrue ) { ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP ) cubemap = MagickTrue ; if ( dds_info . ddscaps2 & DDSCAPS2_VOLUME && dds_info . depth > 0 ) volume = MagickTrue ; ( void ) SeekBlob ( image , 128 , SEEK_SET ) ; if ( dds_info . pixelformat . flags & DDPF_RGB ) { compression = NoCompression ; if ( dds_info . pixelformat . flags & DDPF_ALPHAPIXELS ) { matte = MagickTrue ; decoder = ReadUncompressedRGBA ; } else { matte = MagickTrue ; decoder = ReadUncompressedRGB ; } } else if ( dds_info . pixelformat . flags & DDPF_LUMINANCE ) { compression = NoCompression ; if ( dds_info . pixelformat . flags & DDPF_ALPHAPIXELS ) { ThrowReaderException ( CorruptImageError , ""ImageTypeNotSupported"" ) ; } else { matte = MagickFalse ; decoder = ReadUncompressedRGB ; } } else if ( dds_info . pixelformat . flags & DDPF_FOURCC ) { switch ( dds_info . pixelformat . fourcc ) { case FOURCC_DXT1 : { matte = MagickFalse ; compression = DXT1Compression ; decoder = ReadDXT1 ; break ; } case FOURCC_DXT3 : { matte = MagickTrue ; compression = DXT3Compression ; decoder = ReadDXT3 ; break ; } case FOURCC_DXT5 : { matte = MagickTrue ; compression = DXT5Compression ; decoder = ReadDXT5 ; break ; } default : { ThrowReaderException ( CorruptImageError , ""ImageTypeNotSupported"" ) ; } } } else { ThrowReaderException ( CorruptImageError , ""ImageTypeNotSupported"" ) ; } num_images = 1 ; if ( cubemap ) { num_images = 0 ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEX ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEX ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEY ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEY ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEZ ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEZ ) num_images ++ ; } if ( volume ) num_images = dds_info . depth ; for ( n = 0 ; n < num_images ; n ++ ) { if ( n != 0 ) { <S2SV_StartBug> AcquireNextImage ( image_info , image ) ; <S2SV_EndBug> if ( GetNextImageInList ( image ) == ( Image * ) NULL ) return ( DestroyImageList ( image ) ) ; image = SyncNextImageInList ( image ) ; } image -> matte = matte ; image -> compression = compression ; image -> columns = dds_info . width ; image -> rows = dds_info . height ; image -> storage_class = DirectClass ; image -> endian = LSBEndian ; image -> depth = 8 ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } if ( ( decoder ) ( image , & dds_info , exception ) != MagickTrue ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } } if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }","<S2SV_ModStart> 0 ) { if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;",ImageMagick@ImageMagick/504ada82b6fa38a30c846c1c29116af7290decb2,CVE-2014-9907,https://github.com/ImageMagick/ImageMagick/commit/504ada82b6fa38a30c846c1c29116af7290decb2,2017-04-19T14:59Z
CWE-399,"CWE-399 static int ceph_x_proc_ticket_reply ( struct ceph_auth_client * ac , struct ceph_crypto_key * secret , void * buf , void * end ) { void * p = buf ; <S2SV_StartBug> char * dbuf ; <S2SV_EndBug> char * ticket_buf ; u8 reply_struct_v ; u32 num ; <S2SV_StartBug> int ret ; <S2SV_EndBug> dbuf = kmalloc ( TEMP_TICKET_BUF_LEN , GFP_NOFS ) ; if ( ! dbuf ) return - ENOMEM ; ret = - ENOMEM ; ticket_buf = kmalloc ( TEMP_TICKET_BUF_LEN , GFP_NOFS ) ; if ( ! ticket_buf ) goto out_dbuf ; ceph_decode_8_safe ( & p , end , reply_struct_v , bad ) ; if ( reply_struct_v != 1 ) return - EINVAL ; ceph_decode_32_safe ( & p , end , num , bad ) ; dout ( ""%d<S2SV_blank>tickets\\n"" , num ) ; while ( num -- ) { <S2SV_StartBug> ret = process_one_ticket ( ac , secret , & p , end , <S2SV_EndBug> dbuf , ticket_buf ) ; if ( ret ) <S2SV_StartBug> goto out ; <S2SV_EndBug> } ret = 0 ; out : kfree ( ticket_buf ) ; out_dbuf : kfree ( dbuf ) ; return ret ; bad : <S2SV_StartBug> ret = - EINVAL ; <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> }","<S2SV_ModStart> = buf ; <S2SV_ModEnd> u8 reply_struct_v ; <S2SV_ModStart> ; int ret <S2SV_ModEnd> ; ceph_decode_8_safe ( <S2SV_ModStart> p , end <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( ret ) return ret ; } return 0 <S2SV_ModEnd> ; bad : <S2SV_ModStart> ; bad : return <S2SV_ModEnd> - EINVAL ; <S2SV_ModStart> - EINVAL ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>",torvalds@linux/c27a3e4d667fdcad3db7b104f75659478e0c68d8,CVE-2014-6417,https://github.com/torvalds/linux/commit/c27a3e4d667fdcad3db7b104f75659478e0c68d8,2014-09-28T10:55Z
CWE-189,"CWE-189 int au1100fb_fb_mmap ( struct fb_info * fbi , struct vm_area_struct * vma ) { struct au1100fb_device * fbdev ; <S2SV_StartBug> unsigned int len ; <S2SV_EndBug> unsigned long start = 0 , off ; <S2SV_StartBug> fbdev = to_au1100fb_device ( fbi ) ; <S2SV_EndBug> if ( vma -> vm_pgoff > ( ~ 0UL >> PAGE_SHIFT ) ) { return - EINVAL ; } start = fbdev -> fb_phys & PAGE_MASK ; len = PAGE_ALIGN ( ( start & ~ PAGE_MASK ) + fbdev -> fb_len ) ; off = vma -> vm_pgoff << PAGE_SHIFT ; if ( ( vma -> vm_end - vma -> vm_start + off ) > len ) { return - EINVAL ; } off += start ; vma -> vm_pgoff = off >> PAGE_SHIFT ; vma -> vm_page_prot = pgprot_noncached ( vma -> vm_page_prot ) ; pgprot_val ( vma -> vm_page_prot ) |= ( 6 << 9 ) ; <S2SV_StartBug> if ( io_remap_pfn_range ( vma , vma -> vm_start , off >> PAGE_SHIFT , <S2SV_EndBug> vma -> vm_end - vma -> vm_start , vma -> vm_page_prot ) ) { return - EAGAIN ; } return 0 ; }","<S2SV_ModStart> * fbdev ; <S2SV_ModEnd> fbdev = to_au1100fb_device <S2SV_ModStart> ( fbi ) <S2SV_ModEnd> ; vma -> <S2SV_ModStart> 9 ) ; return vm_iomap_memory <S2SV_ModEnd> ( vma , <S2SV_ModStart> ( vma , fbdev -> fb_phys , fbdev -> fb_len ) <S2SV_ModEnd> ; } <S2SV_null>",torvalds@linux/7314e613d5ff9f0934f7a0f74ed7973b903315d1,CVE-2013-4511,https://github.com/torvalds/linux/commit/7314e613d5ff9f0934f7a0f74ed7973b903315d1,2013-11-12T14:35Z
CWE-284,"CWE-284 static int http_connect ( http_subtransport * t ) { int error ; char * proxy_url ; if ( t -> connected && http_should_keep_alive ( & t -> parser ) && t -> parse_finished ) return 0 ; if ( t -> io ) { git_stream_close ( t -> io ) ; git_stream_free ( t -> io ) ; t -> io = NULL ; t -> connected = 0 ; } if ( t -> connection_data . use_ssl ) { error = git_tls_stream_new ( & t -> io , t -> connection_data . host , t -> connection_data . port ) ; } else { # ifdef GIT_CURL error = git_curl_stream_new ( & t -> io , t -> connection_data . host , t -> connection_data . port ) ; # else error = git_socket_stream_new ( & t -> io , t -> connection_data . host , t -> connection_data . port ) ; # endif } if ( error < 0 ) return error ; GITERR_CHECK_VERSION ( t -> io , GIT_STREAM_VERSION , ""git_stream"" ) ; if ( git_stream_supports_proxy ( t -> io ) && ! git_remote__get_http_proxy ( t -> owner -> owner , ! ! t -> connection_data . use_ssl , & proxy_url ) ) { error = git_stream_set_proxy ( t -> io , proxy_url ) ; git__free ( proxy_url ) ; if ( error < 0 ) return error ; } error = git_stream_connect ( t -> io ) ; # if defined ( GIT_OPENSSL ) || defined ( GIT_SECURE_TRANSPORT ) || defined ( GIT_CURL ) if ( ( ! error || error == GIT_ECERTIFICATE ) && t -> owner -> certificate_check_cb != NULL && git_stream_is_encrypted ( t -> io ) ) { git_cert * cert ; <S2SV_StartBug> int is_valid ; <S2SV_EndBug> if ( ( error = git_stream_certificate ( & cert , t -> io ) ) < 0 ) return error ; <S2SV_StartBug> giterr_clear ( ) ; <S2SV_EndBug> is_valid = error != GIT_ECERTIFICATE ; error = t -> owner -> certificate_check_cb ( cert , is_valid , t -> connection_data . host , t -> owner -> message_cb_payload ) ; if ( error < 0 ) { if ( ! giterr_last ( ) ) giterr_set ( GITERR_NET , ""user<S2SV_blank>cancelled<S2SV_blank>certificate<S2SV_blank>check"" ) ; return error ; } } # endif if ( error < 0 ) return error ; t -> connected = 1 ; return 0 ; }",<S2SV_ModStart> ; int is_valid = ( error == GIT_OK ) <S2SV_ModStart> giterr_clear ( ) <S2SV_ModEnd> ; error =,libgit2@libgit2/b5c6a1b407b7f8b952bded2789593b68b1876211,CVE-2016-10130,https://github.com/libgit2/libgit2/commit/b5c6a1b407b7f8b952bded2789593b68b1876211,2017-03-24T15:59Z
CWE-190,"CWE-190 static int futex_requeue ( u32 __user * uaddr1 , unsigned int flags , u32 __user * uaddr2 , int nr_wake , int nr_requeue , u32 * cmpval , int requeue_pi ) { union futex_key key1 = FUTEX_KEY_INIT , key2 = FUTEX_KEY_INIT ; int drop_count = 0 , task_count = 0 , ret ; struct futex_pi_state * pi_state = NULL ; struct futex_hash_bucket * hb1 , * hb2 ; struct futex_q * this , * next ; <S2SV_StartBug> DEFINE_WAKE_Q ( wake_q ) ; <S2SV_EndBug> if ( ! IS_ENABLED ( CONFIG_FUTEX_PI ) && requeue_pi ) return - ENOSYS ; if ( requeue_pi ) { if ( uaddr1 == uaddr2 ) return - EINVAL ; if ( refill_pi_state_cache ( ) ) return - ENOMEM ; if ( nr_wake != 1 ) return - EINVAL ; } retry : ret = get_futex_key ( uaddr1 , flags & FLAGS_SHARED , & key1 , VERIFY_READ ) ; if ( unlikely ( ret != 0 ) ) goto out ; ret = get_futex_key ( uaddr2 , flags & FLAGS_SHARED , & key2 , requeue_pi ? VERIFY_WRITE : VERIFY_READ ) ; if ( unlikely ( ret != 0 ) ) goto out_put_key1 ; if ( requeue_pi && match_futex ( & key1 , & key2 ) ) { ret = - EINVAL ; goto out_put_keys ; } hb1 = hash_futex ( & key1 ) ; hb2 = hash_futex ( & key2 ) ; retry_private : hb_waiters_inc ( hb2 ) ; double_lock_hb ( hb1 , hb2 ) ; if ( likely ( cmpval != NULL ) ) { u32 curval ; ret = get_futex_value_locked ( & curval , uaddr1 ) ; if ( unlikely ( ret ) ) { double_unlock_hb ( hb1 , hb2 ) ; hb_waiters_dec ( hb2 ) ; ret = get_user ( curval , uaddr1 ) ; if ( ret ) goto out_put_keys ; if ( ! ( flags & FLAGS_SHARED ) ) goto retry_private ; put_futex_key ( & key2 ) ; put_futex_key ( & key1 ) ; goto retry ; } if ( curval != * cmpval ) { ret = - EAGAIN ; goto out_unlock ; } } if ( requeue_pi && ( task_count - nr_wake < nr_requeue ) ) { ret = futex_proxy_trylock_atomic ( uaddr2 , hb1 , hb2 , & key1 , & key2 , & pi_state , nr_requeue ) ; if ( ret > 0 ) { WARN_ON ( pi_state ) ; drop_count ++ ; task_count ++ ; ret = lookup_pi_state ( uaddr2 , ret , hb2 , & key2 , & pi_state ) ; } switch ( ret ) { case 0 : break ; case - EFAULT : double_unlock_hb ( hb1 , hb2 ) ; hb_waiters_dec ( hb2 ) ; put_futex_key ( & key2 ) ; put_futex_key ( & key1 ) ; ret = fault_in_user_writeable ( uaddr2 ) ; if ( ! ret ) goto retry ; goto out ; case - EAGAIN : double_unlock_hb ( hb1 , hb2 ) ; hb_waiters_dec ( hb2 ) ; put_futex_key ( & key2 ) ; put_futex_key ( & key1 ) ; cond_resched ( ) ; goto retry ; default : goto out_unlock ; } } plist_for_each_entry_safe ( this , next , & hb1 -> chain , list ) { if ( task_count - nr_wake >= nr_requeue ) break ; if ( ! match_futex ( & this -> key , & key1 ) ) continue ; if ( ( requeue_pi && ! this -> rt_waiter ) || ( ! requeue_pi && this -> rt_waiter ) || this -> pi_state ) { ret = - EINVAL ; break ; } if ( ++ task_count <= nr_wake && ! requeue_pi ) { mark_wake_futex ( & wake_q , this ) ; continue ; } if ( requeue_pi && ! match_futex ( this -> requeue_pi_key , & key2 ) ) { ret = - EINVAL ; break ; } if ( requeue_pi ) { get_pi_state ( pi_state ) ; this -> pi_state = pi_state ; ret = rt_mutex_start_proxy_lock ( & pi_state -> pi_mutex , this -> rt_waiter , this -> task ) ; if ( ret == 1 ) { requeue_pi_wake_futex ( this , & key2 , hb2 ) ; drop_count ++ ; continue ; } else if ( ret ) { this -> pi_state = NULL ; put_pi_state ( pi_state ) ; break ; } } requeue_futex ( this , hb1 , hb2 , & key2 ) ; drop_count ++ ; } put_pi_state ( pi_state ) ; out_unlock : double_unlock_hb ( hb1 , hb2 ) ; wake_up_q ( & wake_q ) ; hb_waiters_dec ( hb2 ) ; while ( -- drop_count >= 0 ) drop_futex_key_refs ( & key1 ) ; out_put_keys : put_futex_key ( & key2 ) ; out_put_key1 : put_futex_key ( & key1 ) ; out : return ret ? ret : task_count ; }",<S2SV_ModStart> ( wake_q ) ; if ( nr_wake < 0 || nr_requeue < 0 ) return - EINVAL,torvalds@linux/fbe0e839d1e22d88810f3ee3e2f1479be4c0aa4a,CVE-2018-6927,https://github.com/torvalds/linux/commit/fbe0e839d1e22d88810f3ee3e2f1479be4c0aa4a,2018-02-12T19:29Z
CWE-119,"CWE-119 static bool check_underflow ( const struct arpt_entry * e ) { const struct xt_entry_target * t ; unsigned int verdict ; <S2SV_StartBug> if ( ! unconditional ( & e -> arp ) ) <S2SV_EndBug> return false ; t = arpt_get_target_c ( e ) ; if ( strcmp ( t -> u . user . name , XT_STANDARD_TARGET ) != 0 ) return false ; verdict = ( ( struct xt_standard_target * ) t ) -> verdict ; verdict = - verdict - 1 ; return verdict == NF_DROP || verdict == NF_ACCEPT ; }",<S2SV_ModStart> ! unconditional ( e <S2SV_ModEnd> ) ) return,torvalds@linux/54d83fc74aa9ec72794373cb47432c5f7fb1a309,CVE-2016-3134,https://github.com/torvalds/linux/commit/54d83fc74aa9ec72794373cb47432c5f7fb1a309,2016-04-27T17:59Z
CWE-399,"CWE-399 static int filter_frame ( AVFilterLink * inlink , AVFrame * buf ) { AVFilterContext * ctx = inlink -> dst ; FPSContext * s = ctx -> priv ; AVFilterLink * outlink = ctx -> outputs [ 0 ] ; int64_t delta ; int i , ret ; s -> frames_in ++ ; if ( s -> pts == AV_NOPTS_VALUE ) { if ( buf -> pts != AV_NOPTS_VALUE ) { ret = write_to_fifo ( s -> fifo , buf ) ; if ( ret < 0 ) return ret ; if ( s -> start_time != DBL_MAX && s -> start_time != AV_NOPTS_VALUE ) { double first_pts = s -> start_time * AV_TIME_BASE ; first_pts = FFMIN ( FFMAX ( first_pts , INT64_MIN ) , INT64_MAX ) ; s -> first_pts = s -> pts = av_rescale_q ( first_pts , AV_TIME_BASE_Q , inlink -> time_base ) ; av_log ( ctx , AV_LOG_VERBOSE , ""Set<S2SV_blank>first<S2SV_blank>pts<S2SV_blank>to<S2SV_blank>(in:%"" PRId64 ""<S2SV_blank>out:%"" PRId64 "")\\n"" , s -> first_pts , av_rescale_q ( first_pts , AV_TIME_BASE_Q , outlink -> time_base ) ) ; } else { s -> first_pts = s -> pts = buf -> pts ; } } else { av_log ( ctx , AV_LOG_WARNING , ""Discarding<S2SV_blank>initial<S2SV_blank>frame(s)<S2SV_blank>with<S2SV_blank>no<S2SV_blank>"" ""timestamp.\\n"" ) ; av_frame_free ( & buf ) ; s -> drop ++ ; } return 0 ; } <S2SV_StartBug> if ( buf -> pts == AV_NOPTS_VALUE ) { <S2SV_EndBug> return write_to_fifo ( s -> fifo , buf ) ; } delta = av_rescale_q_rnd ( buf -> pts - s -> pts , inlink -> time_base , outlink -> time_base , s -> rounding ) ; if ( delta < 1 ) { AVFrame * tmp ; int drop = av_fifo_size ( s -> fifo ) / sizeof ( AVFrame * ) ; av_log ( ctx , AV_LOG_DEBUG , ""Dropping<S2SV_blank>%d<S2SV_blank>frame(s).\\n"" , drop ) ; s -> drop += drop ; av_fifo_generic_read ( s -> fifo , & tmp , sizeof ( tmp ) , NULL ) ; flush_fifo ( s -> fifo ) ; ret = write_to_fifo ( s -> fifo , tmp ) ; av_frame_free ( & buf ) ; return ret ; } for ( i = 0 ; i < delta ; i ++ ) { AVFrame * buf_out ; av_fifo_generic_read ( s -> fifo , & buf_out , sizeof ( buf_out ) , NULL ) ; if ( ! av_fifo_size ( s -> fifo ) && i < delta - 1 ) { AVFrame * dup = av_frame_clone ( buf_out ) ; av_log ( ctx , AV_LOG_DEBUG , ""Duplicating<S2SV_blank>frame.\\n"" ) ; if ( dup ) ret = write_to_fifo ( s -> fifo , dup ) ; else ret = AVERROR ( ENOMEM ) ; if ( ret < 0 ) { av_frame_free ( & buf_out ) ; av_frame_free ( & buf ) ; return ret ; } s -> dup ++ ; } buf_out -> pts = av_rescale_q ( s -> first_pts , inlink -> time_base , outlink -> time_base ) + s -> frames_out ; if ( ( ret = ff_filter_frame ( outlink , buf_out ) ) < 0 ) { av_frame_free ( & buf ) ; return ret ; } s -> frames_out ++ ; } flush_fifo ( s -> fifo ) ; ret = write_to_fifo ( s -> fifo , buf ) ; s -> pts = s -> first_pts + av_rescale_q ( s -> frames_out , outlink -> time_base , inlink -> time_base ) ; return ret ; }",<S2SV_ModStart> pts == AV_NOPTS_VALUE || av_fifo_size ( s -> fifo ) <= 0,FFmpeg@FFmpeg/cdd5df8189ff1537f7abe8defe971f80602cc2d2,CVE-2013-7021,https://github.com/FFmpeg/FFmpeg/commit/cdd5df8189ff1537f7abe8defe971f80602cc2d2,2013-12-09T16:36Z
CWE-119,"CWE-119 static bool parseOperands ( char * str , ArmOp * op ) { char * t = strdup ( str ) ; int operand = 0 ; char * token = t ; char * x ; int imm_count = 0 ; int mem_opt = 0 ; if ( ! token ) { return false ; } while ( token ) { char * next = strchr ( token , ',' ) ; if ( next ) { * next ++ = 0 ; } while ( token [ 0 ] == '<S2SV_blank>' ) { <S2SV_StartBug> token ++ ; <S2SV_EndBug> } op -> operands [ operand ] . type = ARM_NOTYPE ; op -> operands [ operand ] . reg_type = ARM_UNDEFINED ; op -> operands [ operand ] . shift = ARM_NO_SHIFT ; while ( token [ 0 ] == '<S2SV_blank>' || token [ 0 ] == '[' || token [ 0 ] == ']' ) { token ++ ; } if ( ! strncmp ( token , ""lsl"" , 3 ) ) { op -> operands [ operand ] . shift = ARM_LSL ; } else if ( ! strncmp ( token , ""lsr"" , 3 ) ) { op -> operands [ operand ] . shift = ARM_LSR ; } else if ( ! strncmp ( token , ""asr"" , 3 ) ) { op -> operands [ operand ] . shift = ARM_ASR ; } if ( op -> operands [ operand ] . shift != ARM_NO_SHIFT ) { op -> operands_count ++ ; op -> operands [ operand ] . shift_amount = r_num_math ( NULL , token + 4 ) ; if ( op -> operands [ operand ] . shift_amount > 63 ) { return false ; } operand ++ ; token = next ; continue ; } switch ( token [ 0 ] ) { case 'x' : x = strchr ( token , ',' ) ; if ( x ) { x [ 0 ] = '\\0' ; } op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_GPR ; op -> operands [ operand ] . reg_type = ARM_REG64 ; op -> operands [ operand ] . reg = r_num_math ( NULL , token + 1 ) ; if ( op -> operands [ operand ] . reg > 31 ) { return false ; } break ; case 'w' : op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_GPR ; op -> operands [ operand ] . reg_type = ARM_REG32 ; op -> operands [ operand ] . reg = r_num_math ( NULL , token + 1 ) ; if ( op -> operands [ operand ] . reg > 31 ) { return false ; } break ; case 'v' : op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_FP ; op -> operands [ operand ] . reg = r_num_math ( NULL , token + 1 ) ; break ; case 's' : case 'S' : if ( token [ 1 ] == 'P' || token [ 1 ] == 'p' ) { int i ; for ( i = 0 ; msr_const [ i ] . name ; i ++ ) { if ( ! r_str_ncasecmp ( token , msr_const [ i ] . name , strlen ( msr_const [ i ] . name ) ) ) { op -> operands [ operand ] . sp_val = msr_const [ i ] . val ; break ; } } op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_GPR ; op -> operands [ operand ] . reg_type = ARM_SP | ARM_REG64 ; op -> operands [ operand ] . reg = 31 ; break ; } mem_opt = get_mem_option ( token ) ; if ( mem_opt != - 1 ) { op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_MEM_OPT ; op -> operands [ operand ] . mem_option = mem_opt ; } break ; case 'L' : case 'l' : case 'I' : case 'i' : case 'N' : case 'n' : case 'O' : case 'o' : case 'p' : case 'P' : mem_opt = get_mem_option ( token ) ; if ( mem_opt != - 1 ) { op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_MEM_OPT ; op -> operands [ operand ] . mem_option = mem_opt ; } break ; case '-' : op -> operands [ operand ] . sign = - 1 ; default : op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_CONSTANT ; op -> operands [ operand ] . immediate = r_num_math ( NULL , token ) ; imm_count ++ ; break ; } token = next ; operand ++ ; if ( operand > MAX_OPERANDS ) { free ( t ) ; return false ; } } free ( t ) ; return true ; }","<S2SV_ModStart> { token ++ ; } if ( operand >= MAX_OPERANDS ) { eprintf ( ""Too<S2SV_blank>many<S2SV_blank>operands\\n"" ) ; return false",radare@radare2/df167c7db545953bb7f71c72e98e7a3ca0c793bf,CVE-2018-20460,https://github.com/radare/radare2/commit/df167c7db545953bb7f71c72e98e7a3ca0c793bf,2018-12-25T19:29Z
CWE-400,"CWE-000 <S2SV_StartBug> static void evtchn_fifo_handle_events ( unsigned cpu ) <S2SV_EndBug> { <S2SV_StartBug> __evtchn_fifo_handle_events ( cpu , false ) ; <S2SV_EndBug> }","<S2SV_ModStart> ( unsigned cpu , struct evtchn_loop_ctrl * ctrl <S2SV_ModStart> ( cpu , ctrl <S2SV_ModEnd> ) ; }",torvalds@linux/e99502f76271d6bc4e374fe368c50c67a1fd3070,CVE-2020-27673,https://github.com/torvalds/linux/commit/e99502f76271d6bc4e374fe368c50c67a1fd3070,2020-10-22T21:15Z
CWE-787,"CWE-787 static void ReadReason ( rfbClient * client ) { uint32_t reasonLen ; char * reason ; if ( ! ReadFromRFBServer ( client , ( char * ) & reasonLen , 4 ) ) return ; reasonLen = rfbClientSwap32IfLE ( reasonLen ) ; <S2SV_StartBug> reason = malloc ( ( uint64_t ) reasonLen + 1 ) ; <S2SV_EndBug> if ( ! ReadFromRFBServer ( client , reason , reasonLen ) ) { free ( reason ) ; return ; } reason [ reasonLen ] = 0 ; rfbClientLog ( ""VNC<S2SV_blank>connection<S2SV_blank>failed:<S2SV_blank>%s\\n"" , reason ) ; free ( reason ) ; }","<S2SV_ModStart> reasonLen ) ; if ( reasonLen > 1 << 20 ) { rfbClientLog ( ""VNC<S2SV_blank>connection<S2SV_blank>failed,<S2SV_blank>but<S2SV_blank>sent<S2SV_blank>reason<S2SV_blank>length<S2SV_blank>of<S2SV_blank>%u<S2SV_blank>exceeds<S2SV_blank>limit<S2SV_blank>of<S2SV_blank>1MB"" , ( unsigned int ) reasonLen ) ; return ; } <S2SV_ModStart> = malloc ( <S2SV_ModEnd> reasonLen + 1",LibVNC@libvncserver/e34bcbb759ca5bef85809967a268fdf214c1ad2c,CVE-2018-20748,https://github.com/LibVNC/libvncserver/commit/e34bcbb759ca5bef85809967a268fdf214c1ad2c,2019-01-30T18:29Z
CWE-119,"CWE-119 static int mark_source_chains ( const struct xt_table_info * newinfo , unsigned int valid_hooks , void * entry0 ) { unsigned int hook ; for ( hook = 0 ; hook < NF_INET_NUMHOOKS ; hook ++ ) { unsigned int pos = newinfo -> hook_entry [ hook ] ; struct ipt_entry * e = ( struct ipt_entry * ) ( entry0 + pos ) ; if ( ! ( valid_hooks & ( 1 << hook ) ) ) continue ; e -> counters . pcnt = pos ; for ( ; ; ) { const struct xt_standard_target * t = ( void * ) ipt_get_target_c ( e ) ; int visited = e -> comefrom & ( 1 << hook ) ; if ( e -> comefrom & ( 1 << NF_INET_NUMHOOKS ) ) { pr_err ( ""iptables:<S2SV_blank>loop<S2SV_blank>hook<S2SV_blank>%u<S2SV_blank>pos<S2SV_blank>%u<S2SV_blank>%08X.\\n"" , hook , pos , e -> comefrom ) ; return 0 ; } e -> comefrom |= ( ( 1 << hook ) | ( 1 << NF_INET_NUMHOOKS ) ) ; <S2SV_StartBug> if ( ( e -> target_offset == sizeof ( struct ipt_entry ) && <S2SV_EndBug> ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) && <S2SV_StartBug> t -> verdict < 0 && unconditional ( & e -> ip ) ) || <S2SV_EndBug> visited ) { unsigned int oldpos , size ; if ( ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) && t -> verdict < - NF_MAX_VERDICT - 1 ) { duprintf ( ""mark_source_chains:<S2SV_blank>bad<S2SV_blank>"" ""negative<S2SV_blank>verdict<S2SV_blank>(%i)\\n"" , t -> verdict ) ; return 0 ; } do { e -> comefrom ^= ( 1 << NF_INET_NUMHOOKS ) ; # ifdef DEBUG_IP_FIREWALL_USER if ( e -> comefrom & ( 1 << NF_INET_NUMHOOKS ) ) { duprintf ( ""Back<S2SV_blank>unset<S2SV_blank>"" ""on<S2SV_blank>hook<S2SV_blank>%u<S2SV_blank>"" ""rule<S2SV_blank>%u\\n"" , hook , pos ) ; } # endif oldpos = pos ; pos = e -> counters . pcnt ; e -> counters . pcnt = 0 ; if ( pos == oldpos ) goto next ; e = ( struct ipt_entry * ) ( entry0 + pos ) ; } while ( oldpos == pos + e -> next_offset ) ; size = e -> next_offset ; e = ( struct ipt_entry * ) ( entry0 + pos + size ) ; e -> counters . pcnt = pos ; pos += size ; } else { int newpos = t -> verdict ; if ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 && newpos >= 0 ) { if ( newpos > newinfo -> size - sizeof ( struct ipt_entry ) ) { duprintf ( ""mark_source_chains:<S2SV_blank>"" ""bad<S2SV_blank>verdict<S2SV_blank>(%i)\\n"" , newpos ) ; return 0 ; } duprintf ( ""Jump<S2SV_blank>rule<S2SV_blank>%u<S2SV_blank>-><S2SV_blank>%u\\n"" , pos , newpos ) ; } else { newpos = pos + e -> next_offset ; } e = ( struct ipt_entry * ) ( entry0 + newpos ) ; e -> counters . pcnt = pos ; pos = newpos ; } } next : duprintf ( ""Finished<S2SV_blank>chain<S2SV_blank>%u\\n"" , hook ) ; } return 1 ; }",<S2SV_ModStart> if ( ( unconditional ( e <S2SV_ModEnd> ) && ( <S2SV_ModStart> verdict < 0 <S2SV_ModEnd> ) || visited,torvalds@linux/54d83fc74aa9ec72794373cb47432c5f7fb1a309,CVE-2016-3134,https://github.com/torvalds/linux/commit/54d83fc74aa9ec72794373cb47432c5f7fb1a309,2016-04-27T17:59Z
CWE-119,"CWE-119 static int airspy_probe ( struct usb_interface * intf , const struct usb_device_id * id ) { struct airspy * s ; int ret ; u8 u8tmp , buf [ BUF_SIZE ] ; s = kzalloc ( sizeof ( struct airspy ) , GFP_KERNEL ) ; if ( s == NULL ) { dev_err ( & intf -> dev , ""Could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>state\\n"" ) ; return - ENOMEM ; } mutex_init ( & s -> v4l2_lock ) ; mutex_init ( & s -> vb_queue_lock ) ; spin_lock_init ( & s -> queued_bufs_lock ) ; INIT_LIST_HEAD ( & s -> queued_bufs ) ; s -> dev = & intf -> dev ; s -> udev = interface_to_usbdev ( intf ) ; s -> f_adc = bands [ 0 ] . rangelow ; s -> f_rf = bands_rf [ 0 ] . rangelow ; s -> pixelformat = formats [ 0 ] . pixelformat ; s -> buffersize = formats [ 0 ] . buffersize ; ret = airspy_ctrl_msg ( s , CMD_BOARD_ID_READ , 0 , 0 , & u8tmp , 1 ) ; if ( ret == 0 ) ret = airspy_ctrl_msg ( s , CMD_VERSION_STRING_READ , 0 , 0 , buf , BUF_SIZE ) ; if ( ret ) { dev_err ( s -> dev , ""Could<S2SV_blank>not<S2SV_blank>detect<S2SV_blank>board\\n"" ) ; goto err_free_mem ; } buf [ BUF_SIZE - 1 ] = '\\0' ; dev_info ( s -> dev , ""Board<S2SV_blank>ID:<S2SV_blank>%02x\\n"" , u8tmp ) ; dev_info ( s -> dev , ""Firmware<S2SV_blank>version:<S2SV_blank>%s\\n"" , buf ) ; s -> vb_queue . type = V4L2_BUF_TYPE_SDR_CAPTURE ; s -> vb_queue . io_modes = VB2_MMAP | VB2_USERPTR | VB2_READ ; s -> vb_queue . drv_priv = s ; s -> vb_queue . buf_struct_size = sizeof ( struct airspy_frame_buf ) ; s -> vb_queue . ops = & airspy_vb2_ops ; s -> vb_queue . mem_ops = & vb2_vmalloc_memops ; s -> vb_queue . timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC ; ret = vb2_queue_init ( & s -> vb_queue ) ; if ( ret ) { dev_err ( s -> dev , ""Could<S2SV_blank>not<S2SV_blank>initialize<S2SV_blank>vb2<S2SV_blank>queue\\n"" ) ; goto err_free_mem ; } s -> vdev = airspy_template ; s -> vdev . queue = & s -> vb_queue ; s -> vdev . queue -> lock = & s -> vb_queue_lock ; video_set_drvdata ( & s -> vdev , s ) ; s -> v4l2_dev . release = airspy_video_release ; ret = v4l2_device_register ( & intf -> dev , & s -> v4l2_dev ) ; if ( ret ) { dev_err ( s -> dev , ""Failed<S2SV_blank>to<S2SV_blank>register<S2SV_blank>v4l2-device<S2SV_blank>(%d)\\n"" , ret ) ; goto err_free_mem ; } v4l2_ctrl_handler_init ( & s -> hdl , 5 ) ; s -> lna_gain_auto = v4l2_ctrl_new_std ( & s -> hdl , & airspy_ctrl_ops , V4L2_CID_RF_TUNER_LNA_GAIN_AUTO , 0 , 1 , 1 , 0 ) ; s -> lna_gain = v4l2_ctrl_new_std ( & s -> hdl , & airspy_ctrl_ops , V4L2_CID_RF_TUNER_LNA_GAIN , 0 , 14 , 1 , 8 ) ; v4l2_ctrl_auto_cluster ( 2 , & s -> lna_gain_auto , 0 , false ) ; s -> mixer_gain_auto = v4l2_ctrl_new_std ( & s -> hdl , & airspy_ctrl_ops , V4L2_CID_RF_TUNER_MIXER_GAIN_AUTO , 0 , 1 , 1 , 0 ) ; s -> mixer_gain = v4l2_ctrl_new_std ( & s -> hdl , & airspy_ctrl_ops , V4L2_CID_RF_TUNER_MIXER_GAIN , 0 , 15 , 1 , 8 ) ; v4l2_ctrl_auto_cluster ( 2 , & s -> mixer_gain_auto , 0 , false ) ; s -> if_gain = v4l2_ctrl_new_std ( & s -> hdl , & airspy_ctrl_ops , V4L2_CID_RF_TUNER_IF_GAIN , 0 , 15 , 1 , 0 ) ; if ( s -> hdl . error ) { ret = s -> hdl . error ; dev_err ( s -> dev , ""Could<S2SV_blank>not<S2SV_blank>initialize<S2SV_blank>controls\\n"" ) ; goto err_free_controls ; } v4l2_ctrl_handler_setup ( & s -> hdl ) ; s -> v4l2_dev . ctrl_handler = & s -> hdl ; s -> vdev . v4l2_dev = & s -> v4l2_dev ; s -> vdev . lock = & s -> v4l2_lock ; ret = video_register_device ( & s -> vdev , VFL_TYPE_SDR , - 1 ) ; if ( ret ) { dev_err ( s -> dev , ""Failed<S2SV_blank>to<S2SV_blank>register<S2SV_blank>as<S2SV_blank>video<S2SV_blank>device<S2SV_blank>(%d)\\n"" , ret ) ; <S2SV_StartBug> goto err_unregister_v4l2_dev ; <S2SV_EndBug> } dev_info ( s -> dev , ""Registered<S2SV_blank>as<S2SV_blank>%s\\n"" , video_device_node_name ( & s -> vdev ) ) ; dev_notice ( s -> dev , ""SDR<S2SV_blank>API<S2SV_blank>is<S2SV_blank>still<S2SV_blank>slightly<S2SV_blank>experimental<S2SV_blank>and<S2SV_blank>functionality<S2SV_blank>changes<S2SV_blank>may<S2SV_blank>follow\\n"" ) ; return 0 ; err_free_controls : v4l2_ctrl_handler_free ( & s -> hdl ) ; <S2SV_StartBug> err_unregister_v4l2_dev : <S2SV_EndBug> v4l2_device_unregister ( & s -> v4l2_dev ) ; err_free_mem : kfree ( s ) ; return ret ; }",<S2SV_ModStart> ) ; goto err_free_controls <S2SV_ModEnd> ; } dev_info <S2SV_ModStart> hdl ) ; <S2SV_ModEnd> v4l2_device_unregister ( &,torvalds@linux/aa93d1fee85c890a34f2510a310e55ee76a27848,CVE-2016-5400,https://github.com/torvalds/linux/commit/aa93d1fee85c890a34f2510a310e55ee76a27848,2016-08-06T20:59Z
CWE-399,"CWE-399 static void record_and_restart ( struct perf_event * event , unsigned long val , <S2SV_StartBug> struct pt_regs * regs , int nmi ) <S2SV_EndBug> { u64 period = event -> hw . sample_period ; s64 prev , delta , left ; int record = 0 ; if ( event -> hw . state & PERF_HES_STOPPED ) { write_pmc ( event -> hw . idx , 0 ) ; return ; } prev = local64_read ( & event -> hw . prev_count ) ; delta = ( val - prev ) & 0xfffffffful ; local64_add ( delta , & event -> count ) ; val = 0 ; left = local64_read ( & event -> hw . period_left ) - delta ; if ( period ) { if ( left <= 0 ) { left += period ; if ( left <= 0 ) left = period ; record = 1 ; event -> hw . last_period = event -> hw . sample_period ; } if ( left < 0x80000000LL ) val = 0x80000000LL - left ; } write_pmc ( event -> hw . idx , val ) ; local64_set ( & event -> hw . prev_count , val ) ; local64_set ( & event -> hw . period_left , left ) ; perf_event_update_userpage ( event ) ; if ( record ) { struct perf_sample_data data ; perf_sample_data_init ( & data , 0 ) ; data . period = event -> hw . last_period ; <S2SV_StartBug> if ( perf_event_overflow ( event , nmi , & data , regs ) ) <S2SV_EndBug> fsl_emb_pmu_stop ( event , 0 ) ; } }","<S2SV_ModStart> pt_regs * regs <S2SV_ModEnd> ) { u64 <S2SV_ModStart> ( event , <S2SV_ModEnd> & data ,",torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z
CWE-399,"CWE-399 <S2SV_StartBug> static void kiocb_batch_free ( struct kiocb_batch * batch ) <S2SV_EndBug> { <S2SV_StartBug> struct kiocb * req , * n ; <S2SV_EndBug> list_for_each_entry_safe ( req , n , & batch -> head , ki_batch ) { list_del ( & req -> ki_batch ) ; <S2SV_StartBug> kmem_cache_free ( kiocb_cachep , req ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> }","<S2SV_ModStart> void kiocb_batch_free ( struct kioctx * ctx , <S2SV_ModStart> , * n ; if ( list_empty ( & batch -> head ) ) return ; spin_lock_irq ( & ctx -> ctx_lock ) <S2SV_ModStart> ki_batch ) ; list_del ( & req -> ki_list ) ; <S2SV_ModStart> req ) ; ctx -> reqs_active -- ; } spin_unlock_irq ( & ctx -> ctx_lock ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>",torvalds@linux/802f43594d6e4d2ac61086d239153c17873a0428,CVE-2012-0058,https://github.com/torvalds/linux/commit/802f43594d6e4d2ac61086d239153c17873a0428,2012-05-17T11:00Z
CWE-119,"CWE-119 int process ( register int code , unsigned char * * fill ) { int incode ; static unsigned char firstchar ; if ( code == clear ) { codesize = datasize + 1 ; codemask = ( 1 << codesize ) - 1 ; avail = clear + 2 ; oldcode = - 1 ; return 1 ; } if ( oldcode == - 1 ) { <S2SV_StartBug> * ( * fill ) ++ = suffix [ code ] ; <S2SV_EndBug> firstchar = oldcode = code ; return 1 ; } if ( code > avail ) { fprintf ( stderr , ""code<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>for<S2SV_blank>%d\\n"" , code , avail ) ; return 0 ; } incode = code ; if ( code == avail ) { * stackp ++ = firstchar ; code = oldcode ; } while ( code > clear ) { * stackp ++ = suffix [ code ] ; code = prefix [ code ] ; } * stackp ++ = firstchar = suffix [ code ] ; prefix [ avail ] = oldcode ; suffix [ avail ] = firstchar ; avail ++ ; if ( ( ( avail & codemask ) == 0 ) && ( avail < 4096 ) ) { codesize ++ ; codemask += avail ; } oldcode = incode ; do { * ( * fill ) ++ = * -- stackp ; } while ( stackp > stack ) ; return 1 ; }","<S2SV_ModStart> 1 ) { if ( code >= clear ) { fprintf ( stderr , ""bad<S2SV_blank>input:<S2SV_blank>code=%d<S2SV_blank>is<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>clear=%d\\n"" , code , clear ) ; return 0 ; }",vadz@libtiff/ce6841d9e41d621ba23cf18b190ee6a23b2cc833,CVE-2013-4244,https://github.com/vadz/libtiff/commit/ce6841d9e41d621ba23cf18b190ee6a23b2cc833,2013-09-28T19:55Z
CWE-78,"CWE-000 static char * construct_command_line ( struct manager_ctx * manager , struct server * server ) { static char cmd [ BUF_SIZE ] ; <S2SV_StartBug> char * method = manager -> method ; <S2SV_EndBug> int i ; <S2SV_StartBug> build_config ( working_dir , server ) ; <S2SV_EndBug> if ( server -> method ) method = server -> method ; memset ( cmd , 0 , BUF_SIZE ) ; snprintf ( cmd , BUF_SIZE , <S2SV_StartBug> ""%s<S2SV_blank>-m<S2SV_blank>%s<S2SV_blank>--manager-address<S2SV_blank>%s<S2SV_blank>-f<S2SV_blank>%s/.shadowsocks_%s.pid<S2SV_blank>-c<S2SV_blank>%s/.shadowsocks_%s.conf"" , <S2SV_EndBug> <S2SV_StartBug> executable , method , manager -> manager_address , <S2SV_EndBug> <S2SV_StartBug> working_dir , server -> port , working_dir , server -> port ) ; <S2SV_EndBug> if ( manager -> acl != NULL ) { int len = strlen ( cmd ) ; snprintf ( cmd + len , BUF_SIZE - len , ""<S2SV_blank>--acl<S2SV_blank>%s"" , manager -> acl ) ; } if ( manager -> timeout != NULL ) { int len = strlen ( cmd ) ; snprintf ( cmd + len , BUF_SIZE - len , ""<S2SV_blank>-t<S2SV_blank>%s"" , manager -> timeout ) ; } # ifdef HAVE_SETRLIMIT if ( manager -> nofile ) { int len = strlen ( cmd ) ; snprintf ( cmd + len , BUF_SIZE - len , ""<S2SV_blank>-n<S2SV_blank>%d"" , manager -> nofile ) ; } # endif if ( manager -> user != NULL ) { int len = strlen ( cmd ) ; snprintf ( cmd + len , BUF_SIZE - len , ""<S2SV_blank>-a<S2SV_blank>%s"" , manager -> user ) ; } if ( manager -> verbose ) { int len = strlen ( cmd ) ; snprintf ( cmd + len , BUF_SIZE - len , ""<S2SV_blank>-v"" ) ; } if ( server -> mode == NULL && manager -> mode == UDP_ONLY ) { int len = strlen ( cmd ) ; snprintf ( cmd + len , BUF_SIZE - len , ""<S2SV_blank>-U"" ) ; } if ( server -> mode == NULL && manager -> mode == TCP_AND_UDP ) { int len = strlen ( cmd ) ; snprintf ( cmd + len , BUF_SIZE - len , ""<S2SV_blank>-u"" ) ; } if ( server -> fast_open [ 0 ] == 0 && manager -> fast_open ) { int len = strlen ( cmd ) ; snprintf ( cmd + len , BUF_SIZE - len , ""<S2SV_blank>--fast-open"" ) ; } if ( manager -> ipv6first ) { int len = strlen ( cmd ) ; snprintf ( cmd + len , BUF_SIZE - len , ""<S2SV_blank>-6"" ) ; } if ( manager -> mtu ) { int len = strlen ( cmd ) ; snprintf ( cmd + len , BUF_SIZE - len , ""<S2SV_blank>--mtu<S2SV_blank>%d"" , manager -> mtu ) ; } if ( server -> plugin == NULL && manager -> plugin ) { int len = strlen ( cmd ) ; snprintf ( cmd + len , BUF_SIZE - len , ""<S2SV_blank>--plugin<S2SV_blank>\\""%s\\"""" , manager -> plugin ) ; } if ( server -> plugin_opts == NULL && manager -> plugin_opts ) { int len = strlen ( cmd ) ; snprintf ( cmd + len , BUF_SIZE - len , ""<S2SV_blank>--plugin-opts<S2SV_blank>\\""%s\\"""" , manager -> plugin_opts ) ; } for ( i = 0 ; i < manager -> nameserver_num ; i ++ ) { int len = strlen ( cmd ) ; snprintf ( cmd + len , BUF_SIZE - len , ""<S2SV_blank>-d<S2SV_blank>%s"" , manager -> nameservers [ i ] ) ; } for ( i = 0 ; i < manager -> host_num ; i ++ ) { int len = strlen ( cmd ) ; snprintf ( cmd + len , BUF_SIZE - len , ""<S2SV_blank>-s<S2SV_blank>%s"" , manager -> hosts [ i ] ) ; } { int len = strlen ( cmd ) ; snprintf ( cmd + len , BUF_SIZE - len , ""<S2SV_blank>--reuse-port"" ) ; } if ( verbose ) { LOGI ( ""cmd:<S2SV_blank>%s"" , cmd ) ; } return cmd ; }","<S2SV_ModStart> BUF_SIZE ] ; int i ; int port ; port = atoi ( server -> port ) <S2SV_ModEnd> ; build_config ( <S2SV_ModStart> ( working_dir , manager , server ) <S2SV_ModEnd> ; memset ( <S2SV_ModStart> , BUF_SIZE , ""%s<S2SV_blank>--manager-address<S2SV_blank>%s<S2SV_blank>-f<S2SV_blank>%s/.shadowsocks_%d.pid<S2SV_blank>-c<S2SV_blank>%s/.shadowsocks_%d.conf"" <S2SV_ModEnd> , executable , <S2SV_ModStart> , executable , <S2SV_ModEnd> manager -> manager_address <S2SV_ModStart> , working_dir , <S2SV_ModEnd> port , working_dir <S2SV_ModStart> , working_dir , <S2SV_ModEnd> port ) ;",shadowsocks@shadowsocks-libev/c67d275803dc6ea22c558d06b1f7ba9f94cd8de3,CVE-2017-15924,https://github.com/shadowsocks/shadowsocks-libev/commit/c67d275803dc6ea22c558d06b1f7ba9f94cd8de3,2017-10-27T16:29Z
CWE-119,"CWE-119 <S2SV_StartBug> void usage_exit ( ) { <S2SV_EndBug> fprintf ( stderr , ""Usage:<S2SV_blank>%s<S2SV_blank><infile><S2SV_blank><outfile>\\n"" , exec_name ) ; exit ( EXIT_FAILURE ) ; }",<S2SV_ModStart> void usage_exit ( void,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-119,"CWE-119 static int ExecuteSQL ( SQLHDBC hDbc , char * szSQL , char cDelimiter , int bColumnNames , int bHTMLTable ) { SQLHSTMT hStmt ; SQLTCHAR szSepLine [ 32001 ] ; SQLTCHAR szUcSQL [ 32001 ] ; SQLSMALLINT cols ; SQLINTEGER ret ; SQLLEN nRows = 0 ; szSepLine [ 0 ] = 0 ; ansi_to_unicode ( szSQL , szUcSQL ) ; if ( SQLAllocStmt ( hDbc , & hStmt ) != SQL_SUCCESS ) { if ( bVerbose ) DumpODBCLog ( hEnv , hDbc , 0 ) ; fprintf ( stderr , ""[ISQL]ERROR:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>SQLAllocStmt\\n"" ) ; return 0 ; } if ( buseED ) { ret = SQLExecDirect ( hStmt , szUcSQL , SQL_NTS ) ; if ( ret == SQL_NO_DATA ) { fprintf ( stderr , ""[ISQL]INFO:<S2SV_blank>SQLExecDirect<S2SV_blank>returned<S2SV_blank>SQL_NO_DATA\\n"" ) ; } else if ( ret == SQL_SUCCESS_WITH_INFO ) { if ( bVerbose ) DumpODBCLog ( hEnv , hDbc , hStmt ) ; fprintf ( stderr , ""[ISQL]INFO:<S2SV_blank>SQLExecDirect<S2SV_blank>returned<S2SV_blank>SQL_SUCCESS_WITH_INFO\\n"" ) ; } else if ( ret != SQL_SUCCESS ) { if ( bVerbose ) DumpODBCLog ( hEnv , hDbc , hStmt ) ; fprintf ( stderr , ""[ISQL]ERROR:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>SQLExecDirect\\n"" ) ; SQLFreeStmt ( hStmt , SQL_DROP ) ; <S2SV_StartBug> free ( szSepLine ) ; <S2SV_EndBug> return 0 ; } } else { if ( SQLPrepare ( hStmt , szUcSQL , SQL_NTS ) != SQL_SUCCESS ) { if ( bVerbose ) DumpODBCLog ( hEnv , hDbc , hStmt ) ; fprintf ( stderr , ""[ISQL]ERROR:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>SQLPrepare\\n"" ) ; SQLFreeStmt ( hStmt , SQL_DROP ) ; return 0 ; } ret = SQLExecute ( hStmt ) ; if ( ret == SQL_NO_DATA ) { fprintf ( stderr , ""[ISQL]INFO:<S2SV_blank>SQLExecute<S2SV_blank>returned<S2SV_blank>SQL_NO_DATA\\n"" ) ; } else if ( ret == SQL_SUCCESS_WITH_INFO ) { if ( bVerbose ) DumpODBCLog ( hEnv , hDbc , hStmt ) ; fprintf ( stderr , ""[ISQL]INFO:<S2SV_blank>SQLExecute<S2SV_blank>returned<S2SV_blank>SQL_SUCCESS_WITH_INFO\\n"" ) ; } else if ( ret != SQL_SUCCESS ) { if ( bVerbose ) DumpODBCLog ( hEnv , hDbc , hStmt ) ; fprintf ( stderr , ""[ISQL]ERROR:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>SQLExecute\\n"" ) ; SQLFreeStmt ( hStmt , SQL_DROP ) ; return 0 ; } } do { if ( SQLNumResultCols ( hStmt , & cols ) != SQL_SUCCESS ) { if ( bVerbose ) DumpODBCLog ( hEnv , hDbc , hStmt ) ; fprintf ( stderr , ""[ISQL]ERROR:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>SQLNumResultCols\\n"" ) ; SQLFreeStmt ( hStmt , SQL_DROP ) ; return 0 ; } if ( cols > 0 ) { if ( bHTMLTable ) WriteHeaderHTMLTable ( hStmt ) ; else if ( cDelimiter == 0 ) UWriteHeaderNormal ( hStmt , szSepLine ) ; else if ( cDelimiter && bColumnNames ) WriteHeaderDelimited ( hStmt , cDelimiter ) ; if ( bHTMLTable ) WriteBodyHTMLTable ( hStmt ) ; else if ( cDelimiter == 0 ) nRows = WriteBodyNormal ( hStmt ) ; else WriteBodyDelimited ( hStmt , cDelimiter ) ; } if ( bHTMLTable ) WriteFooterHTMLTable ( hStmt ) ; else if ( cDelimiter == 0 ) UWriteFooterNormal ( hStmt , szSepLine , nRows ) ; } while ( SQL_SUCCEEDED ( SQLMoreResults ( hStmt ) ) ) ; SQLFreeStmt ( hStmt , SQL_DROP ) ; return 1 ; }",<S2SV_ModStart> SQL_DROP ) ; <S2SV_ModEnd> return 0 ;,lurcher@unixODBC/45ef78e037f578b15fc58938a3a3251655e71d6f,CVE-2018-7485,https://github.com/lurcher/unixODBC/commit/45ef78e037f578b15fc58938a3a3251655e71d6f#diff-d52750c7ba4e594410438569d8e2963aL24,2018-02-26T14:29Z
CWE-787,"CWE-787 int idn2_to_ascii_4i ( const uint32_t * input , size_t inlen , char * output , int flags ) { uint32_t * input_u32 ; uint8_t * input_u8 , * output_u8 ; size_t length ; int rc ; if ( ! input ) { if ( output ) * output = 0 ; return IDN2_OK ; } input_u32 = ( uint32_t * ) malloc ( ( inlen + 1 ) * sizeof ( uint32_t ) ) ; if ( ! input_u32 ) return IDN2_MALLOC ; u32_cpy ( input_u32 , input , inlen ) ; input_u32 [ inlen ] = 0 ; input_u8 = u32_to_u8 ( input_u32 , inlen + 1 , NULL , & length ) ; free ( input_u32 ) ; if ( ! input_u8 ) { if ( errno == ENOMEM ) return IDN2_MALLOC ; return IDN2_ENCODING_ERROR ; } rc = idn2_lookup_u8 ( input_u8 , & output_u8 , flags ) ; free ( input_u8 ) ; if ( rc == IDN2_OK ) { <S2SV_StartBug> if ( output ) <S2SV_EndBug> <S2SV_StartBug> strcpy ( output , ( const char * ) output_u8 ) ; <S2SV_EndBug> free ( output_u8 ) ; } return rc ; }","<S2SV_ModStart> IDN2_OK ) { size_t len = strlen ( ( char * ) output_u8 ) ; if ( len > 63 ) { free ( output_u8 ) ; return IDN2_TOO_BIG_DOMAIN ; } <S2SV_ModStart> output , ( <S2SV_ModEnd> char * )",libidn@libidn2/e4d1558aa2c1c04a05066ee8600f37603890ba8c,CVE-2019-18224,https://github.com/libidn/libidn2/commit/e4d1558aa2c1c04a05066ee8600f37603890ba8c,2019-10-21T17:15Z
CWE-119,"CWE-119 static Image * ReadARTImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; QuantumInfo * quantum_info ; QuantumType quantum_type ; MagickBooleanType status ; size_t length ; ssize_t count , y ; unsigned char * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image -> depth = 1 ; image -> endian = MSBEndian ; ( void ) ReadBlobLSBShort ( image ) ; image -> columns = ( size_t ) ReadBlobLSBShort ( image ) ; ( void ) ReadBlobLSBShort ( image ) ; image -> rows = ( size_t ) ReadBlobLSBShort ( image ) ; if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( AcquireImageColormap ( image , 2 ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } <S2SV_StartBug> SetImageColorspace ( image , GRAYColorspace ) ; <S2SV_EndBug> quantum_type = IndexQuantum ; quantum_info = AcquireQuantumInfo ( image_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixels = GetQuantumPixels ( quantum_info ) ; length = GetQuantumExtent ( image , quantum_info , quantum_type ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { register PixelPacket * restrict q ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; count = ReadBlob ( image , length , pixels ) ; if ( count != ( ssize_t ) length ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; ( void ) ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , quantum_type , pixels , exception ) ; count = ReadBlob ( image , ( size_t ) ( - ( ssize_t ) length ) & 0x01 , pixels ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } SetQuantumImageType ( image , quantum_type ) ; quantum_info = DestroyQuantumInfo ( quantum_info ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }","<S2SV_ModStart> ) ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }",ImageMagick@ImageMagick/f6e9d0d9955e85bdd7540b251cd50d598dacc5e6,CVE-2016-10066,https://github.com/ImageMagick/ImageMagick/commit/f6e9d0d9955e85bdd7540b251cd50d598dacc5e6,2017-03-03T17:59Z
CWE-416,"CWE-416 void usb_sg_cancel ( struct usb_sg_request * io ) { unsigned long flags ; int i , retval ; spin_lock_irqsave ( & io -> lock , flags ) ; <S2SV_StartBug> if ( io -> status ) { <S2SV_EndBug> spin_unlock_irqrestore ( & io -> lock , flags ) ; return ; } io -> status = - ECONNRESET ; <S2SV_StartBug> spin_unlock_irqrestore ( & io -> lock , flags ) ; <S2SV_EndBug> for ( i = io -> entries - 1 ; i >= 0 ; -- i ) { usb_block_urb ( io -> urbs [ i ] ) ; retval = usb_unlink_urb ( io -> urbs [ i ] ) ; if ( retval != - EINPROGRESS && retval != - ENODEV && retval != - EBUSY && retval != - EIDRM ) dev_warn ( & io -> dev -> dev , ""%s,<S2SV_blank>unlink<S2SV_blank>--><S2SV_blank>%d\\n"" , __func__ , retval ) ; } <S2SV_StartBug> } <S2SV_EndBug>","<S2SV_ModStart> io -> status || io -> count == 0 <S2SV_ModStart> - ECONNRESET ; io -> count ++ ; <S2SV_ModStart> ) ; } spin_lock_irqsave ( & io -> lock , flags ) ; io -> count -- ; if ( ! io -> count ) complete ( & io -> complete ) ; spin_unlock_irqrestore ( & io -> lock , flags ) ;",torvalds@linux/056ad39ee9253873522f6469c3364964a322912b,CVE-2020-12464,https://github.com/torvalds/linux/commit/056ad39ee9253873522f6469c3364964a322912b,2020-04-29T18:15Z
CWE-362,"CWE-362 static int em_sysenter ( struct x86_emulate_ctxt * ctxt ) { const struct x86_emulate_ops * ops = ctxt -> ops ; struct desc_struct cs , ss ; u64 msr_data ; u16 cs_sel , ss_sel ; u64 efer = 0 ; ops -> get_msr ( ctxt , MSR_EFER , & efer ) ; if ( ctxt -> mode == X86EMUL_MODE_REAL ) return emulate_gp ( ctxt , 0 ) ; <S2SV_StartBug> if ( ( ctxt -> mode == X86EMUL_MODE_PROT32 ) && ( efer & EFER_LMA ) <S2SV_EndBug> && ! vendor_intel ( ctxt ) ) return emulate_ud ( ctxt ) ; if ( ctxt -> mode == X86EMUL_MODE_PROT64 ) return X86EMUL_UNHANDLEABLE ; setup_syscalls_segments ( ctxt , & cs , & ss ) ; ops -> get_msr ( ctxt , MSR_IA32_SYSENTER_CS , & msr_data ) ; <S2SV_StartBug> switch ( ctxt -> mode ) { <S2SV_EndBug> case X86EMUL_MODE_PROT32 : if ( ( msr_data & 0xfffc ) == 0x0 ) return emulate_gp ( ctxt , 0 ) ; <S2SV_StartBug> break ; <S2SV_EndBug> case X86EMUL_MODE_PROT64 : if ( msr_data == 0x0 ) return emulate_gp ( ctxt , 0 ) ; break ; default : break ; } ctxt -> eflags &= ~ ( EFLG_VM | EFLG_IF ) ; <S2SV_StartBug> cs_sel = ( u16 ) msr_data ; <S2SV_EndBug> cs_sel &= ~ SELECTOR_RPL_MASK ; ss_sel = cs_sel + 8 ; <S2SV_StartBug> ss_sel &= ~ SELECTOR_RPL_MASK ; <S2SV_EndBug> <S2SV_StartBug> if ( ctxt -> mode == X86EMUL_MODE_PROT64 || ( efer & EFER_LMA ) ) { <S2SV_EndBug> cs . d = 0 ; cs . l = 1 ; } ops -> set_segment ( ctxt , cs_sel , & cs , 0 , VCPU_SREG_CS ) ; ops -> set_segment ( ctxt , ss_sel , & ss , 0 , VCPU_SREG_SS ) ; ops -> get_msr ( ctxt , MSR_IA32_SYSENTER_EIP , & msr_data ) ; <S2SV_StartBug> ctxt -> _eip = msr_data ; <S2SV_EndBug> ops -> get_msr ( ctxt , MSR_IA32_SYSENTER_ESP , & msr_data ) ; <S2SV_StartBug> * reg_write ( ctxt , VCPU_REGS_RSP ) = msr_data ; <S2SV_EndBug> return X86EMUL_CONTINUE ; }",<S2SV_ModStart> ctxt -> mode != X86EMUL_MODE_PROT64 <S2SV_ModEnd> ) && ( <S2SV_ModStart> msr_data ) ; <S2SV_ModEnd> if ( ( <S2SV_ModStart> 0 ) ; <S2SV_ModEnd> ctxt -> eflags <S2SV_ModStart> u16 ) msr_data & <S2SV_ModEnd> ~ SELECTOR_RPL_MASK ; <S2SV_ModStart> + 8 ; if <S2SV_ModEnd> ( efer & <S2SV_ModStart> efer & EFER_LMA <S2SV_ModEnd> ) { cs <S2SV_ModStart> -> _eip = ( efer & EFER_LMA ) ? msr_data : ( u32 ) <S2SV_ModStart> VCPU_REGS_RSP ) = ( efer & EFER_LMA ) ? msr_data : ( u32 ),torvalds@linux/f3747379accba8e95d70cec0eae0582c8c182050,CVE-2015-0239,https://github.com/torvalds/linux/commit/f3747379accba8e95d70cec0eae0582c8c182050,2015-03-02T11:59Z
CWE-119,"CWE-119 static long vop_ioctl ( struct file * f , unsigned int cmd , unsigned long arg ) { struct vop_vdev * vdev = f -> private_data ; struct vop_info * vi = vdev -> vi ; void __user * argp = ( void __user * ) arg ; int ret ; switch ( cmd ) { case MIC_VIRTIO_ADD_DEVICE : { struct mic_device_desc dd , * dd_config ; if ( copy_from_user ( & dd , argp , sizeof ( dd ) ) ) return - EFAULT ; if ( mic_aligned_desc_size ( & dd ) > MIC_MAX_DESC_BLK_SIZE || dd . num_vq > MIC_MAX_VRINGS ) return - EINVAL ; dd_config = kzalloc ( mic_desc_size ( & dd ) , GFP_KERNEL ) ; if ( ! dd_config ) return - ENOMEM ; if ( copy_from_user ( dd_config , argp , mic_desc_size ( & dd ) ) ) { ret = - EFAULT ; goto free_ret ; } <S2SV_StartBug> mutex_lock ( & vdev -> vdev_mutex ) ; <S2SV_EndBug> mutex_lock ( & vi -> vop_mutex ) ; ret = vop_virtio_add_device ( vdev , dd_config ) ; if ( ret ) goto unlock_ret ; list_add_tail ( & vdev -> list , & vi -> vdev_list ) ; unlock_ret : mutex_unlock ( & vi -> vop_mutex ) ; mutex_unlock ( & vdev -> vdev_mutex ) ; free_ret : kfree ( dd_config ) ; return ret ; } case MIC_VIRTIO_COPY_DESC : { struct mic_copy_desc copy ; mutex_lock ( & vdev -> vdev_mutex ) ; ret = vop_vdev_inited ( vdev ) ; if ( ret ) goto _unlock_ret ; if ( copy_from_user ( & copy , argp , sizeof ( copy ) ) ) { ret = - EFAULT ; goto _unlock_ret ; } ret = vop_virtio_copy_desc ( vdev , & copy ) ; if ( ret < 0 ) goto _unlock_ret ; if ( copy_to_user ( & ( ( struct mic_copy_desc __user * ) argp ) -> out_len , & copy . out_len , sizeof ( copy . out_len ) ) ) ret = - EFAULT ; _unlock_ret : mutex_unlock ( & vdev -> vdev_mutex ) ; return ret ; } case MIC_VIRTIO_CONFIG_CHANGE : { void * buf ; mutex_lock ( & vdev -> vdev_mutex ) ; ret = vop_vdev_inited ( vdev ) ; if ( ret ) goto __unlock_ret ; buf = kzalloc ( vdev -> dd -> config_len , GFP_KERNEL ) ; if ( ! buf ) { ret = - ENOMEM ; goto __unlock_ret ; } if ( copy_from_user ( buf , argp , vdev -> dd -> config_len ) ) { ret = - EFAULT ; goto done ; } ret = vop_virtio_config_change ( vdev , buf ) ; done : kfree ( buf ) ; __unlock_ret : mutex_unlock ( & vdev -> vdev_mutex ) ; return ret ; } default : return - ENOIOCTLCMD ; } ; return 0 ; }","<S2SV_ModStart> free_ret ; } if ( memcmp ( & dd , dd_config , sizeof ( dd ) ) ) { ret = - EINVAL ; goto free_ret ; }",torvalds@linux/9bf292bfca94694a721449e3fd752493856710f6,CVE-2016-5728,https://github.com/torvalds/linux/commit/9bf292bfca94694a721449e3fd752493856710f6,2016-06-27T10:59Z
CWE-401,"CWE-000 static int ath10k_usb_hif_tx_sg ( struct ath10k * ar , u8 pipe_id , struct ath10k_hif_sg_item * items , int n_items ) { struct ath10k_usb * ar_usb = ath10k_usb_priv ( ar ) ; struct ath10k_usb_pipe * pipe = & ar_usb -> pipes [ pipe_id ] ; struct ath10k_urb_context * urb_context ; struct sk_buff * skb ; struct urb * urb ; int ret , i ; for ( i = 0 ; i < n_items ; i ++ ) { urb_context = ath10k_usb_alloc_urb_from_pipe ( pipe ) ; if ( ! urb_context ) { ret = - ENOMEM ; goto err ; } skb = items [ i ] . transfer_context ; urb_context -> skb = skb ; urb = usb_alloc_urb ( 0 , GFP_ATOMIC ) ; if ( ! urb ) { ret = - ENOMEM ; goto err_free_urb_to_pipe ; } usb_fill_bulk_urb ( urb , ar_usb -> udev , pipe -> usb_pipe_handle , skb -> data , skb -> len , ath10k_usb_transmit_complete , urb_context ) ; if ( ! ( skb -> len % pipe -> max_packet_size ) ) { urb -> transfer_flags |= URB_ZERO_PACKET ; } usb_anchor_urb ( urb , & pipe -> urb_submitted ) ; ret = usb_submit_urb ( urb , GFP_ATOMIC ) ; if ( ret ) { ath10k_dbg ( ar , ATH10K_DBG_USB_BULK , ""usb<S2SV_blank>bulk<S2SV_blank>transmit<S2SV_blank>failed:<S2SV_blank>%d\\n"" , ret ) ; usb_unanchor_urb ( urb ) ; <S2SV_StartBug> ret = - EINVAL ; <S2SV_EndBug> goto err_free_urb_to_pipe ; } usb_free_urb ( urb ) ; } return 0 ; err_free_urb_to_pipe : ath10k_usb_free_urb_to_pipe ( urb_context -> pipe , urb_context ) ; err : return ret ; }",<S2SV_ModStart> urb ) ; usb_free_urb ( urb ) ;,torvalds@linux/b8d17e7d93d2beb89e4f34c59996376b8b544792,CVE-2019-19078,https://github.com/torvalds/linux/commit/b8d17e7d93d2beb89e4f34c59996376b8b544792,2019-11-18T06:15Z
CWE-362,"CWE-362 unsigned long insn_get_seg_base ( struct pt_regs * regs , int seg_reg_idx ) { <S2SV_StartBug> struct desc_struct * desc ; <S2SV_EndBug> short sel ; sel = get_segment_selector ( regs , seg_reg_idx ) ; if ( sel < 0 ) return - 1L ; if ( v8086_mode ( regs ) ) return ( unsigned long ) ( sel << 4 ) ; if ( user_64bit_mode ( regs ) ) { unsigned long base ; if ( seg_reg_idx == INAT_SEG_REG_FS ) rdmsrl ( MSR_FS_BASE , base ) ; else if ( seg_reg_idx == INAT_SEG_REG_GS ) rdmsrl ( MSR_KERNEL_GS_BASE , base ) ; else base = 0 ; return base ; } if ( ! sel ) return - 1L ; <S2SV_StartBug> desc = get_desc ( sel ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! desc ) <S2SV_EndBug> return - 1L ; <S2SV_StartBug> return get_desc_base ( desc ) ; <S2SV_EndBug> }","<S2SV_ModStart> { struct desc_struct <S2SV_ModEnd> desc ; short <S2SV_ModStart> - 1L ; <S2SV_ModEnd> if ( ! <S2SV_ModStart> if ( ! get_desc ( & desc , sel ) <S2SV_ModEnd> ) return - <S2SV_ModStart> return get_desc_base ( &",torvalds@linux/de9f869616dd95e95c00bdd6b0fcd3421e8a4323,CVE-2019-13233,https://github.com/torvalds/linux/commit/de9f869616dd95e95c00bdd6b0fcd3421e8a4323,2019-07-04T13:15Z
CWE-125,"CWE-125 static stmt_ty ast_for_for_stmt ( struct compiling * c , const node * n0 , bool is_async ) { const node * const n = is_async ? CHILD ( n0 , 1 ) : n0 ; asdl_seq * _target , * seq = NULL , * suite_seq ; expr_ty expression ; expr_ty target , first ; const node * node_target ; int end_lineno , end_col_offset ; <S2SV_StartBug> REQ ( n , for_stmt ) ; <S2SV_EndBug> <S2SV_StartBug> if ( NCH ( n ) == 9 ) { <S2SV_EndBug> <S2SV_StartBug> seq = ast_for_suite ( c , CHILD ( n , 8 ) ) ; <S2SV_EndBug> if ( ! seq ) return NULL ; } node_target = CHILD ( n , 1 ) ; _target = ast_for_exprlist ( c , node_target , Store ) ; if ( ! _target ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( _target , 0 ) ; if ( NCH ( node_target ) == 1 ) target = first ; else target = Tuple ( _target , Store , first -> lineno , first -> col_offset , node_target -> n_end_lineno , node_target -> n_end_col_offset , c -> c_arena ) ; expression = ast_for_testlist ( c , CHILD ( n , 3 ) ) ; if ( ! expression ) return NULL ; <S2SV_StartBug> suite_seq = ast_for_suite ( c , CHILD ( n , 5 ) ) ; <S2SV_EndBug> if ( ! suite_seq ) return NULL ; if ( seq != NULL ) { get_last_end_pos ( seq , & end_lineno , & end_col_offset ) ; } else { get_last_end_pos ( suite_seq , & end_lineno , & end_col_offset ) ; } <S2SV_StartBug> if ( is_async ) <S2SV_EndBug> <S2SV_StartBug> return AsyncFor ( target , expression , suite_seq , seq , <S2SV_EndBug> LINENO ( n0 ) , n0 -> n_col_offset , end_lineno , end_col_offset , c -> c_arena ) ; else <S2SV_StartBug> return For ( target , expression , suite_seq , seq , <S2SV_EndBug> LINENO ( n ) , n -> n_col_offset , end_lineno , end_col_offset , c -> c_arena ) ; }","<S2SV_ModStart> , end_col_offset ; int has_type_comment ; string type_comment ; <S2SV_ModStart> , for_stmt ) ; has_type_comment = TYPE ( CHILD ( n , 5 ) ) == TYPE_COMMENT <S2SV_ModStart> ) == 9 + has_type_comment <S2SV_ModStart> n , 8 + has_type_comment <S2SV_ModStart> n , 5 + has_type_comment <S2SV_ModStart> } if ( has_type_comment ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , 5 ) ) ; if ( ! type_comment ) return NULL ; } else type_comment = NULL ; if ( <S2SV_ModStart> , seq , type_comment , <S2SV_ModStart> suite_seq , seq , type_comment",python@typed_ast/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,CVE-2019-19275,https://github.com/python/typed_ast/commit/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,2019-11-26T15:15Z
CWE-125,"CWE-125 <S2SV_StartBug> void nego_process_negotiation_failure ( rdpNego * nego , wStream * s ) <S2SV_EndBug> { BYTE flags ; UINT16 length ; UINT32 failureCode ; <S2SV_StartBug> WLog_DBG ( TAG , ""RDP_NEG_FAILURE"" ) ; <S2SV_EndBug> Stream_Read_UINT8 ( s , flags ) ; Stream_Read_UINT16 ( s , length ) ; Stream_Read_UINT32 ( s , failureCode ) ; switch ( failureCode ) { case SSL_REQUIRED_BY_SERVER : WLog_WARN ( TAG , ""Error:<S2SV_blank>SSL_REQUIRED_BY_SERVER"" ) ; break ; case SSL_NOT_ALLOWED_BY_SERVER : WLog_WARN ( TAG , ""Error:<S2SV_blank>SSL_NOT_ALLOWED_BY_SERVER"" ) ; nego -> sendNegoData = TRUE ; break ; case SSL_CERT_NOT_ON_SERVER : WLog_ERR ( TAG , ""Error:<S2SV_blank>SSL_CERT_NOT_ON_SERVER"" ) ; nego -> sendNegoData = TRUE ; break ; case INCONSISTENT_FLAGS : WLog_ERR ( TAG , ""Error:<S2SV_blank>INCONSISTENT_FLAGS"" ) ; break ; case HYBRID_REQUIRED_BY_SERVER : WLog_WARN ( TAG , ""Error:<S2SV_blank>HYBRID_REQUIRED_BY_SERVER"" ) ; break ; default : WLog_ERR ( TAG , ""Error:<S2SV_blank>Unknown<S2SV_blank>protocol<S2SV_blank>security<S2SV_blank>error<S2SV_blank>%"" PRIu32 """" , failureCode ) ; break ; } nego -> state = NEGO_STATE_FAIL ; <S2SV_StartBug> } <S2SV_EndBug>","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> BOOL <S2SV_ModEnd> nego_process_negotiation_failure ( rdpNego <S2SV_ModStart> , ""RDP_NEG_FAILURE"" ) ; if ( Stream_GetRemainingLength ( s ) < 7 ) return FALSE <S2SV_ModStart> = NEGO_STATE_FAIL ; return TRUE ;",FreeRDP@FreeRDP/6b485b146a1b9d6ce72dfd7b5f36456c166e7a16,CVE-2020-11089,https://github.com/FreeRDP/FreeRDP/commit/6b485b146a1b9d6ce72dfd7b5f36456c166e7a16,2020-05-29T20:15Z
CWE-119,"CWE-119 int vp8dx_get_raw_frame ( VP8D_COMP * pbi , YV12_BUFFER_CONFIG * sd , int64_t * time_stamp , int64_t * time_end_stamp , vp8_ppflags_t * flags ) { int ret = - 1 ; if ( pbi -> ready_for_new_data == 1 ) return ret ; if ( pbi -> common . show_frame == 0 ) return ret ; pbi -> ready_for_new_data = 1 ; * time_stamp = pbi -> last_time_stamp ; * time_end_stamp = 0 ; # if CONFIG_POSTPROC ret = vp8_post_proc_frame ( & pbi -> common , sd , flags ) ; # else <S2SV_StartBug> if ( pbi -> common . frame_to_show ) <S2SV_EndBug> { * sd = * pbi -> common . frame_to_show ; sd -> y_width = pbi -> common . Width ; sd -> y_height = pbi -> common . Height ; sd -> uv_height = pbi -> common . Height / 2 ; ret = 0 ; } else { ret = - 1 ; } # endif vp8_clear_system_state ( ) ; return ret ; }",<S2SV_ModStart> ; # else ( void ) flags ;,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-119,"CWE-119 int VP8_UVSSE ( MACROBLOCK * x ) { unsigned char * uptr , * vptr ; unsigned char * upred_ptr = ( * ( x -> block [ 16 ] . base_src ) + x -> block [ 16 ] . src ) ; unsigned char * vpred_ptr = ( * ( x -> block [ 20 ] . base_src ) + x -> block [ 20 ] . src ) ; int uv_stride = x -> block [ 16 ] . src_stride ; unsigned int sse1 = 0 ; unsigned int sse2 = 0 ; int mv_row = x -> e_mbd . mode_info_context -> mbmi . mv . as_mv . row ; int mv_col = x -> e_mbd . mode_info_context -> mbmi . mv . as_mv . col ; int offset ; int pre_stride = x -> e_mbd . pre . uv_stride ; if ( mv_row < 0 ) mv_row -= 1 ; else mv_row += 1 ; if ( mv_col < 0 ) mv_col -= 1 ; else mv_col += 1 ; mv_row /= 2 ; mv_col /= 2 ; offset = ( mv_row >> 3 ) * pre_stride + ( mv_col >> 3 ) ; uptr = x -> e_mbd . pre . u_buffer + offset ; vptr = x -> e_mbd . pre . v_buffer + offset ; if ( ( mv_row | mv_col ) & 7 ) { <S2SV_StartBug> vp8_sub_pixel_variance8x8 ( uptr , pre_stride , <S2SV_EndBug> mv_col & 7 , mv_row & 7 , upred_ptr , uv_stride , & sse2 ) ; <S2SV_StartBug> vp8_sub_pixel_variance8x8 ( vptr , pre_stride , <S2SV_EndBug> mv_col & 7 , mv_row & 7 , vpred_ptr , uv_stride , & sse1 ) ; sse2 += sse1 ; } else { <S2SV_StartBug> vp8_variance8x8 ( uptr , pre_stride , <S2SV_EndBug> upred_ptr , uv_stride , & sse2 ) ; <S2SV_StartBug> vp8_variance8x8 ( vptr , pre_stride , <S2SV_EndBug> vpred_ptr , uv_stride , & sse1 ) ; sse2 += sse1 ; } return sse2 ; }","<S2SV_ModStart> 7 ) { vpx_sub_pixel_variance8x8 <S2SV_ModEnd> ( uptr , <S2SV_ModStart> sse2 ) ; vpx_sub_pixel_variance8x8 <S2SV_ModEnd> ( vptr , <S2SV_ModStart> } else { vpx_variance8x8 <S2SV_ModEnd> ( uptr , <S2SV_ModStart> sse2 ) ; vpx_variance8x8 <S2SV_ModEnd> ( vptr ,",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-189,"CWE-189 int i915_gem_execbuffer2 ( struct drm_device * dev , void * data , struct drm_file * file ) { struct drm_i915_gem_execbuffer2 * args = data ; struct drm_i915_gem_exec_object2 * exec2_list = NULL ; int ret ; <S2SV_StartBug> if ( args -> buffer_count < 1 ) { <S2SV_EndBug> DRM_DEBUG ( ""execbuf2<S2SV_blank>with<S2SV_blank>%d<S2SV_blank>buffers\\n"" , args -> buffer_count ) ; return - EINVAL ; } exec2_list = kmalloc ( sizeof ( * exec2_list ) * args -> buffer_count , GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY ) ; if ( exec2_list == NULL ) exec2_list = drm_malloc_ab ( sizeof ( * exec2_list ) , args -> buffer_count ) ; if ( exec2_list == NULL ) { DRM_DEBUG ( ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>exec<S2SV_blank>list<S2SV_blank>for<S2SV_blank>%d<S2SV_blank>buffers\\n"" , args -> buffer_count ) ; return - ENOMEM ; } ret = copy_from_user ( exec2_list , ( struct drm_i915_relocation_entry __user * ) ( uintptr_t ) args -> buffers_ptr , sizeof ( * exec2_list ) * args -> buffer_count ) ; if ( ret != 0 ) { DRM_DEBUG ( ""copy<S2SV_blank>%d<S2SV_blank>exec<S2SV_blank>entries<S2SV_blank>failed<S2SV_blank>%d\\n"" , args -> buffer_count , ret ) ; drm_free_large ( exec2_list ) ; return - EFAULT ; } ret = i915_gem_do_execbuffer ( dev , data , file , args , exec2_list ) ; if ( ! ret ) { ret = copy_to_user ( ( struct drm_i915_relocation_entry __user * ) ( uintptr_t ) args -> buffers_ptr , exec2_list , sizeof ( * exec2_list ) * args -> buffer_count ) ; if ( ret ) { ret = - EFAULT ; DRM_DEBUG ( ""failed<S2SV_blank>to<S2SV_blank>copy<S2SV_blank>%d<S2SV_blank>exec<S2SV_blank>entries<S2SV_blank>"" ""back<S2SV_blank>to<S2SV_blank>user<S2SV_blank>(%d)\\n"" , args -> buffer_count , ret ) ; } } drm_free_large ( exec2_list ) ; return ret ; }",<S2SV_ModStart> buffer_count < 1 || args -> buffer_count > UINT_MAX / sizeof ( * exec2_list ),torvalds@linux/ed8cd3b2cd61004cab85380c52b1817aca1ca49b,CVE-2012-2383,https://github.com/torvalds/linux/commit/ed8cd3b2cd61004cab85380c52b1817aca1ca49b,2012-06-13T10:24Z
CWE-264,CWE-264 int rpc_type_of_NPNVariable ( int variable ) { int type ; switch ( variable ) { case NPNVjavascriptEnabledBool : case NPNVasdEnabledBool : case NPNVisOfflineBool : case NPNVSupportsXEmbedBool : <S2SV_StartBug> case NPNVSupportsWindowless : <S2SV_EndBug> type = RPC_TYPE_BOOLEAN ; break ; case NPNVToolkit : case NPNVnetscapeWindow : type = RPC_TYPE_UINT32 ; break ; case NPNVWindowNPObject : case NPNVPluginElementNPObject : type = RPC_TYPE_NP_OBJECT ; break ; default : type = RPC_ERROR_GENERIC ; break ; } return type ; },<S2SV_ModStart> : case NPNVSupportsWindowless : case NPNVprivateModeBool : case NPNVsupportsAdvancedKeyHandling,davidben@nspluginwrapper/7e4ab8e1189846041f955e6c83f72bc1624e7a98,CVE-2011-2486,https://github.com/davidben/nspluginwrapper/commit/7e4ab8e1189846041f955e6c83f72bc1624e7a98,2012-11-19T12:10Z
CWE-119,"CWE-119 <S2SV_StartBug> int get_down2_steps ( int in_length , int out_length ) { <S2SV_EndBug> int steps = 0 ; int proj_in_length ; while ( ( proj_in_length = get_down2_length ( in_length , 1 ) ) >= out_length ) { ++ steps ; in_length = proj_in_length ; } return steps ; }",<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-787,"CWE-787 static int decode_zbuf ( AVBPrint * bp , const uint8_t * data , const uint8_t * data_end ) { z_stream zstream ; unsigned char * buf ; unsigned buf_size ; int ret ; zstream . zalloc = ff_png_zalloc ; zstream . zfree = ff_png_zfree ; zstream . opaque = NULL ; if ( inflateInit ( & zstream ) != Z_OK ) return AVERROR_EXTERNAL ; zstream . next_in = ( unsigned char * ) data ; zstream . avail_in = data_end - data ; av_bprint_init ( bp , 0 , - 1 ) ; while ( zstream . avail_in > 0 ) { <S2SV_StartBug> av_bprint_get_buffer ( bp , 1 , & buf , & buf_size ) ; <S2SV_EndBug> if ( ! buf_size ) { ret = AVERROR ( ENOMEM ) ; goto fail ; } zstream . next_out = buf ; <S2SV_StartBug> zstream . avail_out = buf_size ; <S2SV_EndBug> ret = inflate ( & zstream , Z_PARTIAL_FLUSH ) ; if ( ret != Z_OK && ret != Z_STREAM_END ) { ret = AVERROR_EXTERNAL ; goto fail ; } bp -> len += zstream . next_out - buf ; if ( ret == Z_STREAM_END ) break ; } inflateEnd ( & zstream ) ; bp -> str [ bp -> len ] = 0 ; return 0 ; fail : inflateEnd ( & zstream ) ; av_bprint_finalize ( bp , NULL ) ; return ret ; }","<S2SV_ModStart> ( bp , 2 , & buf , & buf_size ) ; if ( buf_size < 2 <S2SV_ModEnd> ) { ret <S2SV_ModStart> avail_out = buf_size - 1",FFmpeg@FFmpeg/e371f031b942d73e02c090170975561fabd5c264,CVE-2017-7866,https://github.com/FFmpeg/FFmpeg/commit/e371f031b942d73e02c090170975561fabd5c264,2017-04-14T04:59Z
CWE-119,"CWE-119 static void Scale2D ( unsigned char * source , int source_pitch , unsigned int source_width , unsigned int source_height , unsigned char * dest , int dest_pitch , unsigned int dest_width , unsigned int dest_height , unsigned char * temp_area , unsigned char temp_area_height , unsigned int hscale , unsigned int hratio , unsigned int vscale , unsigned int vratio , unsigned int interlaced ) { int i , j , k ; int bands ; int dest_band_height ; int source_band_height ; typedef void ( * Scale1D ) ( const unsigned char * source , int source_step , unsigned int source_scale , unsigned int source_length , unsigned char * dest , int dest_step , unsigned int dest_scale , unsigned int dest_length ) ; Scale1D Scale1Dv = scale1d_c ; Scale1D Scale1Dh = scale1d_c ; void ( * horiz_line_scale ) ( const unsigned char * , unsigned int , unsigned char * , unsigned int ) = NULL ; void ( * vert_band_scale ) ( unsigned char * , unsigned int , unsigned char * , unsigned int , unsigned int ) = NULL ; int ratio_scalable = 1 ; int interpolation = 0 ; unsigned char * source_base ; unsigned char * line_src ; source_base = ( unsigned char * ) source ; if ( source_pitch < 0 ) { int offset ; offset = ( source_height - 1 ) ; offset *= source_pitch ; source_base += offset ; } switch ( hratio * 10 / hscale ) { case 8 : horiz_line_scale = vp8_horizontal_line_5_4_scale ; break ; case 6 : horiz_line_scale = vp8_horizontal_line_5_3_scale ; break ; case 5 : horiz_line_scale = vp8_horizontal_line_2_1_scale ; break ; default : ratio_scalable = 0 ; break ; } switch ( vratio * 10 / vscale ) { case 8 : vert_band_scale = vp8_vertical_band_5_4_scale ; source_band_height = 5 ; dest_band_height = 4 ; break ; case 6 : vert_band_scale = vp8_vertical_band_5_3_scale ; source_band_height = 5 ; dest_band_height = 3 ; break ; case 5 : if ( interlaced ) { vert_band_scale = vp8_vertical_band_2_1_scale ; } else { interpolation = 1 ; vert_band_scale = vp8_vertical_band_2_1_scale_i ; } source_band_height = 2 ; dest_band_height = 1 ; break ; default : ratio_scalable = 0 ; break ; } if ( ratio_scalable ) { if ( source_height == dest_height ) { for ( k = 0 ; k < ( int ) dest_height ; k ++ ) { horiz_line_scale ( source , source_width , dest , dest_width ) ; source += source_pitch ; dest += dest_pitch ; } return ; } if ( interpolation ) { if ( source < source_base ) source = source_base ; horiz_line_scale ( source , source_width , temp_area , dest_width ) ; } for ( k = 0 ; k < ( int ) ( dest_height + dest_band_height - 1 ) / dest_band_height ; k ++ ) { for ( i = 0 ; i < source_band_height ; i ++ ) { line_src = ( unsigned char * ) source + i * source_pitch ; if ( line_src < source_base ) line_src = source_base ; horiz_line_scale ( line_src , source_width , temp_area + ( i + 1 ) * dest_pitch , dest_width ) ; } vert_band_scale ( temp_area + dest_pitch , dest_pitch , dest , dest_pitch , dest_width ) ; if ( interpolation ) <S2SV_StartBug> vpx_memcpy ( temp_area , temp_area + source_band_height * dest_pitch , dest_width ) ; <S2SV_EndBug> source += ( unsigned long ) source_band_height * source_pitch ; dest += ( unsigned long ) dest_band_height * dest_pitch ; } return ; } if ( hscale == 2 && hratio == 1 ) Scale1Dh = scale1d_2t1_ps ; if ( vscale == 2 && vratio == 1 ) { if ( interlaced ) Scale1Dv = scale1d_2t1_ps ; else Scale1Dv = scale1d_2t1_i ; } if ( source_height == dest_height ) { for ( k = 0 ; k < ( int ) dest_height ; k ++ ) { Scale1Dh ( source , 1 , hscale , source_width + 1 , dest , 1 , hratio , dest_width ) ; source += source_pitch ; dest += dest_pitch ; } return ; } if ( dest_height > source_height ) { dest_band_height = temp_area_height - 1 ; source_band_height = dest_band_height * source_height / dest_height ; } else { source_band_height = temp_area_height - 1 ; dest_band_height = source_band_height * vratio / vscale ; } Scale1Dh ( source , 1 , hscale , source_width + 1 , temp_area , 1 , hratio , dest_width ) ; bands = ( dest_height + dest_band_height - 1 ) / dest_band_height ; for ( k = 0 ; k < bands ; k ++ ) { for ( i = 1 ; i < source_band_height + 1 ; i ++ ) { if ( k * source_band_height + i < ( int ) source_height ) { Scale1Dh ( source + i * source_pitch , 1 , hscale , source_width + 1 , temp_area + i * dest_pitch , 1 , hratio , dest_width ) ; } else { <S2SV_StartBug> vpx_memcpy ( temp_area + i * dest_pitch , temp_area + ( i - 1 ) * dest_pitch , dest_pitch ) ; <S2SV_EndBug> } } for ( j = 0 ; j < ( int ) dest_width ; j ++ ) { Scale1Dv ( & temp_area [ j ] , dest_pitch , vscale , source_band_height + 1 , & dest [ j ] , dest_pitch , vratio , dest_band_height ) ; } <S2SV_StartBug> vpx_memcpy ( temp_area , temp_area + source_band_height * dest_pitch , dest_pitch ) ; <S2SV_EndBug> source += source_band_height * source_pitch ; dest += dest_band_height * dest_pitch ; } }","<S2SV_ModStart> ( interpolation ) memcpy <S2SV_ModEnd> ( temp_area , <S2SV_ModStart> } else { memcpy <S2SV_ModEnd> ( temp_area + <S2SV_ModStart> ) ; } memcpy <S2SV_ModEnd> ( temp_area ,",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-399,"CWE-399 long pipe_fcntl ( struct file * file , unsigned int cmd , unsigned long arg ) { struct pipe_inode_info * pipe ; long ret ; pipe = get_pipe_info ( file ) ; if ( ! pipe ) return - EBADF ; __pipe_lock ( pipe ) ; switch ( cmd ) { case F_SETPIPE_SZ : { unsigned int size , nr_pages ; size = round_pipe_size ( arg ) ; nr_pages = size >> PAGE_SHIFT ; ret = - EINVAL ; if ( ! nr_pages ) goto out ; if ( ! capable ( CAP_SYS_RESOURCE ) && size > pipe_max_size ) { ret = - EPERM ; goto out ; <S2SV_StartBug> } <S2SV_EndBug> ret = pipe_set_size ( pipe , nr_pages ) ; break ; } case F_GETPIPE_SZ : ret = pipe -> buffers * PAGE_SIZE ; break ; default : ret = - EINVAL ; break ; } out : __pipe_unlock ( pipe ) ; return ret ; }",<S2SV_ModStart> out ; } else if ( ( too_many_pipe_buffers_hard ( pipe -> user ) || too_many_pipe_buffers_soft ( pipe -> user ) ) && ! capable ( CAP_SYS_RESOURCE ) && ! capable ( CAP_SYS_ADMIN ) ) { ret = - EPERM ; goto out ; },torvalds@linux/759c01142a5d0f364a462346168a56de28a80f52,CVE-2016-2847,https://github.com/torvalds/linux/commit/759c01142a5d0f364a462346168a56de28a80f52,2016-04-27T17:59Z
CWE-20,"CWE-20 error_t enc624j600SendPacket ( NetInterface * interface , const NetBuffer * buffer , size_t offset , NetTxAncillary * ancillary ) { size_t length ; length = netBufferGetLength ( buffer ) - offset ; if ( length > 1536 ) { osSetEvent ( & interface -> nicTxEvent ) ; return ERROR_INVALID_LENGTH ; } if ( ! interface -> linkState ) { osSetEvent ( & interface -> nicTxEvent ) ; return NO_ERROR ; } <S2SV_StartBug> if ( enc624j600ReadReg ( interface , ENC624J600_REG_ECON1 ) & ECON1_TXRTS ) <S2SV_EndBug> { return ERROR_FAILURE ; } <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_EGPWRPT , ENC624J600_TX_BUFFER_START ) ; <S2SV_EndBug> enc624j600WriteBuffer ( interface , ENC624J600_CMD_WGPDATA , buffer , offset ) ; <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_ETXST , ENC624J600_TX_BUFFER_START ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_ETXLEN , length ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600ClearBit ( interface , ENC624J600_REG_EIR , EIR_TXIF | EIR_TXABTIF ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600SetBit ( interface , ENC624J600_REG_ECON1 , ECON1_TXRTS ) ; <S2SV_EndBug> return NO_ERROR ; }","<S2SV_ModStart> ( interface , ENC624J600_ECON1 ) & ENC624J600_ECON1_TXRTS <S2SV_ModEnd> ) { return <S2SV_ModStart> ( interface , ENC624J600_EGPWRPT <S2SV_ModEnd> , ENC624J600_TX_BUFFER_START ) <S2SV_ModStart> ( interface , ENC624J600_ETXST <S2SV_ModEnd> , ENC624J600_TX_BUFFER_START ) <S2SV_ModStart> ( interface , ENC624J600_ETXLEN <S2SV_ModEnd> , length ) <S2SV_ModStart> ( interface , ENC624J600_EIR , ENC624J600_EIR_TXIF | ENC624J600_EIR_TXABTIF <S2SV_ModEnd> ) ; enc624j600SetBit <S2SV_ModStart> ( interface , ENC624J600_ECON1 , ENC624J600_ECON1_TXRTS <S2SV_ModEnd> ) ; return",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z
CWE-119,"CWE-119 SQLRETURN SQLSetDescField ( SQLHDESC descriptor_handle , SQLSMALLINT rec_number , SQLSMALLINT field_identifier , SQLPOINTER value , SQLINTEGER buffer_length ) { DMHDESC descriptor = ( DMHDESC ) descriptor_handle ; SQLRETURN ret ; SQLCHAR s1 [ 100 + LOG_MESSAGE_LEN ] ; int isStrField = 0 ; if ( ! __validate_desc ( descriptor ) ) { dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , ""Error:<S2SV_blank>SQL_INVALID_HANDLE"" ) ; return SQL_INVALID_HANDLE ; } function_entry ( descriptor ) ; if ( log_info . log_flag ) { <S2SV_StartBug> sprintf ( descriptor -> msg , ""\\n\\t\\tEntry:\\\n<S2SV_blank>\\n\\t\\t\\tDescriptor<S2SV_blank>=<S2SV_blank>%p\\\n<S2SV_blank>\\n\\t\\t\\tRec<S2SV_blank>Number<S2SV_blank>=<S2SV_blank>%d\\\n<S2SV_blank>\\n\\t\\t\\tField<S2SV_blank>Ident<S2SV_blank>=<S2SV_blank>%s\\\n<S2SV_blank>\\n\\t\\t\\tValue<S2SV_blank>=<S2SV_blank>%p\\\n<S2SV_blank>\\n\\t\\t\\tBuffer<S2SV_blank>Length<S2SV_blank>=<S2SV_blank>%d"" , <S2SV_EndBug> descriptor , rec_number , __desc_attr_as_string ( s1 , field_identifier ) , value , ( int ) buffer_length ) ; dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , descriptor -> msg ) ; } thread_protect ( SQL_HANDLE_DESC , descriptor ) ; if ( descriptor -> connection -> state < STATE_C4 ) { dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , ""Error:<S2SV_blank>HY010"" ) ; __post_internal_error ( & descriptor -> error , ERROR_HY010 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } if ( __check_stmt_from_desc ( descriptor , STATE_S8 ) || __check_stmt_from_desc ( descriptor , STATE_S9 ) || __check_stmt_from_desc ( descriptor , STATE_S10 ) || __check_stmt_from_desc ( descriptor , STATE_S11 ) || __check_stmt_from_desc ( descriptor , STATE_S12 ) || __check_stmt_from_desc ( descriptor , STATE_S13 ) || __check_stmt_from_desc ( descriptor , STATE_S14 ) || __check_stmt_from_desc ( descriptor , STATE_S15 ) ) { dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , ""Error:<S2SV_blank>HY010"" ) ; __post_internal_error ( & descriptor -> error , ERROR_HY010 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } if ( rec_number < 0 ) { __post_internal_error ( & descriptor -> error , ERROR_07009 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } switch ( field_identifier ) { case SQL_DESC_ALLOC_TYPE : case SQL_DESC_ARRAY_SIZE : case SQL_DESC_ARRAY_STATUS_PTR : case SQL_DESC_BIND_OFFSET_PTR : case SQL_DESC_BIND_TYPE : case SQL_DESC_COUNT : case SQL_DESC_ROWS_PROCESSED_PTR : case SQL_DESC_AUTO_UNIQUE_VALUE : case SQL_DESC_CASE_SENSITIVE : case SQL_DESC_CONCISE_TYPE : case SQL_DESC_DATA_PTR : case SQL_DESC_DATETIME_INTERVAL_CODE : case SQL_DESC_DATETIME_INTERVAL_PRECISION : case SQL_DESC_DISPLAY_SIZE : case SQL_DESC_FIXED_PREC_SCALE : case SQL_DESC_INDICATOR_PTR : case SQL_DESC_LENGTH : case SQL_DESC_NULLABLE : case SQL_DESC_NUM_PREC_RADIX : case SQL_DESC_OCTET_LENGTH : case SQL_DESC_OCTET_LENGTH_PTR : case SQL_DESC_PARAMETER_TYPE : case SQL_DESC_PRECISION : case SQL_DESC_ROWVER : case SQL_DESC_SCALE : case SQL_DESC_SEARCHABLE : case SQL_DESC_TYPE : case SQL_DESC_UNNAMED : case SQL_DESC_UNSIGNED : case SQL_DESC_UPDATABLE : isStrField = 0 ; break ; case SQL_DESC_BASE_COLUMN_NAME : case SQL_DESC_BASE_TABLE_NAME : case SQL_DESC_CATALOG_NAME : case SQL_DESC_LABEL : case SQL_DESC_LITERAL_PREFIX : case SQL_DESC_LITERAL_SUFFIX : case SQL_DESC_LOCAL_TYPE_NAME : case SQL_DESC_NAME : case SQL_DESC_SCHEMA_NAME : case SQL_DESC_TABLE_NAME : case SQL_DESC_TYPE_NAME : isStrField = 1 ; break ; default : isStrField = buffer_length != SQL_IS_POINTER && buffer_length != SQL_IS_INTEGER && buffer_length != SQL_IS_UINTEGER && buffer_length != SQL_IS_SMALLINT && buffer_length != SQL_IS_USMALLINT ; } if ( isStrField && buffer_length < 0 && buffer_length != SQL_NTS ) { __post_internal_error ( & descriptor -> error , ERROR_HY090 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } <S2SV_StartBug> if ( field_identifier == SQL_DESC_COUNT && ( SQLINTEGER ) value < 0 ) <S2SV_EndBug> { __post_internal_error ( & descriptor -> error , ERROR_07009 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } <S2SV_StartBug> if ( field_identifier == SQL_DESC_PARAMETER_TYPE && value != SQL_PARAM_INPUT <S2SV_EndBug> <S2SV_StartBug> && value != SQL_PARAM_OUTPUT && value != SQL_PARAM_INPUT_OUTPUT && <S2SV_EndBug> <S2SV_StartBug> value != SQL_PARAM_INPUT_OUTPUT_STREAM && value != SQL_PARAM_OUTPUT_STREAM ) <S2SV_EndBug> { __post_internal_error ( & descriptor -> error , ERROR_HY105 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } if ( CHECK_SQLSETDESCFIELD ( descriptor -> connection ) ) { ret = SQLSETDESCFIELD ( descriptor -> connection , descriptor -> driver_desc , rec_number , field_identifier , value , buffer_length ) ; } else if ( CHECK_SQLSETDESCFIELDW ( descriptor -> connection ) ) { SQLWCHAR * s1 = NULL ; if ( isStrField ) { s1 = ansi_to_unicode_alloc ( value , buffer_length , descriptor -> connection , NULL ) ; if ( SQL_NTS != buffer_length ) { buffer_length *= sizeof ( SQLWCHAR ) ; } } else { s1 = value ; } ret = SQLSETDESCFIELDW ( descriptor -> connection , descriptor -> driver_desc , rec_number , field_identifier , s1 , buffer_length ) ; if ( isStrField ) { if ( s1 ) free ( s1 ) ; } } else { dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , ""Error:<S2SV_blank>IM001"" ) ; __post_internal_error ( & descriptor -> error , ERROR_IM001 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } if ( log_info . log_flag ) { sprintf ( descriptor -> msg , ""\\n\\t\\tExit:[%s]"" , __get_return_status ( ret , s1 ) ) ; dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , descriptor -> msg ) ; } return function_return ( SQL_HANDLE_DESC , descriptor , ret ) ; }","<S2SV_ModStart> -> msg , ""\\n\\t\\tEntry:\\\n\\n\\t\\t\\tDescriptor<S2SV_blank>=<S2SV_blank>%p\\\n\\n\\t\\t\\tRec<S2SV_blank>Number<S2SV_blank>=<S2SV_blank>%d\\\n\\n\\t\\t\\tField<S2SV_blank>Ident<S2SV_blank>=<S2SV_blank>%s\\\n\\n\\t\\t\\tValue<S2SV_blank>=<S2SV_blank>%p\\\n\\n\\t\\t\\tBuffer<S2SV_blank>Length<S2SV_blank>=<S2SV_blank>%d"" <S2SV_ModEnd> , descriptor , <S2SV_ModStart> SQL_DESC_COUNT && ( intptr_t <S2SV_ModEnd> ) value < <S2SV_ModStart> == SQL_DESC_PARAMETER_TYPE && ( intptr_t ) <S2SV_ModStart> != SQL_PARAM_INPUT && ( intptr_t ) <S2SV_ModStart> != SQL_PARAM_OUTPUT && ( intptr_t ) <S2SV_ModStart> != SQL_PARAM_INPUT_OUTPUT && ( intptr_t ) <S2SV_ModStart> != SQL_PARAM_INPUT_OUTPUT_STREAM && ( intptr_t )",lurcher@unixODBC/45ef78e037f578b15fc58938a3a3251655e71d6f,CVE-2018-7485,https://github.com/lurcher/unixODBC/commit/45ef78e037f578b15fc58938a3a3251655e71d6f#diff-d52750c7ba4e594410438569d8e2963aL24,2018-02-26T14:29Z
CWE-78,"CWE-000 static void <S2SV_StartBug> build_config ( char * prefix , struct server * server ) <S2SV_EndBug> { char * path = NULL ; int path_size = strlen ( prefix ) + strlen ( server -> port ) + 20 ; path = ss_malloc ( path_size ) ; snprintf ( path , path_size , ""%s/.shadowsocks_%s.conf"" , prefix , server -> port ) ; FILE * f = fopen ( path , ""w+"" ) ; if ( f == NULL ) { if ( verbose ) { LOGE ( ""unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>config<S2SV_blank>file"" ) ; } ss_free ( path ) ; return ; } fprintf ( f , ""{\\n"" ) ; fprintf ( f , ""\\""server_port\\"":%d,\\n"" , atoi ( server -> port ) ) ; <S2SV_StartBug> fprintf ( f , ""\\""password\\"":\\""%s\\"""" , server -> password ) ; <S2SV_EndBug> if ( server -> fast_open [ 0 ] ) fprintf ( f , "",\\n\\""fast_open\\"":<S2SV_blank>%s"" , server -> fast_open ) ; if ( server -> mode ) fprintf ( f , "",\\n\\""mode\\"":\\""%s\\"""" , server -> mode ) ; <S2SV_StartBug> if ( server -> method ) fprintf ( f , "",\\n\\""method\\"":\\""%s\\"""" , server -> method ) ; <S2SV_EndBug> if ( server -> plugin ) fprintf ( f , "",\\n\\""plugin\\"":\\""%s\\"""" , server -> plugin ) ; if ( server -> plugin_opts ) fprintf ( f , "",\\n\\""plugin_opts\\"":\\""%s\\"""" , server -> plugin_opts ) ; fprintf ( f , ""\\n}\\n"" ) ; fclose ( f ) ; ss_free ( path ) ; }","<S2SV_ModStart> prefix , struct manager_ctx * manager , struct <S2SV_ModStart> server -> password ) ; if ( server -> method ) fprintf ( f , "",\\n\\""method\\"":\\""%s\\"""" , server -> method ) ; else if ( manager -> method ) fprintf ( f , "",\\n\\""method\\"":\\""%s\\"""" , manager -> method <S2SV_ModStart> ( server -> <S2SV_ModEnd> plugin ) fprintf",shadowsocks@shadowsocks-libev/c67d275803dc6ea22c558d06b1f7ba9f94cd8de3,CVE-2017-15924,https://github.com/shadowsocks/shadowsocks-libev/commit/c67d275803dc6ea22c558d06b1f7ba9f94cd8de3,2017-10-27T16:29Z
CWE-119,"CWE-119 int vp9_rc_clamp_iframe_target_size ( const VP9_COMP * const cpi , int target ) { const RATE_CONTROL * rc = & cpi -> rc ; <S2SV_StartBug> const VP9_CONFIG * oxcf = & cpi -> oxcf ; <S2SV_EndBug> if ( oxcf -> rc_max_intra_bitrate_pct ) { <S2SV_StartBug> const int max_rate = rc -> av_per_frame_bandwidth * <S2SV_EndBug> oxcf -> rc_max_intra_bitrate_pct / 100 ; target = MIN ( target , max_rate ) ; } if ( target > rc -> max_frame_bandwidth ) target = rc -> max_frame_bandwidth ; return target ; }",<S2SV_ModStart> rc ; const VP9EncoderConfig <S2SV_ModEnd> * oxcf = <S2SV_ModStart> = rc -> avg_frame_bandwidth <S2SV_ModEnd> * oxcf ->,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-119,"CWE-119 static int udf_pc_to_char ( struct super_block * sb , unsigned char * from , int fromlen , unsigned char * to , int tolen ) { struct pathComponent * pc ; int elen = 0 ; int comp_len ; unsigned char * p = to ; tolen -- ; while ( elen < fromlen ) { pc = ( struct pathComponent * ) ( from + elen ) ; <S2SV_StartBug> switch ( pc -> componentType ) { <S2SV_EndBug> case 1 : if ( pc -> lengthComponentIdent > 0 ) <S2SV_StartBug> break ; <S2SV_EndBug> case 2 : if ( tolen == 0 ) return - ENAMETOOLONG ; p = to ; * p ++ = '/' ; tolen -- ; break ; case 3 : if ( tolen < 3 ) return - ENAMETOOLONG ; memcpy ( p , ""../"" , 3 ) ; p += 3 ; tolen -= 3 ; break ; case 4 : if ( tolen < 2 ) return - ENAMETOOLONG ; memcpy ( p , ""./"" , 2 ) ; p += 2 ; tolen -= 2 ; break ; <S2SV_StartBug> case 5 : <S2SV_EndBug> comp_len = udf_get_filename ( sb , pc -> componentIdent , pc -> lengthComponentIdent , p , tolen ) ; p += comp_len ; tolen -= comp_len ; if ( tolen == 0 ) return - ENAMETOOLONG ; * p ++ = '/' ; tolen -- ; break ; } <S2SV_StartBug> elen += sizeof ( struct pathComponent ) + pc -> lengthComponentIdent ; <S2SV_EndBug> } if ( p > to + 1 ) p [ - 1 ] = '\\0' ; else p [ 0 ] = '\\0' ; return 0 ; }",<S2SV_ModStart> elen ) ; elen += sizeof ( struct pathComponent ) ; <S2SV_ModStart> > 0 ) { elen += pc -> lengthComponentIdent ; break ; } <S2SV_ModEnd> case 2 : <S2SV_ModStart> case 5 : elen += pc -> lengthComponentIdent ; if ( elen > fromlen ) return - EIO ; <S2SV_ModStart> break ; } <S2SV_ModEnd> } if (,torvalds@linux/e237ec37ec154564f8690c5bd1795339955eeef9,CVE-2014-9728,https://github.com/torvalds/linux/commit/e237ec37ec154564f8690c5bd1795339955eeef9,2015-08-31T10:59Z
CWE-119,"CWE-119 static inline int ip6_ufo_append_data ( struct sock * sk , int getfrag ( void * from , char * to , int offset , int len , int odd , struct sk_buff * skb ) , void * from , int length , int hh_len , int fragheaderlen , int transhdrlen , int mtu , unsigned int flags , struct rt6_info * rt ) { struct sk_buff * skb ; int err ; if ( ( skb = skb_peek_tail ( & sk -> sk_write_queue ) ) == NULL ) { <S2SV_StartBug> skb = sock_alloc_send_skb ( sk , <S2SV_EndBug> hh_len + fragheaderlen + transhdrlen + 20 , ( flags & MSG_DONTWAIT ) , & err ) ; if ( skb == NULL ) return err ; skb_reserve ( skb , hh_len ) ; skb_put ( skb , fragheaderlen + transhdrlen ) ; skb_reset_network_header ( skb ) ; skb -> transport_header = skb -> network_header + fragheaderlen ; skb -> protocol = htons ( ETH_P_IPV6 ) ; skb -> ip_summed = CHECKSUM_PARTIAL ; <S2SV_StartBug> skb -> csum = 0 ; <S2SV_EndBug> } err = skb_append_datato_frags ( sk , skb , getfrag , from , ( length - transhdrlen ) ) ; if ( ! err ) { struct frag_hdr fhdr ; skb_shinfo ( skb ) -> gso_size = ( mtu - fragheaderlen - sizeof ( struct frag_hdr ) ) & ~ 7 ; skb_shinfo ( skb ) -> gso_type = SKB_GSO_UDP ; ipv6_select_ident ( & fhdr , rt ) ; skb_shinfo ( skb ) -> ip6_frag_id = fhdr . identification ; __skb_queue_tail ( & sk -> sk_write_queue , skb ) ; <S2SV_StartBug> return 0 ; <S2SV_EndBug> } kfree_skb ( skb ) ; return err ; }","<S2SV_ModStart> NULL ) { struct frag_hdr fhdr ; <S2SV_ModStart> csum = 0 <S2SV_ModEnd> ; skb_shinfo ( <S2SV_ModStart> skb ) ; } return skb_append_datato_frags ( sk , skb , getfrag , from , ( length - transhdrlen ) ) <S2SV_ModEnd> ; } <S2SV_null>",torvalds@linux/2811ebac2521ceac84f2bdae402455baa6a7fb47,CVE-2013-4387,https://github.com/torvalds/linux/commit/2811ebac2521ceac84f2bdae402455baa6a7fb47,2013-10-10T10:55Z
CWE-416,"CWE-416 static struct ipv6_txoptions * ipv6_update_options ( struct sock * sk , struct ipv6_txoptions * opt ) { if ( inet_sk ( sk ) -> is_icsk ) { if ( opt && ! ( ( 1 << sk -> sk_state ) & ( TCPF_LISTEN | TCPF_CLOSE ) ) && inet_sk ( sk ) -> inet_daddr != LOOPBACK4_IPV6 ) { struct inet_connection_sock * icsk = inet_csk ( sk ) ; icsk -> icsk_ext_hdr_len = opt -> opt_flen + opt -> opt_nflen ; icsk -> icsk_sync_mss ( sk , icsk -> icsk_pmtu_cookie ) ; } } <S2SV_StartBug> opt = xchg ( & inet6_sk ( sk ) -> opt , opt ) ; <S2SV_EndBug> sk_dst_reset ( sk ) ; return opt ; }",<S2SV_ModStart> = xchg ( ( __force struct ipv6_txoptions * * ),torvalds@linux/45f6fad84cc305103b28d73482b344d7f5b76f39,CVE-2016-3841,https://github.com/torvalds/linux/commit/45f6fad84cc305103b28d73482b344d7f5b76f39,2016-08-06T20:59Z
CWE-119,"CWE-119 int main ( int argc , char * * argv ) { test_cmp_parameters inParam ; FILE * fbase = NULL , * ftest = NULL ; int same = 0 ; <S2SV_StartBug> char lbase [ 256 ] ; <S2SV_EndBug> <S2SV_StartBug> char strbase [ 256 ] ; <S2SV_EndBug> <S2SV_StartBug> char ltest [ 256 ] ; <S2SV_EndBug> <S2SV_StartBug> char strtest [ 256 ] ; <S2SV_EndBug> if ( parse_cmdline_cmp ( argc , argv , & inParam ) == 1 ) { compare_dump_files_help_display ( ) ; goto cleanup ; } printf ( ""******Parameters*********<S2SV_blank>\\n"" ) ; printf ( ""<S2SV_blank>base_filename<S2SV_blank>=<S2SV_blank>%s\\n"" ""<S2SV_blank>test_filename<S2SV_blank>=<S2SV_blank>%s\\n"" , inParam . base_filename , inParam . test_filename ) ; printf ( ""*************************<S2SV_blank>\\n"" ) ; printf ( ""Try<S2SV_blank>to<S2SV_blank>open:<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading<S2SV_blank>...<S2SV_blank>"" , inParam . base_filename ) ; if ( ( fbase = fopen ( inParam . base_filename , ""rb"" ) ) == NULL ) { goto cleanup ; } printf ( ""Ok.\\n"" ) ; printf ( ""Try<S2SV_blank>to<S2SV_blank>open:<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading<S2SV_blank>...<S2SV_blank>"" , inParam . test_filename ) ; if ( ( ftest = fopen ( inParam . test_filename , ""rb"" ) ) == NULL ) { goto cleanup ; } printf ( ""Ok.\\n"" ) ; while ( fgets ( lbase , sizeof ( lbase ) , fbase ) && fgets ( ltest , sizeof ( ltest ) , ftest ) ) { <S2SV_StartBug> int nbase = sscanf ( lbase , ""%255[^\\r\\n]"" , strbase ) ; <S2SV_EndBug> <S2SV_StartBug> int ntest = sscanf ( ltest , ""%255[^\\r\\n]"" , strtest ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( nbase != 255 && ntest != 255 ) ; <S2SV_EndBug> if ( nbase != 1 || ntest != 1 ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>line<S2SV_blank>from<S2SV_blank>files\\n"" ) ; goto cleanup ; } if ( strcmp ( strbase , strtest ) != 0 ) { fprintf ( stderr , ""<%s><S2SV_blank>vs.<S2SV_blank><%s>\\n"" , strbase , strtest ) ; goto cleanup ; } } same = 1 ; printf ( ""\\n*****<S2SV_blank>TEST<S2SV_blank>SUCCEED:<S2SV_blank>Files<S2SV_blank>are<S2SV_blank>the<S2SV_blank>same.<S2SV_blank>*****\\n"" ) ; cleanup : if ( fbase ) fclose ( fbase ) ; if ( ftest ) fclose ( ftest ) ; free ( inParam . base_filename ) ; free ( inParam . test_filename ) ; return same ? EXIT_SUCCESS : EXIT_FAILURE ; }","<S2SV_ModStart> char lbase [ 512 <S2SV_ModEnd> ] ; char <S2SV_ModStart> char strbase [ 512 <S2SV_ModEnd> ] ; char <S2SV_ModStart> char ltest [ 512 <S2SV_ModEnd> ] ; char <S2SV_ModStart> char strtest [ 512 <S2SV_ModEnd> ] ; if <S2SV_ModStart> ( lbase , ""%511[^\\r\\n]"" <S2SV_ModEnd> , strbase ) <S2SV_ModStart> ( ltest , ""%511[^\\r\\n]"" <S2SV_ModEnd> , strtest ) <S2SV_ModStart> ( nbase != 511 <S2SV_ModEnd> && ntest != <S2SV_ModStart> && ntest != 511 <S2SV_ModEnd> ) ; if",uclouvain@openjpeg/e078172b1c3f98d2219c37076b238fb759c751ea,CVE-2016-5157,https://github.com/uclouvain/openjpeg/commit/e078172b1c3f98d2219c37076b238fb759c751ea,2016-09-11T10:59Z
CWE-404,"CWE-000 int nfsd_mountpoint ( struct dentry * dentry , struct svc_export * exp ) { <S2SV_StartBug> if ( d_mountpoint ( dentry ) ) <S2SV_EndBug> return 1 ; if ( nfsd4_is_junction ( dentry ) ) return 1 ; <S2SV_StartBug> if ( ! ( exp -> ex_flags & NFSEXP_V4ROOT ) ) <S2SV_EndBug> return 0 ; <S2SV_StartBug> return d_inode ( dentry ) != NULL ; <S2SV_EndBug> }",<S2SV_ModStart> { if ( ! d_inode <S2SV_ModEnd> ( dentry ) <S2SV_ModStart> ( dentry ) ) return 0 ; if ( exp -> ex_flags & NFSEXP_V4ROOT <S2SV_ModStart> ; if ( d_mountpoint ( dentry ) ) return 2 ; <S2SV_ModEnd> return 0 ; <S2SV_ModStart> return 0 ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>,torvalds@linux/c70422f760c120480fee4de6c38804c72aa26bc1,CVE-2017-9059,https://github.com/torvalds/linux/commit/c70422f760c120480fee4de6c38804c72aa26bc1,2017-05-18T06:29Z
,"CWE-000 static int rds_loop_xmit ( struct rds_connection * conn , struct rds_message * rm , unsigned int hdr_off , unsigned int sg , unsigned int off ) { <S2SV_StartBug> if ( rm -> m_inc . i_hdr . h_flags & RDS_FLAG_CONG_BITMAP ) { <S2SV_EndBug> rds_cong_map_updated ( conn -> c_fcong , ~ ( u64 ) 0 ) ; <S2SV_StartBug> return sizeof ( struct rds_header ) + RDS_CONG_MAP_BYTES ; <S2SV_EndBug> } BUG_ON ( hdr_off || sg || off ) ; rds_inc_init ( & rm -> m_inc , conn , conn -> c_laddr ) ; rds_message_addref ( rm ) ; rds_recv_incoming ( conn , conn -> c_laddr , conn -> c_faddr , & rm -> m_inc , GFP_KERNEL , KM_USER0 ) ; rds_send_drop_acked ( conn , be64_to_cpu ( rm -> m_inc . i_hdr . h_sequence ) , NULL ) ; rds_inc_put ( & rm -> m_inc ) ; <S2SV_StartBug> return sizeof ( struct rds_header ) + be32_to_cpu ( rm -> m_inc . i_hdr . h_len ) ; <S2SV_EndBug> }","<S2SV_ModStart> off ) { struct scatterlist * sgp = & rm -> data . op_sg [ sg ] ; int ret = sizeof ( struct rds_header ) + be32_to_cpu ( rm -> m_inc . i_hdr . h_len ) ; <S2SV_ModStart> 0 ) ; ret = min_t ( int , ret , sgp -> length - conn -> c_xmit_data_off ) ; goto out <S2SV_ModEnd> ; } BUG_ON <S2SV_ModStart> m_inc ) ; out : return ret <S2SV_ModEnd> ; } <S2SV_null>",torvalds@linux/6094628bfd94323fc1cea05ec2c6affd98c18f7f,CVE-2011-1023,https://github.com/torvalds/linux/commit/6094628bfd94323fc1cea05ec2c6affd98c18f7f,2012-06-21T23:55Z
CWE-200,"CWE-200 static int rfcomm_sock_getname ( struct socket * sock , struct sockaddr * addr , int * len , int peer ) { struct sockaddr_rc * sa = ( struct sockaddr_rc * ) addr ; struct sock * sk = sock -> sk ; <S2SV_StartBug> BT_DBG ( ""sock<S2SV_blank>%p,<S2SV_blank>sk<S2SV_blank>%p"" , sock , sk ) ; <S2SV_EndBug> sa -> rc_family = AF_BLUETOOTH ; sa -> rc_channel = rfcomm_pi ( sk ) -> channel ; if ( peer ) bacpy ( & sa -> rc_bdaddr , & bt_sk ( sk ) -> dst ) ; else bacpy ( & sa -> rc_bdaddr , & bt_sk ( sk ) -> src ) ; * len = sizeof ( struct sockaddr_rc ) ; return 0 ; }","<S2SV_ModStart> sock , sk ) ; memset ( sa , 0 , sizeof ( * sa )",torvalds@linux/9344a972961d1a6d2c04d9008b13617bcb6ec2ef,CVE-2012-6545,https://github.com/torvalds/linux/commit/9344a972961d1a6d2c04d9008b13617bcb6ec2ef,2013-03-15T20:55Z
CWE-191,"CWE-000 void imap_quote_string ( char * dest , size_t dlen , const char * src , bool quote_backtick ) { const char * quote = ""`\\""\\\\"" ; if ( ! quote_backtick ) quote ++ ; char * pt = dest ; const char * s = src ; * pt ++ = \'""\' ; dlen -= 2 ; for ( ; * s && dlen ; s ++ ) { if ( strchr ( quote , * s ) ) { <S2SV_StartBug> dlen -= 2 ; <S2SV_EndBug> if ( dlen == 0 ) break ; * pt ++ = '\\\\' ; * pt ++ = * s ; } else { * pt ++ = * s ; dlen -- ; } } * pt ++ = \'""\' ; * pt = '\\0' ; }",<S2SV_ModStart> ) ) { if ( dlen < 2 ) break ; <S2SV_ModStart> dlen -= 2 <S2SV_ModEnd> ; * pt,neomutt@neomutt/65d64a5b60a4a3883f2cd799d92c6091d8854f23,CVE-2018-14353,https://github.com/neomutt/neomutt/commit/65d64a5b60a4a3883f2cd799d92c6091d8854f23,2018-07-17T17:29Z
CWE-200,"CWE-200 static int atl2_probe ( struct pci_dev * pdev , const struct pci_device_id * ent ) { struct net_device * netdev ; struct atl2_adapter * adapter ; static int cards_found ; unsigned long mmio_start ; int mmio_len ; int err ; cards_found = 0 ; err = pci_enable_device ( pdev ) ; if ( err ) return err ; if ( pci_set_dma_mask ( pdev , DMA_BIT_MASK ( 32 ) ) && pci_set_consistent_dma_mask ( pdev , DMA_BIT_MASK ( 32 ) ) ) { printk ( KERN_ERR ""atl2:<S2SV_blank>No<S2SV_blank>usable<S2SV_blank>DMA<S2SV_blank>configuration,<S2SV_blank>aborting\\n"" ) ; goto err_dma ; } err = pci_request_regions ( pdev , atl2_driver_name ) ; if ( err ) goto err_pci_reg ; pci_set_master ( pdev ) ; err = - ENOMEM ; netdev = alloc_etherdev ( sizeof ( struct atl2_adapter ) ) ; if ( ! netdev ) goto err_alloc_etherdev ; SET_NETDEV_DEV ( netdev , & pdev -> dev ) ; pci_set_drvdata ( pdev , netdev ) ; adapter = netdev_priv ( netdev ) ; adapter -> netdev = netdev ; adapter -> pdev = pdev ; adapter -> hw . back = adapter ; mmio_start = pci_resource_start ( pdev , 0x0 ) ; mmio_len = pci_resource_len ( pdev , 0x0 ) ; adapter -> hw . mem_rang = ( u32 ) mmio_len ; adapter -> hw . hw_addr = ioremap ( mmio_start , mmio_len ) ; if ( ! adapter -> hw . hw_addr ) { err = - EIO ; goto err_ioremap ; } atl2_setup_pcicmd ( pdev ) ; netdev -> netdev_ops = & atl2_netdev_ops ; netdev -> ethtool_ops = & atl2_ethtool_ops ; netdev -> watchdog_timeo = 5 * HZ ; strncpy ( netdev -> name , pci_name ( pdev ) , sizeof ( netdev -> name ) - 1 ) ; netdev -> mem_start = mmio_start ; netdev -> mem_end = mmio_start + mmio_len ; adapter -> bd_number = cards_found ; adapter -> pci_using_64 = false ; err = atl2_sw_init ( adapter ) ; if ( err ) goto err_sw_init ; err = - EIO ; <S2SV_StartBug> netdev -> hw_features = NETIF_F_SG | NETIF_F_HW_VLAN_CTAG_RX ; <S2SV_EndBug> netdev -> features |= ( NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_CTAG_RX ) ; atl2_phy_init ( & adapter -> hw ) ; if ( atl2_reset_hw ( & adapter -> hw ) ) { err = - EIO ; goto err_reset ; } atl2_read_mac_addr ( & adapter -> hw ) ; memcpy ( netdev -> dev_addr , adapter -> hw . mac_addr , netdev -> addr_len ) ; if ( ! is_valid_ether_addr ( netdev -> dev_addr ) ) { err = - EIO ; goto err_eeprom ; } atl2_check_options ( adapter ) ; setup_timer ( & adapter -> watchdog_timer , atl2_watchdog , ( unsigned long ) adapter ) ; setup_timer ( & adapter -> phy_config_timer , atl2_phy_config , ( unsigned long ) adapter ) ; INIT_WORK ( & adapter -> reset_task , atl2_reset_task ) ; INIT_WORK ( & adapter -> link_chg_task , atl2_link_chg_task ) ; strcpy ( netdev -> name , ""eth%d"" ) ; err = register_netdev ( netdev ) ; if ( err ) goto err_register ; netif_carrier_off ( netdev ) ; netif_stop_queue ( netdev ) ; cards_found ++ ; return 0 ; err_reset : err_register : err_sw_init : err_eeprom : iounmap ( adapter -> hw . hw_addr ) ; err_ioremap : free_netdev ( netdev ) ; err_alloc_etherdev : pci_release_regions ( pdev ) ; err_pci_reg : err_dma : pci_disable_device ( pdev ) ; return err ; }",<S2SV_ModStart> -> hw_features = <S2SV_ModEnd> NETIF_F_HW_VLAN_CTAG_RX ; netdev,torvalds@linux/f43bfaeddc79effbf3d0fcb53ca477cca66f3db8,CVE-2016-2117,https://github.com/torvalds/linux/commit/f43bfaeddc79effbf3d0fcb53ca477cca66f3db8,2016-05-02T10:59Z
CWE-125,"CWE-125 int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; <S2SV_StartBug> match_length += callback_args -> forward_matches ; <S2SV_EndBug> if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }",<S2SV_ModStart> callback_args -> forward_matches ; assert ( match_offset + match_length <= callback_args -> data_size ),VirusTotal@yara/992480c30f75943e9cd6245bb2015c7737f9b661,CVE-2017-9465,https://github.com/VirusTotal/yara/commit/992480c30f75943e9cd6245bb2015c7737f9b661,2017-06-06T21:29Z
CWE-295,"CWE-000 NOEXPORT void print_cipher ( CLI * c ) { SSL_CIPHER * cipher ; # ifndef OPENSSL_NO_COMP const COMP_METHOD * compression , * expansion ; # endif if ( c -> opt -> log_level < LOG_INFO ) return ; s_log ( LOG_INFO , ""TLS<S2SV_blank>%s:<S2SV_blank>%s"" , c -> opt -> option . client ? ""connected"" : ""accepted"" , SSL_session_reused ( c -> ssl ) && ! c -> flag . psk ? ""previous<S2SV_blank>session<S2SV_blank>reused"" : ""new<S2SV_blank>session<S2SV_blank>negotiated"" ) ; cipher = ( SSL_CIPHER * ) SSL_get_current_cipher ( c -> ssl ) ; s_log ( LOG_INFO , ""%s<S2SV_blank>ciphersuite:<S2SV_blank>%s<S2SV_blank>(%d-bit<S2SV_blank>encryption)"" , SSL_get_version ( c -> ssl ) , SSL_CIPHER_get_name ( cipher ) , SSL_CIPHER_get_bits ( cipher , NULL ) ) ; <S2SV_StartBug> # ifndef OPENSSL_NO_COMP <S2SV_EndBug> compression = SSL_get_current_compression ( c -> ssl ) ; expansion = SSL_get_current_expansion ( c -> ssl ) ; s_log ( compression || expansion ? LOG_INFO : LOG_DEBUG , ""Compression:<S2SV_blank>%s,<S2SV_blank>expansion:<S2SV_blank>%s"" , compression ? SSL_COMP_get_name ( compression ) : ""null"" , expansion ? SSL_COMP_get_name ( expansion ) : ""null"" ) ; # endif }",<S2SV_ModStart> ) ; # if OPENSSL_VERSION_NUMBER >= 0x10101000L print_tmp_key ( c -> ssl ) ; # endif #,mtrojnar@stunnel/ebad9ddc4efb2635f37174c9d800d06206f1edf9,CVE-2021-20230,https://github.com/mtrojnar/stunnel/commit/ebad9ddc4efb2635f37174c9d800d06206f1edf9,2021-02-23T17:15Z
CWE-399,"CWE-399 static int cuse_channel_release ( struct inode * inode , struct file * file ) { struct fuse_dev * fud = file -> private_data ; struct cuse_conn * cc = fc_to_cc ( fud -> fc ) ; int rc ; mutex_lock ( & cuse_lock ) ; list_del_init ( & cc -> list ) ; mutex_unlock ( & cuse_lock ) ; if ( cc -> dev ) device_unregister ( cc -> dev ) ; if ( cc -> cdev ) { unregister_chrdev_region ( cc -> cdev -> dev , 1 ) ; cdev_del ( cc -> cdev ) ; } <S2SV_StartBug> rc = fuse_dev_release ( inode , file ) ; <S2SV_EndBug> return rc ; }",<S2SV_ModStart> ) ; } fuse_conn_put ( & cc -> fc ) ;,torvalds@linux/2c5816b4beccc8ba709144539f6fdd764f8fa49c,CVE-2015-1339,https://github.com/torvalds/linux/commit/2c5816b4beccc8ba709144539f6fdd764f8fa49c,2016-04-27T17:59Z
CWE-287,"CWE-000 static ngx_int_t ngx_http_auth_spnego_handler ( ngx_http_request_t * r ) { ngx_int_t ret = NGX_DECLINED ; ngx_http_auth_spnego_ctx_t * ctx ; ngx_http_auth_spnego_loc_conf_t * alcf ; alcf = ngx_http_get_module_loc_conf ( r , ngx_http_auth_spnego_module ) ; if ( alcf -> protect == 0 ) { return NGX_DECLINED ; } ctx = ngx_http_get_module_ctx ( r , ngx_http_auth_spnego_module ) ; if ( NULL == ctx ) { ctx = ngx_palloc ( r -> pool , sizeof ( ngx_http_auth_spnego_ctx_t ) ) ; if ( NULL == ctx ) { return NGX_HTTP_INTERNAL_SERVER_ERROR ; } ctx -> token . len = 0 ; ctx -> token . data = NULL ; ctx -> head = 0 ; ctx -> ret = NGX_HTTP_UNAUTHORIZED ; ngx_http_set_ctx ( r , ctx , ngx_http_auth_spnego_module ) ; } spnego_debug3 ( ""SSO<S2SV_blank>auth<S2SV_blank>handling<S2SV_blank>IN:<S2SV_blank>token.len=%d,<S2SV_blank>head=%d,<S2SV_blank>ret=%d"" , ctx -> token . len , ctx -> head , ctx -> ret ) ; if ( ctx -> token . len && ctx -> head ) { spnego_debug1 ( ""Found<S2SV_blank>token<S2SV_blank>and<S2SV_blank>head,<S2SV_blank>returning<S2SV_blank>%d"" , ctx -> ret ) ; return ctx -> ret ; } if ( NULL != r -> headers_in . user . data ) { spnego_debug0 ( ""User<S2SV_blank>header<S2SV_blank>set"" ) ; return NGX_OK ; } spnego_debug0 ( ""Begin<S2SV_blank>auth"" ) ; if ( alcf -> allow_basic ) { spnego_debug0 ( ""Detect<S2SV_blank>basic<S2SV_blank>auth"" ) ; ret = ngx_http_auth_basic_user ( r ) ; if ( NGX_OK == ret ) { spnego_debug0 ( ""Basic<S2SV_blank>auth<S2SV_blank>credentials<S2SV_blank>supplied<S2SV_blank>by<S2SV_blank>client"" ) ; <S2SV_StartBug> if ( NGX_DECLINED == ngx_http_auth_spnego_basic ( r , ctx , alcf ) ) { <S2SV_EndBug> spnego_debug0 ( ""Basic<S2SV_blank>auth<S2SV_blank>failed"" ) ; if ( NGX_ERROR == ngx_http_auth_spnego_headers_basic_only ( r , ctx , alcf ) ) { spnego_debug0 ( ""Error<S2SV_blank>setting<S2SV_blank>headers"" ) ; return ( ctx -> ret = NGX_HTTP_INTERNAL_SERVER_ERROR ) ; } return ( ctx -> ret = NGX_HTTP_UNAUTHORIZED ) ; } if ( ! ngx_spnego_authorized_principal ( r , & r -> headers_in . user , alcf ) ) { spnego_debug0 ( ""User<S2SV_blank>not<S2SV_blank>authorized"" ) ; return ( ctx -> ret = NGX_HTTP_FORBIDDEN ) ; } spnego_debug0 ( ""Basic<S2SV_blank>auth<S2SV_blank>succeeded"" ) ; return ( ctx -> ret = NGX_OK ) ; } } spnego_debug0 ( ""Detect<S2SV_blank>SPNEGO<S2SV_blank>token"" ) ; ret = ngx_http_auth_spnego_token ( r , ctx ) ; if ( NGX_OK == ret ) { spnego_debug0 ( ""Client<S2SV_blank>sent<S2SV_blank>a<S2SV_blank>reasonable<S2SV_blank>Negotiate<S2SV_blank>header"" ) ; ret = ngx_http_auth_spnego_auth_user_gss ( r , ctx , alcf ) ; if ( NGX_ERROR == ret ) { spnego_debug0 ( ""GSSAPI<S2SV_blank>failed"" ) ; return ( ctx -> ret = NGX_HTTP_INTERNAL_SERVER_ERROR ) ; } if ( NGX_DECLINED == ret ) { spnego_debug0 ( ""GSSAPI<S2SV_blank>failed"" ) ; if ( ! alcf -> allow_basic ) { return ( ctx -> ret = NGX_HTTP_FORBIDDEN ) ; } if ( NGX_ERROR == ngx_http_auth_spnego_headers_basic_only ( r , ctx , alcf ) ) { spnego_debug0 ( ""Error<S2SV_blank>setting<S2SV_blank>headers"" ) ; return ( ctx -> ret = NGX_HTTP_INTERNAL_SERVER_ERROR ) ; } return ( ctx -> ret = NGX_HTTP_UNAUTHORIZED ) ; } if ( ! ngx_spnego_authorized_principal ( r , & r -> headers_in . user , alcf ) ) { spnego_debug0 ( ""User<S2SV_blank>not<S2SV_blank>authorized"" ) ; return ( ctx -> ret = NGX_HTTP_FORBIDDEN ) ; } spnego_debug0 ( ""GSSAPI<S2SV_blank>auth<S2SV_blank>succeeded"" ) ; } ngx_str_t * token_out_b64 = NULL ; switch ( ret ) { case NGX_DECLINED : ctx -> ret = NGX_HTTP_UNAUTHORIZED ; break ; case NGX_OK : ctx -> ret = NGX_OK ; token_out_b64 = & ctx -> token_out_b64 ; break ; case NGX_ERROR : default : ctx -> ret = NGX_HTTP_INTERNAL_SERVER_ERROR ; break ; } if ( NGX_ERROR == ngx_http_auth_spnego_headers ( r , ctx , token_out_b64 , alcf ) ) { spnego_debug0 ( ""Error<S2SV_blank>setting<S2SV_blank>headers"" ) ; ctx -> ret = NGX_HTTP_INTERNAL_SERVER_ERROR ; } spnego_debug3 ( ""SSO<S2SV_blank>auth<S2SV_blank>handling<S2SV_blank>OUT:<S2SV_blank>token.len=%d,<S2SV_blank>head=%d,<S2SV_blank>ret=%d"" , ctx -> token . len , ctx -> head , ctx -> ret ) ; return ctx -> ret ; }",<S2SV_ModStart> ; if ( NGX_OK != <S2SV_ModEnd> ngx_http_auth_spnego_basic ( r,stnoonan@spnego-http-auth-nginx-module/a06f9efca373e25328b1c53639a48decd0854570,CVE-2021-21335,https://github.com/stnoonan/spnego-http-auth-nginx-module/commit/a06f9efca373e25328b1c53639a48decd0854570,2021-03-08T21:15Z
,"CWE-000 int simple_set_acl ( struct inode * inode , struct posix_acl * acl , int type ) { int error ; if ( type == ACL_TYPE_ACCESS ) { <S2SV_StartBug> error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; <S2SV_EndBug> <S2SV_StartBug> if ( error < 0 ) <S2SV_EndBug> return 0 ; if ( error == 0 ) acl = NULL ; } inode -> i_ctime = current_time ( inode ) ; set_cached_acl ( inode , type , acl ) ; return 0 ; }","<S2SV_ModStart> { error = posix_acl_update_mode ( inode <S2SV_ModEnd> , & inode <S2SV_ModStart> inode -> i_mode , & acl <S2SV_ModStart> if ( error ) return error <S2SV_ModEnd> ; } inode",torvalds@linux/497de07d89c1410d76a15bec2bb41f24a2a89f31,CVE-2017-5551,https://github.com/torvalds/linux/commit/497de07d89c1410d76a15bec2bb41f24a2a89f31,2017-02-06T06:59Z
CWE-119,"CWE-119 static int get_results ( struct iperf_test * test ) { int r = 0 ; cJSON * j ; cJSON * j_cpu_util_total ; cJSON * j_cpu_util_user ; cJSON * j_cpu_util_system ; cJSON * j_sender_has_retransmits ; int result_has_retransmits ; cJSON * j_streams ; int n , i ; cJSON * j_stream ; cJSON * j_id ; cJSON * j_bytes ; cJSON * j_retransmits ; cJSON * j_jitter ; cJSON * j_errors ; cJSON * j_packets ; cJSON * j_server_output ; int sid , cerror , pcount ; double jitter ; iperf_size_t bytes_transferred ; int retransmits ; struct iperf_stream * sp ; j = JSON_read ( test -> ctrl_sck ) ; if ( j == NULL ) { i_errno = IERECVRESULTS ; r = - 1 ; } else { j_cpu_util_total = cJSON_GetObjectItem ( j , ""cpu_util_total"" ) ; j_cpu_util_user = cJSON_GetObjectItem ( j , ""cpu_util_user"" ) ; j_cpu_util_system = cJSON_GetObjectItem ( j , ""cpu_util_system"" ) ; j_sender_has_retransmits = cJSON_GetObjectItem ( j , ""sender_has_retransmits"" ) ; if ( j_cpu_util_total == NULL || j_cpu_util_user == NULL || j_cpu_util_system == NULL || j_sender_has_retransmits == NULL ) { i_errno = IERECVRESULTS ; r = - 1 ; } else { if ( test -> debug ) { printf ( ""get_results\\n%s\\n"" , cJSON_Print ( j ) ) ; } <S2SV_StartBug> test -> remote_cpu_util [ 0 ] = j_cpu_util_total -> valuefloat ; <S2SV_EndBug> <S2SV_StartBug> test -> remote_cpu_util [ 1 ] = j_cpu_util_user -> valuefloat ; <S2SV_EndBug> <S2SV_StartBug> test -> remote_cpu_util [ 2 ] = j_cpu_util_system -> valuefloat ; <S2SV_EndBug> result_has_retransmits = j_sender_has_retransmits -> valueint ; if ( ! test -> sender ) test -> sender_has_retransmits = result_has_retransmits ; j_streams = cJSON_GetObjectItem ( j , ""streams"" ) ; if ( j_streams == NULL ) { i_errno = IERECVRESULTS ; r = - 1 ; } else { n = cJSON_GetArraySize ( j_streams ) ; for ( i = 0 ; i < n ; ++ i ) { j_stream = cJSON_GetArrayItem ( j_streams , i ) ; if ( j_stream == NULL ) { i_errno = IERECVRESULTS ; r = - 1 ; } else { j_id = cJSON_GetObjectItem ( j_stream , ""id"" ) ; j_bytes = cJSON_GetObjectItem ( j_stream , ""bytes"" ) ; j_retransmits = cJSON_GetObjectItem ( j_stream , ""retransmits"" ) ; j_jitter = cJSON_GetObjectItem ( j_stream , ""jitter"" ) ; j_errors = cJSON_GetObjectItem ( j_stream , ""errors"" ) ; j_packets = cJSON_GetObjectItem ( j_stream , ""packets"" ) ; if ( j_id == NULL || j_bytes == NULL || j_retransmits == NULL || j_jitter == NULL || j_errors == NULL || j_packets == NULL ) { i_errno = IERECVRESULTS ; r = - 1 ; } else { sid = j_id -> valueint ; bytes_transferred = j_bytes -> valueint ; retransmits = j_retransmits -> valueint ; <S2SV_StartBug> jitter = j_jitter -> valuefloat ; <S2SV_EndBug> cerror = j_errors -> valueint ; pcount = j_packets -> valueint ; SLIST_FOREACH ( sp , & test -> streams , streams ) if ( sp -> id == sid ) break ; if ( sp == NULL ) { i_errno = IESTREAMID ; r = - 1 ; } else { if ( test -> sender ) { sp -> jitter = jitter ; sp -> cnt_error = cerror ; sp -> packet_count = pcount ; sp -> result -> bytes_received = bytes_transferred ; } else { sp -> result -> bytes_sent = bytes_transferred ; sp -> result -> stream_retrans = retransmits ; } } } } } if ( test -> role == 'c' && iperf_get_test_get_server_output ( test ) ) { j_server_output = cJSON_DetachItemFromObject ( j , ""server_output_json"" ) ; if ( j_server_output != NULL ) { test -> json_server_output = j_server_output ; } else { j_server_output = cJSON_GetObjectItem ( j , ""server_output_text"" ) ; if ( j_server_output != NULL ) { test -> server_output_text = strdup ( j_server_output -> valuestring ) ; } } } } } cJSON_Delete ( j ) ; } return r ; }",<S2SV_ModStart> = j_cpu_util_total -> valuedouble <S2SV_ModEnd> ; test -> <S2SV_ModStart> = j_cpu_util_user -> valuedouble <S2SV_ModEnd> ; test -> <S2SV_ModStart> = j_cpu_util_system -> valuedouble <S2SV_ModEnd> ; result_has_retransmits = <S2SV_ModStart> = j_jitter -> valuedouble <S2SV_ModEnd> ; cerror =,esnet@iperf/91f2fa59e8ed80dfbf400add0164ee0e508e412a,CVE-2016-4303,https://github.com/esnet/iperf/commit/91f2fa59e8ed80dfbf400add0164ee0e508e412a,2016-09-26T14:59Z
CWE-399,CWE-399 static void kvmclock_reset ( struct kvm_vcpu * vcpu ) { <S2SV_StartBug> if ( vcpu -> arch . time_page ) { <S2SV_EndBug> kvm_release_page_dirty ( vcpu -> arch . time_page ) ; vcpu -> arch . time_page = NULL ; } },<S2SV_ModStart> vcpu ) { <S2SV_ModEnd> vcpu -> arch <S2SV_ModStart> -> arch . pv_time_enabled = false ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>,torvalds@linux/0b79459b482e85cb7426aa7da683a9f2c97aeae1,CVE-2013-1797,https://github.com/torvalds/linux/commit/0b79459b482e85cb7426aa7da683a9f2c97aeae1,2013-03-22T11:59Z
CWE-787,"CWE-787 BOOL nsc_process_message ( NSC_CONTEXT * context , UINT16 bpp , UINT32 width , UINT32 height , const BYTE * data , UINT32 length , BYTE * pDstData , UINT32 DstFormat , UINT32 nDstStride , UINT32 nXDst , UINT32 nYDst , UINT32 nWidth , UINT32 nHeight , UINT32 flip ) { wStream * s ; BOOL ret ; s = Stream_New ( ( BYTE * ) data , length ) ; if ( ! s ) return FALSE ; if ( nDstStride == 0 ) nDstStride = nWidth * GetBytesPerPixel ( DstFormat ) ; switch ( bpp ) { case 32 : context -> format = PIXEL_FORMAT_BGRA32 ; break ; case 24 : context -> format = PIXEL_FORMAT_BGR24 ; break ; case 16 : context -> format = PIXEL_FORMAT_BGR16 ; break ; case 8 : context -> format = PIXEL_FORMAT_RGB8 ; break ; case 4 : context -> format = PIXEL_FORMAT_A4 ; break ; default : Stream_Free ( s , TRUE ) ; return FALSE ; } context -> width = width ; context -> height = height ; ret = nsc_context_initialize ( context , s ) ; Stream_Free ( s , FALSE ) ; if ( ! ret ) return FALSE ; <S2SV_StartBug> PROFILER_ENTER ( context -> priv -> prof_nsc_rle_decompress_data ) <S2SV_EndBug> <S2SV_StartBug> nsc_rle_decompress_data ( context ) ; <S2SV_EndBug> PROFILER_EXIT ( context -> priv -> prof_nsc_rle_decompress_data ) <S2SV_StartBug> PROFILER_ENTER ( context -> priv -> prof_nsc_decode ) <S2SV_EndBug> <S2SV_StartBug> context -> decode ( context ) ; <S2SV_EndBug> <S2SV_StartBug> PROFILER_EXIT ( context -> priv -> prof_nsc_decode ) <S2SV_EndBug> if ( ! freerdp_image_copy ( pDstData , DstFormat , nDstStride , nXDst , nYDst , width , height , context -> BitmapData , PIXEL_FORMAT_BGRA32 , 0 , 0 , 0 , NULL , flip ) ) return FALSE ; return TRUE ; }",<S2SV_ModStart> return FALSE ; { BOOL rc ; <S2SV_ModStart> -> prof_nsc_rle_decompress_data ) rc = <S2SV_ModStart> -> prof_nsc_rle_decompress_data ) if ( ! rc ) return FALSE ; } { BOOL rc ; <S2SV_ModStart> -> prof_nsc_decode ) rc = <S2SV_ModStart> -> prof_nsc_decode ) if ( ! rc ) return FALSE ; },FreeRDP@FreeRDP/d1112c279bd1a327e8e4d0b5f371458bf2579659,CVE-2018-8788,https://github.com/FreeRDP/FreeRDP/commit/d1112c279bd1a327e8e4d0b5f371458bf2579659,2018-11-29T18:29Z
CWE-416,"CWE-416 static void sunkbd_enable ( struct sunkbd * sunkbd , bool enable ) { serio_pause_rx ( sunkbd -> serio ) ; sunkbd -> enabled = enable ; serio_continue_rx ( sunkbd -> serio ) ; <S2SV_StartBug> } <S2SV_EndBug>",<S2SV_ModStart> serio ) ; if ( ! enable ) { wake_up_interruptible ( & sunkbd -> wait ) ; cancel_work_sync ( & sunkbd -> tq ) ; },torvalds@linux/77e70d351db7de07a46ac49b87a6c3c7a60fca7e,CVE-2020-25669,https://github.com/torvalds/linux/commit/77e70d351db7de07a46ac49b87a6c3c7a60fca7e,2021-05-26T12:15Z
CWE-125,"CWE-125 void Util_handleEscapes ( char * buf ) { int editpos ; int insertpos ; ASSERT ( buf ) ; for ( editpos = insertpos = 0 ; * ( buf + editpos ) != '\\0' ; editpos ++ , insertpos ++ ) { if ( * ( buf + editpos ) == '\\\\' ) { switch ( * ( buf + editpos + 1 ) ) { case 'n' : * ( buf + insertpos ) = '\\n' ; editpos ++ ; break ; case 't' : * ( buf + insertpos ) = '\\t' ; editpos ++ ; break ; case 'r' : * ( buf + insertpos ) = '\\r' ; editpos ++ ; break ; case '<S2SV_blank>' : * ( buf + insertpos ) = '<S2SV_blank>' ; editpos ++ ; break ; case '0' : if ( * ( buf + editpos + 2 ) == 'x' ) { if ( ( * ( buf + editpos + 3 ) == '0' && * ( buf + editpos + 4 ) == '0' ) ) { * ( buf + insertpos ) = * ( buf + editpos ) ; } else { <S2SV_StartBug> * ( buf + insertpos ) = x2c ( & buf [ editpos + 3 ] ) ; <S2SV_EndBug> editpos += 4 ; } } break ; case '\\\\' : * ( buf + insertpos ) = '\\\\' ; editpos ++ ; break ; default : * ( buf + insertpos ) = * ( buf + editpos ) ; } } else { * ( buf + insertpos ) = * ( buf + editpos ) ; } } * ( buf + insertpos ) = '\\0' ; }",<S2SV_ModStart> insertpos ) = _x2c <S2SV_ModEnd> ( & buf,tildeslash@monit/f12d0cdb42d4e74dffe1525d4062c815c48ac57a,CVE-2019-11455,https://bitbucket.org/tildeslash/monit/commit/f12d0cdb42d4e74dffe1525d4062c815c48ac57a,2019-04-22T16:29Z
CWE-119,"CWE-119 static gboolean cosine_read ( wtap * wth , int * err , gchar * * err_info , gint64 * data_offset ) { <S2SV_StartBug> gint64 offset ; <S2SV_EndBug> int pkt_len ; char line [ COSINE_LINE_LENGTH ] ; offset = cosine_seek_next_packet ( wth , err , err_info , line ) ; if ( offset < 0 ) return FALSE ; * data_offset = offset ; <S2SV_StartBug> pkt_len = parse_cosine_rec_hdr ( & wth -> phdr , line , err , err_info ) ; <S2SV_EndBug> if ( pkt_len == - 1 ) return FALSE ; <S2SV_StartBug> return parse_cosine_hex_dump ( wth -> fh , & wth -> phdr , pkt_len , <S2SV_EndBug> <S2SV_StartBug> wth -> frame_buffer , err , err_info ) ; <S2SV_EndBug> }","<S2SV_ModStart> { gint64 offset <S2SV_ModEnd> ; char line <S2SV_ModStart> = offset ; return parse_cosine_packet <S2SV_ModEnd> ( wth -> <S2SV_ModStart> -> phdr , <S2SV_ModEnd> wth -> frame_buffer <S2SV_ModStart> wth -> frame_buffer , line",wireshark@wireshark/f5ec0afb766f19519ea9623152cca3bbe2229500,CVE-2016-5356,https://github.com/wireshark/wireshark/commit/f5ec0afb766f19519ea9623152cca3bbe2229500,2016-08-07T16:59Z
CWE-20,"CWE-20 void SetColor ( double c , double m , double y , double k , int par ) { if ( par == STROKING ) { <S2SV_StartBug> outpos += sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>K"" , c , m , y , k ) ; <S2SV_EndBug> } else { <S2SV_StartBug> outpos += sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>k"" , c , m , y , k ) ; <S2SV_EndBug> } <S2SV_StartBug> } <S2SV_EndBug>","<S2SV_ModStart> STROKING ) { sprintf ( outputbuffer <S2SV_ModEnd> , ""<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>K"" , <S2SV_ModStart> } else { sprintf ( outputbuffer <S2SV_ModEnd> , ""<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>k"" , <S2SV_ModStart> ) ; } sendClean ( outputbuffer ) ;",TeX-Live@texlive-source/9216833a3888a4105a18e8c349f65b045ddb1079,CVE-2019-18604,https://github.com/TeX-Live/texlive-source/commit/9216833a3888a4105a18e8c349f65b045ddb1079,2019-10-29T19:15Z
CWE-189,"CWE-189 static void sgi_timer_get ( struct k_itimer * timr , struct itimerspec * cur_setting ) { if ( timr -> it . mmtimer . clock == TIMER_OFF ) { cur_setting -> it_interval . tv_nsec = 0 ; cur_setting -> it_interval . tv_sec = 0 ; cur_setting -> it_value . tv_nsec = 0 ; cur_setting -> it_value . tv_sec = 0 ; return ; } <S2SV_StartBug> ns_to_timespec ( cur_setting -> it_interval , timr -> it . mmtimer . incr * sgi_clock_period ) ; <S2SV_EndBug> <S2SV_StartBug> ns_to_timespec ( cur_setting -> it_value , ( timr -> it . mmtimer . expires - rtc_time ( ) ) * sgi_clock_period ) ; <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> }",<S2SV_ModStart> return ; } <S2SV_ModEnd> cur_setting -> it_interval <S2SV_ModStart> cur_setting -> it_interval = ns_to_timespec ( <S2SV_ModEnd> timr -> it <S2SV_ModStart> sgi_clock_period ) ; <S2SV_ModEnd> cur_setting -> it_value <S2SV_ModStart> cur_setting -> it_value = ns_to_timespec ( <S2SV_ModEnd> ( timr -> <S2SV_ModStart> sgi_clock_period ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>,torvalds@linux/f8bd2258e2d520dff28c855658bd24bdafb5102d,CVE-2011-3209,https://github.com/torvalds/linux/commit/f8bd2258e2d520dff28c855658bd24bdafb5102d,2012-10-03T11:02Z
CWE-189,"CWE-189 void jiffies_to_timeval ( const unsigned long jiffies , struct timeval * value ) { <S2SV_StartBug> u64 nsec = ( u64 ) jiffies * TICK_NSEC ; <S2SV_EndBug> long tv_usec ; <S2SV_StartBug> value -> tv_sec = div_long_long_rem ( nsec , NSEC_PER_SEC , & tv_usec ) ; <S2SV_EndBug> tv_usec /= NSEC_PER_USEC ; <S2SV_StartBug> value -> tv_usec = tv_usec ; <S2SV_EndBug> }","<S2SV_ModStart> value ) { u32 rem ; value -> tv_sec = div_u64_rem ( <S2SV_ModEnd> ( u64 ) <S2SV_ModStart> jiffies * TICK_NSEC , <S2SV_ModEnd> NSEC_PER_SEC , & <S2SV_ModStart> NSEC_PER_SEC , & rem ) <S2SV_ModEnd> ; value -> <S2SV_ModStart> -> tv_usec = rem / NSEC_PER_USEC <S2SV_ModEnd> ; } <S2SV_null>",torvalds@linux/f8bd2258e2d520dff28c855658bd24bdafb5102d,CVE-2011-3209,https://github.com/torvalds/linux/commit/f8bd2258e2d520dff28c855658bd24bdafb5102d,2012-10-03T11:02Z
CWE-476,"CWE-476 static int compile_length_bag_node ( BagNode * node , regex_t * reg ) { int len ; int tlen ; if ( node -> type == BAG_OPTION ) return compile_length_option_node ( node , reg ) ; if ( NODE_BAG_BODY ( node ) ) { tlen = compile_length_tree ( NODE_BAG_BODY ( node ) , reg ) ; if ( tlen < 0 ) return tlen ; } else tlen = 0 ; switch ( node -> type ) { case BAG_MEMORY : # ifdef USE_CALL if ( node -> m . regnum == 0 && NODE_IS_CALLED ( node ) ) { len = tlen + SIZE_OP_CALL + SIZE_OP_JUMP + SIZE_OP_RETURN ; return len ; } if ( NODE_IS_CALLED ( node ) ) { len = SIZE_OP_MEMORY_START_PUSH + tlen + SIZE_OP_CALL + SIZE_OP_JUMP + SIZE_OP_RETURN ; if ( MEM_STATUS_AT0 ( reg -> bt_mem_end , node -> m . regnum ) ) len += ( NODE_IS_RECURSION ( node ) ? SIZE_OP_MEMORY_END_PUSH_REC : SIZE_OP_MEMORY_END_PUSH ) ; else len += ( NODE_IS_RECURSION ( node ) ? SIZE_OP_MEMORY_END_REC : SIZE_OP_MEMORY_END ) ; } else if ( NODE_IS_RECURSION ( node ) ) { len = SIZE_OP_MEMORY_START_PUSH ; len += tlen + ( MEM_STATUS_AT0 ( reg -> bt_mem_end , node -> m . regnum ) ? SIZE_OP_MEMORY_END_PUSH_REC : SIZE_OP_MEMORY_END_REC ) ; } else # endif { if ( MEM_STATUS_AT0 ( reg -> bt_mem_start , node -> m . regnum ) ) len = SIZE_OP_MEMORY_START_PUSH ; else len = SIZE_OP_MEMORY_START ; len += tlen + ( MEM_STATUS_AT0 ( reg -> bt_mem_end , node -> m . regnum ) ? SIZE_OP_MEMORY_END_PUSH : SIZE_OP_MEMORY_END ) ; } break ; case BAG_STOP_BACKTRACK : if ( NODE_IS_STOP_BT_SIMPLE_REPEAT ( node ) ) { int v ; QuantNode * qn ; qn = QUANT_ ( NODE_BAG_BODY ( node ) ) ; tlen = compile_length_tree ( NODE_QUANT_BODY ( qn ) , reg ) ; if ( tlen < 0 ) return tlen ; v = onig_positive_int_multiply ( qn -> lower , tlen ) ; if ( v < 0 ) return ONIGERR_TOO_BIG_NUMBER_FOR_REPEAT_RANGE ; len = v + SIZE_OP_PUSH + tlen + SIZE_OP_POP_OUT + SIZE_OP_JUMP ; } else { len = SIZE_OP_ATOMIC_START + tlen + SIZE_OP_ATOMIC_END ; } break ; case BAG_IF_ELSE : { Node * cond = NODE_BAG_BODY ( node ) ; Node * Then = node -> te . Then ; Node * Else = node -> te . Else ; len = compile_length_tree ( cond , reg ) ; if ( len < 0 ) return len ; len += SIZE_OP_PUSH ; len += SIZE_OP_ATOMIC_START + SIZE_OP_ATOMIC_END ; if ( IS_NOT_NULL ( Then ) ) { tlen = compile_length_tree ( Then , reg ) ; if ( tlen < 0 ) return tlen ; len += tlen ; } <S2SV_StartBug> if ( IS_NOT_NULL ( Else ) ) { <S2SV_EndBug> <S2SV_StartBug> len += SIZE_OP_JUMP ; <S2SV_EndBug> tlen = compile_length_tree ( Else , reg ) ; if ( tlen < 0 ) return tlen ; len += tlen ; } } break ; case BAG_OPTION : len = 0 ; break ; } return len ; }",<S2SV_ModStart> tlen ; } len += SIZE_OP_JUMP + SIZE_OP_ATOMIC_END ; <S2SV_ModStart> ) ) { <S2SV_ModEnd> tlen = compile_length_tree,kkos@oniguruma/c509265c5f6ae7264f7b8a8aae1cfa5fc59d108c,CVE-2019-13225,https://github.com/kkos/oniguruma/commit/c509265c5f6ae7264f7b8a8aae1cfa5fc59d108c,2019-07-10T14:15Z
CWE-863,"CWE-000 static int sanitize_ptr_alu ( struct bpf_verifier_env * env , struct bpf_insn * insn , const struct bpf_reg_state * ptr_reg , const struct bpf_reg_state * off_reg , struct bpf_reg_state * dst_reg , struct bpf_insn_aux_data * tmp_aux , const bool commit_window ) { struct bpf_insn_aux_data * aux = commit_window ? cur_aux ( env ) : tmp_aux ; struct bpf_verifier_state * vstate = env -> cur_state ; <S2SV_StartBug> bool off_is_neg = off_reg -> smin_value < 0 ; <S2SV_EndBug> bool ptr_is_dst_reg = ptr_reg == dst_reg ; u8 opcode = BPF_OP ( insn -> code ) ; u32 alu_state , alu_limit ; struct bpf_reg_state tmp ; bool ret ; int err ; if ( can_skip_alu_sanitation ( env , insn ) ) return 0 ; if ( vstate -> speculative ) goto do_sim ; err = retrieve_ptr_limit ( ptr_reg , off_reg , & alu_limit , opcode ) ; if ( err < 0 ) return err ; if ( commit_window ) { alu_state = tmp_aux -> alu_state ; alu_limit = abs ( tmp_aux -> alu_limit - alu_limit ) ; } else { <S2SV_StartBug> alu_state = off_is_neg ? BPF_ALU_NEG_VALUE : 0 ; <S2SV_EndBug> alu_state |= ptr_is_dst_reg ? BPF_ALU_SANITIZE_SRC : BPF_ALU_SANITIZE_DST ; } err = update_alu_sanitation_state ( aux , alu_state , alu_limit ) ; if ( err < 0 ) return err ; do_sim : if ( commit_window ) return 0 ; if ( ! ptr_is_dst_reg ) { tmp = * dst_reg ; * dst_reg = * ptr_reg ; } ret = push_stack ( env , env -> insn_idx + 1 , env -> insn_idx , true ) ; if ( ! ptr_is_dst_reg && ret ) * dst_reg = tmp ; return ! ret ? REASON_STACK : 0 ; }",<S2SV_ModStart> cur_state ; bool off_is_imm = tnum_is_const ( off_reg -> var_off ) ; bool <S2SV_ModStart> off_is_neg ? BPF_ALU_NEG_VALUE : 0 ; alu_state |= off_is_imm ? BPF_ALU_IMMEDIATE,torvalds@linux/801c6058d14a82179a7ee17a4b532cac6fad067f,CVE-2021-31829,https://github.com/torvalds/linux/commit/801c6058d14a82179a7ee17a4b532cac6fad067f,2021-05-06T16:15Z
CWE-20,"CWE-20 error_t udpReceiveDatagram ( Socket * socket , SocketMsg * message , uint_t flags ) { error_t error ; SocketQueueItem * queueItem ; if ( ( flags & SOCKET_FLAG_DONT_WAIT ) == 0 ) { if ( socket -> receiveQueue == NULL ) { socket -> eventMask = SOCKET_EVENT_RX_READY ; osResetEvent ( & socket -> event ) ; osReleaseMutex ( & netMutex ) ; osWaitForEvent ( & socket -> event , socket -> timeout ) ; osAcquireMutex ( & netMutex ) ; } } if ( socket -> receiveQueue != NULL ) { queueItem = socket -> receiveQueue ; message -> length = netBufferRead ( message -> data , queueItem -> buffer , queueItem -> offset , message -> size ) ; <S2SV_StartBug> message -> srcIpAddr = queueItem -> srcIpAddr ; <S2SV_EndBug> message -> srcPort = queueItem -> srcPort ; message -> destIpAddr = queueItem -> destIpAddr ; message -> ttl = queueItem -> ancillary . ttl ; # if ( ETH_SUPPORT == ENABLED ) message -> srcMacAddr = queueItem -> ancillary . srcMacAddr ; message -> destMacAddr = queueItem -> ancillary . destMacAddr ; # endif # if ( ETH_PORT_TAGGING_SUPPORT == ENABLED ) message -> switchPort = queueItem -> ancillary . port ; # endif # if ( ETH_TIMESTAMP_SUPPORT == ENABLED ) message -> timestamp = queueItem -> ancillary . timestamp ; # endif if ( ( flags & SOCKET_FLAG_PEEK ) == 0 ) { socket -> receiveQueue = queueItem -> next ; netBufferFree ( queueItem -> buffer ) ; } udpUpdateEvents ( socket ) ; error = NO_ERROR ; } else { message -> length = 0 ; error = ERROR_TIMEOUT ; } return error ; }",<S2SV_ModStart> ; message -> interface = queueItem -> interface ; message ->,Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z
CWE-362,"CWE-362 static unsigned long get_seg_limit ( struct pt_regs * regs , int seg_reg_idx ) { <S2SV_StartBug> struct desc_struct * desc ; <S2SV_EndBug> unsigned long limit ; short sel ; sel = get_segment_selector ( regs , seg_reg_idx ) ; if ( sel < 0 ) return 0 ; if ( user_64bit_mode ( regs ) || v8086_mode ( regs ) ) return - 1L ; if ( ! sel ) return 0 ; <S2SV_StartBug> desc = get_desc ( sel ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! desc ) <S2SV_EndBug> return 0 ; <S2SV_StartBug> limit = get_desc_limit ( desc ) ; <S2SV_EndBug> <S2SV_StartBug> if ( desc -> g ) <S2SV_EndBug> limit = ( limit << 12 ) + 0xfff ; return limit ; }","<S2SV_ModStart> { struct desc_struct <S2SV_ModEnd> desc ; unsigned <S2SV_ModStart> return 0 ; <S2SV_ModEnd> if ( ! <S2SV_ModStart> if ( ! get_desc ( & desc , sel ) <S2SV_ModEnd> ) return 0 <S2SV_ModStart> = get_desc_limit ( & <S2SV_ModStart> if ( desc . <S2SV_ModEnd> g ) limit",torvalds@linux/de9f869616dd95e95c00bdd6b0fcd3421e8a4323,CVE-2019-13233,https://github.com/torvalds/linux/commit/de9f869616dd95e95c00bdd6b0fcd3421e8a4323,2019-07-04T13:15Z
CWE-20,"CWE-20 static int irda_recvmsg_dgram ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; struct irda_sock * self = irda_sk ( sk ) ; struct sk_buff * skb ; size_t copied ; int err ; IRDA_DEBUG ( 4 , ""%s()\\n"" , __func__ ) ; <S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> skb = skb_recv_datagram ( sk , flags & ~ MSG_DONTWAIT , flags & MSG_DONTWAIT , & err ) ; if ( ! skb ) return err ; skb_reset_transport_header ( skb ) ; copied = skb -> len ; if ( copied > size ) { IRDA_DEBUG ( 2 , ""%s(),<S2SV_blank>Received<S2SV_blank>truncated<S2SV_blank>frame<S2SV_blank>(%zd<S2SV_blank><<S2SV_blank>%zd)!\\n"" , __func__ , copied , size ) ; copied = size ; msg -> msg_flags |= MSG_TRUNC ; } skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; skb_free_datagram ( sk , skb ) ; if ( self -> rx_flow == FLOW_STOP ) { if ( ( atomic_read ( & sk -> sk_rmem_alloc ) << 2 ) <= sk -> sk_rcvbuf ) { IRDA_DEBUG ( 2 , ""%s(),<S2SV_blank>Starting<S2SV_blank>IrTTP\\n"" , __func__ ) ; self -> rx_flow = FLOW_START ; irttp_flow_request ( self -> tsap , FLOW_START ) ; } } return copied ; }",<S2SV_ModStart> __func__ ) ; <S2SV_ModEnd> skb = skb_recv_datagram,torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7270,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z
CWE-119,"CWE-119 <S2SV_StartBug> static void encode_b ( VP9_COMP * cpi , const TileInfo * const tile , <S2SV_EndBug> TOKENEXTRA * * tp , int mi_row , int mi_col , <S2SV_StartBug> int output_enabled , BLOCK_SIZE bsize ) { <S2SV_EndBug> <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> <S2SV_StartBug> if ( bsize < BLOCK_8X8 ) { <S2SV_EndBug> if ( x -> ab_index > 0 ) return ; } <S2SV_StartBug> set_offsets ( cpi , tile , mi_row , mi_col , bsize ) ; <S2SV_EndBug> <S2SV_StartBug> update_state ( cpi , get_block_context ( x , bsize ) , mi_row , mi_col , bsize , <S2SV_EndBug> output_enabled ) ; <S2SV_StartBug> encode_superblock ( cpi , tp , output_enabled , mi_row , mi_col , bsize ) ; <S2SV_EndBug> if ( output_enabled ) { <S2SV_StartBug> update_stats ( cpi ) ; <S2SV_EndBug> ( * tp ) -> token = EOSB_TOKEN ; ( * tp ) ++ ; } }","<S2SV_ModStart> * const tile , ThreadData * td <S2SV_ModStart> , BLOCK_SIZE bsize , PICK_MODE_CONTEXT * ctx <S2SV_ModStart> x = & td <S2SV_ModEnd> -> mb ; <S2SV_ModStart> -> mb ; <S2SV_ModEnd> set_offsets ( cpi <S2SV_ModStart> cpi , tile , x <S2SV_ModStart> ( cpi , td , ctx <S2SV_ModEnd> , mi_row , <S2SV_ModStart> encode_superblock ( cpi , td <S2SV_ModStart> mi_col , bsize , ctx <S2SV_ModStart> { update_stats ( & cpi -> common , td <S2SV_ModEnd> ) ; (",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-119,"CWE-119 static int udf_symlink_filler ( struct file * file , struct page * page ) { struct inode * inode = page -> mapping -> host ; struct buffer_head * bh = NULL ; unsigned char * symlink ; <S2SV_StartBug> int err = - EIO ; <S2SV_EndBug> unsigned char * p = kmap ( page ) ; struct udf_inode_info * iinfo ; <S2SV_StartBug> uint32_t pos ; <S2SV_EndBug> iinfo = UDF_I ( inode ) ; pos = udf_block_map ( inode , 0 ) ; down_read ( & iinfo -> i_data_sem ) ; if ( iinfo -> i_alloc_type == ICBTAG_FLAG_AD_IN_ICB ) { symlink = iinfo -> i_ext . i_data + iinfo -> i_lenEAttr ; } else { bh = sb_bread ( inode -> i_sb , pos ) ; <S2SV_StartBug> if ( ! bh ) <S2SV_EndBug> goto out ; symlink = bh -> b_data ; } udf_pc_to_char ( inode -> i_sb , symlink , inode -> i_size , p ) ; brelse ( bh ) ; up_read ( & iinfo -> i_data_sem ) ; SetPageUptodate ( page ) ; kunmap ( page ) ; unlock_page ( page ) ; return 0 ; <S2SV_StartBug> out : <S2SV_EndBug> up_read ( & iinfo -> i_data_sem ) ; SetPageError ( page ) ; <S2SV_StartBug> kunmap ( page ) ; <S2SV_EndBug> unlock_page ( page ) ; return err ; }",<S2SV_ModStart> ; int err <S2SV_ModEnd> ; unsigned char <S2SV_ModStart> uint32_t pos ; if ( inode -> i_size > inode -> i_sb -> s_blocksize ) { err = - ENAMETOOLONG ; goto out_unmap ; } <S2SV_ModStart> ! bh ) { err = - EIO ; goto out_unlock_inode ; } <S2SV_ModEnd> symlink = bh <S2SV_ModStart> return 0 ; out_unlock_inode <S2SV_ModEnd> : up_read ( <S2SV_ModStart> page ) ; out_unmap :,torvalds@linux/a1d47b262952a45aae62bd49cfaf33dd76c11a2c,CVE-2014-9728,https://github.com/torvalds/linux/commit/a1d47b262952a45aae62bd49cfaf33dd76c11a2c,2015-08-31T10:59Z
CWE-254,"CWE-000 static inline int handle_dots ( struct nameidata * nd , int type ) { if ( type == LAST_DOTDOT ) { if ( nd -> flags & LOOKUP_RCU ) { return follow_dotdot_rcu ( nd ) ; } else <S2SV_StartBug> follow_dotdot ( nd ) ; <S2SV_EndBug> } return 0 ; }",<S2SV_ModStart> ; } else return,torvalds@linux/397d425dc26da728396e66d392d5dcb8dac30c37,CVE-2015-2925,https://github.com/torvalds/linux/commit/397d425dc26da728396e66d392d5dcb8dac30c37,2015-11-16T11:59Z
CWE-125,"CWE-125 arg_ty <S2SV_StartBug> arg ( identifier arg , expr_ty annotation , int lineno , int col_offset , int <S2SV_EndBug> end_lineno , int end_col_offset , PyArena * arena ) { arg_ty p ; if ( ! arg ) { PyErr_SetString ( PyExc_ValueError , ""field<S2SV_blank>arg<S2SV_blank>is<S2SV_blank>required<S2SV_blank>for<S2SV_blank>arg"" ) ; return NULL ; } p = ( arg_ty ) PyArena_Malloc ( arena , sizeof ( * p ) ) ; if ( ! p ) return NULL ; p -> arg = arg ; p -> annotation = annotation ; <S2SV_StartBug> p -> lineno = lineno ; <S2SV_EndBug> p -> col_offset = col_offset ; p -> end_lineno = end_lineno ; p -> end_col_offset = end_col_offset ; return p ; }","<S2SV_ModStart> expr_ty annotation , string type_comment , <S2SV_ModStart> ; p -> type_comment = type_comment ; p ->",python@typed_ast/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,CVE-2019-19275,https://github.com/python/typed_ast/commit/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,2019-11-26T15:15Z
CWE-125,"CWE-125 static bool checkreturn decode_pointer_field ( pb_istream_t * stream , pb_wire_type_t wire_type , pb_field_iter_t * field ) { # ifndef PB_ENABLE_MALLOC PB_UNUSED ( wire_type ) ; PB_UNUSED ( field ) ; PB_RETURN_ERROR ( stream , ""no<S2SV_blank>malloc<S2SV_blank>support"" ) ; # else switch ( PB_HTYPE ( field -> type ) ) { case PB_HTYPE_REQUIRED : case PB_HTYPE_OPTIONAL : case PB_HTYPE_ONEOF : if ( ! check_wire_type ( wire_type , field ) ) PB_RETURN_ERROR ( stream , ""wrong<S2SV_blank>wire<S2SV_blank>type"" ) ; if ( PB_LTYPE_IS_SUBMSG ( field -> type ) && * ( void * * ) field -> pField != NULL ) { pb_release_single_field ( field ) ; } if ( PB_HTYPE ( field -> type ) == PB_HTYPE_ONEOF ) { * ( pb_size_t * ) field -> pSize = field -> tag ; } if ( PB_LTYPE ( field -> type ) == PB_LTYPE_STRING || PB_LTYPE ( field -> type ) == PB_LTYPE_BYTES ) { field -> pData = field -> pField ; return decode_basic_field ( stream , field ) ; } else { if ( ! allocate_field ( stream , field -> pField , field -> data_size , 1 ) ) return false ; field -> pData = * ( void * * ) field -> pField ; initialize_pointer_field ( field -> pData , field ) ; return decode_basic_field ( stream , field ) ; } case PB_HTYPE_REPEATED : if ( wire_type == PB_WT_STRING && PB_LTYPE ( field -> type ) <= PB_LTYPE_LAST_PACKABLE ) { bool status = true ; pb_size_t * size = ( pb_size_t * ) field -> pSize ; size_t allocated_size = * size ; pb_istream_t substream ; if ( ! pb_make_string_substream ( stream , & substream ) ) return false ; while ( substream . bytes_left ) { if ( ( size_t ) * size + 1 > allocated_size ) { allocated_size += ( substream . bytes_left - 1 ) / field -> data_size + 1 ; if ( ! allocate_field ( & substream , field -> pField , field -> data_size , allocated_size ) ) { status = false ; break ; } } field -> pData = * ( char * * ) field -> pField + field -> data_size * ( * size ) ; initialize_pointer_field ( field -> pData , field ) ; if ( ! decode_basic_field ( & substream , field ) ) { status = false ; break ; } if ( * size == PB_SIZE_MAX ) { # ifndef PB_NO_ERRMSG stream -> errmsg = ""too<S2SV_blank>many<S2SV_blank>array<S2SV_blank>entries"" ; # endif status = false ; break ; } ( * size ) ++ ; } if ( ! pb_close_string_substream ( stream , & substream ) ) return false ; return status ; } else { pb_size_t * size = ( pb_size_t * ) field -> pSize ; if ( * size == PB_SIZE_MAX ) PB_RETURN_ERROR ( stream , ""too<S2SV_blank>many<S2SV_blank>array<S2SV_blank>entries"" ) ; if ( ! check_wire_type ( wire_type , field ) ) PB_RETURN_ERROR ( stream , ""wrong<S2SV_blank>wire<S2SV_blank>type"" ) ; <S2SV_StartBug> ( * size ) ++ ; <S2SV_EndBug> if ( ! allocate_field ( stream , field -> pField , field -> data_size , * size ) ) return false ; field -> pData = * ( char * * ) field -> pField + field -> data_size * ( * size - 1 ) ; initialize_pointer_field ( field -> pData , field ) ; return decode_basic_field ( stream , field ) ; } default : PB_RETURN_ERROR ( stream , ""invalid<S2SV_blank>field<S2SV_blank>type"" ) ; } # endif }","<S2SV_ModStart> ""wrong<S2SV_blank>wire<S2SV_blank>type"" ) ; if ( ! allocate_field ( stream , field -> pField , field -> data_size , ( size_t ) ( * size + 1 ) ) ) return false ; field -> pData = * ( char * * ) field -> pField + field -> data_size * ( * size ) ; <S2SV_ModStart> size ) ++ <S2SV_ModEnd> ; initialize_pointer_field (",nanopb@nanopb/45582f1f97f49e2abfdba1463d1e1027682d9856,CVE-2020-5235,https://github.com/nanopb/nanopb/commit/45582f1f97f49e2abfdba1463d1e1027682d9856,2020-02-04T03:15Z
CWE-254,"CWE-000 IMPEG2D_ERROR_CODES_T impeg2d_dec_pic_ext_data ( dec_state_t * ps_dec ) { stream_t * ps_stream ; UWORD32 u4_start_code ; IMPEG2D_ERROR_CODES_T e_error ; e_error = ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE ; ps_stream = & ps_dec -> s_bit_stream ; u4_start_code = impeg2d_bit_stream_nxt ( ps_stream , START_CODE_LEN ) ; while ( ( u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE ) && <S2SV_StartBug> ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE == e_error ) <S2SV_EndBug> { if ( u4_start_code == USER_DATA_START_CODE ) { impeg2d_dec_user_data ( ps_dec ) ; } else { impeg2d_bit_stream_flush ( ps_stream , START_CODE_LEN ) ; u4_start_code = impeg2d_bit_stream_nxt ( ps_stream , EXT_ID_LEN ) ; switch ( u4_start_code ) { case QUANT_MATRIX_EXT_ID : impeg2d_dec_quant_matrix_ext ( ps_dec ) ; break ; case COPYRIGHT_EXT_ID : impeg2d_dec_copyright_ext ( ps_dec ) ; break ; case PIC_DISPLAY_EXT_ID : impeg2d_dec_pic_disp_ext ( ps_dec ) ; break ; case CAMERA_PARAM_EXT_ID : impeg2d_dec_cam_param_ext ( ps_dec ) ; break ; case ITU_T_EXT_ID : impeg2d_dec_itu_t_ext ( ps_dec ) ; break ; case PIC_SPATIAL_SCALABLE_EXT_ID : case PIC_TEMPORAL_SCALABLE_EXT_ID : e_error = IMPEG2D_SCALABLITY_NOT_SUP ; break ; default : impeg2d_bit_stream_flush ( ps_stream , EXT_ID_LEN ) ; impeg2d_next_start_code ( ps_dec ) ; break ; } } u4_start_code = impeg2d_bit_stream_nxt ( ps_stream , START_CODE_LEN ) ; } return e_error ; }",<S2SV_ModStart> IVD_ERROR_NONE == e_error && ( ps_stream -> u4_offset < ps_stream -> u4_max_offset ),external@libmpeg2/ffab15eb80630dc799eb410855c93525b75233c3,CVE-2016-0824,https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3,2016-03-12T21:59Z
CWE-119,"CWE-119 struct se_portal_group * tcm_loop_make_naa_tpg ( struct se_wwn * wwn , struct config_group * group , const char * name ) { struct tcm_loop_hba * tl_hba = container_of ( wwn , struct tcm_loop_hba , tl_hba_wwn ) ; struct tcm_loop_tpg * tl_tpg ; char * tpgt_str , * end_ptr ; int ret ; unsigned short int tpgt ; tpgt_str = strstr ( name , ""tpgt_"" ) ; if ( ! tpgt_str ) { printk ( KERN_ERR ""Unable<S2SV_blank>to<S2SV_blank>locate<S2SV_blank>\\""tpgt_#\\""<S2SV_blank>directory"" ""<S2SV_blank>group\\n"" ) ; return ERR_PTR ( - EINVAL ) ; } tpgt_str += 5 ; tpgt = ( unsigned short int ) simple_strtoul ( tpgt_str , & end_ptr , 0 ) ; <S2SV_StartBug> if ( tpgt > TL_TPGS_PER_HBA ) { <S2SV_EndBug> printk ( KERN_ERR ""Passed<S2SV_blank>tpgt:<S2SV_blank>%hu<S2SV_blank>exceeds<S2SV_blank>TL_TPGS_PER_HBA:"" ""<S2SV_blank>%u\\n"" , tpgt , TL_TPGS_PER_HBA ) ; return ERR_PTR ( - EINVAL ) ; } tl_tpg = & tl_hba -> tl_hba_tpgs [ tpgt ] ; tl_tpg -> tl_hba = tl_hba ; tl_tpg -> tl_tpgt = tpgt ; ret = core_tpg_register ( & tcm_loop_fabric_configfs -> tf_ops , wwn , & tl_tpg -> tl_se_tpg , tl_tpg , TRANSPORT_TPG_TYPE_NORMAL ) ; if ( ret < 0 ) return ERR_PTR ( - ENOMEM ) ; printk ( KERN_INFO ""TCM_Loop_ConfigFS:<S2SV_blank>Allocated<S2SV_blank>Emulated<S2SV_blank>%s"" ""<S2SV_blank>Target<S2SV_blank>Port<S2SV_blank>%s,t,0x%04x\\n"" , tcm_loop_dump_proto_id ( tl_hba ) , config_item_name ( & wwn -> wwn_group . cg_item ) , tpgt ) ; return & tl_tpg -> tl_se_tpg ; }",<S2SV_ModStart> if ( tpgt >= <S2SV_ModEnd> TL_TPGS_PER_HBA ) {,torvalds@linux/12f09ccb4612734a53e47ed5302e0479c10a50f8,CVE-2011-5327,https://github.com/torvalds/linux/commit/12f09ccb4612734a53e47ed5302e0479c10a50f8,2019-07-27T22:15Z
CWE-119,CWE-119 <S2SV_StartBug> static vp9_variance_fn_t get_block_variance_fn ( BLOCK_SIZE bsize ) { <S2SV_EndBug> switch ( bsize ) { case BLOCK_8X8 : <S2SV_StartBug> return vp9_mse8x8 ; <S2SV_EndBug> case BLOCK_16X8 : <S2SV_StartBug> return vp9_mse16x8 ; <S2SV_EndBug> case BLOCK_8X16 : <S2SV_StartBug> return vp9_mse8x16 ; <S2SV_EndBug> default : <S2SV_StartBug> return vp9_mse16x16 ; <S2SV_EndBug> } },<S2SV_ModStart> <S2SV_null> <S2SV_null> static vpx_variance_fn_t <S2SV_ModEnd> get_block_variance_fn ( BLOCK_SIZE <S2SV_ModStart> BLOCK_8X8 : return vpx_mse8x8 <S2SV_ModEnd> ; case BLOCK_16X8 <S2SV_ModStart> BLOCK_16X8 : return vpx_mse16x8 <S2SV_ModEnd> ; case BLOCK_8X16 <S2SV_ModStart> BLOCK_8X16 : return vpx_mse8x16 <S2SV_ModEnd> ; default : <S2SV_ModStart> default : return vpx_mse16x16 <S2SV_ModEnd> ; } },external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-20,"CWE-20 error_t coapClientSetRxBlockSize ( CoapClientRequest * request , uint_t blockSize ) { if ( request == NULL ) return ERROR_INVALID_PARAMETER ; osAcquireMutex ( & request -> context -> mutex ) ; if ( blockSize == 16 ) <S2SV_StartBug> request -> rxBlockSzx = COAP_BLOCK_SIZE_16 ; <S2SV_EndBug> <S2SV_StartBug> else if ( blockSize == 32 ) <S2SV_EndBug> <S2SV_StartBug> request -> rxBlockSzx = COAP_BLOCK_SIZE_32 ; <S2SV_EndBug> <S2SV_StartBug> else if ( blockSize == 64 ) <S2SV_EndBug> <S2SV_StartBug> request -> rxBlockSzx = COAP_BLOCK_SIZE_64 ; <S2SV_EndBug> <S2SV_StartBug> else if ( blockSize == 128 ) <S2SV_EndBug> <S2SV_StartBug> request -> rxBlockSzx = COAP_BLOCK_SIZE_128 ; <S2SV_EndBug> <S2SV_StartBug> else if ( blockSize == 256 ) <S2SV_EndBug> <S2SV_StartBug> request -> rxBlockSzx = COAP_BLOCK_SIZE_256 ; <S2SV_EndBug> <S2SV_StartBug> else if ( blockSize == 512 ) <S2SV_EndBug> <S2SV_StartBug> request -> rxBlockSzx = COAP_BLOCK_SIZE_512 ; <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> request -> rxBlockSzx = COAP_BLOCK_SIZE_1024 ; <S2SV_EndBug> if ( request -> rxBlockSzx > coapClientGetMaxBlockSize ( ) ) <S2SV_StartBug> request -> rxBlockSzx = coapClientGetMaxBlockSize ( ) ; <S2SV_EndBug> osReleaseMutex ( & request -> context -> mutex ) ; return NO_ERROR ; }",<S2SV_ModStart> == 16 ) { <S2SV_ModStart> = COAP_BLOCK_SIZE_16 ; } <S2SV_ModStart> == 32 ) { <S2SV_ModStart> = COAP_BLOCK_SIZE_32 ; } <S2SV_ModStart> == 64 ) { <S2SV_ModStart> = COAP_BLOCK_SIZE_64 ; } <S2SV_ModStart> == 128 ) { <S2SV_ModStart> = COAP_BLOCK_SIZE_128 ; } <S2SV_ModStart> == 256 ) { <S2SV_ModStart> = COAP_BLOCK_SIZE_256 ; } <S2SV_ModStart> == 512 ) { <S2SV_ModStart> = COAP_BLOCK_SIZE_512 ; } else { <S2SV_ModEnd> request -> rxBlockSzx <S2SV_ModStart> = COAP_BLOCK_SIZE_1024 ; } <S2SV_ModStart> ( ) ) { <S2SV_ModStart> ( ) ; },Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z
,"CWE-000 SYSCALL_DEFINE4 ( epoll_ctl , int , epfd , int , op , int , fd , struct epoll_event __user * , event ) { int error ; int did_lock_epmutex = 0 ; struct file * file , * tfile ; struct eventpoll * ep ; struct epitem * epi ; struct epoll_event epds ; error = - EFAULT ; if ( ep_op_has_event ( op ) && copy_from_user ( & epds , event , sizeof ( struct epoll_event ) ) ) goto error_return ; error = - EBADF ; file = fget ( epfd ) ; if ( ! file ) goto error_return ; tfile = fget ( fd ) ; if ( ! tfile ) goto error_fput ; error = - EPERM ; if ( ! tfile -> f_op || ! tfile -> f_op -> poll ) goto error_tgt_fput ; error = - EINVAL ; if ( file == tfile || ! is_file_epoll ( file ) ) goto error_tgt_fput ; ep = file -> private_data ; if ( op == EPOLL_CTL_ADD || op == EPOLL_CTL_DEL ) { mutex_lock ( & epmutex ) ; did_lock_epmutex = 1 ; } if ( op == EPOLL_CTL_ADD ) { if ( is_file_epoll ( tfile ) ) { error = - ELOOP ; <S2SV_StartBug> if ( ep_loop_check ( ep , tfile ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> goto error_tgt_fput ; <S2SV_EndBug> } else list_add ( & tfile -> f_tfile_llink , & tfile_check_list ) ; } mutex_lock_nested ( & ep -> mtx , 0 ) ; epi = ep_find ( ep , tfile , fd ) ; error = - EINVAL ; switch ( op ) { case EPOLL_CTL_ADD : if ( ! epi ) { epds . events |= POLLERR | POLLHUP ; error = ep_insert ( ep , & epds , tfile , fd ) ; } else error = - EEXIST ; clear_tfile_check_list ( ) ; break ; case EPOLL_CTL_DEL : if ( epi ) error = ep_remove ( ep , epi ) ; else error = - ENOENT ; break ; case EPOLL_CTL_MOD : if ( epi ) { epds . events |= POLLERR | POLLHUP ; error = ep_modify ( ep , epi , & epds ) ; } else error = - ENOENT ; break ; } mutex_unlock ( & ep -> mtx ) ; error_tgt_fput : if ( did_lock_epmutex ) mutex_unlock ( & epmutex ) ; fput ( tfile ) ; error_fput : fput ( file ) ; error_return : return error ; }",<S2SV_ModStart> != 0 ) { clear_tfile_check_list ( ) ; <S2SV_ModStart> goto error_tgt_fput ; },torvalds@linux/13d518074a952d33d47c428419693f63389547e9,CVE-2012-3375,https://github.com/torvalds/linux/commit/13d518074a952d33d47c428419693f63389547e9,2012-10-03T11:02Z
CWE-119,"CWE-119 <S2SV_StartBug> static int prob_diff_update_cost ( vp9_prob newp , vp9_prob oldp ) { <S2SV_EndBug> int delp = remap_prob ( newp , oldp ) ; return update_bits [ delp ] * 256 ; }","<S2SV_ModStart> int prob_diff_update_cost ( vpx_prob newp , vpx_prob <S2SV_ModEnd> oldp ) {",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-404,"CWE-000 int nfs3svc_decode_readdirargs ( struct svc_rqst * rqstp , __be32 * p , struct nfsd3_readdirargs * args ) { p = decode_fh ( p , & args -> fh ) ; if ( ! p ) return 0 ; p = xdr_decode_hyper ( p , & args -> cookie ) ; args -> verf = p ; p += 2 ; args -> dircount = ~ 0 ; args -> count = ntohl ( * p ++ ) ; <S2SV_StartBug> args -> count = min_t ( u32 , args -> count , PAGE_SIZE ) ; <S2SV_EndBug> args -> buffer = page_address ( * ( rqstp -> rq_next_page ++ ) ) ; <S2SV_StartBug> return xdr_argsize_check ( rqstp , p ) ; <S2SV_EndBug> }","<S2SV_ModStart> ++ ) ; if ( ! xdr_argsize_check ( rqstp , p ) ) return 0 ; <S2SV_ModStart> ) ; return 1 <S2SV_ModEnd> ; } <S2SV_null>",torvalds@linux/c70422f760c120480fee4de6c38804c72aa26bc1,CVE-2017-9059,https://github.com/torvalds/linux/commit/c70422f760c120480fee4de6c38804c72aa26bc1,2017-05-18T06:29Z
CWE-125,"CWE-125 <S2SV_StartBug> void ntlm_populate_message_header ( NTLM_MESSAGE_HEADER * header , UINT32 MessageType ) <S2SV_EndBug> { CopyMemory ( header -> Signature , NTLM_SIGNATURE , sizeof ( NTLM_SIGNATURE ) ) ; header -> MessageType = MessageType ; }",<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static,FreeRDP@FreeRDP/2ee663f39dc8dac3d9988e847db19b2d7e3ac8c6,CVE-2018-8789,https://github.com/FreeRDP/FreeRDP/commit/2ee663f39dc8dac3d9988e847db19b2d7e3ac8c6,2018-11-29T18:29Z
NVD-CWE-noinfo,"CWE-000 void Con_Dump_f ( void ) { int l , x , i ; short * line ; fileHandle_t f ; int bufferlen ; char * buffer ; char filename [ MAX_QPATH ] ; if ( Cmd_Argc ( ) != 2 ) { Com_Printf ( ""usage:<S2SV_blank>condump<S2SV_blank><filename>\\n"" ) ; return ; } Q_strncpyz ( filename , Cmd_Argv ( 1 ) , sizeof ( filename ) ) ; <S2SV_StartBug> COM_DefaultExtension ( filename , sizeof ( filename ) , "".txt"" ) ; <S2SV_EndBug> f = FS_FOpenFileWrite ( filename ) ; if ( ! f ) { Com_Printf ( ""ERROR:<S2SV_blank>couldn\'t<S2SV_blank>open<S2SV_blank>%s.\\n"" , filename ) ; return ; } Com_Printf ( ""Dumped<S2SV_blank>console<S2SV_blank>text<S2SV_blank>to<S2SV_blank>%s.\\n"" , filename ) ; for ( l = con . current - con . totallines + 1 ; l <= con . current ; l ++ ) { line = con . text + ( l % con . totallines ) * con . linewidth ; for ( x = 0 ; x < con . linewidth ; x ++ ) if ( ( line [ x ] & 0xff ) != '<S2SV_blank>' ) { break ; } if ( x != con . linewidth ) { break ; } } # ifdef _WIN32 bufferlen = con . linewidth + 3 * sizeof ( char ) ; # else bufferlen = con . linewidth + 2 * sizeof ( char ) ; # endif buffer = Hunk_AllocateTempMemory ( bufferlen ) ; buffer [ bufferlen - 1 ] = 0 ; for ( ; l <= con . current ; l ++ ) { line = con . text + ( l % con . totallines ) * con . linewidth ; for ( i = 0 ; i < con . linewidth ; i ++ ) buffer [ i ] = line [ i ] & 0xff ; for ( x = con . linewidth - 1 ; x >= 0 ; x -- ) { if ( buffer [ x ] == '<S2SV_blank>' ) { buffer [ x ] = 0 ; } else { break ; } } # ifdef _WIN32 Q_strcat ( buffer , bufferlen , ""\\r\\n"" ) ; # else Q_strcat ( buffer , bufferlen , ""\\n"" ) ; # endif FS_Write ( buffer , strlen ( buffer ) , f ) ; } Hunk_FreeTempMemory ( buffer ) ; FS_FCloseFile ( f ) ; }","<S2SV_ModStart> "".txt"" ) ; if ( ! COM_CompareExtension ( filename , "".txt"" ) ) { Com_Printf ( ""Con_Dump_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\"".txt\\""<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\n"" ) ; return ; }",JACoders@OpenJK/11a83410153756ae350a82ed41b08d128ff7f998,CVE-2017-6903,https://github.com/JACoders/OpenJK/commit/11a83410153756ae350a82ed41b08d128ff7f998,2017-03-14T22:59Z
CWE-285,"CWE-000 static int __btrfs_set_acl ( struct btrfs_trans_handle * trans , struct inode * inode , struct posix_acl * acl , int type ) { int ret , size = 0 ; const char * name ; char * value = NULL ; switch ( type ) { case ACL_TYPE_ACCESS : name = XATTR_NAME_POSIX_ACL_ACCESS ; if ( acl ) { <S2SV_StartBug> ret = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; <S2SV_EndBug> if ( ret < 0 ) return ret ; if ( ret == 0 ) acl = NULL ; } ret = 0 ; break ; case ACL_TYPE_DEFAULT : if ( ! S_ISDIR ( inode -> i_mode ) ) return acl ? - EINVAL : 0 ; name = XATTR_NAME_POSIX_ACL_DEFAULT ; break ; default : return - EINVAL ; } if ( acl ) { size = posix_acl_xattr_size ( acl -> a_count ) ; value = kmalloc ( size , GFP_KERNEL ) ; if ( ! value ) { ret = - ENOMEM ; goto out ; } ret = posix_acl_to_xattr ( & init_user_ns , acl , value , size ) ; if ( ret < 0 ) goto out ; } ret = __btrfs_setxattr ( trans , inode , name , value , size , 0 ) ; out : kfree ( value ) ; if ( ! ret ) set_cached_acl ( inode , type , acl ) ; return ret ; }","<S2SV_ModStart> { ret = posix_acl_update_mode ( inode <S2SV_ModEnd> , & inode <S2SV_ModStart> inode -> i_mode , & acl ) ; if ( ret ) return ret <S2SV_ModEnd> ; } ret",torvalds@linux/073931017b49d9458aa351605b43a7e34598caef,CVE-2016-7097,https://github.com/torvalds/linux/commit/073931017b49d9458aa351605b43a7e34598caef,2016-10-16T21:59Z
CWE-787,"CWE-787 static int list_devices ( struct file * filp , struct dm_ioctl * param , size_t param_size ) { unsigned int i ; struct hash_cell * hc ; size_t len , needed = 0 ; struct gendisk * disk ; struct dm_name_list * orig_nl , * nl , * old_nl = NULL ; uint32_t * event_nr ; down_write ( & _hash_lock ) ; for ( i = 0 ; i < NUM_BUCKETS ; i ++ ) { list_for_each_entry ( hc , _name_buckets + i , name_list ) { needed += align_val ( offsetof ( struct dm_name_list , name ) + strlen ( hc -> name ) + 1 ) ; needed += align_val ( sizeof ( uint32_t ) ) ; } } nl = orig_nl = get_result_buffer ( param , param_size , & len ) ; <S2SV_StartBug> if ( len < needed ) { <S2SV_EndBug> param -> flags |= DM_BUFFER_FULL_FLAG ; goto out ; } param -> data_size = param -> data_start + needed ; nl -> dev = 0 ; for ( i = 0 ; i < NUM_BUCKETS ; i ++ ) { list_for_each_entry ( hc , _name_buckets + i , name_list ) { if ( old_nl ) old_nl -> next = ( uint32_t ) ( ( void * ) nl - ( void * ) old_nl ) ; disk = dm_disk ( hc -> md ) ; nl -> dev = huge_encode_dev ( disk_devt ( disk ) ) ; nl -> next = 0 ; strcpy ( nl -> name , hc -> name ) ; old_nl = nl ; event_nr = align_ptr ( nl -> name + strlen ( hc -> name ) + 1 ) ; * event_nr = dm_get_event_nr ( hc -> md ) ; nl = align_ptr ( event_nr + 1 ) ; } } BUG_ON ( ( char * ) nl - ( char * ) orig_nl != needed ) ; out : up_write ( & _hash_lock ) ; return 0 ; }",<S2SV_ModStart> len < needed || len < sizeof ( nl -> dev ),torvalds@linux/4edbe1d7bcffcd6269f3b5eb63f710393ff2ec7a,CVE-2021-31916,https://github.com/torvalds/linux/commit/4edbe1d7bcffcd6269f3b5eb63f710393ff2ec7a,2021-05-06T17:15Z
CWE-119,"CWE-119 static int cx24116_send_diseqc_msg ( struct dvb_frontend * fe , struct dvb_diseqc_master_cmd * d ) { struct cx24116_state * state = fe -> demodulator_priv ; int i , ret ; <S2SV_StartBug> if ( debug ) { <S2SV_EndBug> printk ( KERN_INFO ""cx24116:<S2SV_blank>%s("" , __func__ ) ; for ( i = 0 ; i < d -> msg_len ; ) { printk ( KERN_INFO ""0x%02x"" , d -> msg [ i ] ) ; if ( ++ i < d -> msg_len ) printk ( KERN_INFO "",<S2SV_blank>"" ) ; } printk ( "")<S2SV_blank>toneburst=%d\\n"" , toneburst ) ; } <S2SV_StartBug> if ( d -> msg_len > ( CX24116_ARGLEN - CX24116_DISEQC_MSGOFS ) ) <S2SV_EndBug> return - EINVAL ; for ( i = 0 ; i < d -> msg_len ; i ++ ) state -> dsec_cmd . args [ CX24116_DISEQC_MSGOFS + i ] = d -> msg [ i ] ; state -> dsec_cmd . args [ CX24116_DISEQC_MSGLEN ] = d -> msg_len ; state -> dsec_cmd . len = CX24116_DISEQC_MSGOFS + state -> dsec_cmd . args [ CX24116_DISEQC_MSGLEN ] ; if ( toneburst == CX24116_DISEQC_MESGCACHE ) return 0 ; else if ( toneburst == CX24116_DISEQC_TONEOFF ) state -> dsec_cmd . args [ CX24116_DISEQC_BURST ] = 0 ; else if ( toneburst == CX24116_DISEQC_TONECACHE ) { if ( d -> msg_len >= 4 && d -> msg [ 2 ] == 0x38 ) state -> dsec_cmd . args [ CX24116_DISEQC_BURST ] = ( ( d -> msg [ 3 ] & 4 ) >> 2 ) ; if ( debug ) dprintk ( ""%s<S2SV_blank>burst=%d\\n"" , __func__ , state -> dsec_cmd . args [ CX24116_DISEQC_BURST ] ) ; } ret = cx24116_wait_for_lnb ( fe ) ; if ( ret != 0 ) return ret ; msleep ( 100 ) ; ret = cx24116_cmd_execute ( fe , & state -> dsec_cmd ) ; if ( ret != 0 ) return ret ; msleep ( ( state -> dsec_cmd . args [ CX24116_DISEQC_MSGLEN ] << 4 ) + ( ( toneburst == CX24116_DISEQC_TONEOFF ) ? 30 : 60 ) ) ; return 0 ; }",<S2SV_ModStart> ; if ( d -> msg_len > sizeof ( d -> msg ) ) return - EINVAL ; if ( <S2SV_ModStart> ) ; } <S2SV_ModEnd> for ( i,torvalds@linux/1fa2337a315a2448c5434f41e00d56b01a22283c,CVE-2015-9289,https://github.com/torvalds/linux/commit/1fa2337a315a2448c5434f41e00d56b01a22283c,2019-07-27T22:15Z
CWE-494,"CWE-000 LONG ValidateSignature ( HWND hDlg , const char * path ) { LONG r ; WINTRUST_DATA trust_data = { 0 } ; WINTRUST_FILE_INFO trust_file = { 0 } ; GUID guid_generic_verify = { 0xaac56b , 0xcd44 , 0x11d0 , { 0x8c , 0xc2 , 0x0 , 0xc0 , 0x4f , 0xc2 , 0x95 , 0xee } } ; char * signature_name ; size_t i , len ; signature_name = GetSignatureName ( path ) ; if ( signature_name == NULL ) { uprintf ( ""PKI:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>get<S2SV_blank>signature<S2SV_blank>name"" ) ; MessageBoxExU ( hDlg , lmprintf ( MSG_284 ) , lmprintf ( MSG_283 ) , MB_OK | MB_ICONERROR | MB_IS_RTL , selected_langid ) ; return TRUST_E_NOSIGNATURE ; } for ( i = 0 ; i < ARRAYSIZE ( cert_name ) ; i ++ ) { len = strlen ( cert_name [ i ] ) ; if ( strncmp ( signature_name , cert_name [ i ] , len ) == 0 ) { if ( ( len >= strlen ( signature_name ) ) || isspace ( signature_name [ len ] ) ) break ; } } if ( i >= ARRAYSIZE ( cert_name ) ) { uprintf ( ""PKI:<S2SV_blank>Signature<S2SV_blank>\'%s\'<S2SV_blank>is<S2SV_blank>unexpected..."" , signature_name ) ; if ( MessageBoxExU ( hDlg , lmprintf ( MSG_285 , signature_name ) , lmprintf ( MSG_283 ) , MB_YESNO | MB_ICONWARNING | MB_IS_RTL , selected_langid ) != IDYES ) return TRUST_E_EXPLICIT_DISTRUST ; } trust_file . cbStruct = sizeof ( trust_file ) ; trust_file . pcwszFilePath = utf8_to_wchar ( path ) ; if ( trust_file . pcwszFilePath == NULL ) { uprintf ( ""PKI:<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>convert<S2SV_blank>\'%s\'<S2SV_blank>to<S2SV_blank>UTF16"" , path ) ; return ERROR_SEVERITY_ERROR | FAC ( FACILITY_CERT ) | ERROR_NOT_ENOUGH_MEMORY ; } trust_data . cbStruct = sizeof ( trust_data ) ; <S2SV_StartBug> trust_data . dwUIChoice = WTD_UI_ALL ; <S2SV_EndBug> trust_data . fdwRevocationChecks = WTD_REVOKE_WHOLECHAIN ; trust_data . dwProvFlags = WTD_REVOCATION_CHECK_CHAIN | 0x400 ; trust_data . dwUnionChoice = WTD_CHOICE_FILE ; trust_data . pFile = & trust_file ; r = WinVerifyTrust ( NULL , & guid_generic_verify , & trust_data ) ; safe_free ( trust_file . pcwszFilePath ) ; <S2SV_StartBug> return r ; <S2SV_EndBug> }","<S2SV_ModStart> . dwUIChoice = WTD_UI_NONE <S2SV_ModEnd> ; trust_data . <S2SV_ModStart> pcwszFilePath ) ; switch ( r ) { case ERROR_SUCCESS : break ; case TRUST_E_NOSIGNATURE : uprintf ( ""PKI:<S2SV_blank>File<S2SV_blank>does<S2SV_blank>not<S2SV_blank>appear<S2SV_blank>to<S2SV_blank>be<S2SV_blank>signed:<S2SV_blank>%s"" , WinPKIErrorString ( ) ) ; MessageBoxExU ( hDlg , lmprintf ( MSG_284 ) , lmprintf ( MSG_283 ) , MB_OK | MB_ICONERROR | MB_IS_RTL , selected_langid ) ; break ; default : uprintf ( ""PKI:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>validate<S2SV_blank>signature:<S2SV_blank>%s"" , WinPKIErrorString ( ) ) ; MessageBoxExU ( hDlg , lmprintf ( MSG_240 ) , lmprintf ( MSG_283 ) , MB_OK | MB_ICONERROR | MB_IS_RTL , selected_langid ) ; break ; }",pbatard@rufus/c3c39f7f8a11f612c4ebf7affce25ec6928eb1cb,CVE-2017-13083,https://github.com/pbatard/rufus/commit/c3c39f7f8a11f612c4ebf7affce25ec6928eb1cb,2017-10-18T13:29Z
CWE-190,CWE-190 TfLiteIntArray * TfLiteIntArrayCreate ( int size ) { <S2SV_StartBug> TfLiteIntArray * ret = <S2SV_EndBug> <S2SV_StartBug> ( TfLiteIntArray * ) malloc ( TfLiteIntArrayGetSizeInBytes ( size ) ) ; <S2SV_EndBug> ret -> size = size ; return ret ; },<S2SV_ModStart> size ) { int alloc_size = TfLiteIntArrayGetSizeInBytes ( size ) ; if ( alloc_size <= 0 ) return NULL ; <S2SV_ModStart> ) malloc ( alloc_size ) ; if ( ! ret ) return ret <S2SV_ModEnd> ; ret ->,tensorflow@tensorflow/7c8cc4ec69cd348e44ad6a2699057ca88faad3e5,CVE-2021-29605,https://github.com/tensorflow/tensorflow/commit/7c8cc4ec69cd348e44ad6a2699057ca88faad3e5,2021-05-14T20:15Z
CWE-200,"CWE-200 enum auth_stat gssrpc__svcauth_gss ( struct svc_req * rqst , struct rpc_msg * msg , bool_t * no_dispatch ) { enum auth_stat retstat ; XDR xdrs ; SVCAUTH * auth ; struct svc_rpc_gss_data * gd ; struct rpc_gss_cred * gc ; struct rpc_gss_init_res gr ; int call_stat , offset ; OM_uint32 min_stat ; log_debug ( ""in<S2SV_blank>svcauth_gss()"" ) ; rqst -> rq_xprt -> xp_verf = gssrpc__null_auth ; if ( rqst -> rq_xprt -> xp_auth == NULL || rqst -> rq_xprt -> xp_auth == & svc_auth_none ) { if ( ( auth = calloc ( sizeof ( * auth ) , 1 ) ) == NULL ) { fprintf ( stderr , ""svcauth_gss:<S2SV_blank>out_of_memory\\n"" ) ; return ( AUTH_FAILED ) ; } if ( ( gd = calloc ( sizeof ( * gd ) , 1 ) ) == NULL ) { fprintf ( stderr , ""svcauth_gss:<S2SV_blank>out_of_memory\\n"" ) ; return ( AUTH_FAILED ) ; } auth -> svc_ah_ops = & svc_auth_gss_ops ; SVCAUTH_PRIVATE ( auth ) = gd ; rqst -> rq_xprt -> xp_auth = auth ; } else gd = SVCAUTH_PRIVATE ( rqst -> rq_xprt -> xp_auth ) ; log_debug ( ""xp_auth=%p,<S2SV_blank>gd=%p"" , rqst -> rq_xprt -> xp_auth , gd ) ; if ( rqst -> rq_cred . oa_length <= 0 ) return ( AUTH_BADCRED ) ; gc = ( struct rpc_gss_cred * ) rqst -> rq_clntcred ; memset ( gc , 0 , sizeof ( * gc ) ) ; log_debug ( ""calling<S2SV_blank>xdrmem_create()"" ) ; log_debug ( ""oa_base=%p,<S2SV_blank>oa_length=%u"" , rqst -> rq_cred . oa_base , rqst -> rq_cred . oa_length ) ; xdrmem_create ( & xdrs , rqst -> rq_cred . oa_base , rqst -> rq_cred . oa_length , XDR_DECODE ) ; log_debug ( ""xdrmem_create()<S2SV_blank>returned"" ) ; if ( ! xdr_rpc_gss_cred ( & xdrs , gc ) ) { log_debug ( ""xdr_rpc_gss_cred()<S2SV_blank>failed"" ) ; XDR_DESTROY ( & xdrs ) ; return ( AUTH_BADCRED ) ; } XDR_DESTROY ( & xdrs ) ; retstat = AUTH_FAILED ; # define ret_freegc ( code ) do { retstat = code ; goto freegc ; } while ( 0 ) if ( gc -> gc_v != RPCSEC_GSS_VERSION ) ret_freegc ( AUTH_BADCRED ) ; if ( gc -> gc_svc != RPCSEC_GSS_SVC_NONE && gc -> gc_svc != RPCSEC_GSS_SVC_INTEGRITY && gc -> gc_svc != RPCSEC_GSS_SVC_PRIVACY ) ret_freegc ( AUTH_BADCRED ) ; if ( gd -> established ) { if ( gc -> gc_seq > MAXSEQ ) ret_freegc ( RPCSEC_GSS_CTXPROBLEM ) ; if ( ( offset = gd -> seqlast - gc -> gc_seq ) < 0 ) { gd -> seqlast = gc -> gc_seq ; offset = 0 - offset ; gd -> seqmask <<= offset ; offset = 0 ; } else if ( ( u_int ) offset >= gd -> win || ( gd -> seqmask & ( 1 << offset ) ) ) { * no_dispatch = 1 ; ret_freegc ( RPCSEC_GSS_CTXPROBLEM ) ; } gd -> seq = gc -> gc_seq ; gd -> seqmask |= ( 1 << offset ) ; } if ( gd -> established ) { rqst -> rq_clntname = ( char * ) gd -> client_name ; rqst -> rq_svccred = ( char * ) gd -> ctx ; } switch ( gc -> gc_proc ) { case RPCSEC_GSS_INIT : case RPCSEC_GSS_CONTINUE_INIT : if ( rqst -> rq_proc != NULLPROC ) ret_freegc ( AUTH_FAILED ) ; if ( ! svcauth_gss_acquire_cred ( ) ) ret_freegc ( AUTH_FAILED ) ; if ( ! svcauth_gss_accept_sec_context ( rqst , & gr ) ) ret_freegc ( AUTH_REJECTEDCRED ) ; if ( ! svcauth_gss_nextverf ( rqst , htonl ( gr . gr_win ) ) ) { gss_release_buffer ( & min_stat , & gr . gr_token ) ; <S2SV_StartBug> mem_free ( gr . gr_ctx . value , <S2SV_EndBug> sizeof ( gss_union_ctx_id_desc ) ) ; ret_freegc ( AUTH_FAILED ) ; } * no_dispatch = TRUE ; call_stat = svc_sendreply ( rqst -> rq_xprt , xdr_rpc_gss_init_res , ( caddr_t ) & gr ) ; gss_release_buffer ( & min_stat , & gr . gr_token ) ; <S2SV_StartBug> gss_release_buffer ( & min_stat , & gd -> checksum ) ; <S2SV_EndBug> mem_free ( gr . gr_ctx . value , sizeof ( gss_union_ctx_id_desc ) ) ; if ( ! call_stat ) ret_freegc ( AUTH_FAILED ) ; if ( gr . gr_major == GSS_S_COMPLETE ) gd -> established = TRUE ; break ; case RPCSEC_GSS_DATA : if ( ! svcauth_gss_validate ( rqst , gd , msg ) ) ret_freegc ( RPCSEC_GSS_CREDPROBLEM ) ; if ( ! svcauth_gss_nextverf ( rqst , htonl ( gc -> gc_seq ) ) ) ret_freegc ( AUTH_FAILED ) ; break ; case RPCSEC_GSS_DESTROY : if ( rqst -> rq_proc != NULLPROC ) ret_freegc ( AUTH_FAILED ) ; if ( ! svcauth_gss_validate ( rqst , gd , msg ) ) ret_freegc ( RPCSEC_GSS_CREDPROBLEM ) ; if ( ! svcauth_gss_nextverf ( rqst , htonl ( gc -> gc_seq ) ) ) ret_freegc ( AUTH_FAILED ) ; * no_dispatch = TRUE ; call_stat = svc_sendreply ( rqst -> rq_xprt , xdr_void , ( caddr_t ) NULL ) ; log_debug ( ""sendreply<S2SV_blank>in<S2SV_blank>destroy:<S2SV_blank>%d"" , call_stat ) ; if ( ! svcauth_gss_release_cred ( ) ) ret_freegc ( AUTH_FAILED ) ; SVCAUTH_DESTROY ( rqst -> rq_xprt -> xp_auth ) ; rqst -> rq_xprt -> xp_auth = & svc_auth_none ; break ; default : ret_freegc ( AUTH_REJECTEDCRED ) ; break ; } retstat = AUTH_OK ; freegc : xdr_free ( xdr_rpc_gss_cred , gc ) ; log_debug ( ""returning<S2SV_blank>%d<S2SV_blank>from<S2SV_blank>svcauth_gss()"" , retstat ) ; return ( retstat ) ; }",<S2SV_ModStart> gr_token ) ; <S2SV_ModEnd> ret_freegc ( AUTH_FAILED <S2SV_ModStart> gd -> checksum <S2SV_ModEnd> ) ; if,krb5@krb5/5bb8a6b9c9eb8dd22bc9526751610aaa255ead9c,CVE-2014-9423,https://github.com/krb5/krb5/commit/5bb8a6b9c9eb8dd22bc9526751610aaa255ead9c,2015-02-19T11:59Z
CWE-362,"CWE-362 <S2SV_StartBug> static struct desc_struct * get_desc ( unsigned short sel ) <S2SV_EndBug> { struct desc_ptr gdt_desc = { 0 , 0 } ; unsigned long desc_base ; # ifdef CONFIG_MODIFY_LDT_SYSCALL if ( ( sel & SEGMENT_TI_MASK ) == SEGMENT_LDT ) { <S2SV_StartBug> struct desc_struct * desc = NULL ; <S2SV_EndBug> struct ldt_struct * ldt ; sel >>= 3 ; mutex_lock ( & current -> active_mm -> context . lock ) ; ldt = current -> active_mm -> context . ldt ; <S2SV_StartBug> if ( ldt && sel < ldt -> nr_entries ) <S2SV_EndBug> <S2SV_StartBug> desc = & ldt -> entries [ sel ] ; <S2SV_EndBug> mutex_unlock ( & current -> active_mm -> context . lock ) ; <S2SV_StartBug> return desc ; <S2SV_EndBug> } # endif native_store_gdt ( & gdt_desc ) ; desc_base = sel & ~ ( SEGMENT_RPL_MASK | SEGMENT_TI_MASK ) ; if ( desc_base > gdt_desc . size ) <S2SV_StartBug> return NULL ; <S2SV_EndBug> return ( struct desc_struct * ) ( gdt_desc . address + desc_base ) ; <S2SV_StartBug> } <S2SV_EndBug>","<S2SV_ModStart> <S2SV_null> <S2SV_null> static bool get_desc ( <S2SV_ModStart> struct desc_struct * out , <S2SV_ModEnd> unsigned short sel <S2SV_ModStart> SEGMENT_LDT ) { bool success = false <S2SV_ModEnd> ; struct ldt_struct <S2SV_ModStart> -> nr_entries ) { * out = <S2SV_ModEnd> ldt -> entries <S2SV_ModStart> sel ] ; success = true ; } <S2SV_ModStart> ) ; return success <S2SV_ModEnd> ; } # <S2SV_ModStart> size ) return false ; * out = * <S2SV_ModEnd> ( struct desc_struct <S2SV_ModStart> desc_base ) ; return true ;",torvalds@linux/de9f869616dd95e95c00bdd6b0fcd3421e8a4323,CVE-2019-13233,https://github.com/torvalds/linux/commit/de9f869616dd95e95c00bdd6b0fcd3421e8a4323,2019-07-04T13:15Z
CWE-754,"CWE-000 STATIC int xfs_attr_shortform_addname ( xfs_da_args_t * args ) { int newsize , forkoff , retval ; trace_xfs_attr_sf_addname ( args ) ; retval = xfs_attr_shortform_lookup ( args ) ; if ( ( args -> flags & ATTR_REPLACE ) && ( retval == - ENOATTR ) ) { return retval ; } else if ( retval == - EEXIST ) { if ( args -> flags & ATTR_CREATE ) return retval ; retval = xfs_attr_shortform_remove ( args ) ; <S2SV_StartBug> ASSERT ( retval == 0 ) ; <S2SV_EndBug> } if ( args -> namelen >= XFS_ATTR_SF_ENTSIZE_MAX || args -> valuelen >= XFS_ATTR_SF_ENTSIZE_MAX ) return - ENOSPC ; newsize = XFS_ATTR_SF_TOTSIZE ( args -> dp ) ; newsize += XFS_ATTR_SF_ENTSIZE_BYNAME ( args -> namelen , args -> valuelen ) ; forkoff = xfs_attr_shortform_bytesfit ( args -> dp , newsize ) ; if ( ! forkoff ) return - ENOSPC ; xfs_attr_shortform_add ( args , forkoff ) ; return 0 ; }",<S2SV_ModStart> args ) ; if ( retval ) return retval ; args -> flags &= ~ ATTR_REPLACE <S2SV_ModEnd> ; } if,torvalds@linux/7b38460dc8e4eafba06c78f8e37099d3b34d473c,CVE-2018-18690,https://github.com/torvalds/linux/commit/7b38460dc8e4eafba06c78f8e37099d3b34d473c,2018-10-26T18:29Z
CWE-399,"CWE-399 int udpv6_recvmsg ( struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct inet_sock * inet = inet_sk ( sk ) ; struct sk_buff * skb ; unsigned int ulen , copied ; int peeked , off = 0 ; int err ; int is_udplite = IS_UDPLITE ( sk ) ; int is_udp4 ; bool slow ; if ( flags & MSG_ERRQUEUE ) return ipv6_recv_error ( sk , msg , len , addr_len ) ; if ( np -> rxpmtu && np -> rxopt . bits . rxpmtu ) return ipv6_recv_rxpmtu ( sk , msg , len , addr_len ) ; try_again : skb = __skb_recv_datagram ( sk , flags | ( noblock ? MSG_DONTWAIT : 0 ) , & peeked , & off , & err ) ; if ( ! skb ) goto out ; ulen = skb -> len - sizeof ( struct udphdr ) ; copied = len ; if ( copied > ulen ) copied = ulen ; else if ( copied < ulen ) msg -> msg_flags |= MSG_TRUNC ; is_udp4 = ( skb -> protocol == htons ( ETH_P_IP ) ) ; if ( copied < ulen || UDP_SKB_CB ( skb ) -> partial_cov ) { if ( udp_lib_checksum_complete ( skb ) ) goto csum_copy_err ; } if ( skb_csum_unnecessary ( skb ) ) err = skb_copy_datagram_msg ( skb , sizeof ( struct udphdr ) , msg , copied ) ; else { err = skb_copy_and_csum_datagram_msg ( skb , sizeof ( struct udphdr ) , msg ) ; if ( err == - EINVAL ) goto csum_copy_err ; } if ( unlikely ( err ) ) { trace_kfree_skb ( skb , udpv6_recvmsg ) ; if ( ! peeked ) { atomic_inc ( & sk -> sk_drops ) ; if ( is_udp4 ) UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; else UDP6_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; } goto out_free ; } if ( ! peeked ) { if ( is_udp4 ) UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INDATAGRAMS , is_udplite ) ; else UDP6_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INDATAGRAMS , is_udplite ) ; } sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( msg -> msg_name ) { DECLARE_SOCKADDR ( struct sockaddr_in6 * , sin6 , msg -> msg_name ) ; sin6 -> sin6_family = AF_INET6 ; sin6 -> sin6_port = udp_hdr ( skb ) -> source ; sin6 -> sin6_flowinfo = 0 ; if ( is_udp4 ) { ipv6_addr_set_v4mapped ( ip_hdr ( skb ) -> saddr , & sin6 -> sin6_addr ) ; sin6 -> sin6_scope_id = 0 ; } else { sin6 -> sin6_addr = ipv6_hdr ( skb ) -> saddr ; sin6 -> sin6_scope_id = ipv6_iface_scope_id ( & sin6 -> sin6_addr , inet6_iif ( skb ) ) ; } * addr_len = sizeof ( * sin6 ) ; } if ( np -> rxopt . all ) ip6_datagram_recv_common_ctl ( sk , msg , skb ) ; if ( is_udp4 ) { if ( inet -> cmsg_flags ) ip_cmsg_recv ( msg , skb ) ; } else { if ( np -> rxopt . all ) ip6_datagram_recv_specific_ctl ( sk , msg , skb ) ; } err = copied ; if ( flags & MSG_TRUNC ) err = ulen ; out_free : skb_free_datagram_locked ( sk , skb ) ; out : return err ; csum_copy_err : slow = lock_sock_fast ( sk ) ; if ( ! skb_kill_datagram ( sk , skb , flags ) ) { if ( is_udp4 ) { UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_CSUMERRORS , is_udplite ) ; UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; } else { UDP6_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_CSUMERRORS , is_udplite ) ; UDP6_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; } } unlock_sock_fast ( sk , slow ) ; <S2SV_StartBug> if ( noblock ) <S2SV_EndBug> return - EAGAIN ; msg -> msg_flags &= ~ MSG_TRUNC ; goto try_again ; }",<S2SV_ModStart> slow ) ; cond_resched ( ) <S2SV_ModEnd> ; msg ->,torvalds@linux/beb39db59d14990e401e235faf66a6b9b31240b0,CVE-2015-5364,https://github.com/torvalds/linux/commit/beb39db59d14990e401e235faf66a6b9b31240b0,2015-08-31T10:59Z
CWE-119,"CWE-119 <S2SV_StartBug> static void read_frame_reference_mode_probs ( VP9_COMMON * cm , vp9_reader * r ) { <S2SV_EndBug> <S2SV_StartBug> FRAME_CONTEXT * const fc = & cm -> fc ; <S2SV_EndBug> int i ; if ( cm -> reference_mode == REFERENCE_MODE_SELECT ) for ( i = 0 ; i < COMP_INTER_CONTEXTS ; ++ i ) vp9_diff_update_prob ( r , & fc -> comp_inter_prob [ i ] ) ; if ( cm -> reference_mode != COMPOUND_REFERENCE ) for ( i = 0 ; i < REF_CONTEXTS ; ++ i ) { vp9_diff_update_prob ( r , & fc -> single_ref_prob [ i ] [ 0 ] ) ; vp9_diff_update_prob ( r , & fc -> single_ref_prob [ i ] [ 1 ] ) ; } if ( cm -> reference_mode != SINGLE_REFERENCE ) for ( i = 0 ; i < REF_CONTEXTS ; ++ i ) vp9_diff_update_prob ( r , & fc -> comp_ref_prob [ i ] ) ; }","<S2SV_ModStart> * cm , vpx_reader <S2SV_ModEnd> * r ) <S2SV_ModStart> const fc = <S2SV_ModEnd> cm -> fc",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-399,"CWE-399 <S2SV_StartBug> static void xen_netbk_idx_release ( struct xen_netbk * netbk , u16 pending_idx ) <S2SV_EndBug> { struct xenvif * vif ; struct pending_tx_info * pending_tx_info ; pending_ring_idx_t index ; if ( netbk -> mmap_pages [ pending_idx ] == NULL ) return ; pending_tx_info = & netbk -> pending_tx_info [ pending_idx ] ; vif = pending_tx_info -> vif ; <S2SV_StartBug> make_tx_response ( vif , & pending_tx_info -> req , XEN_NETIF_RSP_OKAY ) ; <S2SV_EndBug> index = pending_index ( netbk -> pending_prod ++ ) ; netbk -> pending_ring [ index ] = pending_idx ; xenvif_put ( vif ) ; netbk -> mmap_pages [ pending_idx ] -> mapping = 0 ; put_page ( netbk -> mmap_pages [ pending_idx ] ) ; netbk -> mmap_pages [ pending_idx ] = NULL ; }","<S2SV_ModStart> , u16 pending_idx , u8 status <S2SV_ModStart> -> req , status <S2SV_ModEnd> ) ; index",torvalds@linux/7d5145d8eb2b9791533ffe4dc003b129b9696c48,CVE-2013-0217,https://github.com/torvalds/linux/commit/7d5145d8eb2b9791533ffe4dc003b129b9696c48,2013-02-18T04:41Z
CWE-20,"CWE-20 static struct dst_entry * ip6_sk_dst_check ( struct sock * sk , struct dst_entry * dst , const struct flowi6 * fl6 ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; <S2SV_StartBug> struct rt6_info * rt = ( struct rt6_info * ) dst ; <S2SV_EndBug> if ( ! dst ) <S2SV_StartBug> goto out ; <S2SV_EndBug> if ( ip6_rt_check ( & rt -> rt6i_dst , & fl6 -> daddr , np -> daddr_cache ) || # ifdef CONFIG_IPV6_SUBTREES ip6_rt_check ( & rt -> rt6i_src , & fl6 -> saddr , np -> saddr_cache ) || # endif ( fl6 -> flowi6_oif && fl6 -> flowi6_oif != dst -> dev -> ifindex ) ) { dst_release ( dst ) ; dst = NULL ; } out : return dst ; }",<S2SV_ModStart> rt6_info * rt <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) goto out ; if ( dst -> ops -> family != AF_INET6 ) { dst_release ( dst ) ; return NULL ; } rt = ( struct rt6_info * ) dst,torvalds@linux/a963a37d384d71ad43b3e9e79d68d42fbe0901f3,CVE-2013-2232,https://github.com/torvalds/linux/commit/a963a37d384d71ad43b3e9e79d68d42fbe0901f3,2013-07-04T21:55Z
CWE-125,"CWE-125 void mpls_print ( netdissect_options * ndo , const u_char * bp , u_int length ) { const u_char * p ; uint32_t label_entry ; uint16_t label_stack_depth = 0 ; enum mpls_packet_type pt = PT_UNKNOWN ; p = bp ; ND_PRINT ( ( ndo , ""MPLS"" ) ) ; do { ND_TCHECK2 ( * p , sizeof ( label_entry ) ) ; if ( length < sizeof ( label_entry ) ) { ND_PRINT ( ( ndo , ""[|MPLS],<S2SV_blank>length<S2SV_blank>%u"" , length ) ) ; return ; } label_entry = EXTRACT_32BITS ( p ) ; ND_PRINT ( ( ndo , ""%s(label<S2SV_blank>%u"" , ( label_stack_depth && ndo -> ndo_vflag ) ? ""\\n\\t"" : ""<S2SV_blank>"" , MPLS_LABEL ( label_entry ) ) ) ; label_stack_depth ++ ; if ( ndo -> ndo_vflag && MPLS_LABEL ( label_entry ) < sizeof ( mpls_labelname ) / sizeof ( mpls_labelname [ 0 ] ) ) ND_PRINT ( ( ndo , ""<S2SV_blank>(%s)"" , mpls_labelname [ MPLS_LABEL ( label_entry ) ] ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>exp<S2SV_blank>%u"" , MPLS_EXP ( label_entry ) ) ) ; if ( MPLS_STACK ( label_entry ) ) ND_PRINT ( ( ndo , "",<S2SV_blank>[S]"" ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>ttl<S2SV_blank>%u)"" , MPLS_TTL ( label_entry ) ) ) ; p += sizeof ( label_entry ) ; length -= sizeof ( label_entry ) ; } while ( ! MPLS_STACK ( label_entry ) ) ; switch ( MPLS_LABEL ( label_entry ) ) { case 0 : case 3 : pt = PT_IPV4 ; break ; case 2 : pt = PT_IPV6 ; break ; default : ND_TCHECK ( * p ) ; if ( length < 1 ) { return ; } switch ( * p ) { case 0x45 : case 0x46 : case 0x47 : case 0x48 : case 0x49 : case 0x4a : case 0x4b : case 0x4c : case 0x4d : case 0x4e : case 0x4f : pt = PT_IPV4 ; break ; case 0x60 : case 0x61 : case 0x62 : case 0x63 : case 0x64 : case 0x65 : case 0x66 : case 0x67 : case 0x68 : case 0x69 : case 0x6a : case 0x6b : case 0x6c : case 0x6d : case 0x6e : case 0x6f : pt = PT_IPV6 ; break ; case 0x81 : case 0x82 : case 0x83 : pt = PT_OSI ; break ; default : break ; } } if ( pt == PT_UNKNOWN ) { if ( ! ndo -> ndo_suppress_default_print ) ND_DEFAULTPRINT ( p , length ) ; return ; } ND_PRINT ( ( ndo , ndo -> ndo_vflag ? ""\\n\\t"" : ""<S2SV_blank>"" ) ) ; switch ( pt ) { case PT_IPV4 : ip_print ( ndo , p , length ) ; break ; case PT_IPV6 : ip6_print ( ndo , p , length ) ; break ; case PT_OSI : <S2SV_StartBug> isoclns_print ( ndo , p , length , length ) ; <S2SV_EndBug> break ; default : break ; } return ; trunc : ND_PRINT ( ( ndo , ""[|MPLS]"" ) ) ; }","<S2SV_ModStart> p , length <S2SV_ModEnd> ) ; break",the-tcpdump-group@tcpdump/1dcd10aceabbc03bf571ea32b892c522cbe923de,CVE-2017-12897,https://github.com/the-tcpdump-group/tcpdump/commit/1dcd10aceabbc03bf571ea32b892c522cbe923de,2017-09-14T06:29Z
CWE-119,"CWE-119 static vpx_codec_err_t ctrl_set_previewpp ( vpx_codec_alg_priv_t * ctx , <S2SV_StartBug> int ctr_id , va_list args ) { <S2SV_EndBug> # if CONFIG_VP9_POSTPROC <S2SV_StartBug> vp8_postproc_cfg_t * config = va_arg ( args , vp8_postproc_cfg_t * ) ; <S2SV_EndBug> ( void ) ctr_id ; if ( config != NULL ) { ctx -> preview_ppcfg = * config ; return VPX_CODEC_OK ; } else { return VPX_CODEC_INVALID_PARAM ; } # else ( void ) ctx ; <S2SV_StartBug> ( void ) ctr_id ; <S2SV_EndBug> ( void ) args ; return VPX_CODEC_INCAPABLE ; # endif }","<S2SV_ModStart> * ctx , <S2SV_ModEnd> va_list args ) <S2SV_ModStart> vp8_postproc_cfg_t * ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> ( void ) <S2SV_ModEnd> args ; return",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-125,"CWE-125 node * PyParser_ParseFileObject ( FILE * fp , PyObject * filename , const char * enc , grammar * g , int start , const char * ps1 , const char * ps2 , perrdetail * err_ret , int * flags ) { struct tok_state * tok ; if ( initerr ( err_ret , filename ) < 0 ) return NULL ; if ( ( tok = PyTokenizer_FromFile ( fp , enc , ps1 , ps2 ) ) == NULL ) { err_ret -> error = E_NOMEM ; return NULL ; } <S2SV_StartBug> # ifndef PGEN <S2SV_EndBug> Py_INCREF ( err_ret -> filename ) ; tok -> filename = err_ret -> filename ; # endif return parsetok ( tok , g , start , err_ret , flags ) ; }",<S2SV_ModStart> NULL ; } if ( * flags & PyPARSE_TYPE_COMMENTS ) { tok -> type_comments = 1 ; },python@typed_ast/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,CVE-2019-19275,https://github.com/python/typed_ast/commit/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,2019-11-26T15:15Z
CWE-20,"CWE-20 error_t tja1100Init ( NetInterface * interface ) { uint16_t value ; TRACE_INFO ( ""Initializing<S2SV_blank>TJA1100...\\r\\n"" ) ; if ( interface -> phyAddr >= 32 ) { interface -> phyAddr = TJA1100_PHY_ADDR ; } if ( interface -> smiDriver != NULL ) { interface -> smiDriver -> init ( ) ; } if ( interface -> extIntDriver != NULL ) { interface -> extIntDriver -> init ( ) ; } tja1100WritePhyReg ( interface , TJA1100_BASIC_CTRL , TJA1100_BASIC_CTRL_RESET ) ; while ( tja1100ReadPhyReg ( interface , TJA1100_BASIC_CTRL ) & TJA1100_BASIC_CTRL_RESET ) { } tja1100DumpPhyReg ( interface ) ; value = tja1100ReadPhyReg ( interface , TJA1100_EXTENDED_CTRL ) ; value |= TJA1100_EXTENDED_CTRL_CONFIG_EN ; tja1100WritePhyReg ( interface , TJA1100_EXTENDED_CTRL , value ) ; value = tja1100ReadPhyReg ( interface , TJA1100_CONFIG1 ) ; value &= ~ TJA1100_CONFIG1_MII_MODE ; <S2SV_StartBug> value |= TJA1100_CONFIG1_MII_MODE_RMII_25MHZ ; <S2SV_EndBug> tja1100WritePhyReg ( interface , TJA1100_CONFIG1 , value ) ; value = tja1100ReadPhyReg ( interface , TJA1100_CONFIG1 ) ; value |= TJA1100_CONFIG1_AUTO_OP ; tja1100WritePhyReg ( interface , TJA1100_CONFIG1 , value ) ; interface -> phyEvent = TRUE ; osSetEvent ( & netEvent ) ; return NO_ERROR ; }",<S2SV_ModStart> ; value |= TJA1100_CONFIG1_MII_MODE_RMII_25MHZ_XTAL <S2SV_ModEnd> ; tja1100WritePhyReg (,Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z
CWE-59,"CWE-000 int add_mibdir ( const char * dirname ) { <S2SV_StartBug> FILE * ip ; <S2SV_EndBug> const char * oldFile = File ; char * * filenames ; int count = 0 ; int filename_count , i ; <S2SV_StartBug> # if ! ( defined ( WIN32 ) || defined ( cygwin ) ) <S2SV_EndBug> char * token ; char space ; char newline ; struct stat dir_stat , idx_stat ; char tmpstr [ 300 ] ; char tmpstr1 [ 300 ] ; # endif DEBUGMSGTL ( ( ""parse-mibs"" , ""Scanning<S2SV_blank>directory<S2SV_blank>%s\\n"" , dirname ) ) ; <S2SV_StartBug> # if ! ( defined ( WIN32 ) || defined ( cygwin ) ) <S2SV_EndBug> token = netsnmp_mibindex_lookup ( dirname ) ; if ( token && stat ( token , & idx_stat ) == 0 && stat ( dirname , & dir_stat ) == 0 ) { if ( dir_stat . st_mtime < idx_stat . st_mtime ) { DEBUGMSGTL ( ( ""parse-mibs"" , ""The<S2SV_blank>index<S2SV_blank>is<S2SV_blank>good\\n"" ) ) ; if ( ( ip = fopen ( token , ""r"" ) ) != NULL ) { fgets ( tmpstr , sizeof ( tmpstr ) , ip ) ; while ( fscanf ( ip , ""%127s%c%299[^\\n]%c"" , token , & space , tmpstr , & newline ) == 4 ) { if ( space != '<S2SV_blank>' || newline != '\\n' ) { snmp_log ( LOG_ERR , ""add_mibdir:<S2SV_blank>strings<S2SV_blank>scanned<S2SV_blank>in<S2SV_blank>from<S2SV_blank>%s/%s<S2SV_blank>"" ""are<S2SV_blank>too<S2SV_blank>large.<S2SV_blank><S2SV_blank>count<S2SV_blank>=<S2SV_blank>%d\\n<S2SV_blank>"" , dirname , "".index"" , count ) ; break ; } snprintf ( tmpstr1 , sizeof ( tmpstr1 ) , ""%s/%s"" , dirname , tmpstr ) ; tmpstr1 [ sizeof ( tmpstr1 ) - 1 ] = 0 ; new_module ( token , tmpstr1 ) ; count ++ ; } fclose ( ip ) ; return count ; } else DEBUGMSGTL ( ( ""parse-mibs"" , ""Can\'t<S2SV_blank>read<S2SV_blank>index\\n"" ) ) ; } else DEBUGMSGTL ( ( ""parse-mibs"" , ""Index<S2SV_blank>outdated\\n"" ) ) ; } else DEBUGMSGTL ( ( ""parse-mibs"" , ""No<S2SV_blank>index\\n"" ) ) ; # endif filename_count = scan_directory ( & filenames , dirname ) ; if ( filename_count >= 0 ) { <S2SV_StartBug> ip = netsnmp_mibindex_new ( dirname ) ; <S2SV_EndBug> for ( i = 0 ; i < filename_count ; i ++ ) { <S2SV_StartBug> if ( add_mibfile ( filenames [ i ] , strrchr ( filenames [ i ] , '/' ) , ip ) == 0 ) <S2SV_EndBug> count ++ ; free ( filenames [ i ] ) ; } <S2SV_StartBug> File = oldFile ; <S2SV_EndBug> if ( ip ) fclose ( ip ) ; free ( filenames ) ; return ( count ) ; } else DEBUGMSGTL ( ( ""parse-mibs"" , ""cannot<S2SV_blank>open<S2SV_blank>MIB<S2SV_blank>directory<S2SV_blank>%s\\n"" , dirname ) ) ; return ( - 1 ) ; }","<S2SV_ModStart> dirname ) { <S2SV_ModEnd> const char * <S2SV_ModStart> , i ; <S2SV_ModEnd> DEBUGMSGTL ( ( <S2SV_ModStart> ) ) ; <S2SV_ModEnd> filename_count = scan_directory <S2SV_ModStart> 0 ) { <S2SV_ModEnd> for ( i <S2SV_ModStart> , '/' ) <S2SV_ModEnd> ) == 0 <S2SV_ModStart> File = oldFile <S2SV_ModEnd> ; free (",net-snmp@net-snmp/4fd9a450444a434a993bc72f7c3486ccce41f602,CVE-2020-15861,https://github.com/net-snmp/net-snmp/commit/4fd9a450444a434a993bc72f7c3486ccce41f602,2020-08-20T01:17Z
CWE-119,"CWE-119 <S2SV_StartBug> static void write_tile_info ( VP9_COMMON * cm , struct vp9_write_bit_buffer * wb ) { <S2SV_EndBug> int min_log2_tile_cols , max_log2_tile_cols , ones ; vp9_get_tile_n_bits ( cm -> mi_cols , & min_log2_tile_cols , & max_log2_tile_cols ) ; ones = cm -> log2_tile_cols - min_log2_tile_cols ; while ( ones -- ) <S2SV_StartBug> vp9_wb_write_bit ( wb , 1 ) ; <S2SV_EndBug> if ( cm -> log2_tile_cols < max_log2_tile_cols ) <S2SV_StartBug> vp9_wb_write_bit ( wb , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , cm -> log2_tile_rows != 0 ) ; <S2SV_EndBug> if ( cm -> log2_tile_rows != 0 ) <S2SV_StartBug> vp9_wb_write_bit ( wb , cm -> log2_tile_rows != 1 ) ; <S2SV_EndBug> }","<S2SV_ModStart> void write_tile_info ( const VP9_COMMON * const <S2SV_ModEnd> cm , struct <S2SV_ModStart> cm , struct vpx_write_bit_buffer <S2SV_ModEnd> * wb ) <S2SV_ModStart> ones -- ) vpx_wb_write_bit <S2SV_ModEnd> ( wb , <S2SV_ModStart> < max_log2_tile_cols ) vpx_wb_write_bit <S2SV_ModEnd> ( wb , <S2SV_ModStart> 0 ) ; vpx_wb_write_bit <S2SV_ModEnd> ( wb , <S2SV_ModStart> != 0 ) vpx_wb_write_bit <S2SV_ModEnd> ( wb ,",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
